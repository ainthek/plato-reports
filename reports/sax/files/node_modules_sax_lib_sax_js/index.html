<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Plato - node_modules/sax/lib/sax.js</title>

  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="">
  <meta name="author" content="">

  <!--[if lt IE 9]>
  <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->

  <link href="../../assets/css/vendor/morris.css" rel="stylesheet">
  <link href="../../assets/css/vendor/bootstrap.css" rel="stylesheet">
  <link href="../../assets/css/vendor/font-awesome.css" rel="stylesheet">
  <link href="../../assets/css/vendor/codemirror.css" rel="stylesheet">
  <link href="../../assets/css/plato.css" rel="stylesheet">
  <link href="../../assets/css/plato-file.css" rel="stylesheet">

</head>

<body>

<div class="navbar navbar-fixed-top">
  <div class="container">
    <a class="navbar-brand" href="http://github.com/es-analysis/plato">Plato on Github</a>
    <ul class="nav navbar-nav">
      <li>
        <a href="../../index.html">Report Home</a>
      </li>
    </ul>
  </div>
</div>

<div class="jumbotron">
  <div class="container">
    <h1>node_modules/sax/lib/sax.js</h1>
  </div>
</div>

<div class="container aggregate-stats">
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Maintainability <a href="http://blogs.msdn.com/b/codeanalysis/archive/2007/11/20/maintainability-index-range-and-meaning.aspx"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="A value between 0 and 100 that represents the relative ease of maintaining the code. A high value means better maintainability." data-original-title="Maintainability Index"  data-container="body"></i></a></h2>
      <p class="stat">48.98</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Lines of code <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h2>
      <p class="stat">1409</p>
    </div>
  </div>
  <div class="row historical">
    <div class="col-md-6">
      <p id="chart_historical_maint" class="chart"></p>
    </div>
    <div class="col-md-6">
      <p id="chart_historical_sloc" class="chart"></p>
    </div>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Difficulty  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="The difficulty measure is related to the difficulty of the program to write or understand." data-original-title="Difficulty" data-container="body"></i></a></h2>
      <p class="stat">83.65</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Estimated Errors  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Halstead's delivered bugs is an estimate for the number of errors in the implementation." data-original-title="Delivered Bugs" data-container="body"></i></a></h2>
      <p class="stat">18.53</p>
    </div>
  </div>
</div>

<div class="container charts">
  <div class="row">
    <h2 class="header">Function weight</h2>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h3 class="chart-header">By Complexity <a href="http://en.wikipedia.org/wiki/Cyclomatic_complexity"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="This metric counts the number of distinct paths through a block of code. Lower values are better." data-original-title="Cyclomatic Complexity" data-container="body"></i></a></h3>
      <div id="fn-by-complexity" class="stat"></div>
    </div>
    <div class="col-md-6">
      <h3 class="chart-header">By SLOC  <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h3>
      <div id="fn-by-sloc" class="stat"></div>
    </div>
  </div>
</div>

<div class="container">
  <div class="row">
    <textarea id="file-source" class="col-md-12">// wrapper for non-node envs
;(function (sax) {

sax.parser = function (strict, opt) { return new SAXParser(strict, opt) }
sax.SAXParser = SAXParser
sax.SAXStream = SAXStream
sax.createStream = createStream

// When we pass the MAX_BUFFER_LENGTH position, start checking for buffer overruns.
// When we check, schedule the next check for MAX_BUFFER_LENGTH - (max(buffer lengths)),
// since that&#039;s the earliest that a buffer overrun could occur.  This way, checks are
// as rare as required, but as often as necessary to ensure never crossing this bound.
// Furthermore, buffers are only tested at most once per write(), so passing a very
// large string into write() might have undesirable effects, but this is manageable by
// the caller, so it is assumed to be safe.  Thus, a call to write() may, in the extreme
// edge case, result in creating at most one complete copy of the string passed in.
// Set to Infinity to have unlimited buffers.
sax.MAX_BUFFER_LENGTH = 64 * 1024

var buffers = [
  &quot;comment&quot;, &quot;sgmlDecl&quot;, &quot;textNode&quot;, &quot;tagName&quot;, &quot;doctype&quot;,
  &quot;procInstName&quot;, &quot;procInstBody&quot;, &quot;entity&quot;, &quot;attribName&quot;,
  &quot;attribValue&quot;, &quot;cdata&quot;, &quot;script&quot;
]

sax.EVENTS = // for discoverability.
  [ &quot;text&quot;
  , &quot;processinginstruction&quot;
  , &quot;sgmldeclaration&quot;
  , &quot;doctype&quot;
  , &quot;comment&quot;
  , &quot;attribute&quot;
  , &quot;opentag&quot;
  , &quot;closetag&quot;
  , &quot;opencdata&quot;
  , &quot;cdata&quot;
  , &quot;closecdata&quot;
  , &quot;error&quot;
  , &quot;end&quot;
  , &quot;ready&quot;
  , &quot;script&quot;
  , &quot;opennamespace&quot;
  , &quot;closenamespace&quot;
  ]

function SAXParser (strict, opt) {
  if (!(this instanceof SAXParser)) return new SAXParser(strict, opt)

  var parser = this
  clearBuffers(parser)
  parser.q = parser.c = &quot;&quot;
  parser.bufferCheckPosition = sax.MAX_BUFFER_LENGTH
  parser.opt = opt || {}
  parser.opt.lowercase = parser.opt.lowercase || parser.opt.lowercasetags
  parser.looseCase = parser.opt.lowercase ? &quot;toLowerCase&quot; : &quot;toUpperCase&quot;
  parser.tags = []
  parser.closed = parser.closedRoot = parser.sawRoot = false
  parser.tag = parser.error = null
  parser.strict = !!strict
  parser.noscript = !!(strict || parser.opt.noscript)
  parser.state = S.BEGIN
  parser.ENTITIES = Object.create(sax.ENTITIES)
  parser.attribList = []

  // namespaces form a prototype chain.
  // it always points at the current tag,
  // which protos to its parent tag.
  if (parser.opt.xmlns) parser.ns = Object.create(rootNS)

  // mostly just for error reporting
  parser.trackPosition = parser.opt.position !== false
  if (parser.trackPosition) {
    parser.position = parser.line = parser.column = 0
  }
  emit(parser, &quot;onready&quot;)
}

if (!Object.create) Object.create = function (o) {
  function f () { this.__proto__ = o }
  f.prototype = o
  return new f
}

if (!Object.getPrototypeOf) Object.getPrototypeOf = function (o) {
  return o.__proto__
}

if (!Object.keys) Object.keys = function (o) {
  var a = []
  for (var i in o) if (o.hasOwnProperty(i)) a.push(i)
  return a
}

function checkBufferLength (parser) {
  var maxAllowed = Math.max(sax.MAX_BUFFER_LENGTH, 10)
    , maxActual = 0
  for (var i = 0, l = buffers.length; i &lt; l; i ++) {
    var len = parser[buffers[i]].length
    if (len &gt; maxAllowed) {
      // Text/cdata nodes can get big, and since they&#039;re buffered,
      // we can get here under normal conditions.
      // Avoid issues by emitting the text node now,
      // so at least it won&#039;t get any bigger.
      switch (buffers[i]) {
        case &quot;textNode&quot;:
          closeText(parser)
        break

        case &quot;cdata&quot;:
          emitNode(parser, &quot;oncdata&quot;, parser.cdata)
          parser.cdata = &quot;&quot;
        break

        case &quot;script&quot;:
          emitNode(parser, &quot;onscript&quot;, parser.script)
          parser.script = &quot;&quot;
        break

        default:
          error(parser, &quot;Max buffer length exceeded: &quot;+buffers[i])
      }
    }
    maxActual = Math.max(maxActual, len)
  }
  // schedule the next check for the earliest possible buffer overrun.
  parser.bufferCheckPosition = (sax.MAX_BUFFER_LENGTH - maxActual)
                             + parser.position
}

function clearBuffers (parser) {
  for (var i = 0, l = buffers.length; i &lt; l; i ++) {
    parser[buffers[i]] = &quot;&quot;
  }
}

function flushBuffers (parser) {
  closeText(parser)
  if (parser.cdata !== &quot;&quot;) {
    emitNode(parser, &quot;oncdata&quot;, parser.cdata)
    parser.cdata = &quot;&quot;
  }
  if (parser.script !== &quot;&quot;) {
    emitNode(parser, &quot;onscript&quot;, parser.script)
    parser.script = &quot;&quot;
  }
}

SAXParser.prototype =
  { end: function () { end(this) }
  , write: write
  , resume: function () { this.error = null; return this }
  , close: function () { return this.write(null) }
  , flush: function () { flushBuffers(this) }
  }

try {
  var Stream = require(&quot;stream&quot;).Stream
} catch (ex) {
  var Stream = function () {}
}


var streamWraps = sax.EVENTS.filter(function (ev) {
  return ev !== &quot;error&quot; &amp;&amp; ev !== &quot;end&quot;
})

function createStream (strict, opt) {
  return new SAXStream(strict, opt)
}

function SAXStream (strict, opt) {
  if (!(this instanceof SAXStream)) return new SAXStream(strict, opt)

  Stream.apply(this)

  this._parser = new SAXParser(strict, opt)
  this.writable = true
  this.readable = true


  var me = this

  this._parser.onend = function () {
    me.emit(&quot;end&quot;)
  }

  this._parser.onerror = function (er) {
    me.emit(&quot;error&quot;, er)

    // if didn&#039;t throw, then means error was handled.
    // go ahead and clear error, so we can write again.
    me._parser.error = null
  }

  this._decoder = null;

  streamWraps.forEach(function (ev) {
    Object.defineProperty(me, &quot;on&quot; + ev, {
      get: function () { return me._parser[&quot;on&quot; + ev] },
      set: function (h) {
        if (!h) {
          me.removeAllListeners(ev)
          return me._parser[&quot;on&quot;+ev] = h
        }
        me.on(ev, h)
      },
      enumerable: true,
      configurable: false
    })
  })
}

SAXStream.prototype = Object.create(Stream.prototype,
  { constructor: { value: SAXStream } })

SAXStream.prototype.write = function (data) {
  if (typeof Buffer === &#039;function&#039; &amp;&amp;
      typeof Buffer.isBuffer === &#039;function&#039; &amp;&amp;
      Buffer.isBuffer(data)) {
    if (!this._decoder) {
      var SD = require(&#039;string_decoder&#039;).StringDecoder
      this._decoder = new SD(&#039;utf8&#039;)
    }
    data = this._decoder.write(data);
  }

  this._parser.write(data.toString())
  this.emit(&quot;data&quot;, data)
  return true
}

SAXStream.prototype.end = function (chunk) {
  if (chunk &amp;&amp; chunk.length) this.write(chunk)
  this._parser.end()
  return true
}

SAXStream.prototype.on = function (ev, handler) {
  var me = this
  if (!me._parser[&quot;on&quot;+ev] &amp;&amp; streamWraps.indexOf(ev) !== -1) {
    me._parser[&quot;on&quot;+ev] = function () {
      var args = arguments.length === 1 ? [arguments[0]]
               : Array.apply(null, arguments)
      args.splice(0, 0, ev)
      me.emit.apply(me, args)
    }
  }

  return Stream.prototype.on.call(me, ev, handler)
}



// character classes and tokens
var whitespace = &quot;\r\n\t &quot;
  // this really needs to be replaced with character classes.
  // XML allows all manner of ridiculous numbers and digits.
  , number = &quot;0124356789&quot;
  , letter = &quot;abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ&quot;
  // (Letter | &quot;_&quot; | &quot;:&quot;)
  , quote = &quot;&#039;\&quot;&quot;
  , entity = number+letter+&quot;#&quot;
  , attribEnd = whitespace + &quot;&gt;&quot;
  , CDATA = &quot;[CDATA[&quot;
  , DOCTYPE = &quot;DOCTYPE&quot;
  , XML_NAMESPACE = &quot;http://www.w3.org/XML/1998/namespace&quot;
  , XMLNS_NAMESPACE = &quot;http://www.w3.org/2000/xmlns/&quot;
  , rootNS = { xml: XML_NAMESPACE, xmlns: XMLNS_NAMESPACE }

// turn all the string character sets into character class objects.
whitespace = charClass(whitespace)
number = charClass(number)
letter = charClass(letter)

// http://www.w3.org/TR/REC-xml/#NT-NameStartChar
// This implementation works on strings, a single character at a time
// as such, it cannot ever support astral-plane characters (10000-EFFFF)
// without a significant breaking change to either this  parser, or the
// JavaScript language.  Implementation of an emoji-capable xml parser
// is left as an exercise for the reader.
var nameStart = /[:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD]/

var nameBody = /[:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\u00B7\u0300-\u036F\u203F-\u2040\.\d-]/

quote = charClass(quote)
entity = charClass(entity)
attribEnd = charClass(attribEnd)

function charClass (str) {
  return str.split(&quot;&quot;).reduce(function (s, c) {
    s[c] = true
    return s
  }, {})
}

function isRegExp (c) {
  return Object.prototype.toString.call(c) === &#039;[object RegExp]&#039;
}

function is (charclass, c) {
  return isRegExp(charclass) ? !!c.match(charclass) : charclass[c]
}

function not (charclass, c) {
  return !is(charclass, c)
}

var S = 0
sax.STATE =
{ BEGIN                     : S++
, TEXT                      : S++ // general stuff
, TEXT_ENTITY               : S++ // &amp;amp and such.
, OPEN_WAKA                 : S++ // &lt;
, SGML_DECL                 : S++ // &lt;!BLARG
, SGML_DECL_QUOTED          : S++ // &lt;!BLARG foo &quot;bar
, DOCTYPE                   : S++ // &lt;!DOCTYPE
, DOCTYPE_QUOTED            : S++ // &lt;!DOCTYPE &quot;//blah
, DOCTYPE_DTD               : S++ // &lt;!DOCTYPE &quot;//blah&quot; [ ...
, DOCTYPE_DTD_QUOTED        : S++ // &lt;!DOCTYPE &quot;//blah&quot; [ &quot;foo
, COMMENT_STARTING          : S++ // &lt;!-
, COMMENT                   : S++ // &lt;!--
, COMMENT_ENDING            : S++ // &lt;!-- blah -
, COMMENT_ENDED             : S++ // &lt;!-- blah --
, CDATA                     : S++ // &lt;![CDATA[ something
, CDATA_ENDING              : S++ // ]
, CDATA_ENDING_2            : S++ // ]]
, PROC_INST                 : S++ // &lt;?hi
, PROC_INST_BODY            : S++ // &lt;?hi there
, PROC_INST_ENDING          : S++ // &lt;?hi &quot;there&quot; ?
, OPEN_TAG                  : S++ // &lt;strong
, OPEN_TAG_SLASH            : S++ // &lt;strong /
, ATTRIB                    : S++ // &lt;a
, ATTRIB_NAME               : S++ // &lt;a foo
, ATTRIB_NAME_SAW_WHITE     : S++ // &lt;a foo _
, ATTRIB_VALUE              : S++ // &lt;a foo=
, ATTRIB_VALUE_QUOTED       : S++ // &lt;a foo=&quot;bar
, ATTRIB_VALUE_CLOSED       : S++ // &lt;a foo=&quot;bar&quot;
, ATTRIB_VALUE_UNQUOTED     : S++ // &lt;a foo=bar
, ATTRIB_VALUE_ENTITY_Q     : S++ // &lt;foo bar=&quot;&amp;quot;&quot;
, ATTRIB_VALUE_ENTITY_U     : S++ // &lt;foo bar=&amp;quot;
, CLOSE_TAG                 : S++ // &lt;/a
, CLOSE_TAG_SAW_WHITE       : S++ // &lt;/a   &gt;
, SCRIPT                    : S++ // &lt;script&gt; ...
, SCRIPT_ENDING             : S++ // &lt;script&gt; ... &lt;
}

sax.ENTITIES =
{ &quot;amp&quot; : &quot;&amp;&quot;
, &quot;gt&quot; : &quot;&gt;&quot;
, &quot;lt&quot; : &quot;&lt;&quot;
, &quot;quot&quot; : &quot;\&quot;&quot;
, &quot;apos&quot; : &quot;&#039;&quot;
, &quot;AElig&quot; : 198
, &quot;Aacute&quot; : 193
, &quot;Acirc&quot; : 194
, &quot;Agrave&quot; : 192
, &quot;Aring&quot; : 197
, &quot;Atilde&quot; : 195
, &quot;Auml&quot; : 196
, &quot;Ccedil&quot; : 199
, &quot;ETH&quot; : 208
, &quot;Eacute&quot; : 201
, &quot;Ecirc&quot; : 202
, &quot;Egrave&quot; : 200
, &quot;Euml&quot; : 203
, &quot;Iacute&quot; : 205
, &quot;Icirc&quot; : 206
, &quot;Igrave&quot; : 204
, &quot;Iuml&quot; : 207
, &quot;Ntilde&quot; : 209
, &quot;Oacute&quot; : 211
, &quot;Ocirc&quot; : 212
, &quot;Ograve&quot; : 210
, &quot;Oslash&quot; : 216
, &quot;Otilde&quot; : 213
, &quot;Ouml&quot; : 214
, &quot;THORN&quot; : 222
, &quot;Uacute&quot; : 218
, &quot;Ucirc&quot; : 219
, &quot;Ugrave&quot; : 217
, &quot;Uuml&quot; : 220
, &quot;Yacute&quot; : 221
, &quot;aacute&quot; : 225
, &quot;acirc&quot; : 226
, &quot;aelig&quot; : 230
, &quot;agrave&quot; : 224
, &quot;aring&quot; : 229
, &quot;atilde&quot; : 227
, &quot;auml&quot; : 228
, &quot;ccedil&quot; : 231
, &quot;eacute&quot; : 233
, &quot;ecirc&quot; : 234
, &quot;egrave&quot; : 232
, &quot;eth&quot; : 240
, &quot;euml&quot; : 235
, &quot;iacute&quot; : 237
, &quot;icirc&quot; : 238
, &quot;igrave&quot; : 236
, &quot;iuml&quot; : 239
, &quot;ntilde&quot; : 241
, &quot;oacute&quot; : 243
, &quot;ocirc&quot; : 244
, &quot;ograve&quot; : 242
, &quot;oslash&quot; : 248
, &quot;otilde&quot; : 245
, &quot;ouml&quot; : 246
, &quot;szlig&quot; : 223
, &quot;thorn&quot; : 254
, &quot;uacute&quot; : 250
, &quot;ucirc&quot; : 251
, &quot;ugrave&quot; : 249
, &quot;uuml&quot; : 252
, &quot;yacute&quot; : 253
, &quot;yuml&quot; : 255
, &quot;copy&quot; : 169
, &quot;reg&quot; : 174
, &quot;nbsp&quot; : 160
, &quot;iexcl&quot; : 161
, &quot;cent&quot; : 162
, &quot;pound&quot; : 163
, &quot;curren&quot; : 164
, &quot;yen&quot; : 165
, &quot;brvbar&quot; : 166
, &quot;sect&quot; : 167
, &quot;uml&quot; : 168
, &quot;ordf&quot; : 170
, &quot;laquo&quot; : 171
, &quot;not&quot; : 172
, &quot;shy&quot; : 173
, &quot;macr&quot; : 175
, &quot;deg&quot; : 176
, &quot;plusmn&quot; : 177
, &quot;sup1&quot; : 185
, &quot;sup2&quot; : 178
, &quot;sup3&quot; : 179
, &quot;acute&quot; : 180
, &quot;micro&quot; : 181
, &quot;para&quot; : 182
, &quot;middot&quot; : 183
, &quot;cedil&quot; : 184
, &quot;ordm&quot; : 186
, &quot;raquo&quot; : 187
, &quot;frac14&quot; : 188
, &quot;frac12&quot; : 189
, &quot;frac34&quot; : 190
, &quot;iquest&quot; : 191
, &quot;times&quot; : 215
, &quot;divide&quot; : 247
, &quot;OElig&quot; : 338
, &quot;oelig&quot; : 339
, &quot;Scaron&quot; : 352
, &quot;scaron&quot; : 353
, &quot;Yuml&quot; : 376
, &quot;fnof&quot; : 402
, &quot;circ&quot; : 710
, &quot;tilde&quot; : 732
, &quot;Alpha&quot; : 913
, &quot;Beta&quot; : 914
, &quot;Gamma&quot; : 915
, &quot;Delta&quot; : 916
, &quot;Epsilon&quot; : 917
, &quot;Zeta&quot; : 918
, &quot;Eta&quot; : 919
, &quot;Theta&quot; : 920
, &quot;Iota&quot; : 921
, &quot;Kappa&quot; : 922
, &quot;Lambda&quot; : 923
, &quot;Mu&quot; : 924
, &quot;Nu&quot; : 925
, &quot;Xi&quot; : 926
, &quot;Omicron&quot; : 927
, &quot;Pi&quot; : 928
, &quot;Rho&quot; : 929
, &quot;Sigma&quot; : 931
, &quot;Tau&quot; : 932
, &quot;Upsilon&quot; : 933
, &quot;Phi&quot; : 934
, &quot;Chi&quot; : 935
, &quot;Psi&quot; : 936
, &quot;Omega&quot; : 937
, &quot;alpha&quot; : 945
, &quot;beta&quot; : 946
, &quot;gamma&quot; : 947
, &quot;delta&quot; : 948
, &quot;epsilon&quot; : 949
, &quot;zeta&quot; : 950
, &quot;eta&quot; : 951
, &quot;theta&quot; : 952
, &quot;iota&quot; : 953
, &quot;kappa&quot; : 954
, &quot;lambda&quot; : 955
, &quot;mu&quot; : 956
, &quot;nu&quot; : 957
, &quot;xi&quot; : 958
, &quot;omicron&quot; : 959
, &quot;pi&quot; : 960
, &quot;rho&quot; : 961
, &quot;sigmaf&quot; : 962
, &quot;sigma&quot; : 963
, &quot;tau&quot; : 964
, &quot;upsilon&quot; : 965
, &quot;phi&quot; : 966
, &quot;chi&quot; : 967
, &quot;psi&quot; : 968
, &quot;omega&quot; : 969
, &quot;thetasym&quot; : 977
, &quot;upsih&quot; : 978
, &quot;piv&quot; : 982
, &quot;ensp&quot; : 8194
, &quot;emsp&quot; : 8195
, &quot;thinsp&quot; : 8201
, &quot;zwnj&quot; : 8204
, &quot;zwj&quot; : 8205
, &quot;lrm&quot; : 8206
, &quot;rlm&quot; : 8207
, &quot;ndash&quot; : 8211
, &quot;mdash&quot; : 8212
, &quot;lsquo&quot; : 8216
, &quot;rsquo&quot; : 8217
, &quot;sbquo&quot; : 8218
, &quot;ldquo&quot; : 8220
, &quot;rdquo&quot; : 8221
, &quot;bdquo&quot; : 8222
, &quot;dagger&quot; : 8224
, &quot;Dagger&quot; : 8225
, &quot;bull&quot; : 8226
, &quot;hellip&quot; : 8230
, &quot;permil&quot; : 8240
, &quot;prime&quot; : 8242
, &quot;Prime&quot; : 8243
, &quot;lsaquo&quot; : 8249
, &quot;rsaquo&quot; : 8250
, &quot;oline&quot; : 8254
, &quot;frasl&quot; : 8260
, &quot;euro&quot; : 8364
, &quot;image&quot; : 8465
, &quot;weierp&quot; : 8472
, &quot;real&quot; : 8476
, &quot;trade&quot; : 8482
, &quot;alefsym&quot; : 8501
, &quot;larr&quot; : 8592
, &quot;uarr&quot; : 8593
, &quot;rarr&quot; : 8594
, &quot;darr&quot; : 8595
, &quot;harr&quot; : 8596
, &quot;crarr&quot; : 8629
, &quot;lArr&quot; : 8656
, &quot;uArr&quot; : 8657
, &quot;rArr&quot; : 8658
, &quot;dArr&quot; : 8659
, &quot;hArr&quot; : 8660
, &quot;forall&quot; : 8704
, &quot;part&quot; : 8706
, &quot;exist&quot; : 8707
, &quot;empty&quot; : 8709
, &quot;nabla&quot; : 8711
, &quot;isin&quot; : 8712
, &quot;notin&quot; : 8713
, &quot;ni&quot; : 8715
, &quot;prod&quot; : 8719
, &quot;sum&quot; : 8721
, &quot;minus&quot; : 8722
, &quot;lowast&quot; : 8727
, &quot;radic&quot; : 8730
, &quot;prop&quot; : 8733
, &quot;infin&quot; : 8734
, &quot;ang&quot; : 8736
, &quot;and&quot; : 8743
, &quot;or&quot; : 8744
, &quot;cap&quot; : 8745
, &quot;cup&quot; : 8746
, &quot;int&quot; : 8747
, &quot;there4&quot; : 8756
, &quot;sim&quot; : 8764
, &quot;cong&quot; : 8773
, &quot;asymp&quot; : 8776
, &quot;ne&quot; : 8800
, &quot;equiv&quot; : 8801
, &quot;le&quot; : 8804
, &quot;ge&quot; : 8805
, &quot;sub&quot; : 8834
, &quot;sup&quot; : 8835
, &quot;nsub&quot; : 8836
, &quot;sube&quot; : 8838
, &quot;supe&quot; : 8839
, &quot;oplus&quot; : 8853
, &quot;otimes&quot; : 8855
, &quot;perp&quot; : 8869
, &quot;sdot&quot; : 8901
, &quot;lceil&quot; : 8968
, &quot;rceil&quot; : 8969
, &quot;lfloor&quot; : 8970
, &quot;rfloor&quot; : 8971
, &quot;lang&quot; : 9001
, &quot;rang&quot; : 9002
, &quot;loz&quot; : 9674
, &quot;spades&quot; : 9824
, &quot;clubs&quot; : 9827
, &quot;hearts&quot; : 9829
, &quot;diams&quot; : 9830
}

Object.keys(sax.ENTITIES).forEach(function (key) {
    var e = sax.ENTITIES[key]
    var s = typeof e === &#039;number&#039; ? String.fromCharCode(e) : e
    sax.ENTITIES[key] = s
})

for (var S in sax.STATE) sax.STATE[sax.STATE[S]] = S

// shorthand
S = sax.STATE

function emit (parser, event, data) {
  parser[event] &amp;&amp; parser[event](data)
}

function emitNode (parser, nodeType, data) {
  if (parser.textNode) closeText(parser)
  emit(parser, nodeType, data)
}

function closeText (parser) {
  parser.textNode = textopts(parser.opt, parser.textNode)
  if (parser.textNode) emit(parser, &quot;ontext&quot;, parser.textNode)
  parser.textNode = &quot;&quot;
}

function textopts (opt, text) {
  if (opt.trim) text = text.trim()
  if (opt.normalize) text = text.replace(/\s+/g, &quot; &quot;)
  return text
}

function error (parser, er) {
  closeText(parser)
  if (parser.trackPosition) {
    er += &quot;\nLine: &quot;+parser.line+
          &quot;\nColumn: &quot;+parser.column+
          &quot;\nChar: &quot;+parser.c
  }
  er = new Error(er)
  parser.error = er
  emit(parser, &quot;onerror&quot;, er)
  return parser
}

function end (parser) {
  if (!parser.closedRoot) strictFail(parser, &quot;Unclosed root tag&quot;)
  if ((parser.state !== S.BEGIN) &amp;&amp; (parser.state !== S.TEXT)) error(parser, &quot;Unexpected end&quot;)
  closeText(parser)
  parser.c = &quot;&quot;
  parser.closed = true
  emit(parser, &quot;onend&quot;)
  SAXParser.call(parser, parser.strict, parser.opt)
  return parser
}

function strictFail (parser, message) {
  if (typeof parser !== &#039;object&#039; || !(parser instanceof SAXParser))
    throw new Error(&#039;bad call to strictFail&#039;);
  if (parser.strict) error(parser, message)
}

function newTag (parser) {
  if (!parser.strict) parser.tagName = parser.tagName[parser.looseCase]()
  var parent = parser.tags[parser.tags.length - 1] || parser
    , tag = parser.tag = { name : parser.tagName, attributes : {} }

  // will be overridden if tag contails an xmlns=&quot;foo&quot; or xmlns:foo=&quot;bar&quot;
  if (parser.opt.xmlns) tag.ns = parent.ns
  parser.attribList.length = 0
}

function qname (name, attribute) {
  var i = name.indexOf(&quot;:&quot;)
    , qualName = i &lt; 0 ? [ &quot;&quot;, name ] : name.split(&quot;:&quot;)
    , prefix = qualName[0]
    , local = qualName[1]

  // &lt;x &quot;xmlns&quot;=&quot;http://foo&quot;&gt;
  if (attribute &amp;&amp; name === &quot;xmlns&quot;) {
    prefix = &quot;xmlns&quot;
    local = &quot;&quot;
  }

  return { prefix: prefix, local: local }
}

function attrib (parser) {
  if (!parser.strict) parser.attribName = parser.attribName[parser.looseCase]()

  if (parser.attribList.indexOf(parser.attribName) !== -1 ||
      parser.tag.attributes.hasOwnProperty(parser.attribName)) {
    return parser.attribName = parser.attribValue = &quot;&quot;
  }

  if (parser.opt.xmlns) {
    var qn = qname(parser.attribName, true)
      , prefix = qn.prefix
      , local = qn.local

    if (prefix === &quot;xmlns&quot;) {
      // namespace binding attribute; push the binding into scope
      if (local === &quot;xml&quot; &amp;&amp; parser.attribValue !== XML_NAMESPACE) {
        strictFail( parser
                  , &quot;xml: prefix must be bound to &quot; + XML_NAMESPACE + &quot;\n&quot;
                  + &quot;Actual: &quot; + parser.attribValue )
      } else if (local === &quot;xmlns&quot; &amp;&amp; parser.attribValue !== XMLNS_NAMESPACE) {
        strictFail( parser
                  , &quot;xmlns: prefix must be bound to &quot; + XMLNS_NAMESPACE + &quot;\n&quot;
                  + &quot;Actual: &quot; + parser.attribValue )
      } else {
        var tag = parser.tag
          , parent = parser.tags[parser.tags.length - 1] || parser
        if (tag.ns === parent.ns) {
          tag.ns = Object.create(parent.ns)
        }
        tag.ns[local] = parser.attribValue
      }
    }

    // defer onattribute events until all attributes have been seen
    // so any new bindings can take effect; preserve attribute order
    // so deferred events can be emitted in document order
    parser.attribList.push([parser.attribName, parser.attribValue])
  } else {
    // in non-xmlns mode, we can emit the event right away
    parser.tag.attributes[parser.attribName] = parser.attribValue
    emitNode( parser
            , &quot;onattribute&quot;
            , { name: parser.attribName
              , value: parser.attribValue } )
  }

  parser.attribName = parser.attribValue = &quot;&quot;
}

function openTag (parser, selfClosing) {
  if (parser.opt.xmlns) {
    // emit namespace binding events
    var tag = parser.tag

    // add namespace info to tag
    var qn = qname(parser.tagName)
    tag.prefix = qn.prefix
    tag.local = qn.local
    tag.uri = tag.ns[qn.prefix] || &quot;&quot;

    if (tag.prefix &amp;&amp; !tag.uri) {
      strictFail(parser, &quot;Unbound namespace prefix: &quot;
                       + JSON.stringify(parser.tagName))
      tag.uri = qn.prefix
    }

    var parent = parser.tags[parser.tags.length - 1] || parser
    if (tag.ns &amp;&amp; parent.ns !== tag.ns) {
      Object.keys(tag.ns).forEach(function (p) {
        emitNode( parser
                , &quot;onopennamespace&quot;
                , { prefix: p , uri: tag.ns[p] } )
      })
    }

    // handle deferred onattribute events
    // Note: do not apply default ns to attributes:
    //   http://www.w3.org/TR/REC-xml-names/#defaulting
    for (var i = 0, l = parser.attribList.length; i &lt; l; i ++) {
      var nv = parser.attribList[i]
      var name = nv[0]
        , value = nv[1]
        , qualName = qname(name, true)
        , prefix = qualName.prefix
        , local = qualName.local
        , uri = prefix == &quot;&quot; ? &quot;&quot; : (tag.ns[prefix] || &quot;&quot;)
        , a = { name: name
              , value: value
              , prefix: prefix
              , local: local
              , uri: uri
              }

      // if there&#039;s any attributes with an undefined namespace,
      // then fail on them now.
      if (prefix &amp;&amp; prefix != &quot;xmlns&quot; &amp;&amp; !uri) {
        strictFail(parser, &quot;Unbound namespace prefix: &quot;
                         + JSON.stringify(prefix))
        a.uri = prefix
      }
      parser.tag.attributes[name] = a
      emitNode(parser, &quot;onattribute&quot;, a)
    }
    parser.attribList.length = 0
  }

  parser.tag.isSelfClosing = !!selfClosing

  // process the tag
  parser.sawRoot = true
  parser.tags.push(parser.tag)
  emitNode(parser, &quot;onopentag&quot;, parser.tag)
  if (!selfClosing) {
    // special case for &lt;script&gt; in non-strict mode.
    if (!parser.noscript &amp;&amp; parser.tagName.toLowerCase() === &quot;script&quot;) {
      parser.state = S.SCRIPT
    } else {
      parser.state = S.TEXT
    }
    parser.tag = null
    parser.tagName = &quot;&quot;
  }
  parser.attribName = parser.attribValue = &quot;&quot;
  parser.attribList.length = 0
}

function closeTag (parser) {
  if (!parser.tagName) {
    strictFail(parser, &quot;Weird empty close tag.&quot;)
    parser.textNode += &quot;&lt;/&gt;&quot;
    parser.state = S.TEXT
    return
  }

  if (parser.script) {
    if (parser.tagName !== &quot;script&quot;) {
      parser.script += &quot;&lt;/&quot; + parser.tagName + &quot;&gt;&quot;
      parser.tagName = &quot;&quot;
      parser.state = S.SCRIPT
      return
    }
    emitNode(parser, &quot;onscript&quot;, parser.script)
    parser.script = &quot;&quot;
  }

  // first make sure that the closing tag actually exists.
  // &lt;a&gt;&lt;b&gt;&lt;/c&gt;&lt;/b&gt;&lt;/a&gt; will close everything, otherwise.
  var t = parser.tags.length
  var tagName = parser.tagName
  if (!parser.strict) tagName = tagName[parser.looseCase]()
  var closeTo = tagName
  while (t --) {
    var close = parser.tags[t]
    if (close.name !== closeTo) {
      // fail the first time in strict mode
      strictFail(parser, &quot;Unexpected close tag&quot;)
    } else break
  }

  // didn&#039;t find it.  we already failed for strict, so just abort.
  if (t &lt; 0) {
    strictFail(parser, &quot;Unmatched closing tag: &quot;+parser.tagName)
    parser.textNode += &quot;&lt;/&quot; + parser.tagName + &quot;&gt;&quot;
    parser.state = S.TEXT
    return
  }
  parser.tagName = tagName
  var s = parser.tags.length
  while (s --&gt; t) {
    var tag = parser.tag = parser.tags.pop()
    parser.tagName = parser.tag.name
    emitNode(parser, &quot;onclosetag&quot;, parser.tagName)

    var x = {}
    for (var i in tag.ns) x[i] = tag.ns[i]

    var parent = parser.tags[parser.tags.length - 1] || parser
    if (parser.opt.xmlns &amp;&amp; tag.ns !== parent.ns) {
      // remove namespace bindings introduced by tag
      Object.keys(tag.ns).forEach(function (p) {
        var n = tag.ns[p]
        emitNode(parser, &quot;onclosenamespace&quot;, { prefix: p, uri: n })
      })
    }
  }
  if (t === 0) parser.closedRoot = true
  parser.tagName = parser.attribValue = parser.attribName = &quot;&quot;
  parser.attribList.length = 0
  parser.state = S.TEXT
}

function parseEntity (parser) {
  var entity = parser.entity
    , entityLC = entity.toLowerCase()
    , num
    , numStr = &quot;&quot;
  if (parser.ENTITIES[entity])
    return parser.ENTITIES[entity]
  if (parser.ENTITIES[entityLC])
    return parser.ENTITIES[entityLC]
  entity = entityLC
  if (entity.charAt(0) === &quot;#&quot;) {
    if (entity.charAt(1) === &quot;x&quot;) {
      entity = entity.slice(2)
      num = parseInt(entity, 16)
      numStr = num.toString(16)
    } else {
      entity = entity.slice(1)
      num = parseInt(entity, 10)
      numStr = num.toString(10)
    }
  }
  entity = entity.replace(/^0+/, &quot;&quot;)
  if (numStr.toLowerCase() !== entity) {
    strictFail(parser, &quot;Invalid character entity&quot;)
    return &quot;&amp;&quot;+parser.entity + &quot;;&quot;
  }

  return String.fromCodePoint(num)
}

function write (chunk) {
  var parser = this
  if (this.error) throw this.error
  if (parser.closed) return error(parser,
    &quot;Cannot write after close. Assign an onready handler.&quot;)
  if (chunk === null) return end(parser)
  var i = 0, c = &quot;&quot;
  while (parser.c = c = chunk.charAt(i++)) {
    if (parser.trackPosition) {
      parser.position ++
      if (c === &quot;\n&quot;) {
        parser.line ++
        parser.column = 0
      } else parser.column ++
    }
    switch (parser.state) {

      case S.BEGIN:
        if (c === &quot;&lt;&quot;) {
          parser.state = S.OPEN_WAKA
          parser.startTagPosition = parser.position
        } else if (not(whitespace,c)) {
          // have to process this as a text node.
          // weird, but happens.
          strictFail(parser, &quot;Non-whitespace before first tag.&quot;)
          parser.textNode = c
          parser.state = S.TEXT
        }
      continue

      case S.TEXT:
        if (parser.sawRoot &amp;&amp; !parser.closedRoot) {
          var starti = i-1
          while (c &amp;&amp; c!==&quot;&lt;&quot; &amp;&amp; c!==&quot;&amp;&quot;) {
            c = chunk.charAt(i++)
            if (c &amp;&amp; parser.trackPosition) {
              parser.position ++
              if (c === &quot;\n&quot;) {
                parser.line ++
                parser.column = 0
              } else parser.column ++
            }
          }
          parser.textNode += chunk.substring(starti, i-1)
        }
        if (c === &quot;&lt;&quot;) {
          parser.state = S.OPEN_WAKA
          parser.startTagPosition = parser.position
        } else {
          if (not(whitespace, c) &amp;&amp; (!parser.sawRoot || parser.closedRoot))
            strictFail(parser, &quot;Text data outside of root node.&quot;)
          if (c === &quot;&amp;&quot;) parser.state = S.TEXT_ENTITY
          else parser.textNode += c
        }
      continue

      case S.SCRIPT:
        // only non-strict
        if (c === &quot;&lt;&quot;) {
          parser.state = S.SCRIPT_ENDING
        } else parser.script += c
      continue

      case S.SCRIPT_ENDING:
        if (c === &quot;/&quot;) {
          parser.state = S.CLOSE_TAG
        } else {
          parser.script += &quot;&lt;&quot; + c
          parser.state = S.SCRIPT
        }
      continue

      case S.OPEN_WAKA:
        // either a /, ?, !, or text is coming next.
        if (c === &quot;!&quot;) {
          parser.state = S.SGML_DECL
          parser.sgmlDecl = &quot;&quot;
        } else if (is(whitespace, c)) {
          // wait for it...
        } else if (is(nameStart,c)) {
          parser.state = S.OPEN_TAG
          parser.tagName = c
        } else if (c === &quot;/&quot;) {
          parser.state = S.CLOSE_TAG
          parser.tagName = &quot;&quot;
        } else if (c === &quot;?&quot;) {
          parser.state = S.PROC_INST
          parser.procInstName = parser.procInstBody = &quot;&quot;
        } else {
          strictFail(parser, &quot;Unencoded &lt;&quot;)
          // if there was some whitespace, then add that in.
          if (parser.startTagPosition + 1 &lt; parser.position) {
            var pad = parser.position - parser.startTagPosition
            c = new Array(pad).join(&quot; &quot;) + c
          }
          parser.textNode += &quot;&lt;&quot; + c
          parser.state = S.TEXT
        }
      continue

      case S.SGML_DECL:
        if ((parser.sgmlDecl+c).toUpperCase() === CDATA) {
          emitNode(parser, &quot;onopencdata&quot;)
          parser.state = S.CDATA
          parser.sgmlDecl = &quot;&quot;
          parser.cdata = &quot;&quot;
        } else if (parser.sgmlDecl+c === &quot;--&quot;) {
          parser.state = S.COMMENT
          parser.comment = &quot;&quot;
          parser.sgmlDecl = &quot;&quot;
        } else if ((parser.sgmlDecl+c).toUpperCase() === DOCTYPE) {
          parser.state = S.DOCTYPE
          if (parser.doctype || parser.sawRoot) strictFail(parser,
            &quot;Inappropriately located doctype declaration&quot;)
          parser.doctype = &quot;&quot;
          parser.sgmlDecl = &quot;&quot;
        } else if (c === &quot;&gt;&quot;) {
          emitNode(parser, &quot;onsgmldeclaration&quot;, parser.sgmlDecl)
          parser.sgmlDecl = &quot;&quot;
          parser.state = S.TEXT
        } else if (is(quote, c)) {
          parser.state = S.SGML_DECL_QUOTED
          parser.sgmlDecl += c
        } else parser.sgmlDecl += c
      continue

      case S.SGML_DECL_QUOTED:
        if (c === parser.q) {
          parser.state = S.SGML_DECL
          parser.q = &quot;&quot;
        }
        parser.sgmlDecl += c
      continue

      case S.DOCTYPE:
        if (c === &quot;&gt;&quot;) {
          parser.state = S.TEXT
          emitNode(parser, &quot;ondoctype&quot;, parser.doctype)
          parser.doctype = true // just remember that we saw it.
        } else {
          parser.doctype += c
          if (c === &quot;[&quot;) parser.state = S.DOCTYPE_DTD
          else if (is(quote, c)) {
            parser.state = S.DOCTYPE_QUOTED
            parser.q = c
          }
        }
      continue

      case S.DOCTYPE_QUOTED:
        parser.doctype += c
        if (c === parser.q) {
          parser.q = &quot;&quot;
          parser.state = S.DOCTYPE
        }
      continue

      case S.DOCTYPE_DTD:
        parser.doctype += c
        if (c === &quot;]&quot;) parser.state = S.DOCTYPE
        else if (is(quote,c)) {
          parser.state = S.DOCTYPE_DTD_QUOTED
          parser.q = c
        }
      continue

      case S.DOCTYPE_DTD_QUOTED:
        parser.doctype += c
        if (c === parser.q) {
          parser.state = S.DOCTYPE_DTD
          parser.q = &quot;&quot;
        }
      continue

      case S.COMMENT:
        if (c === &quot;-&quot;) parser.state = S.COMMENT_ENDING
        else parser.comment += c
      continue

      case S.COMMENT_ENDING:
        if (c === &quot;-&quot;) {
          parser.state = S.COMMENT_ENDED
          parser.comment = textopts(parser.opt, parser.comment)
          if (parser.comment) emitNode(parser, &quot;oncomment&quot;, parser.comment)
          parser.comment = &quot;&quot;
        } else {
          parser.comment += &quot;-&quot; + c
          parser.state = S.COMMENT
        }
      continue

      case S.COMMENT_ENDED:
        if (c !== &quot;&gt;&quot;) {
          strictFail(parser, &quot;Malformed comment&quot;)
          // allow &lt;!-- blah -- bloo --&gt; in non-strict mode,
          // which is a comment of &quot; blah -- bloo &quot;
          parser.comment += &quot;--&quot; + c
          parser.state = S.COMMENT
        } else parser.state = S.TEXT
      continue

      case S.CDATA:
        if (c === &quot;]&quot;) parser.state = S.CDATA_ENDING
        else parser.cdata += c
      continue

      case S.CDATA_ENDING:
        if (c === &quot;]&quot;) parser.state = S.CDATA_ENDING_2
        else {
          parser.cdata += &quot;]&quot; + c
          parser.state = S.CDATA
        }
      continue

      case S.CDATA_ENDING_2:
        if (c === &quot;&gt;&quot;) {
          if (parser.cdata) emitNode(parser, &quot;oncdata&quot;, parser.cdata)
          emitNode(parser, &quot;onclosecdata&quot;)
          parser.cdata = &quot;&quot;
          parser.state = S.TEXT
        } else if (c === &quot;]&quot;) {
          parser.cdata += &quot;]&quot;
        } else {
          parser.cdata += &quot;]]&quot; + c
          parser.state = S.CDATA
        }
      continue

      case S.PROC_INST:
        if (c === &quot;?&quot;) parser.state = S.PROC_INST_ENDING
        else if (is(whitespace, c)) parser.state = S.PROC_INST_BODY
        else parser.procInstName += c
      continue

      case S.PROC_INST_BODY:
        if (!parser.procInstBody &amp;&amp; is(whitespace, c)) continue
        else if (c === &quot;?&quot;) parser.state = S.PROC_INST_ENDING
        else parser.procInstBody += c
      continue

      case S.PROC_INST_ENDING:
        if (c === &quot;&gt;&quot;) {
          emitNode(parser, &quot;onprocessinginstruction&quot;, {
            name : parser.procInstName,
            body : parser.procInstBody
          })
          parser.procInstName = parser.procInstBody = &quot;&quot;
          parser.state = S.TEXT
        } else {
          parser.procInstBody += &quot;?&quot; + c
          parser.state = S.PROC_INST_BODY
        }
      continue

      case S.OPEN_TAG:
        if (is(nameBody, c)) parser.tagName += c
        else {
          newTag(parser)
          if (c === &quot;&gt;&quot;) openTag(parser)
          else if (c === &quot;/&quot;) parser.state = S.OPEN_TAG_SLASH
          else {
            if (not(whitespace, c)) strictFail(
              parser, &quot;Invalid character in tag name&quot;)
            parser.state = S.ATTRIB
          }
        }
      continue

      case S.OPEN_TAG_SLASH:
        if (c === &quot;&gt;&quot;) {
          openTag(parser, true)
          closeTag(parser)
        } else {
          strictFail(parser, &quot;Forward-slash in opening tag not followed by &gt;&quot;)
          parser.state = S.ATTRIB
        }
      continue

      case S.ATTRIB:
        // haven&#039;t read the attribute name yet.
        if (is(whitespace, c)) continue
        else if (c === &quot;&gt;&quot;) openTag(parser)
        else if (c === &quot;/&quot;) parser.state = S.OPEN_TAG_SLASH
        else if (is(nameStart, c)) {
          parser.attribName = c
          parser.attribValue = &quot;&quot;
          parser.state = S.ATTRIB_NAME
        } else strictFail(parser, &quot;Invalid attribute name&quot;)
      continue

      case S.ATTRIB_NAME:
        if (c === &quot;=&quot;) parser.state = S.ATTRIB_VALUE
        else if (c === &quot;&gt;&quot;) {
          strictFail(parser, &quot;Attribute without value&quot;)
          parser.attribValue = parser.attribName
          attrib(parser)
          openTag(parser)
        }
        else if (is(whitespace, c)) parser.state = S.ATTRIB_NAME_SAW_WHITE
        else if (is(nameBody, c)) parser.attribName += c
        else strictFail(parser, &quot;Invalid attribute name&quot;)
      continue

      case S.ATTRIB_NAME_SAW_WHITE:
        if (c === &quot;=&quot;) parser.state = S.ATTRIB_VALUE
        else if (is(whitespace, c)) continue
        else {
          strictFail(parser, &quot;Attribute without value&quot;)
          parser.tag.attributes[parser.attribName] = &quot;&quot;
          parser.attribValue = &quot;&quot;
          emitNode(parser, &quot;onattribute&quot;,
                   { name : parser.attribName, value : &quot;&quot; })
          parser.attribName = &quot;&quot;
          if (c === &quot;&gt;&quot;) openTag(parser)
          else if (is(nameStart, c)) {
            parser.attribName = c
            parser.state = S.ATTRIB_NAME
          } else {
            strictFail(parser, &quot;Invalid attribute name&quot;)
            parser.state = S.ATTRIB
          }
        }
      continue

      case S.ATTRIB_VALUE:
        if (is(whitespace, c)) continue
        else if (is(quote, c)) {
          parser.q = c
          parser.state = S.ATTRIB_VALUE_QUOTED
        } else {
          strictFail(parser, &quot;Unquoted attribute value&quot;)
          parser.state = S.ATTRIB_VALUE_UNQUOTED
          parser.attribValue = c
        }
      continue

      case S.ATTRIB_VALUE_QUOTED:
        if (c !== parser.q) {
          if (c === &quot;&amp;&quot;) parser.state = S.ATTRIB_VALUE_ENTITY_Q
          else parser.attribValue += c
          continue
        }
        attrib(parser)
        parser.q = &quot;&quot;
        parser.state = S.ATTRIB_VALUE_CLOSED
      continue

      case S.ATTRIB_VALUE_CLOSED:
        if (is(whitespace, c)) {
          parser.state = S.ATTRIB
        } else if (c === &quot;&gt;&quot;) openTag(parser)
        else if (c === &quot;/&quot;) parser.state = S.OPEN_TAG_SLASH
        else if (is(nameStart, c)) {
          strictFail(parser, &quot;No whitespace between attributes&quot;)
          parser.attribName = c
          parser.attribValue = &quot;&quot;
          parser.state = S.ATTRIB_NAME
        } else strictFail(parser, &quot;Invalid attribute name&quot;)
      continue

      case S.ATTRIB_VALUE_UNQUOTED:
        if (not(attribEnd,c)) {
          if (c === &quot;&amp;&quot;) parser.state = S.ATTRIB_VALUE_ENTITY_U
          else parser.attribValue += c
          continue
        }
        attrib(parser)
        if (c === &quot;&gt;&quot;) openTag(parser)
        else parser.state = S.ATTRIB
      continue

      case S.CLOSE_TAG:
        if (!parser.tagName) {
          if (is(whitespace, c)) continue
          else if (not(nameStart, c)) {
            if (parser.script) {
              parser.script += &quot;&lt;/&quot; + c
              parser.state = S.SCRIPT
            } else {
              strictFail(parser, &quot;Invalid tagname in closing tag.&quot;)
            }
          } else parser.tagName = c
        }
        else if (c === &quot;&gt;&quot;) closeTag(parser)
        else if (is(nameBody, c)) parser.tagName += c
        else if (parser.script) {
          parser.script += &quot;&lt;/&quot; + parser.tagName
          parser.tagName = &quot;&quot;
          parser.state = S.SCRIPT
        } else {
          if (not(whitespace, c)) strictFail(parser,
            &quot;Invalid tagname in closing tag&quot;)
          parser.state = S.CLOSE_TAG_SAW_WHITE
        }
      continue

      case S.CLOSE_TAG_SAW_WHITE:
        if (is(whitespace, c)) continue
        if (c === &quot;&gt;&quot;) closeTag(parser)
        else strictFail(parser, &quot;Invalid characters in closing tag&quot;)
      continue

      case S.TEXT_ENTITY:
      case S.ATTRIB_VALUE_ENTITY_Q:
      case S.ATTRIB_VALUE_ENTITY_U:
        switch(parser.state) {
          case S.TEXT_ENTITY:
            var returnState = S.TEXT, buffer = &quot;textNode&quot;
          break

          case S.ATTRIB_VALUE_ENTITY_Q:
            var returnState = S.ATTRIB_VALUE_QUOTED, buffer = &quot;attribValue&quot;
          break

          case S.ATTRIB_VALUE_ENTITY_U:
            var returnState = S.ATTRIB_VALUE_UNQUOTED, buffer = &quot;attribValue&quot;
          break
        }
        if (c === &quot;;&quot;) {
          parser[buffer] += parseEntity(parser)
          parser.entity = &quot;&quot;
          parser.state = returnState
        }
        else if (is(entity, c)) parser.entity += c
        else {
          strictFail(parser, &quot;Invalid character entity&quot;)
          parser[buffer] += &quot;&amp;&quot; + parser.entity + c
          parser.entity = &quot;&quot;
          parser.state = returnState
        }
      continue

      default:
        throw new Error(parser, &quot;Unknown state: &quot; + parser.state)
    }
  } // while
  // cdata blocks can get very big under normal conditions. emit and move on.
  // if (parser.state === S.CDATA &amp;&amp; parser.cdata) {
  //   emitNode(parser, &quot;oncdata&quot;, parser.cdata)
  //   parser.cdata = &quot;&quot;
  // }
  if (parser.position &gt;= parser.bufferCheckPosition) checkBufferLength(parser)
  return parser
}

/*! http://mths.be/fromcodepoint v0.1.0 by @mathias */
if (!String.fromCodePoint) {
        (function() {
                var stringFromCharCode = String.fromCharCode;
                var floor = Math.floor;
                var fromCodePoint = function() {
                        var MAX_SIZE = 0x4000;
                        var codeUnits = [];
                        var highSurrogate;
                        var lowSurrogate;
                        var index = -1;
                        var length = arguments.length;
                        if (!length) {
                                return &#039;&#039;;
                        }
                        var result = &#039;&#039;;
                        while (++index &lt; length) {
                                var codePoint = Number(arguments[index]);
                                if (
                                        !isFinite(codePoint) || // `NaN`, `+Infinity`, or `-Infinity`
                                        codePoint &lt; 0 || // not a valid Unicode code point
                                        codePoint &gt; 0x10FFFF || // not a valid Unicode code point
                                        floor(codePoint) != codePoint // not an integer
                                ) {
                                        throw RangeError(&#039;Invalid code point: &#039; + codePoint);
                                }
                                if (codePoint &lt;= 0xFFFF) { // BMP code point
                                        codeUnits.push(codePoint);
                                } else { // Astral code point; split in surrogate halves
                                        // http://mathiasbynens.be/notes/javascript-encoding#surrogate-formulae
                                        codePoint -= 0x10000;
                                        highSurrogate = (codePoint &gt;&gt; 10) + 0xD800;
                                        lowSurrogate = (codePoint % 0x400) + 0xDC00;
                                        codeUnits.push(highSurrogate, lowSurrogate);
                                }
                                if (index + 1 == length || codeUnits.length &gt; MAX_SIZE) {
                                        result += stringFromCharCode.apply(null, codeUnits);
                                        codeUnits.length = 0;
                                }
                        }
                        return result;
                };
                if (Object.defineProperty) {
                        Object.defineProperty(String, &#039;fromCodePoint&#039;, {
                                &#039;value&#039;: fromCodePoint,
                                &#039;configurable&#039;: true,
                                &#039;writable&#039;: true
                        });
                } else {
                        String.fromCodePoint = fromCodePoint;
                }
        }());
}

})(typeof exports === &quot;undefined&quot; ? sax = {} : exports);</textarea>
  </div>
</div>

<footer class="footer">
  <div class="container">
    <p>.</p>
  </div>
</footer>

<script type="text/html" id="complexity-popover-template">
  <div class="complexity-notice">
    Complexity : {{ complexity.cyclomatic }} <br>
    Length : {{ complexity.halstead.length }} <br>
    Difficulty : {{ complexity.halstead.difficulty.toFixed(2) }} <br>
    Est # bugs : {{ complexity.halstead.bugs.toFixed(2) }}<br>
  </div>
</script>

<script type="text/javascript" src="../../assets/scripts/bundles/core-bundle.js"></script>
<script type="text/javascript" src="../../assets/scripts/bundles/codemirror.js"></script>
<script type="text/javascript" src="../../assets/scripts/codemirror.markpopovertext.js"></script>
<script type="text/javascript" src="report.js"></script>
<script type="text/javascript" src="report.history.js"></script>
<script type="text/javascript" src="../../assets/scripts/plato-file.js"></script>
</body>
</html>
