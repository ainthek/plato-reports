<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Plato - node_modules/json-diff-patch/jsonpatch.js</title>

  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="">
  <meta name="author" content="">

  <!--[if lt IE 9]>
  <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->

  <link href="../../assets/css/vendor/morris.css" rel="stylesheet">
  <link href="../../assets/css/vendor/bootstrap.css" rel="stylesheet">
  <link href="../../assets/css/vendor/font-awesome.css" rel="stylesheet">
  <link href="../../assets/css/vendor/codemirror.css" rel="stylesheet">
  <link href="../../assets/css/plato.css" rel="stylesheet">
  <link href="../../assets/css/plato-file.css" rel="stylesheet">

</head>

<body>

<div class="navbar navbar-fixed-top">
  <div class="container">
    <a class="navbar-brand" href="http://github.com/es-analysis/plato">Plato on Github</a>
    <ul class="nav navbar-nav">
      <li>
        <a href="../../index.html">Report Home</a>
      </li>
    </ul>
  </div>
</div>

<div class="jumbotron">
  <div class="container">
    <h1>node_modules/json-diff-patch/jsonpatch.js</h1>
  </div>
</div>

<div class="container aggregate-stats">
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Maintainability <a href="http://blogs.msdn.com/b/codeanalysis/archive/2007/11/20/maintainability-index-range-and-meaning.aspx"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="A value between 0 and 100 that represents the relative ease of maintaining the code. A high value means better maintainability." data-original-title="Maintainability Index"  data-container="body"></i></a></h2>
      <p class="stat">64.23</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Lines of code <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h2>
      <p class="stat">503</p>
    </div>
  </div>
  <div class="row historical">
    <div class="col-md-6">
      <p id="chart_historical_maint" class="chart"></p>
    </div>
    <div class="col-md-6">
      <p id="chart_historical_sloc" class="chart"></p>
    </div>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Difficulty  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="The difficulty measure is related to the difficulty of the program to write or understand." data-original-title="Difficulty" data-container="body"></i></a></h2>
      <p class="stat">165.03</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Estimated Errors  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Halstead's delivered bugs is an estimate for the number of errors in the implementation." data-original-title="Delivered Bugs" data-container="body"></i></a></h2>
      <p class="stat">5.03</p>
    </div>
  </div>
</div>

<div class="container charts">
  <div class="row">
    <h2 class="header">Function weight</h2>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h3 class="chart-header">By Complexity <a href="http://en.wikipedia.org/wiki/Cyclomatic_complexity"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="This metric counts the number of distinct paths through a block of code. Lower values are better." data-original-title="Cyclomatic Complexity" data-container="body"></i></a></h3>
      <div id="fn-by-complexity" class="stat"></div>
    </div>
    <div class="col-md-6">
      <h3 class="chart-header">By SLOC  <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h3>
      <div id="fn-by-sloc" class="stat"></div>
    </div>
  </div>
</div>

<div class="container">
  <div class="row">
    <textarea id="file-source" class="col-md-12">// Generated by CoffeeScript 1.4.0
(function() {
  var __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i &lt; l; i++) { if (i in this &amp;&amp; this[i] === item) return i; } return -1; },
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  (function(root, factory) {
    if (typeof exports !== &#039;undefined&#039;) {
      return factory(root, exports);
    } else if (typeof define === &#039;function&#039; &amp;&amp; define.amd) {
      return define([&#039;exports&#039;], function(exports) {
        return root.jsonpatch = factory(root, exports);
      });
    } else {
      return root.jsonpatch = factory(root, {});
    }
  })(this, function(root) {
    var AddPatch, CopyPatch, InvalidPatchError, InvalidPointerError, JSONPatch, JSONPatchError, JSONPointer, MovePatch, PatchConflictError, RemovePatch, ReplacePatch, TestPatch, apply, compile, hasOwnProperty, isArray, isEqual, isObject, isString, operationMap, toString, _isEqual;
    toString = Object.prototype.toString;
    hasOwnProperty = Object.prototype.hasOwnProperty;
    isArray = function(obj) {
      return toString.call(obj) === &#039;[object Array]&#039;;
    };
    isObject = function(obj) {
      return toString.call(obj) === &#039;[object Object]&#039;;
    };
    isString = function(obj) {
      return toString.call(obj) === &#039;[object String]&#039;;
    };
    _isEqual = function(a, b, stack) {
      var className, key, length, result, size;
      if (a === b) {
        return a !== 0 || 1 / a === 1 / b;
      }
      if (a === null || b === null) {
        return a === b;
      }
      className = toString.call(a);
      if (className !== toString.call(b)) {
        return false;
      }
      switch (className) {
        case &#039;[object String]&#039;:
          String(a) === String(b);
          break;
        case &#039;[object Number]&#039;:
          a = +a;
          b = +b;
          if (a !== a) {
            b !== b;
          } else {
            if (a === 0) {
              1 / a === 1 / b;
            } else {
              a === b;
            }
          }
          break;
        case &#039;[object Boolean]&#039;:
          +a === +b;
      }
      if (typeof a !== &#039;object&#039; || typeof b !== &#039;object&#039;) {
        return false;
      }
      length = stack.length;
      while (length--) {
        if (stack[length] === a) {
          return true;
        }
      }
      stack.push(a);
      size = 0;
      result = true;
      if (className === &#039;[object Array]&#039;) {
        size = a.length;
        result = size === b.length;
        if (result) {
          while (size--) {
            if (!(result = __indexOf.call(a, size) &gt;= 0 === __indexOf.call(b, size) &gt;= 0 &amp;&amp; _isEqual(a[size], b[size], stack))) {
              break;
            }
          }
        }
      } else {
        if (__indexOf.call(a, &quot;constructor&quot;) &gt;= 0 !== __indexOf.call(b, &quot;constructor&quot;) &gt;= 0 || a.constructor !== b.constructor) {
          return false;
        }
        for (key in a) {
          if (hasOwnProperty.call(a, key)) {
            size++;
            if (!(result = hasOwnProperty.call(b, key) &amp;&amp; _isEqual(a[key], b[key], stack))) {
              break;
            }
          }
        }
        if (result) {
          for (key in b) {
            if (hasOwnProperty.call(b, key) &amp;&amp; !size--) {
              break;
            }
          }
          result = !size;
        }
      }
      stack.pop();
      return result;
    };
    isEqual = function(a, b) {
      return _isEqual(a, b, []);
    };
    JSONPatchError = (function(_super) {

      __extends(JSONPatchError, _super);

      function JSONPatchError(message) {
        this.message = message != null ? message : &#039;JSON patch error&#039;;
        this.name = &#039;JSONPatchError&#039;;
      }

      return JSONPatchError;

    })(Error);
    InvalidPointerError = (function(_super) {

      __extends(InvalidPointerError, _super);

      function InvalidPointerError(message) {
        this.message = message != null ? message : &#039;Invalid pointer&#039;;
        this.name = &#039;InvalidPointer&#039;;
      }

      return InvalidPointerError;

    })(Error);
    InvalidPatchError = (function(_super) {

      __extends(InvalidPatchError, _super);

      function InvalidPatchError(message) {
        this.message = message != null ? message : &#039;Invalid patch&#039;;
        this.name = &#039;InvalidPatch&#039;;
      }

      return InvalidPatchError;

    })(JSONPatchError);
    PatchConflictError = (function(_super) {

      __extends(PatchConflictError, _super);

      function PatchConflictError(message) {
        this.message = message != null ? message : &#039;Patch conflict&#039;;
        this.name = &#039;PatchConflictError&#039;;
      }

      return PatchConflictError;

    })(JSONPatchError);
    JSONPointer = (function() {

      function JSONPointer(path) {
        var i, step, steps, _i, _len;
        steps = [];
        if (path &amp;&amp; (steps = decodeURIComponent(path).split(&#039;/&#039;)).shift() !== &#039;&#039;) {
          throw new InvalidPointerError();
        }
        for (i = _i = 0, _len = steps.length; _i &lt; _len; i = ++_i) {
          step = steps[i];
          steps[i] = step.replace(&#039;~1&#039;, &#039;/&#039;).replace(&#039;~0&#039;, &#039;~&#039;);
        }
        this.accessor = steps.pop();
        this.steps = steps;
        this.path = path;
      }

      JSONPointer.prototype.getReference = function(parent) {
        var step, _i, _len, _ref;
        _ref = this.steps;
        for (_i = 0, _len = _ref.length; _i &lt; _len; _i++) {
          step = _ref[_i];
          if (isArray(parent)) {
            step = parseInt(step, 10);
          }
          if (!(step in parent)) {
            throw new PatchConflictError(&#039;Array location out of &#039;, &#039;bounds or not an instance property&#039;);
          }
          parent = parent[step];
        }
        return parent;
      };

      return JSONPointer;

    })();
    JSONPatch = (function() {

      function JSONPatch(patch) {
        if (!(&#039;path&#039; in patch)) {
          throw new InvalidPatchError();
        }
        this.validate(patch);
        this.patch = patch;
        this.path = new JSONPointer(patch.path);
        this.initialize(patch);
      }

      JSONPatch.prototype.initialize = function() {};

      JSONPatch.prototype.validate = function(patch) {};

      JSONPatch.prototype.apply = function(document) {
        throw new Error(&#039;Method not implemented&#039;);
      };

      return JSONPatch;

    })();
    AddPatch = (function(_super) {

      __extends(AddPatch, _super);

      function AddPatch() {
        return AddPatch.__super__.constructor.apply(this, arguments);
      }

      AddPatch.prototype.validate = function(patch) {
        if (!(&#039;value&#039; in patch)) {
          throw new InvalidPatchError();
        }
      };

      AddPatch.prototype.apply = function(document) {
        var accessor, reference, value;
        reference = this.path.getReference(document);
        accessor = this.path.accessor;
        value = this.patch.value;
        if (isArray(reference)) {
          if (accessor === &#039;-&#039;) {
            reference.push(value);
          } else {
            accessor = parseInt(accessor, 10);
            if (accessor &lt; 0 || accessor &gt; reference.length) {
              throw new PatchConflictError(&quot;Index &quot; + accessor + &quot; out of bounds&quot;);
            }
            reference.splice(accessor, 0, value);
          }
        } else {
          if (accessor in reference) {
            throw new PatchConflictError(&quot;Value at &quot; + accessor + &quot; exists&quot;);
          }
          reference[accessor] = value;
        }
      };

      return AddPatch;

    })(JSONPatch);
    RemovePatch = (function(_super) {

      __extends(RemovePatch, _super);

      function RemovePatch() {
        return RemovePatch.__super__.constructor.apply(this, arguments);
      }

      RemovePatch.prototype.apply = function(document) {
        var accessor, reference;
        reference = this.path.getReference(document);
        accessor = this.path.accessor;
        if (isArray(reference)) {
          accessor = parseInt(accessor, 10);
          if (!(accessor in reference)) {
            throw new PatchConflictError(&quot;Value at &quot; + accessor + &quot; does not exist&quot;);
          }
          reference.splice(accessor, 1);
        } else {
          if (!(accessor in reference)) {
            throw new PatchConflictError(&quot;Value at &quot; + accessor + &quot; does not exist&quot;);
          }
          delete reference[accessor];
        }
      };

      return RemovePatch;

    })(JSONPatch);
    ReplacePatch = (function(_super) {

      __extends(ReplacePatch, _super);

      function ReplacePatch() {
        return ReplacePatch.__super__.constructor.apply(this, arguments);
      }

      ReplacePatch.prototype.validate = function(patch) {
        if (!(&#039;value&#039; in patch)) {
          throw new InvalidPatchError();
        }
      };

      ReplacePatch.prototype.apply = function(document) {
        var accessor, reference, value;
        reference = this.path.getReference(document);
        accessor = this.path.accessor;
        value = this.patch.value;
        if (isArray(reference)) {
          accessor = parseInt(accessor, 10);
          if (!(accessor in reference)) {
            throw new PatchConflictError(&quot;Value at &quot; + accessor + &quot; does not exist&quot;);
          }
          reference.splice(accessor, 1, value);
        } else {
          if (!(accessor in reference)) {
            throw new PatchConflictError(&quot;Value at &quot; + accessor + &quot; does not exist&quot;);
          }
          reference[accessor] = value;
        }
      };

      return ReplacePatch;

    })(JSONPatch);
    TestPatch = (function(_super) {

      __extends(TestPatch, _super);

      function TestPatch() {
        return TestPatch.__super__.constructor.apply(this, arguments);
      }

      TestPatch.prototype.validate = function(patch) {
        if (!(&#039;value&#039; in patch)) {
          throw new InvalidPatchError();
        }
      };

      TestPatch.prototype.apply = function(document) {
        var accessor, reference, value;
        reference = this.path.getReference(document);
        accessor = this.path.accessor;
        value = this.patch.value;
        if (isArray(reference)) {
          accessor = parseInt(accessor, 10);
        }
        return isEqual(reference[accessor], value);
      };

      return TestPatch;

    })(JSONPatch);
    MovePatch = (function(_super) {

      __extends(MovePatch, _super);

      function MovePatch() {
        return MovePatch.__super__.constructor.apply(this, arguments);
      }

      MovePatch.prototype.initialize = function(patch) {
        var i, len, within, _i;
        this.from = new JSONPointer(patch.from);
        len = this.from.steps.length;
        within = true;
        for (i = _i = 0; 0 &lt;= len ? _i &lt;= len : _i &gt;= len; i = 0 &lt;= len ? ++_i : --_i) {
          if (this.from.steps[i] !== this.path.steps[i]) {
            within = false;
            break;
          }
        }
        if (within) {
          if (this.path.steps.length !== len) {
            throw new InvalidPatchError(&quot;&#039;to&#039; member cannot be a descendent of &#039;path&#039;&quot;);
          }
          if (this.from.accessor === this.path.accessor) {
            return this.apply = function() {};
          }
        }
      };

      MovePatch.prototype.validate = function(patch) {
        if (!(&#039;from&#039; in patch)) {
          throw new InvalidPatchError();
        }
      };

      MovePatch.prototype.apply = function(document) {
        var accessor, reference, value;
        reference = this.from.getReference(document);
        accessor = this.from.accessor;
        if (isArray(reference)) {
          accessor = parseInt(accessor, 10);
          if (!(accessor in reference)) {
            throw new PatchConflictError(&quot;Value at &quot; + accessor + &quot; does not exist&quot;);
          }
          value = reference.splice(accessor, 1)[0];
        } else {
          if (!(accessor in reference)) {
            throw new PatchConflictError(&quot;Value at &quot; + accessor + &quot; does not exist&quot;);
          }
          value = reference[accessor];
          delete reference[accessor];
        }
        reference = this.path.getReference(document);
        accessor = this.path.accessor;
        if (isArray(reference)) {
          accessor = parseInt(accessor, 10);
          if (accessor &lt; 0 || accessor &gt; reference.length) {
            throw new PatchConflictError(&quot;Index &quot; + accessor + &quot; out of bounds&quot;);
          }
          reference.splice(accessor, 0, value);
        } else {
          if (accessor in reference) {
            throw new PatchConflictError(&quot;Value at &quot; + accessor + &quot; exists&quot;);
          }
          reference[accessor] = value;
        }
      };

      return MovePatch;

    })(JSONPatch);
    CopyPatch = (function(_super) {

      __extends(CopyPatch, _super);

      function CopyPatch() {
        return CopyPatch.__super__.constructor.apply(this, arguments);
      }

      CopyPatch.prototype.apply = function(document) {
        var accessor, reference, value;
        reference = this.from.getReference(document);
        accessor = this.from.accessor;
        if (isArray(reference)) {
          accessor = parseInt(accessor, 10);
          if (!(accessor in reference)) {
            throw new PatchConflictError(&quot;Value at &quot; + accessor + &quot; does not exist&quot;);
          }
          value = reference.slice(accessor, accessor + 1)[0];
        } else {
          if (!(accessor in reference)) {
            throw new PatchConflictError(&quot;Value at &quot; + accessor + &quot; does not exist&quot;);
          }
          value = reference[accessor];
        }
        reference = this.path.getReference(document);
        accessor = this.path.accessor;
        if (isArray(reference)) {
          accessor = parseInt(accessor, 10);
          if (accessor &lt; 0 || accessor &gt; reference.length) {
            throw new PatchConflictError(&quot;Index &quot; + accessor + &quot; out of bounds&quot;);
          }
          reference.splice(accessor, 0, value);
        } else {
          if (accessor in reference) {
            throw new PatchConflictError(&quot;Value at &quot; + accessor + &quot; exists&quot;);
          }
          reference[accessor] = value;
        }
      };

      return CopyPatch;

    })(MovePatch);
    operationMap = {
      add: AddPatch,
      remove: RemovePatch,
      replace: ReplacePatch,
      move: MovePatch,
      copy: CopyPatch,
      test: TestPatch
    };
    compile = function(patch) {
      var klass, ops, p, _i, _len;
      ops = [];
      for (_i = 0, _len = patch.length; _i &lt; _len; _i++) {
        p = patch[_i];
        if (!(klass = operationMap[p.op])) {
          throw new InvalidPatchError();
        }
        ops.push(new klass(p));
      }
      return function(document) {
        var op, result, _j, _len1;
        for (_j = 0, _len1 = ops.length; _j &lt; _len1; _j++) {
          op = ops[_j];
          result = op.apply(document);
        }
        return result;
      };
    };
    apply = function(document, patch) {
      return compile(patch)(document);
    };
    root.apply = apply;
    root.compile = compile;
    root.JSONPatchError = JSONPatchError;
    root.InvalidPointerError = InvalidPointerError;
    root.InvalidPatchError = InvalidPatchError;
    root.PatchConflictError = PatchConflictError;
    return root;
  });

}).call(this);</textarea>
  </div>
</div>

<footer class="footer">
  <div class="container">
    <p>.</p>
  </div>
</footer>

<script type="text/html" id="complexity-popover-template">
  <div class="complexity-notice">
    Complexity : {{ complexity.cyclomatic }} <br>
    Length : {{ complexity.halstead.length }} <br>
    Difficulty : {{ complexity.halstead.difficulty.toFixed(2) }} <br>
    Est # bugs : {{ complexity.halstead.bugs.toFixed(2) }}<br>
  </div>
</script>

<script type="text/javascript" src="../../assets/scripts/bundles/core-bundle.js"></script>
<script type="text/javascript" src="../../assets/scripts/bundles/codemirror.js"></script>
<script type="text/javascript" src="../../assets/scripts/codemirror.markpopovertext.js"></script>
<script type="text/javascript" src="report.js"></script>
<script type="text/javascript" src="report.history.js"></script>
<script type="text/javascript" src="../../assets/scripts/plato-file.js"></script>
</body>
</html>
