<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Plato - node_modules/xmlhttprequest/lib/XMLHttpRequest.js</title>

  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="">
  <meta name="author" content="">

  <!--[if lt IE 9]>
  <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->

  <link href="../../assets/css/vendor/morris.css" rel="stylesheet">
  <link href="../../assets/css/vendor/bootstrap.css" rel="stylesheet">
  <link href="../../assets/css/vendor/font-awesome.css" rel="stylesheet">
  <link href="../../assets/css/vendor/codemirror.css" rel="stylesheet">
  <link href="../../assets/css/plato.css" rel="stylesheet">
  <link href="../../assets/css/plato-file.css" rel="stylesheet">

</head>

<body>

<div class="navbar navbar-fixed-top">
  <div class="container">
    <a class="navbar-brand" href="http://github.com/es-analysis/plato">Plato on Github</a>
    <ul class="nav navbar-nav">
      <li>
        <a href="../../index.html">Report Home</a>
      </li>
    </ul>
  </div>
</div>

<div class="jumbotron">
  <div class="container">
    <h1>node_modules/xmlhttprequest/lib/XMLHttpRequest.js</h1>
  </div>
</div>

<div class="container aggregate-stats">
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Maintainability <a href="http://blogs.msdn.com/b/codeanalysis/archive/2007/11/20/maintainability-index-range-and-meaning.aspx"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="A value between 0 and 100 that represents the relative ease of maintaining the code. A high value means better maintainability." data-original-title="Maintainability Index"  data-container="body"></i></a></h2>
      <p class="stat">59.57</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Lines of code <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h2>
      <p class="stat">586</p>
    </div>
  </div>
  <div class="row historical">
    <div class="col-md-6">
      <p id="chart_historical_maint" class="chart"></p>
    </div>
    <div class="col-md-6">
      <p id="chart_historical_sloc" class="chart"></p>
    </div>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Difficulty  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="The difficulty measure is related to the difficulty of the program to write or understand." data-original-title="Difficulty" data-container="body"></i></a></h2>
      <p class="stat">62.40</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Estimated Errors  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Halstead's delivered bugs is an estimate for the number of errors in the implementation." data-original-title="Delivered Bugs" data-container="body"></i></a></h2>
      <p class="stat">4.09</p>
    </div>
  </div>
</div>

<div class="container charts">
  <div class="row">
    <h2 class="header">Function weight</h2>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h3 class="chart-header">By Complexity <a href="http://en.wikipedia.org/wiki/Cyclomatic_complexity"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="This metric counts the number of distinct paths through a block of code. Lower values are better." data-original-title="Cyclomatic Complexity" data-container="body"></i></a></h3>
      <div id="fn-by-complexity" class="stat"></div>
    </div>
    <div class="col-md-6">
      <h3 class="chart-header">By SLOC  <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h3>
      <div id="fn-by-sloc" class="stat"></div>
    </div>
  </div>
</div>

<div class="container">
  <div class="row">
    <textarea id="file-source" class="col-md-12">/**
 * Wrapper for built-in http.js to emulate the browser XMLHttpRequest object.
 *
 * This can be used with JS designed for browsers to improve reuse of code and
 * allow the use of existing libraries.
 *
 * Usage: include(&quot;XMLHttpRequest.js&quot;) and use XMLHttpRequest per W3C specs.
 *
 * @author Dan DeFelippi &lt;dan@driverdan.com&gt;
 * @contributor David Ellis &lt;d.f.ellis@ieee.org&gt;
 * @license MIT
 */

var Url = require(&quot;url&quot;)
  , spawn = require(&quot;child_process&quot;).spawn
  , fs = require(&#039;fs&#039;);

exports.XMLHttpRequest = function() {
  /**
   * Private variables
   */
  var self = this;
  var http = require(&#039;http&#039;);
  var https = require(&#039;https&#039;);

  // Holds http.js objects
  var request;
  var response;

  // Request settings
  var settings = {};

  // Disable header blacklist.
  // Not part of XHR specs.
  var disableHeaderCheck = false;

  // Set some default headers
  var defaultHeaders = {
    &quot;User-Agent&quot;: &quot;node-XMLHttpRequest&quot;,
    &quot;Accept&quot;: &quot;*/*&quot;,
  };

  var headers = defaultHeaders;

  // These headers are not user setable.
  // The following are allowed but banned in the spec:
  // * user-agent
  var forbiddenRequestHeaders = [
    &quot;accept-charset&quot;,
    &quot;accept-encoding&quot;,
    &quot;access-control-request-headers&quot;,
    &quot;access-control-request-method&quot;,
    &quot;connection&quot;,
    &quot;content-length&quot;,
    &quot;content-transfer-encoding&quot;,
    &quot;cookie&quot;,
    &quot;cookie2&quot;,
    &quot;date&quot;,
    &quot;expect&quot;,
    &quot;host&quot;,
    &quot;keep-alive&quot;,
    &quot;origin&quot;,
    &quot;referer&quot;,
    &quot;te&quot;,
    &quot;trailer&quot;,
    &quot;transfer-encoding&quot;,
    &quot;upgrade&quot;,
    &quot;via&quot;
  ];

  // These request methods are not allowed
  var forbiddenRequestMethods = [
    &quot;TRACE&quot;,
    &quot;TRACK&quot;,
    &quot;CONNECT&quot;
  ];

  // Send flag
  var sendFlag = false;
  // Error flag, used when errors occur or abort is called
  var errorFlag = false;

  // Event listeners
  var listeners = {};

  /**
   * Constants
   */

  this.UNSENT = 0;
  this.OPENED = 1;
  this.HEADERS_RECEIVED = 2;
  this.LOADING = 3;
  this.DONE = 4;

  /**
   * Public vars
   */

  // Current state
  this.readyState = this.UNSENT;

  // default ready state change handler in case one is not set or is set late
  this.onreadystatechange = null;

  // Result &amp; response
  this.responseText = &quot;&quot;;
  this.responseXML = &quot;&quot;;
  this.status = null;
  this.statusText = null;

  /**
   * Private methods
   */

  /**
   * Check if the specified header is allowed.
   *
   * @param string header Header to validate
   * @return boolean False if not allowed, otherwise true
   */
  var isAllowedHttpHeader = function(header) {
    return disableHeaderCheck || (header &amp;&amp; forbiddenRequestHeaders.indexOf(header.toLowerCase()) === -1);
  };

  /**
   * Check if the specified method is allowed.
   *
   * @param string method Request method to validate
   * @return boolean False if not allowed, otherwise true
   */
  var isAllowedHttpMethod = function(method) {
    return (method &amp;&amp; forbiddenRequestMethods.indexOf(method) === -1);
  };

  /**
   * Public methods
   */

  /**
   * Open the connection. Currently supports local server requests.
   *
   * @param string method Connection method (eg GET, POST)
   * @param string url URL for the connection.
   * @param boolean async Asynchronous connection. Default is true.
   * @param string user Username for basic authentication (optional)
   * @param string password Password for basic authentication (optional)
   */
  this.open = function(method, url, async, user, password) {
    this.abort();
    errorFlag = false;

    // Check for valid request method
    if (!isAllowedHttpMethod(method)) {
      throw &quot;SecurityError: Request method not allowed&quot;;
    }

    settings = {
      &quot;method&quot;: method,
      &quot;url&quot;: url.toString(),
      &quot;async&quot;: (typeof async !== &quot;boolean&quot; ? true : async),
      &quot;user&quot;: user || null,
      &quot;password&quot;: password || null
    };

    setState(this.OPENED);
  };

  /**
   * Disables or enables isAllowedHttpHeader() check the request. Enabled by default.
   * This does not conform to the W3C spec.
   *
   * @param boolean state Enable or disable header checking.
   */
  this.setDisableHeaderCheck = function(state) {
    disableHeaderCheck = state;
  };

  /**
   * Sets a header for the request.
   *
   * @param string header Header name
   * @param string value Header value
   */
  this.setRequestHeader = function(header, value) {
    if (this.readyState != this.OPENED) {
      throw &quot;INVALID_STATE_ERR: setRequestHeader can only be called when state is OPEN&quot;;
    }
    if (!isAllowedHttpHeader(header)) {
      console.warn(&#039;Refused to set unsafe header &quot;&#039; + header + &#039;&quot;&#039;);
      return;
    }
    if (sendFlag) {
      throw &quot;INVALID_STATE_ERR: send flag is true&quot;;
    }
    headers[header] = value;
  };

  /**
   * Gets a header from the server response.
   *
   * @param string header Name of header to get.
   * @return string Text of the header or null if it doesn&#039;t exist.
   */
  this.getResponseHeader = function(header) {
    if (typeof header === &quot;string&quot;
      &amp;&amp; this.readyState &gt; this.OPENED
      &amp;&amp; response.headers[header.toLowerCase()]
      &amp;&amp; !errorFlag
    ) {
      return response.headers[header.toLowerCase()];
    }

    return null;
  };

  /**
   * Gets all the response headers.
   *
   * @return string A string with all response headers separated by CR+LF
   */
  this.getAllResponseHeaders = function() {
    if (this.readyState &lt; this.HEADERS_RECEIVED || errorFlag) {
      return &quot;&quot;;
    }
    var result = &quot;&quot;;

    for (var i in response.headers) {
      // Cookie headers are excluded
      if (i !== &quot;set-cookie&quot; &amp;&amp; i !== &quot;set-cookie2&quot;) {
        result += i + &quot;: &quot; + response.headers[i] + &quot;\r\n&quot;;
      }
    }
    return result.substr(0, result.length - 2);
  };

  /**
   * Gets a request header
   *
   * @param string name Name of header to get
   * @return string Returns the request header or empty string if not set
   */
  this.getRequestHeader = function(name) {
    // @TODO Make this case insensitive
    if (typeof name === &quot;string&quot; &amp;&amp; headers[name]) {
      return headers[name];
    }

    return &quot;&quot;;
  };

  /**
   * Sends the request to the server.
   *
   * @param string data Optional data to send as request body.
   */
  this.send = function(data) {
    if (this.readyState != this.OPENED) {
      throw &quot;INVALID_STATE_ERR: connection must be opened before send() is called&quot;;
    }

    if (sendFlag) {
      throw &quot;INVALID_STATE_ERR: send has already been called&quot;;
    }

    var ssl = false, local = false;
    var url = Url.parse(settings.url);
    var host;
    // Determine the server
    switch (url.protocol) {
      case &#039;https:&#039;:
        ssl = true;
        // SSL &amp; non-SSL both need host, no break here.
      case &#039;http:&#039;:
        host = url.hostname;
        break;

      case &#039;file:&#039;:
        local = true;
        break;

      case undefined:
      case &#039;&#039;:
        host = &quot;localhost&quot;;
        break;

      default:
        throw &quot;Protocol not supported.&quot;;
    }

    // Load files off the local filesystem (file://)
    if (local) {
      if (settings.method !== &quot;GET&quot;) {
        throw &quot;XMLHttpRequest: Only GET method is supported&quot;;
      }

      if (settings.async) {
        fs.readFile(url.pathname, &#039;utf8&#039;, function(error, data) {
          if (error) {
            self.handleError(error);
          } else {
            self.status = 200;
            self.responseText = data;
            setState(self.DONE);
          }
        });
      } else {
        try {
          this.responseText = fs.readFileSync(url.pathname, &#039;utf8&#039;);
          this.status = 200;
          setState(self.DONE);
        } catch(e) {
          this.handleError(e);
        }
      }

      return;
    }

    // Default to port 80. If accessing localhost on another port be sure
    // to use http://localhost:port/path
    var port = url.port || (ssl ? 443 : 80);
    // Add query string if one is used
    var uri = url.pathname + (url.search ? url.search : &#039;&#039;);

    // Set the Host header or the server may reject the request
    headers[&quot;Host&quot;] = host;
    if (!((ssl &amp;&amp; port === 443) || port === 80)) {
      headers[&quot;Host&quot;] += &#039;:&#039; + url.port;
    }

    // Set Basic Auth if necessary
    if (settings.user) {
      if (typeof settings.password == &quot;undefined&quot;) {
        settings.password = &quot;&quot;;
      }
      var authBuf = new Buffer(settings.user + &quot;:&quot; + settings.password);
      headers[&quot;Authorization&quot;] = &quot;Basic &quot; + authBuf.toString(&quot;base64&quot;);
    }

    // Set content length header
    if (settings.method === &quot;GET&quot; || settings.method === &quot;HEAD&quot;) {
      data = null;
    } else if (data) {
      headers[&quot;Content-Length&quot;] = Buffer.isBuffer(data) ? data.length : Buffer.byteLength(data);

      if (!headers[&quot;Content-Type&quot;]) {
        headers[&quot;Content-Type&quot;] = &quot;text/plain;charset=UTF-8&quot;;
      }
    } else if (settings.method === &quot;POST&quot;) {
      // For a post with no data set Content-Length: 0.
      // This is required by buggy servers that don&#039;t meet the specs.
      headers[&quot;Content-Length&quot;] = 0;
    }

    var options = {
      host: host,
      port: port,
      path: uri,
      method: settings.method,
      headers: headers,
      agent: false
    };

    // Reset error flag
    errorFlag = false;

    // Handle async requests
    if (settings.async) {
      // Use the proper protocol
      var doRequest = ssl ? https.request : http.request;

      // Request is being sent, set send flag
      sendFlag = true;

      // As per spec, this is called here for historical reasons.
      self.dispatchEvent(&quot;readystatechange&quot;);

      // Handler for the response
      function responseHandler(resp) {
        // Set response var to the response we got back
        // This is so it remains accessable outside this scope
        response = resp;
        // Check for redirect
        // @TODO Prevent looped redirects
        if (response.statusCode === 302 || response.statusCode === 303 || response.statusCode === 307) {
          // Change URL to the redirect location
          settings.url = response.headers.location;
          var url = Url.parse(settings.url);
          // Set host var in case it&#039;s used later
          host = url.hostname;
          // Options for the new request
          var newOptions = {
            hostname: url.hostname,
            port: url.port,
            path: url.path,
            method: response.statusCode === 303 ? &#039;GET&#039; : settings.method,
            headers: headers
          };

          // Issue the new request
          request = doRequest(newOptions, responseHandler).on(&#039;error&#039;, errorHandler);
          request.end();
          // @TODO Check if an XHR event needs to be fired here
          return;
        }

        response.setEncoding(&quot;utf8&quot;);

        setState(self.HEADERS_RECEIVED);
        self.status = response.statusCode;

        response.on(&#039;data&#039;, function(chunk) {
          // Make sure there&#039;s some data
          if (chunk) {
            self.responseText += chunk;
          }
          // Don&#039;t emit state changes if the connection has been aborted.
          if (sendFlag) {
            setState(self.LOADING);
          }
        });

        response.on(&#039;end&#039;, function() {
          if (sendFlag) {
            // Discard the &#039;end&#039; event if the connection has been aborted
            setState(self.DONE);
            sendFlag = false;
          }
        });

        response.on(&#039;error&#039;, function(error) {
          self.handleError(error);
        });
      }

      // Error handler for the request
      function errorHandler(error) {
        self.handleError(error);
      }

      // Create the request
      request = doRequest(options, responseHandler).on(&#039;error&#039;, errorHandler);

      // Node 0.4 and later won&#039;t accept empty data. Make sure it&#039;s needed.
      if (data) {
        request.write(data);
      }

      request.end();

      self.dispatchEvent(&quot;loadstart&quot;);
    } else { // Synchronous
      // Create a temporary file for communication with the other Node process
      var contentFile = &quot;.node-xmlhttprequest-content-&quot; + process.pid;
      var syncFile = &quot;.node-xmlhttprequest-sync-&quot; + process.pid;
      fs.writeFileSync(syncFile, &quot;&quot;, &quot;utf8&quot;);
      // The async request the other Node process executes
      var execString = &quot;var http = require(&#039;http&#039;), https = require(&#039;https&#039;), fs = require(&#039;fs&#039;);&quot;
        + &quot;var doRequest = http&quot; + (ssl ? &quot;s&quot; : &quot;&quot;) + &quot;.request;&quot;
        + &quot;var options = &quot; + JSON.stringify(options) + &quot;;&quot;
        + &quot;var responseText = &#039;&#039;;&quot;
        + &quot;var req = doRequest(options, function(response) {&quot;
        + &quot;response.setEncoding(&#039;utf8&#039;);&quot;
        + &quot;response.on(&#039;data&#039;, function(chunk) {&quot;
        + &quot;  responseText += chunk;&quot;
        + &quot;});&quot;
        + &quot;response.on(&#039;end&#039;, function() {&quot;
        + &quot;fs.writeFileSync(&#039;&quot; + contentFile + &quot;&#039;, &#039;NODE-XMLHTTPREQUEST-STATUS:&#039; + response.statusCode + &#039;,&#039; + responseText, &#039;utf8&#039;);&quot;
        + &quot;fs.unlinkSync(&#039;&quot; + syncFile + &quot;&#039;);&quot;
        + &quot;});&quot;
        + &quot;response.on(&#039;error&#039;, function(error) {&quot;
        + &quot;fs.writeFileSync(&#039;&quot; + contentFile + &quot;&#039;, &#039;NODE-XMLHTTPREQUEST-ERROR:&#039; + JSON.stringify(error), &#039;utf8&#039;);&quot;
        + &quot;fs.unlinkSync(&#039;&quot; + syncFile + &quot;&#039;);&quot;
        + &quot;});&quot;
        + &quot;}).on(&#039;error&#039;, function(error) {&quot;
        + &quot;fs.writeFileSync(&#039;&quot; + contentFile + &quot;&#039;, &#039;NODE-XMLHTTPREQUEST-ERROR:&#039; + JSON.stringify(error), &#039;utf8&#039;);&quot;
        + &quot;fs.unlinkSync(&#039;&quot; + syncFile + &quot;&#039;);&quot;
        + &quot;});&quot;
        + (data ? &quot;req.write(&#039;&quot; + data.replace(/&#039;/g, &quot;\\&#039;&quot;) + &quot;&#039;);&quot;:&quot;&quot;)
        + &quot;req.end();&quot;;
      // Start the other Node Process, executing this string
      var syncProc = spawn(process.argv[0], [&quot;-e&quot;, execString]);
      var statusText;
      while(fs.existsSync(syncFile)) {
        // Wait while the sync file is empty
      }
      self.responseText = fs.readFileSync(contentFile, &#039;utf8&#039;);
      // Kill the child process once the file has data
      syncProc.stdin.end();
      // Remove the temporary file
      fs.unlinkSync(contentFile);
      if (self.responseText.match(/^NODE-XMLHTTPREQUEST-ERROR:/)) {
        // If the file returned an error, handle it
        var errorObj = self.responseText.replace(/^NODE-XMLHTTPREQUEST-ERROR:/, &quot;&quot;);
        self.handleError(errorObj);
      } else {
        // If the file returned okay, parse its data and move to the DONE state
        self.status = self.responseText.replace(/^NODE-XMLHTTPREQUEST-STATUS:([0-9]*),.*/, &quot;$1&quot;);
        self.responseText = self.responseText.replace(/^NODE-XMLHTTPREQUEST-STATUS:[0-9]*,(.*)/, &quot;$1&quot;);
        setState(self.DONE);
      }
    }
  };

  /**
   * Called when an error is encountered to deal with it.
   */
  this.handleError = function(error) {
    this.status = 503;
    this.statusText = error;
    this.responseText = error.stack;
    errorFlag = true;
    setState(this.DONE);
  };

  /**
   * Aborts a request.
   */
  this.abort = function() {
    if (request) {
      request.abort();
      request = null;
    }

    headers = defaultHeaders;
    this.responseText = &quot;&quot;;
    this.responseXML = &quot;&quot;;

    errorFlag = true;

    if (this.readyState !== this.UNSENT
        &amp;&amp; (this.readyState !== this.OPENED || sendFlag)
        &amp;&amp; this.readyState !== this.DONE) {
      sendFlag = false;
      setState(this.DONE);
    }
    this.readyState = this.UNSENT;
  };

  /**
   * Adds an event listener. Preferred method of binding to events.
   */
  this.addEventListener = function(event, callback) {
    if (!(event in listeners)) {
      listeners[event] = [];
    }
    // Currently allows duplicate callbacks. Should it?
    listeners[event].push(callback);
  };

  /**
   * Remove an event callback that has already been bound.
   * Only works on the matching funciton, cannot be a copy.
   */
  this.removeEventListener = function(event, callback) {
    if (event in listeners) {
      // Filter will return a new array with the callback removed
      listeners[event] = listeners[event].filter(function(ev) {
        return ev !== callback;
      });
    }
  };

  /**
   * Dispatch any events, including both &quot;on&quot; methods and events attached using addEventListener.
   */
  this.dispatchEvent = function(event) {
    if (typeof self[&quot;on&quot; + event] === &quot;function&quot;) {
      self[&quot;on&quot; + event]();
    }
    if (event in listeners) {
      for (var i = 0, len = listeners[event].length; i &lt; len; i++) {
        listeners[event][i].call(self);
      }
    }
  };

  /**
   * Changes readyState and calls onreadystatechange.
   *
   * @param int state New state
   */
  var setState = function(state) {
    if (self.readyState !== state) {
      self.readyState = state;

      if (settings.async || self.readyState &lt; self.OPENED || self.readyState === self.DONE) {
        self.dispatchEvent(&quot;readystatechange&quot;);
      }

      if (self.readyState === self.DONE &amp;&amp; !errorFlag) {
        self.dispatchEvent(&quot;load&quot;);
        // @TODO figure out InspectorInstrumentation::didLoadXHR(cookie)
        self.dispatchEvent(&quot;loadend&quot;);
      }
    }
  };
};</textarea>
  </div>
</div>

<footer class="footer">
  <div class="container">
    <p>.</p>
  </div>
</footer>

<script type="text/html" id="complexity-popover-template">
  <div class="complexity-notice">
    Complexity : {{ complexity.cyclomatic }} <br>
    Length : {{ complexity.halstead.length }} <br>
    Difficulty : {{ complexity.halstead.difficulty.toFixed(2) }} <br>
    Est # bugs : {{ complexity.halstead.bugs.toFixed(2) }}<br>
  </div>
</script>

<script type="text/javascript" src="../../assets/scripts/bundles/core-bundle.js"></script>
<script type="text/javascript" src="../../assets/scripts/bundles/codemirror.js"></script>
<script type="text/javascript" src="../../assets/scripts/codemirror.markpopovertext.js"></script>
<script type="text/javascript" src="report.js"></script>
<script type="text/javascript" src="report.history.js"></script>
<script type="text/javascript" src="../../assets/scripts/plato-file.js"></script>
</body>
</html>
