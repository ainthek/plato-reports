<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Plato - node_modules/nwmatcher/src/nwmatcher.js</title>

  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="">
  <meta name="author" content="">

  <!--[if lt IE 9]>
  <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->

  <link href="../../assets/css/vendor/morris.css" rel="stylesheet">
  <link href="../../assets/css/vendor/bootstrap.css" rel="stylesheet">
  <link href="../../assets/css/vendor/font-awesome.css" rel="stylesheet">
  <link href="../../assets/css/vendor/codemirror.css" rel="stylesheet">
  <link href="../../assets/css/plato.css" rel="stylesheet">
  <link href="../../assets/css/plato-file.css" rel="stylesheet">

</head>

<body>

<div class="navbar navbar-fixed-top">
  <div class="container">
    <a class="navbar-brand" href="http://github.com/es-analysis/plato">Plato on Github</a>
    <ul class="nav navbar-nav">
      <li>
        <a href="../../index.html">Report Home</a>
      </li>
    </ul>
  </div>
</div>

<div class="jumbotron">
  <div class="container">
    <h1>node_modules/nwmatcher/src/nwmatcher.js</h1>
  </div>
</div>

<div class="container aggregate-stats">
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Maintainability <a href="http://blogs.msdn.com/b/codeanalysis/archive/2007/11/20/maintainability-index-range-and-meaning.aspx"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="A value between 0 and 100 that represents the relative ease of maintaining the code. A high value means better maintainability." data-original-title="Maintainability Index"  data-container="body"></i></a></h2>
      <p class="stat">52.78</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Lines of code <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h2>
      <p class="stat">1653</p>
    </div>
  </div>
  <div class="row historical">
    <div class="col-md-6">
      <p id="chart_historical_maint" class="chart"></p>
    </div>
    <div class="col-md-6">
      <p id="chart_historical_sloc" class="chart"></p>
    </div>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Difficulty  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="The difficulty measure is related to the difficulty of the program to write or understand." data-original-title="Difficulty" data-container="body"></i></a></h2>
      <p class="stat">105.77</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Estimated Errors  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Halstead's delivered bugs is an estimate for the number of errors in the implementation." data-original-title="Delivered Bugs" data-container="body"></i></a></h2>
      <p class="stat">18.49</p>
    </div>
  </div>
</div>

<div class="container charts">
  <div class="row">
    <h2 class="header">Function weight</h2>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h3 class="chart-header">By Complexity <a href="http://en.wikipedia.org/wiki/Cyclomatic_complexity"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="This metric counts the number of distinct paths through a block of code. Lower values are better." data-original-title="Cyclomatic Complexity" data-container="body"></i></a></h3>
      <div id="fn-by-complexity" class="stat"></div>
    </div>
    <div class="col-md-6">
      <h3 class="chart-header">By SLOC  <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h3>
      <div id="fn-by-sloc" class="stat"></div>
    </div>
  </div>
</div>

<div class="container">
  <div class="row">
    <textarea id="file-source" class="col-md-12">/*
 * Copyright (C) 2007-2014 Diego Perini
 * All rights reserved.
 *
 * nwmatcher.js - A fast CSS selector engine and matcher
 *
 * Author: Diego Perini &lt;diego.perini at gmail com&gt;
 * Version: 1.3.3
 * Created: 20070722
 * Release: 20140330
 *
 * License:
 *  http://javascript.nwbox.com/NWMatcher/MIT-LICENSE
 * Download:
 *  http://javascript.nwbox.com/NWMatcher/nwmatcher.js
 */

(function(global, factory) {

  if (typeof module == &#039;object&#039; &amp;&amp; typeof exports == &#039;object&#039;) {
    // in a Node.js environment, the nwmatcher functions will operate on
    // the passed &quot;browserGlobal&quot; and will be returned in an object
    module.exports = function (browserGlobal) {
      // passed global does not contain
      // references to native objects
      browserGlobal.console = console;
      browserGlobal.parseInt = parseInt;
      browserGlobal.Function = Function;
      browserGlobal.Boolean = Boolean;
      browserGlobal.Number = Number;
      browserGlobal.RegExp = RegExp;
      browserGlobal.String = String;
      browserGlobal.Object = Object;
      browserGlobal.Array = Array;
      browserGlobal.Error = Error;
      browserGlobal.Date = Date;
      browserGlobal.Math = Math;
      var exports = browserGlobal.Object();
      factory(browserGlobal, exports);
      return exports;
    };
    module.factory = factory; 
  } else {
    // in a browser environment, the nwmatcher functions will operate on
    // the &quot;global&quot; loading them and be attached to &quot;global.NW.Dom&quot;
    factory(global,
      (global.NW || (global.NW = global.Object())) &amp;&amp;
      (global.NW.Dom || (global.NW.Dom = global.Object())));
    global.NW.Dom.factory = factory;
  }

})(this, function(global, exports) {

  var version = &#039;nwmatcher-1.3.3&#039;,

  Dom = exports,

  // processing context &amp; root element
  doc = global.document,
  root = doc.documentElement,

  // save utility methods references
  slice = global.Array.prototype.slice,
  string = global.Object.prototype.toString,

  // persist previous parsed data
  isSingleMatch,
  isSingleSelect,

  lastSlice,
  lastContext,
  lastPosition,

  lastMatcher,
  lastSelector,

  lastPartsMatch,
  lastPartsSelect,

  // accepted prefix identifiers
  // (id, class &amp; pseudo-class)
  prefixes = &#039;[#.:]?&#039;,

  // accepted attribute operators
  operators = &#039;([~*^$|!]?={1})&#039;,

  // accepted whitespace characters
  whitespace = &#039;[\\x20\\t\\n\\r\\f]*&#039;,

  // 4 combinators F E, F&gt;E, F+E, F~E
  combinators = &#039;[\\x20]|[&gt;+~][^&gt;+~]&#039;,

  // an+b format params for pseudo-classes
  pseudoparms = &#039;(?:[-+]?\\d*n)?[-+]?\\d*&#039;,

  // CSS quoted string values
  quotedvalue = &#039;&quot;[^&quot;]*&quot;&#039; + &quot;|&#039;[^&#039;]*&#039;&quot;,

  // skip round brackets groups
  skipround = &#039;\\([^()]+\\)|\\(.*\\)&#039;,
  // skip curly brackets groups
  skipcurly = &#039;\\{[^{}]+\\}|\\{.*\\}&#039;,
  // skip square brackets groups
  skipsquare = &#039;\\[[^[\\]]*\\]|\\[.*\\]&#039;,

  // skip [ ], ( ), { } brackets groups
  skipgroup = &#039;\\[.*\\]|\\(.*\\)|\\{.*\\}&#039;,

  // http://www.w3.org/TR/css3-syntax/#characters
  // unicode/ISO 10646 characters 161 and higher
  // NOTE: Safari 2.0.x crashes with escaped (\\)
  // Unicode ranges in regular expressions so we
  // use a negated character range class instead
  encoding = &#039;(?:[-\\w]|[^\\x00-\\xa0]|\\\\.)&#039;,

  // CSS identifier syntax
  identifier = &#039;(?:-?[_a-zA-Z]{1}[-\\w]*|[^\\x00-\\xa0]+|\\\\.+)+&#039;,

  // build attribute string
  attrcheck = &#039;(&#039; + quotedvalue + &#039;|&#039; + identifier + &#039;)&#039;,
  attributes = whitespace + &#039;(&#039; + encoding + &#039;*:?&#039; + encoding + &#039;+)&#039; +
    whitespace + &#039;(?:&#039; + operators + whitespace + attrcheck + &#039;)?&#039; + whitespace,
  attrmatcher = attributes.replace(attrcheck, &#039;([\\x22\\x27]*)((?:\\\\?.)*?)\\3&#039;),

  // build pseudoclass string
  pseudoclass = &#039;((?:&#039; +
    // an+b parameters or quoted string
    pseudoparms + &#039;|&#039; + quotedvalue + &#039;|&#039; +
    // id, class, pseudo-class selector
    prefixes + &#039;|&#039; + encoding + &#039;+|&#039; +
    // nested HTML attribute selector
    &#039;\\[&#039; + attributes + &#039;\\]|&#039; +
    // nested pseudo-class selector
    &#039;\\(.+\\)|&#039; + whitespace + &#039;|&#039; +
    // nested pseudos/separators
    &#039;,)+)&#039;,

  // placeholder for extensions
  extensions = &#039;.+&#039;,

  // CSS3: syntax scanner and
  // one pass validation only
  // using regular expression
  standardValidator =
    // discard start
    &#039;(?=[\\x20\\t\\n\\r\\f]*[^&gt;+~(){}&lt;&gt;])&#039; +
    // open match group
    &#039;(&#039; +
    //universal selector
    &#039;\\*&#039; +
    // id/class/tag/pseudo-class identifier
    &#039;|(?:&#039; + prefixes + identifier + &#039;)&#039; +
    // combinator selector
    &#039;|&#039; + combinators +
    // HTML attribute selector
    &#039;|\\[&#039; + attributes + &#039;\\]&#039; +
    // pseudo-classes parameters
    &#039;|\\(&#039; + pseudoclass + &#039;\\)&#039; +
    // dom properties selector (extension)
    &#039;|\\{&#039; + extensions + &#039;\\}&#039; +
    // selector group separator (comma)
    &#039;|(?:,|&#039; + whitespace + &#039;)&#039; +
    // close match group
    &#039;)+&#039;,

  // validator for complex selectors in &#039;:not()&#039; pseudo-classes
  extendedValidator = standardValidator.replace(pseudoclass, &#039;.*&#039;),

  // validator for standard selectors as default
  reValidator = new global.RegExp(standardValidator, &#039;g&#039;),

  // whitespace is any combination of these 5 character [\x20\t\n\r\f]
  // http://www.w3.org/TR/css3-selectors/#selector-syntax
  reTrimSpaces = new global.RegExp(&#039;^&#039; +
    whitespace + &#039;|&#039; + whitespace + &#039;$&#039;, &#039;g&#039;),

  // only allow simple selectors nested in &#039;:not()&#039; pseudo-classes
  reSimpleNot = new global.RegExp(&#039;^(&#039; +
    &#039;(?!:not)&#039; +
    &#039;(&#039; + prefixes +
    &#039;|&#039; + identifier +
    &#039;|\\([^()]*\\))+&#039; +
    &#039;|\\[&#039; + attributes + &#039;\\]&#039; +
    &#039;)$&#039;),

  // split comma groups, exclude commas from
  // quotes &#039;&#039; &quot;&quot; and from brackets () [] {}
  reSplitGroup = new global.RegExp(&#039;(&#039; +
    &#039;[^,\\\\()[\\]]+&#039; +
    &#039;|&#039; + skipsquare +
    &#039;|&#039; + skipround +
    &#039;|&#039; + skipcurly +
    &#039;|\\\\.&#039; +
    &#039;)+&#039;, &#039;g&#039;),

  // split last, right most, selector group token
  reSplitToken = new global.RegExp(&#039;(&#039; +
    &#039;\\[&#039; + attributes + &#039;\\]|&#039; +
    &#039;\\(&#039; + pseudoclass + &#039;\\)|&#039; +
    &#039;\\\\.|[^\\x20\\t\\r\\n\\f&gt;+~])+&#039;, &#039;g&#039;),

  // for in excess whitespace removal
  reWhiteSpace = /[\x20\t\n\r\f]+/g,

  reOptimizeSelector = new global.RegExp(identifier + &#039;|^$&#039;),

  /*----------------------------- FEATURE TESTING ----------------------------*/

  // detect native methods
  isNative = (function() {
    var s = (doc.appendChild + &#039;&#039;).replace(/appendChild/g, &#039;&#039;);
    return function(object, method) {
      var m = object &amp;&amp; object[method] || false;
      return m &amp;&amp; typeof m != &#039;string&#039; &amp;&amp;
        s == (m + &#039;&#039;).replace(new global.RegExp(method, &#039;g&#039;), &#039;&#039;);
    };
  })(),

  // NATIVE_XXXXX true if method exist and is callable
  // detect if DOM methods are native in browsers
  NATIVE_FOCUS = isNative(doc, &#039;hasFocus&#039;),
  NATIVE_QSAPI = isNative(doc, &#039;querySelector&#039;),
  NATIVE_GEBID = isNative(doc, &#039;getElementById&#039;),
  NATIVE_GEBTN = isNative(root, &#039;getElementsByTagName&#039;),
  NATIVE_GEBCN = isNative(root, &#039;getElementsByClassName&#039;),

  // detect native getAttribute/hasAttribute methods,
  // frameworks extend these to elements, but it seems
  // this does not work for XML namespaced attributes,
  // used to check both getAttribute/hasAttribute in IE
  NATIVE_GET_ATTRIBUTE = isNative(root, &#039;getAttribute&#039;),
  NATIVE_HAS_ATTRIBUTE = isNative(root, &#039;hasAttribute&#039;),

  // check if slice() can convert nodelist to array
  // see http://yura.thinkweb2.com/cft/
  NATIVE_SLICE_PROTO =
    (function() {
      var isBuggy = false;
      try {
        isBuggy = !!slice.call(doc.childNodes, 0)[0];
      } catch(e) { }
      return isBuggy;
    })(),

  // supports the new traversal API
  NATIVE_TRAVERSAL_API =
    &#039;nextElementSibling&#039; in root &amp;&amp; &#039;previousElementSibling&#039; in root,

  // BUGGY_XXXXX true if method is feature tested and has known bugs
  // detect buggy gEBID
  BUGGY_GEBID = NATIVE_GEBID ?
    (function() {
      var isBuggy = true, x = &#039;x&#039; + global.String(+new global.Date),
        a = doc.createElementNS ? &#039;a&#039; : &#039;&lt;a name=&quot;&#039; + x + &#039;&quot;&gt;&#039;;
      (a = doc.createElement(a)).name = x;
      root.insertBefore(a, root.firstChild);
      isBuggy = !!doc.getElementById(x);
      root.removeChild(a);
      return isBuggy;
    })() :
    true,

  // detect IE gEBTN comment nodes bug
  BUGGY_GEBTN = NATIVE_GEBTN ?
    (function() {
      var div = doc.createElement(&#039;div&#039;);
      div.appendChild(doc.createComment(&#039;&#039;));
      return !!div.getElementsByTagName(&#039;*&#039;)[0];
    })() :
    true,

  // detect Opera gEBCN second class and/or UTF8 bugs as well as Safari 3.2
  // caching class name results and not detecting when changed,
  // tests are based on the jQuery selector test suite
  BUGGY_GEBCN = NATIVE_GEBCN ?
    (function() {
      var isBuggy, div = doc.createElement(&#039;div&#039;), test = &#039;\u53f0\u5317&#039;;

      // Opera tests
      div.appendChild(doc.createElement(&#039;span&#039;)).
        setAttribute(&#039;class&#039;, test + &#039;abc &#039; + test);
      div.appendChild(doc.createElement(&#039;span&#039;)).
        setAttribute(&#039;class&#039;, &#039;x&#039;);

      isBuggy = !div.getElementsByClassName(test)[0];

      // Safari test
      div.lastChild.className = test;
      return isBuggy || div.getElementsByClassName(test).length != 2;
    })() :
    true,

  // detect IE bug with dynamic attributes
  BUGGY_GET_ATTRIBUTE = NATIVE_GET_ATTRIBUTE ?
    (function() {
      var input = doc.createElement(&#039;input&#039;);
      input.setAttribute(&#039;value&#039;, 5);
      return input.defaultValue != 5;
    })() :
    true,

  // detect IE bug with non-standard boolean attributes
  BUGGY_HAS_ATTRIBUTE = NATIVE_HAS_ATTRIBUTE ?
    (function() {
      var option = doc.createElement(&#039;option&#039;);
      option.setAttribute(&#039;selected&#039;, &#039;selected&#039;);
      return !option.hasAttribute(&#039;selected&#039;);
    })() :
    true,

  // detect Safari bug with selected option elements
  BUGGY_SELECTED =
    (function() {
      var select = doc.createElement(&#039;select&#039;);
      select.appendChild(doc.createElement(&#039;option&#039;));
      return !select.firstChild.selected;
    })(),

  // initialized with the loading context
  // and reset for each different context
  BUGGY_QUIRKS_GEBCN,
  BUGGY_QUIRKS_QSAPI,

  QUIRKS_MODE,
  XML_DOCUMENT,

  // detect Opera browser
  OPERA = /opera/i.test(string.call(global.opera)),

  // skip simple selector optimizations for Opera &gt;= 11
  OPERA_QSAPI = OPERA &amp;&amp; global.parseFloat(global.opera.version()) &gt;= 11,

  // check Selector API implementations
  RE_BUGGY_QSAPI = NATIVE_QSAPI ?
    (function() {
      var pattern = new global.Array(), div = doc.createElement(&#039;div&#039;), element,

      expect = function(selector, context, element, n) {
        var result = false;
        context.appendChild(element);
        try { result = context.querySelectorAll(selector).length == n; } catch(e) { }
        while (context.firstChild) { context.removeChild(context.firstChild); }
        return result;
      };

      // ^= $= *= operators bugs with empty values (Opera 10 / IE8)
      element = doc.createElement(&#039;p&#039;);
      element.setAttribute(&#039;class&#039;, &#039;&#039;);
      expect(&#039;[class^=&quot;&quot;]&#039;, div, element, 1) &amp;&amp;
        pattern.push(&#039;[*^$]=[\\x20\\t\\n\\r\\f]*(?:&quot;&quot;|&#039; + &quot;&#039;&#039;)&quot;);

      // :checked bug with option elements (Firefox 3.6.x)
      // it wrongly includes &#039;selected&#039; options elements
      // HTML5 rules says selected options also match
      element = doc.createElement(&#039;option&#039;);
      element.setAttribute(&#039;selected&#039;, &#039;selected&#039;);
      expect(&#039;:checked&#039;, div, element, 0) &amp;&amp;
        pattern.push(&#039;:checked&#039;);

      // :enabled :disabled bugs with hidden fields (Firefox 3.5)
      // http://www.w3.org/TR/html5/links.html#selector-enabled
      // http://www.w3.org/TR/css3-selectors/#enableddisabled
      // not supported by IE8 Query Selector
      element = doc.createElement(&#039;input&#039;);
      element.setAttribute(&#039;type&#039;, &#039;hidden&#039;);
      expect(&#039;:enabled&#039;, div, element, 0) &amp;&amp;
        pattern.push(&#039;:enabled&#039;, &#039;:disabled&#039;);

      // :link bugs with hyperlinks matching (Firefox/Safari)
      element = doc.createElement(&#039;link&#039;);
      element.setAttribute(&#039;href&#039;, &#039;x&#039;);
      expect(&#039;:link&#039;, div, element, 1) ||
        pattern.push(&#039;:link&#039;);

      // avoid attribute selectors for IE QSA
      if (BUGGY_HAS_ATTRIBUTE) {
        // IE fails in reading:
        // - original values for input/textarea
        // - original boolean values for controls
        pattern.push(&#039;\\[[\\x20\\t\\n\\r\\f]*(?:checked|disabled|ismap|multiple|readonly|selected|value)&#039;);
      }

      return pattern.length ?
        new global.RegExp(pattern.join(&#039;|&#039;)) :
        { &#039;test&#039;: function() { return false; } };

    })() :
    true,

  // matches class selectors
  RE_CLASS = new global.RegExp(&#039;(?:\\[[\\x20\\t\\n\\r\\f]*class\\b|\\.&#039; + identifier + &#039;)&#039;),

  // matches simple id, tag &amp; class selectors
  RE_SIMPLE_SELECTOR = new global.RegExp(
    BUGGY_GEBTN &amp;&amp; BUGGY_GEBCN || OPERA ?
      &#039;^#?-?[_a-zA-Z]{1}&#039; + encoding + &#039;*$&#039; : BUGGY_GEBTN ?
      &#039;^[.#]?-?[_a-zA-Z]{1}&#039; + encoding + &#039;*$&#039; : BUGGY_GEBCN ?
      &#039;^(?:\\*|#-?[_a-zA-Z]{1}&#039; + encoding + &#039;*)$&#039; :
      &#039;^(?:\\*|[.#]?-?[_a-zA-Z]{1}&#039; + encoding + &#039;*)$&#039;),

  /*----------------------------- LOOKUP OBJECTS -----------------------------*/

  LINK_NODES = new global.Object({ &#039;a&#039;: 1, &#039;A&#039;: 1, &#039;area&#039;: 1, &#039;AREA&#039;: 1, &#039;link&#039;: 1, &#039;LINK&#039;: 1 }),

  // boolean attributes should return attribute name instead of true/false
  ATTR_BOOLEAN = new global.Object({
    &#039;checked&#039;: 1, &#039;disabled&#039;: 1, &#039;ismap&#039;: 1,
    &#039;multiple&#039;: 1, &#039;readonly&#039;: 1, &#039;selected&#039;: 1
  }),

  // dynamic attributes that needs to be checked against original HTML value
  ATTR_DEFAULT = new global.Object({
    &#039;value&#039;: &#039;defaultValue&#039;,
    &#039;checked&#039;: &#039;defaultChecked&#039;,
    &#039;selected&#039;: &#039;defaultSelected&#039;
  }),

  // attributes referencing URI data values need special treatment in IE
  ATTR_URIDATA = new global.Object({
    &#039;action&#039;: 2, &#039;cite&#039;: 2, &#039;codebase&#039;: 2, &#039;data&#039;: 2, &#039;href&#039;: 2,
    &#039;longdesc&#039;: 2, &#039;lowsrc&#039;: 2, &#039;src&#039;: 2, &#039;usemap&#039;: 2
  }),

  // HTML 5 draft specifications
  // http://www.whatwg.org/specs/web-apps/current-work/#selectors
  HTML_TABLE = new global.Object({
    // class attribute must be treated case-insensitive in HTML quirks mode
    // initialized by default to Standard Mode (case-sensitive),
    // set dynamically by the attribute resolver
    &#039;class&#039;: 0,
    &#039;accept&#039;: 1, &#039;accept-charset&#039;: 1, &#039;align&#039;: 1, &#039;alink&#039;: 1, &#039;axis&#039;: 1,
    &#039;bgcolor&#039;: 1, &#039;charset&#039;: 1, &#039;checked&#039;: 1, &#039;clear&#039;: 1, &#039;codetype&#039;: 1, &#039;color&#039;: 1,
    &#039;compact&#039;: 1, &#039;declare&#039;: 1, &#039;defer&#039;: 1, &#039;dir&#039;: 1, &#039;direction&#039;: 1, &#039;disabled&#039;: 1,
    &#039;enctype&#039;: 1, &#039;face&#039;: 1, &#039;frame&#039;: 1, &#039;hreflang&#039;: 1, &#039;http-equiv&#039;: 1, &#039;lang&#039;: 1,
    &#039;language&#039;: 1, &#039;link&#039;: 1, &#039;media&#039;: 1, &#039;method&#039;: 1, &#039;multiple&#039;: 1, &#039;nohref&#039;: 1,
    &#039;noresize&#039;: 1, &#039;noshade&#039;: 1, &#039;nowrap&#039;: 1, &#039;readonly&#039;: 1, &#039;rel&#039;: 1, &#039;rev&#039;: 1,
    &#039;rules&#039;: 1, &#039;scope&#039;: 1, &#039;scrolling&#039;: 1, &#039;selected&#039;: 1, &#039;shape&#039;: 1, &#039;target&#039;: 1,
    &#039;text&#039;: 1, &#039;type&#039;: 1, &#039;valign&#039;: 1, &#039;valuetype&#039;: 1, &#039;vlink&#039;: 1
  }),

  // the following attributes must be treated case-insensitive in XHTML mode
  // Niels Leenheer http://rakaz.nl/item/css_selector_bugs_case_sensitivity
  XHTML_TABLE = new global.Object({
    &#039;accept&#039;: 1, &#039;accept-charset&#039;: 1, &#039;alink&#039;: 1, &#039;axis&#039;: 1,
    &#039;bgcolor&#039;: 1, &#039;charset&#039;: 1, &#039;codetype&#039;: 1, &#039;color&#039;: 1,
    &#039;enctype&#039;: 1, &#039;face&#039;: 1, &#039;hreflang&#039;: 1, &#039;http-equiv&#039;: 1,
    &#039;lang&#039;: 1, &#039;language&#039;: 1, &#039;link&#039;: 1, &#039;media&#039;: 1, &#039;rel&#039;: 1,
    &#039;rev&#039;: 1, &#039;target&#039;: 1, &#039;text&#039;: 1, &#039;type&#039;: 1, &#039;vlink&#039;: 1
  }),

  /*-------------------------- REGULAR EXPRESSIONS ---------------------------*/

  // placeholder to add functionalities
  Selectors = new global.Object({
    // as a simple example this will check
    // for chars not in standard ascii table
    //
    // &#039;mySpecialSelector&#039;: {
    //  &#039;Expression&#039;: /\u0080-\uffff/,
    //  &#039;Callback&#039;: mySelectorCallback
    // }
    //
    // &#039;mySelectorCallback&#039; will be invoked
    // only after passing all other standard
    // checks and only if none of them worked
  }),

  // attribute operators
  Operators = new global.Object({
     &#039;=&#039;: &quot;n==&#039;%m&#039;&quot;,
    &#039;^=&#039;: &quot;n.indexOf(&#039;%m&#039;)==0&quot;,
    &#039;*=&#039;: &quot;n.indexOf(&#039;%m&#039;)&gt;-1&quot;,
    &#039;|=&#039;: &quot;(n+&#039;-&#039;).indexOf(&#039;%m-&#039;)==0&quot;,
    &#039;~=&#039;: &quot;(&#039; &#039;+n+&#039; &#039;).indexOf(&#039; %m &#039;)&gt;-1&quot;,
    &#039;$=&#039;: &quot;n.substr(n.length-&#039;%m&#039;.length)==&#039;%m&#039;&quot;
  }),

  // optimization expressions
  Optimize = new global.Object({
    ID: new global.RegExp(&#039;^\\*?#(&#039; + encoding + &#039;+)|&#039; + skipgroup),
    TAG: new global.RegExp(&#039;^(&#039; + encoding + &#039;+)|&#039; + skipgroup),
    CLASS: new global.RegExp(&#039;^\\*?\\.(&#039; + encoding + &#039;+$)|&#039; + skipgroup)
  }),

  // precompiled Regular Expressions
  Patterns = new global.Object({
    // structural pseudo-classes and child selectors
    spseudos: /^\:(root|empty|(?:first|last|only)(?:-child|-of-type)|nth(?:-last)?(?:-child|-of-type)\(\s*(even|odd|(?:[-+]{0,1}\d*n\s*)?[-+]{0,1}\s*\d*)\s*\))?(.*)/i,
    // uistates + dynamic + negation pseudo-classes
    dpseudos: /^\:(link|visited|target|active|focus|hover|checked|disabled|enabled|selected|lang\(([-\w]{2,})\)|not\(([^()]*|.*)\))?(.*)/i,
    // element attribute matcher
    attribute: new global.RegExp(&#039;^\\[&#039; + attrmatcher + &#039;\\](.*)&#039;),
    // E &gt; F
    children: /^[\x20\t\n\r\f]*\&gt;[\x20\t\n\r\f]*(.*)/,
    // E + F
    adjacent: /^[\x20\t\n\r\f]*\+[\x20\t\n\r\f]*(.*)/,
    // E ~ F
    relative: /^[\x20\t\n\r\f]*\~[\x20\t\n\r\f]*(.*)/,
    // E F
    ancestor: /^[\x20\t\n\r\f]+(.*)/,
    // all
    universal: /^\*(.*)/,
    // id
    id: new global.RegExp(&#039;^#(&#039; + encoding + &#039;+)(.*)&#039;),
    // tag
    tagName: new global.RegExp(&#039;^(&#039; + encoding + &#039;+)(.*)&#039;),
    // class
    className: new global.RegExp(&#039;^\\.(&#039; + encoding + &#039;+)(.*)&#039;)
  }),

  /*------------------------------ UTIL METHODS ------------------------------*/

  // concat elements to data
  concatList =
    function(data, elements) {
      var i = -1, element;
      if (!data.length &amp;&amp; global.Array.slice)
        return global.Array.slice(elements);
      while ((element = elements[++i]))
        data[data.length] = element;
      return data;
    },

  // concat elements to data and callback
  concatCall =
    function(data, elements, callback) {
      var i = -1, element;
      while ((element = elements[++i])) {
        if (false === callback(data[data.length] = element)) { break; }
      }
      return data;
    },

  // change context specific variables
  switchContext =
    function(from, force) {
      var div, oldDoc = doc;
      // save passed context
      lastContext = from;
      // set new context document
      doc = from.ownerDocument || from;
      if (force || oldDoc !== doc) {
        // set document root
        root = doc.documentElement;
        // set host environment flags
        XML_DOCUMENT = doc.createElement(&#039;DiV&#039;).nodeName == &#039;DiV&#039;;

        // In quirks mode css class names are case insensitive.
        // In standards mode they are case sensitive. See docs:
        // https://developer.mozilla.org/en/Mozilla_Quirks_Mode_Behavior
        // http://www.whatwg.org/specs/web-apps/current-work/#selectors
        QUIRKS_MODE = !XML_DOCUMENT &amp;&amp;
          typeof doc.compatMode == &#039;string&#039; ?
          doc.compatMode.indexOf(&#039;CSS&#039;) &lt; 0 :
          (function() {
            var style = doc.createElement(&#039;div&#039;).style;
            return style &amp;&amp; (style.width = 1) &amp;&amp; style.width == &#039;1px&#039;;
          })();

        div = doc.createElement(&#039;div&#039;);
        div.appendChild(doc.createElement(&#039;p&#039;)).setAttribute(&#039;class&#039;, &#039;xXx&#039;);
        div.appendChild(doc.createElement(&#039;p&#039;)).setAttribute(&#039;class&#039;, &#039;xxx&#039;);

        // GEBCN buggy in quirks mode, match count is:
        // Firefox 3.0+ [xxx = 1, xXx = 1]
        // Opera 10.63+ [xxx = 0, xXx = 2]
        BUGGY_QUIRKS_GEBCN =
          !XML_DOCUMENT &amp;&amp; NATIVE_GEBCN &amp;&amp; QUIRKS_MODE &amp;&amp;
          (div.getElementsByClassName(&#039;xxx&#039;).length != 2 ||
          div.getElementsByClassName(&#039;xXx&#039;).length != 2);

        // QSAPI buggy in quirks mode, match count is:
        // At least Chrome 4+, Firefox 3.5+, Opera 10.x+, Safari 4+ [xxx = 1, xXx = 2]
        // Safari 3.2 QSA doesn&#039;t work with mixedcase in quirksmode [xxx = 1, xXx = 0]
        // https://bugs.webkit.org/show_bug.cgi?id=19047
        // must test the attribute selector &#039;[class~=xxx]&#039;
        // before &#039;.xXx&#039; or the bug may not present itself
        BUGGY_QUIRKS_QSAPI =
          !XML_DOCUMENT &amp;&amp; NATIVE_QSAPI &amp;&amp; QUIRKS_MODE &amp;&amp;
          (div.querySelectorAll(&#039;[class~=xxx]&#039;).length != 2 ||
          div.querySelectorAll(&#039;.xXx&#039;).length != 2);

        Config.CACHING &amp;&amp; Dom.setCache(true, doc);
      }
    },

  /*------------------------------ DOM METHODS -------------------------------*/

  // element by id (raw)
  // @return reference or null
  byIdRaw =
    function(id, elements) {
      var i = -1, element = null;
      while ((element = elements[++i])) {
        if (element.getAttribute(&#039;id&#039;) == id) {
          break;
        }
      }
      return element;
    },

  // element by id
  // @return reference or null
  _byId = !BUGGY_GEBID ?
    function(id, from) {
      id = id.replace(/\\([^\\]{1})/g, &#039;$1&#039;);
      return from.getElementById &amp;&amp; from.getElementById(id) ||
        byIdRaw(id, from.getElementsByTagName(&#039;*&#039;));
    } :
    function(id, from) {
      var element = null;
      id = id.replace(/\\([^\\]{1})/g, &#039;$1&#039;);
      if (XML_DOCUMENT || from.nodeType != 9) {
        return byIdRaw(id, from.getElementsByTagName(&#039;*&#039;));
      }
      if ((element = from.getElementById(id)) &amp;&amp;
        element.name == id &amp;&amp; from.getElementsByName) {
        return byIdRaw(id, from.getElementsByName(id));
      }
      return element;
    },

  // publicly exposed byId
  // @return reference or null
  byId =
    function(id, from) {
      from || (from = doc);
      if (lastContext !== from) { switchContext(from); }
      return _byId(id, from);
    },

  // elements by tag (raw)
  // @return array
  byTagRaw =
    function(tag, from) {
      var any = tag == &#039;*&#039;, element = from, elements = new global.Array(), next = element.firstChild;
      any || (tag = tag.toUpperCase());
      while ((element = next)) {
        if (element.tagName &gt; &#039;@&#039; &amp;&amp; (any || element.tagName.toUpperCase() == tag)) {
          elements[elements.length] = element;
        }
        if ((next = element.firstChild || element.nextSibling)) continue;
        while (!next &amp;&amp; (element = element.parentNode) &amp;&amp; element !== from) {
          next = element.nextSibling;
        }
      }
      return elements;
    },

  // elements by tag
  // @return array
  _byTag = !BUGGY_GEBTN &amp;&amp; NATIVE_SLICE_PROTO ?
    function(tag, from) {
      return XML_DOCUMENT || from.nodeType == 11 ? byTagRaw(tag, from) :
        slice.call(from.getElementsByTagName(tag), 0);
    } :
    function(tag, from) {
      var i = -1, j = i, data = new global.Array(),
        element, elements = from.getElementsByTagName(tag);
      if (tag == &#039;*&#039;) {
        while ((element = elements[++i])) {
          if (element.nodeName &gt; &#039;@&#039;)
            data[++j] = element;
        }
      } else {
        while ((element = elements[++i])) {
          data[i] = element;
        }
      }
      return data;
    },

  // publicly exposed byTag
  // @return array
  byTag =
    function(tag, from) {
      from || (from = doc);
      if (lastContext !== from) { switchContext(from); }
      return _byTag(tag, from);
    },

  // publicly exposed byName
  // @return array
  byName =
    function(name, from) {
      return select(&#039;[name=&quot;&#039; + name.replace(/\\([^\\]{1})/g, &#039;$1&#039;) + &#039;&quot;]&#039;, from);
    },

  // elements by class (raw)
  // @return array
  byClassRaw =
    function(name, from) {
      var i = -1, j = i, data = new global.Array(), element, elements = _byTag(&#039;*&#039;, from), n;
      name = &#039; &#039; + (QUIRKS_MODE ? name.toLowerCase() : name).replace(/\\([^\\]{1})/g, &#039;$1&#039;) + &#039; &#039;;
      while ((element = elements[++i])) {
        n = XML_DOCUMENT ? element.getAttribute(&#039;class&#039;) : element.className;
        if (n &amp;&amp; n.length &amp;&amp; (&#039; &#039; + (QUIRKS_MODE ? n.toLowerCase() : n).
          replace(reWhiteSpace, &#039; &#039;) + &#039; &#039;).indexOf(name) &gt; -1) {
          data[++j] = element;
        }
      }
      return data;
    },

  // elements by class
  // @return array
  _byClass =
    function(name, from) {
      return (BUGGY_GEBCN || BUGGY_QUIRKS_GEBCN || XML_DOCUMENT || !from.getElementsByClassName) ?
        byClassRaw(name, from) : slice.call(from.getElementsByClassName(name.replace(/\\([^\\]{1})/g, &#039;$1&#039;)), 0);
    },

  // publicly exposed byClass
  // @return array
  byClass =
    function(name, from) {
      from || (from = doc);
      if (lastContext !== from) { switchContext(from); }
      return _byClass(name, from);
    },

  // check element is descendant of container
  // @return boolean
  contains = &#039;compareDocumentPosition&#039; in root ?
    function(container, element) {
      return (container.compareDocumentPosition(element) &amp; 16) == 16;
    } : &#039;contains&#039; in root ?
    function(container, element) {
      return container !== element &amp;&amp; container.contains(element);
    } :
    function(container, element) {
      while ((element = element.parentNode)) {
        if (element === container) return true;
      }
      return false;
    },

  // attribute value
  // @return string
  getAttribute = !BUGGY_GET_ATTRIBUTE ?
    function(node, attribute) {
      return node.getAttribute(attribute) || &#039;&#039;;
    } :
    function(node, attribute) {
      attribute = attribute.toLowerCase();
      if (typeof node[attribute] == &#039;object&#039;) {
        return node.attributes[attribute] &amp;&amp;
          node.attributes[attribute].value || &#039;&#039;;
      }
      return (
        // &#039;type&#039; can only be read by using native getAttribute
        attribute == &#039;type&#039; ? node.getAttribute(attribute) || &#039;&#039; :
        // specific URI data attributes (parameter 2 to fix IE bug)
        ATTR_URIDATA[attribute] ? node.getAttribute(attribute, 2) || &#039;&#039; :
        // boolean attributes should return name instead of true/false
        ATTR_BOOLEAN[attribute] ? node.getAttribute(attribute) ? attribute : &#039;false&#039; :
          ((node = node.getAttributeNode(attribute)) &amp;&amp; node.value) || &#039;&#039;);
    },

  // attribute presence
  // @return boolean
  hasAttribute = !BUGGY_HAS_ATTRIBUTE ?
    function(node, attribute) {
      return XML_DOCUMENT ?
        !!node.getAttribute(attribute) :
        node.hasAttribute(attribute);
    } :
    function(node, attribute) {
      attribute = attribute.toLowerCase();
      if (ATTR_DEFAULT[attribute]) {
        return !!node[ATTR_DEFAULT[attribute]];
      }
      // read the attribute node
      node = node.getAttributeNode(attribute);
      return !!(node &amp;&amp; node.specified);
    },

  // check node emptyness
  // @return boolean
  isEmpty =
    function(node) {
      node = node.firstChild;
      while (node) {
        if (node.nodeType == 3 || node.nodeName &gt; &#039;@&#039;) return false;
        node = node.nextSibling;
      }
      return true;
    },

  // check if element matches the :link pseudo
  // @return boolean
  isLink =
    function(element) {
      return hasAttribute(element,&#039;href&#039;) &amp;&amp; LINK_NODES[element.nodeName];
    },

  // child position by nodeType
  // @return number
  nthElement =
    function(element, last) {
      var count = 1, succ = last ? &#039;nextSibling&#039; : &#039;previousSibling&#039;;
      while ((element = element[succ])) {
        if (element.nodeName &gt; &#039;@&#039;) ++count;
      }
      return count;
    },

  // child position by nodeName
  // @return number
  nthOfType =
    function(element, last) {
      var count = 1, succ = last ? &#039;nextSibling&#039; : &#039;previousSibling&#039;, type = element.nodeName;
      while ((element = element[succ])) {
        if (element.nodeName == type) ++count;
      }
      return count;
    },

  /*------------------------------- DEBUGGING --------------------------------*/

  // get/set (string/object) working modes
  configure =
    function(option) {
      if (typeof option == &#039;string&#039;) { return Config[option]; }
      if (typeof option != &#039;object&#039;) { return false; }
      for (var i in option) {
        Config[i] = !!option[i];
        if (i == &#039;SIMPLENOT&#039;) {
          matchContexts = new global.Object();
          matchResolvers = new global.Object();
          selectContexts = new global.Object();
          selectResolvers = new global.Object();
          Config[&#039;USE_QSAPI&#039;] = false;
        } else if (i == &#039;USE_QSAPI&#039;) {
          Config[i] = !!option[i] &amp;&amp; NATIVE_QSAPI;
        }
      }
      reValidator = new global.RegExp(Config.SIMPLENOT ?
        standardValidator : extendedValidator, &#039;g&#039;);
      return true;
    },

  // control user notifications
  emit =
    function(message) {
      if (Config.VERBOSITY) { throw new global.Error(message); }
      if (global.console &amp;&amp; global.console.log) {
        global.console.log(message);
      }
    },

  Config = new global.Object({

    // used to enable/disable caching of result sets
    CACHING: false,

    // by default do not add missing left/right context
    // to selector string shortcuts like &quot;+div&quot; or &quot;ul&gt;&quot;
    // callable Dom.shortcuts method has to be available
    SHORTCUTS: false,

    // by default disable complex selectors nested in
    // &#039;:not()&#039; pseudo-classes, as for specifications
    SIMPLENOT: true,

    // strict QSA match all non-unique IDs (false)
    // speed &amp; libs compat match unique ID (true)
    UNIQUE_ID: true,

    // HTML5 handling for the &quot;:checked&quot; pseudo-class
    USE_HTML5: true,

    // controls enabling the Query Selector API branch
    USE_QSAPI: NATIVE_QSAPI,

    // controls the engine error/warning notifications
    VERBOSITY: true

  }),

  /*---------------------------- COMPILER METHODS ----------------------------*/

  // code string reused to build compiled functions
  ACCEPT_NODE = &#039;r[r.length]=c[k];if(f&amp;&amp;false===f(c[k]))break main;else continue main;&#039;,

  // compile a comma separated group of selector
  // @mode boolean true for select, false for match
  // return a compiled function
  compile =
    function(selector, source, mode) {

      var parts = typeof selector == &#039;string&#039; ? selector.match(reSplitGroup) : selector;

      // ensures that source is a string
      typeof source == &#039;string&#039; || (source = &#039;&#039;);

      if (parts.length == 1) {
        source += compileSelector(parts[0], mode ? ACCEPT_NODE : &#039;f&amp;&amp;f(k);return true;&#039;, mode);
      } else {
        // for each selector in the group
        var i = -1, seen = new global.Object(), token;
        while ((token = parts[++i])) {
          token = token.replace(reTrimSpaces, &#039;&#039;);
          // avoid repeating the same token
          // in comma separated group (p, p)
          if (!seen[token] &amp;&amp; (seen[token] = true)) {
            source += compileSelector(token, mode ? ACCEPT_NODE : &#039;f&amp;&amp;f(k);return true;&#039;, mode);
          }
        }
      }

      if (mode) {
        // for select method
        return new global.Function(&#039;c,s,r,d,h,g,f,v&#039;,
          &#039;var N,n,x=0,k=-1,e;main:while((e=c[++k])){&#039; + source + &#039;}return r;&#039;);
      } else {
        // for match method
        return new global.Function(&#039;e,s,r,d,h,g,f,v&#039;,
          &#039;var N,n,x=0,k=e;&#039; + source + &#039;return false;&#039;);
      }
    },

  // allows to cache already visited nodes
  FILTER =
    &#039;var z=v[@]||(v[@]=[]),l=z.length-1;&#039; +
    &#039;while(l&gt;=0&amp;&amp;z[l]!==e)--l;&#039; +
    &#039;if(l!==-1){break;}&#039; +
    &#039;z[z.length]=e;&#039;,

  // compile a CSS3 string selector into ad-hoc javascript matching function
  // @return string (to be compiled)
  compileSelector =
    function(selector, source, mode) {

      var a, b, n, k = 0, expr, match, result, status, test, type;

      while (selector) {

        k++;

        // *** Universal selector
        // * match all (empty block, do not remove)
        if ((match = selector.match(Patterns.universal))) {
          // do nothing, handled in the compiler where
          // BUGGY_GEBTN return comment nodes (ex: IE)
          expr = &#039;&#039;;
        }

        // *** ID selector
        // #Foo Id case sensitive
        else if ((match = selector.match(Patterns.id))) {
          // document can contain conflicting elements (id/name)
          // prototype selector unit need this method to recover bad HTML forms
          source = &#039;if(&#039; + (XML_DOCUMENT ?
            &#039;s.getAttribute(e,&quot;id&quot;)&#039; :
            &#039;(e.submit?s.getAttribute(e,&quot;id&quot;):e.id)&#039;) +
            &#039;==&quot;&#039; + match[1] + &#039;&quot;&#039; +
            &#039;){&#039; + source + &#039;}&#039;;
        }

        // *** Type selector
        // Foo Tag (case insensitive)
        else if ((match = selector.match(Patterns.tagName))) {
          // both tagName and nodeName properties may be upper/lower case
          // depending on their creation NAMESPACE in createElementNS()
          source = &#039;if(e.nodeName&#039; + (XML_DOCUMENT ?
            &#039;==&quot;&#039; + match[1] + &#039;&quot;&#039; : &#039;.toUpperCase()&#039; +
            &#039;==&quot;&#039; + match[1].toUpperCase() + &#039;&quot;&#039;) +
            &#039;){&#039; + source + &#039;}&#039;;
        }

        // *** Class selector
        // .Foo Class (case sensitive)
        else if ((match = selector.match(Patterns.className))) {
          // W3C CSS3 specs: element whose &quot;class&quot; attribute has been assigned a
          // list of whitespace-separated values, see section 6.4 Class selectors
          // and notes at the bottom; explicitly non-normative in this specification.
          source = &#039;if((n=&#039; + (XML_DOCUMENT ?
            &#039;s.getAttribute(e,&quot;class&quot;)&#039; : &#039;e.className&#039;) +
            &#039;)&amp;&amp;n.length&amp;&amp;(&quot; &quot;+&#039; + (QUIRKS_MODE ? &#039;n.toLowerCase()&#039; : &#039;n&#039;) +
            &#039;.replace(&#039; + reWhiteSpace + &#039;,&quot; &quot;)+&quot; &quot;).indexOf(&quot; &#039; +
            (QUIRKS_MODE ? match[1].toLowerCase() : match[1]) + &#039; &quot;)&gt;-1&#039; +
            &#039;){&#039; + source + &#039;}&#039;;
        }

        // *** Attribute selector
        // [attr] [attr=value] [attr=&quot;value&quot;] [attr=&#039;value&#039;] and !=, *=, ~=, |=, ^=, $=
        // case sensitivity is treated differently depending on the document type (see map)
        else if ((match = selector.match(Patterns.attribute))) {

          // xml namespaced attribute ?
          expr = match[1].split(&#039;:&#039;);
          expr = expr.length == 2 ? expr[1] : expr[0] + &#039;&#039;;

          if (match[2] &amp;&amp; !Operators[match[2]]) {
            emit(&#039;Unsupported operator in attribute selectors &quot;&#039; + selector + &#039;&quot;&#039;);
            return &#039;&#039;;
          }

          test = false;
          type = &#039;false&#039;;

          // replace Operators parameter if needed
          if (match[2] &amp;&amp; match[4] &amp;&amp; (type = Operators[match[2]])) {
            // case treatment depends on document
            HTML_TABLE[&#039;class&#039;] = QUIRKS_MODE ? 1 : 0;
            // replace escaped values and HTML entities
            match[4] = match[4].replace(/(\x22|\x27)/g, &#039;\\$1&#039;);
            match[4] = match[4].replace(/\\([0-9a-f]{2,2})/g, &#039;\\x$1&#039;);
            test = (XML_DOCUMENT ? XHTML_TABLE : HTML_TABLE)[expr.toLowerCase()];
            type = type.replace(/\%m/g, test ? match[4].toLowerCase() : match[4]);
          } else if (match[2] == &#039;!=&#039; || match[2] == &#039;=&#039;) {
            match[4] = match[4].replace(/(\x22|\x27)/g, &#039;\\$1&#039;);
            type = &#039;n&#039; + match[2] + &#039;=&quot;&#039; + match[4] + &#039;&quot;&#039;;
          }

          // build expression for has/getAttribute
          expr = &#039;n=s.&#039; + (match[2] ? &#039;get&#039; : &#039;has&#039;) +
            &#039;Attribute(e,&quot;&#039; + match[1] + &#039;&quot;)&#039; +
            (test ? &#039;.toLowerCase();&#039; : &#039;;&#039;);

          source = expr + &#039;if(&#039; + (match[2] ? type : &#039;n&#039;) + &#039;){&#039; + source + &#039;}&#039;;
        }

        // *** Adjacent sibling combinator
        // E + F (F adiacent sibling of E)
        else if ((match = selector.match(Patterns.adjacent))) {
          source = (mode ? &#039;&#039; : FILTER.replace(/@/g, k)) + source;
          source = NATIVE_TRAVERSAL_API ?
            &#039;var N&#039; + k + &#039;=e;while(e&amp;&amp;(e=e.previousElementSibling)){&#039; + source + &#039;break;}e=N&#039; + k + &#039;;&#039; :
            &#039;var N&#039; + k + &#039;=e;while(e&amp;&amp;(e=e.previousSibling)){if(e.nodeName&gt;&quot;@&quot;){&#039; + source + &#039;break;}}e=N&#039; + k + &#039;;&#039;;
        }

        // *** General sibling combinator
        // E ~ F (F relative sibling of E)
        else if ((match = selector.match(Patterns.relative))) {
          source = (mode ? &#039;&#039; : FILTER.replace(/@/g, k)) + source;
          source = NATIVE_TRAVERSAL_API ?
            (&#039;var N&#039; + k + &#039;=e;e=e.parentNode.firstElementChild;&#039; +
            &#039;while(e&amp;&amp;e!==N&#039; + k + &#039;){&#039; + source + &#039;e=e.nextElementSibling;}e=N&#039; + k + &#039;;&#039;) :
            (&#039;var N&#039; + k + &#039;=e;e=e.parentNode.firstChild;&#039; +
            &#039;while(e&amp;&amp;e!==N&#039; + k + &#039;){if(e.nodeName&gt;&quot;@&quot;){&#039; + source + &#039;}e=e.nextSibling;}e=N&#039; + k + &#039;;&#039;);
        }

        // *** Child combinator
        // E &gt; F (F children of E)
        else if ((match = selector.match(Patterns.children))) {
          source = (mode ? &#039;&#039; : FILTER.replace(/@/g, k)) + source;
          source = &#039;var N&#039; + k + &#039;=e;while(e&amp;&amp;e!==h&amp;&amp;e!==g&amp;&amp;(e=e.parentNode)){&#039; + source + &#039;break;}e=N&#039; + k + &#039;;&#039;;
        }

        // *** Descendant combinator
        // E F (E ancestor of F)
        else if ((match = selector.match(Patterns.ancestor))) {
          source = (mode ? &#039;&#039; : FILTER.replace(/@/g, k)) + source;
          source = &#039;var N&#039; + k + &#039;=e;while(e&amp;&amp;e!==h&amp;&amp;e!==g&amp;&amp;(e=e.parentNode)){&#039; + source + &#039;}e=N&#039; + k + &#039;;&#039;;
        }

        // *** Structural pseudo-classes
        // :root, :empty,
        // :first-child, :last-child, :only-child,
        // :first-of-type, :last-of-type, :only-of-type,
        // :nth-child(), :nth-last-child(), :nth-of-type(), :nth-last-of-type()
        else if ((match = selector.match(Patterns.spseudos)) &amp;&amp; match[1]) {

          switch (match[1]) {
            case &#039;root&#039;:
              // element root of the document
              if (match[3]) {
                source = &#039;if(e===h||s.contains(h,e)){&#039; + source + &#039;}&#039;;
              } else {
                source = &#039;if(e===h){&#039; + source + &#039;}&#039;;
              }
              break;

            case &#039;empty&#039;:
              // element that has no children
              source = &#039;if(s.isEmpty(e)){&#039; + source + &#039;}&#039;;
              break;

            default:
              if (match[1] &amp;&amp; match[2]) {
                if (match[2] == &#039;n&#039;) {
                  source = &#039;if(e!==h){&#039; + source + &#039;}&#039;;
                  break;
                } else if (match[2] == &#039;even&#039;) {
                  a = 2;
                  b = 0;
                } else if (match[2] == &#039;odd&#039;) {
                  a = 2;
                  b = 1;
                } else {
                  // assumes correct &quot;an+b&quot; format, &quot;b&quot; before &quot;a&quot; to keep &quot;n&quot; values
                  b = ((n = match[2].match(/(-?\d+)$/)) ? global.parseInt(n[1], 10) : 0);
                  a = ((n = match[2].match(/(-?\d*)n/i)) ? global.parseInt(n[1], 10) : 0);
                  if (n &amp;&amp; n[1] == &#039;-&#039;) a = -1;
                }

                // build test expression out of structural pseudo (an+b) parameters
                // see here: http://www.w3.org/TR/css3-selectors/#nth-child-pseudo
                test = a &gt; 1 ?
                  (/last/i.test(match[1])) ? &#039;(n-(&#039; + b + &#039;))%&#039; + a + &#039;==0&#039; :
                  &#039;n&gt;=&#039; + b + &#039;&amp;&amp;(n-(&#039; + b + &#039;))%&#039; + a + &#039;==0&#039; : a &lt; -1 ?
                  (/last/i.test(match[1])) ? &#039;(n-(&#039; + b + &#039;))%&#039; + a + &#039;==0&#039; :
                  &#039;n&lt;=&#039; + b + &#039;&amp;&amp;(n-(&#039; + b + &#039;))%&#039; + a + &#039;==0&#039; : a=== 0 ?
                  &#039;n==&#039; + b :
                  (/last/i.test(match[1])) ?
                    a == -1 ? &#039;n&gt;=&#039; + b : &#039;n&lt;=&#039; + b :
                    a == -1 ? &#039;n&lt;=&#039; + b : &#039;n&gt;=&#039; + b;

                // 4 cases: 1 (nth) x 4 (child, of-type, last-child, last-of-type)
                source =
                  &#039;if(e!==h){&#039; +
                    &#039;n=s[&#039; + (/-of-type/i.test(match[1]) ? &#039;&quot;nthOfType&quot;&#039; : &#039;&quot;nthElement&quot;&#039;) + &#039;]&#039; +
                      &#039;(e,&#039; + (/last/i.test(match[1]) ? &#039;true&#039; : &#039;false&#039;) + &#039;);&#039; +
                    &#039;if(&#039; + test + &#039;){&#039; + source + &#039;}&#039; +
                  &#039;}&#039;;

              } else {
                // 6 cases: 3 (first, last, only) x 1 (child) x 2 (-of-type)
                a = /first/i.test(match[1]) ? &#039;previous&#039; : &#039;next&#039;;
                n = /only/i.test(match[1]) ? &#039;previous&#039; : &#039;next&#039;;
                b = /first|last/i.test(match[1]);

                type = /-of-type/i.test(match[1]) ? &#039;&amp;&amp;n.nodeName!=e.nodeName&#039; : &#039;&amp;&amp;n.nodeName&lt;&quot;@&quot;&#039;;

                source = &#039;if(e!==h){&#039; +
                  ( &#039;n=e;while((n=n.&#039; + a + &#039;Sibling)&#039; + type + &#039;);if(!n){&#039; + (b ? source :
                    &#039;n=e;while((n=n.&#039; + n + &#039;Sibling)&#039; + type + &#039;);if(!n){&#039; + source + &#039;}&#039;) + &#039;}&#039; ) + &#039;}&#039;;
              }
              break;
          }

        }

        // *** negation, user action and target pseudo-classes
        // *** UI element states and dynamic pseudo-classes
        // CSS3 :not, :checked, :enabled, :disabled, :target
        // CSS3 :active, :hover, :focus
        // CSS3 :link, :visited
        else if ((match = selector.match(Patterns.dpseudos)) &amp;&amp; match[1]) {

          switch (match[1].match(/^\w+/)[0]) {
            // CSS3 negation pseudo-class
            case &#039;not&#039;:
              // compile nested selectors, DO NOT pass the callback parameter
              // SIMPLENOT allow disabling complex selectors nested
              // in &#039;:not()&#039; pseudo-classes, breaks some test units
              expr = match[3].replace(reTrimSpaces, &#039;&#039;);

              if (Config.SIMPLENOT &amp;&amp; !reSimpleNot.test(expr)) {
                // see above, log error but continue execution
                emit(&#039;Negation pseudo-class only accepts simple selectors &quot;&#039; + selector + &#039;&quot;&#039;);
                return &#039;&#039;;
              } else {
                if (&#039;compatMode&#039; in doc) {
                  source = &#039;if(!&#039; + compile(expr, &#039;&#039;, false) + &#039;(e,s,r,d,h,g)){&#039; + source + &#039;}&#039;;
                } else {
                  source = &#039;if(!s.match(e, &quot;&#039; + expr.replace(/\x22/g, &#039;\\&quot;&#039;) + &#039;&quot;,g)){&#039; + source +&#039;}&#039;;
                }
              }
              break;

            // CSS3 UI element states
            case &#039;checked&#039;:
              // for radio buttons checkboxes (HTML4) and options (HTML5)
              source = &#039;if((typeof e.form!==&quot;undefined&quot;&amp;&amp;(/^(?:radio|checkbox)$/i).test(e.type)&amp;&amp;e.checked)&#039; +
                (Config.USE_HTML5 ? &#039;||(/^option$/i.test(e.nodeName)&amp;&amp;(e.selected||e.checked))&#039; : &#039;&#039;) +
                &#039;){&#039; + source + &#039;}&#039;;
              break;
            case &#039;disabled&#039;:
              // does not consider hidden input fields
              source = &#039;if(((typeof e.form!==&quot;undefined&quot;&#039; +
                (Config.USE_HTML5 ? &#039;&#039; : &#039;&amp;&amp;!(/^hidden$/i).test(e.type)&#039;) +
                &#039;)||s.isLink(e))&amp;&amp;e.disabled===true){&#039; + source + &#039;}&#039;;
              break;
            case &#039;enabled&#039;:
              // does not consider hidden input fields
              source = &#039;if(((typeof e.form!==&quot;undefined&quot;&#039; +
                (Config.USE_HTML5 ? &#039;&#039; : &#039;&amp;&amp;!(/^hidden$/i).test(e.type)&#039;) +
                &#039;)||s.isLink(e))&amp;&amp;e.disabled===false){&#039; + source + &#039;}&#039;;
              break;

            // CSS3 lang pseudo-class
            case &#039;lang&#039;:
              test = &#039;&#039;;
              if (match[2]) test = match[2].substr(0, 2) + &#039;-&#039;;
              source = &#039;do{(n=e.lang||&quot;&quot;).toLowerCase();&#039; +
                &#039;if((n==&quot;&quot;&amp;&amp;h.lang==&quot;&#039; + match[2].toLowerCase() + &#039;&quot;)||&#039; +
                &#039;(n&amp;&amp;(n==&quot;&#039; + match[2].toLowerCase() +
                &#039;&quot;||n.substr(0,3)==&quot;&#039; + test.toLowerCase() + &#039;&quot;)))&#039; +
                &#039;{&#039; + source + &#039;break;}}while((e=e.parentNode)&amp;&amp;e!==g);&#039;;
              break;

            // CSS3 target pseudo-class
            case &#039;target&#039;:
              n = doc.location ? doc.location.hash : &#039;&#039;;
              if (n) {
                source = &#039;if(e.id==&quot;&#039; + n.slice(1) + &#039;&quot;){&#039; + source + &#039;}&#039;;
              }
              break;

            // CSS3 dynamic pseudo-classes
            case &#039;link&#039;:
              source = &#039;if(s.isLink(e)&amp;&amp;!e.visited){&#039; + source + &#039;}&#039;;
              break;
            case &#039;visited&#039;:
              source = &#039;if(s.isLink(e)&amp;&amp;e.visited){&#039; + source + &#039;}&#039;;
              break;

            // CSS3 user action pseudo-classes IE &amp; FF3 have native support
            // these capabilities may be emulated by some event managers
            case &#039;active&#039;:
              if (XML_DOCUMENT) break;
              source = &#039;if(e===d.activeElement){&#039; + source + &#039;}&#039;;
              break;
            case &#039;hover&#039;:
              if (XML_DOCUMENT) break;
              source = &#039;if(e===d.hoverElement){&#039; + source + &#039;}&#039;;
              break;
            case &#039;focus&#039;:
              if (XML_DOCUMENT) break;
              source = NATIVE_FOCUS ?
                &#039;if(e===d.activeElement&amp;&amp;d.hasFocus()&amp;&amp;(e.type||e.href||typeof e.tabIndex==&quot;number&quot;)){&#039; + source + &#039;}&#039; :
                &#039;if(e===d.activeElement&amp;&amp;(e.type||e.href)){&#039; + source + &#039;}&#039;;
              break;

            // CSS2 selected pseudo-classes, not part of current CSS3 drafts
            // the &#039;selected&#039; property is only available for option elements
            case &#039;selected&#039;:
              // fix Safari selectedIndex property bug
              expr = BUGGY_SELECTED ? &#039;||(n=e.parentNode)&amp;&amp;n.options[n.selectedIndex]===e&#039; : &#039;&#039;;
              source = &#039;if(/^option$/i.test(e.nodeName)&amp;&amp;(e.selected||e.checked&#039; + expr + &#039;)){&#039; + source + &#039;}&#039;;
              break;

            default:
              break;
          }

        }

        else {

          // this is where external extensions are
          // invoked if expressions match selectors
          expr = false;
          status = false;
          for (expr in Selectors) {
            if ((match = selector.match(Selectors[expr].Expression)) &amp;&amp; match[1]) {
              result = Selectors[expr].Callback(match, source);
              source = result.source;
              status = result.status;
              if (status) { break; }
            }
          }

          // if an extension fails to parse the selector
          // it must return a false boolean in &quot;status&quot;
          if (!status) {
            // log error but continue execution, don&#039;t throw real exceptions
            // because blocking following processes maybe is not a good idea
            emit(&#039;Unknown pseudo-class selector &quot;&#039; + selector + &#039;&quot;&#039;);
            return &#039;&#039;;
          }

          if (!expr) {
            // see above, log error but continue execution
            emit(&#039;Unknown token in selector &quot;&#039; + selector + &#039;&quot;&#039;);
            return &#039;&#039;;
          }

        }

        // error if no matches found by the pattern scan
        if (!match) {
          emit(&#039;Invalid syntax in selector &quot;&#039; + selector + &#039;&quot;&#039;);
          return &#039;&#039;;
        }

        // ensure &quot;match&quot; is not null or empty since
        // we do not throw real DOMExceptions above
        selector = match &amp;&amp; match[match.length - 1];
      }

      return source;
    },

  /*----------------------------- QUERY METHODS ------------------------------*/

  // match element with selector
  // @return boolean
  match =
    function(element, selector, from, callback) {

      var parts;

      if (!(element &amp;&amp; element.nodeName &gt; &#039;@&#039;)) {
        emit(&#039;Invalid element argument&#039;);
        return false;
      } else if (typeof selector != &#039;string&#039;) {
        emit(&#039;Invalid selector argument&#039;);
        return false;
      } else if (from &amp;&amp; from.nodeType == 1 &amp;&amp; !contains(from, element)) {
        return false;
      } else if (lastContext !== from) {
        // reset context data when it changes
        // and ensure context is set to a default
        switchContext(from || (from = element.ownerDocument));
      }

      selector = selector.replace(reTrimSpaces, &#039;&#039;);

      Config.SHORTCUTS &amp;&amp; (selector = Dom.shortcuts(selector, element, from));

      if (lastMatcher != selector) {
        // process valid selector strings
        if ((parts = selector.match(reValidator)) &amp;&amp; parts[0] == selector) {
          isSingleMatch = (parts = selector.match(reSplitGroup)).length &lt; 2;
          // save passed selector
          lastMatcher = selector;
          lastPartsMatch = parts;
        } else {
          emit(&#039;The string &quot;&#039; + selector + &#039;&quot;, is not a valid CSS selector&#039;);
          return false;
        }
      } else parts = lastPartsMatch;

      // compile matcher resolvers if necessary
      if (!matchResolvers[selector] || matchContexts[selector] !== from) {
        matchResolvers[selector] = compile(isSingleMatch ? [selector] : parts, &#039;&#039;, false);
        matchContexts[selector] = from;
      }

      return matchResolvers[selector](element, Snapshot, [ ], doc, root, from, callback, new global.Object());
    },

  // select only the first element
  // matching selector (document ordered)
  first =
    function(selector, from) {
      return select(selector, from, function() { return false; })[0] || null;
    },

  // select elements matching selector
  // using new Query Selector API
  // or cross-browser client API
  // @return array
  select =
    function(selector, from, callback) {

      var i, changed, element, elements, parts, token, original = selector;

      if (arguments.length === 0) {
        emit(&#039;Not enough arguments&#039;);
        return [ ];
      } else if (typeof selector != &#039;string&#039;) {
        return [ ];
      } else if (from &amp;&amp; !(/1|9|11/).test(from.nodeType)) {
        emit(&#039;Invalid or illegal context element&#039;);
        return [ ];
      } else if (lastContext !== from) {
        // reset context data when it changes
        // and ensure context is set to a default
        switchContext(from || (from = doc));
      }

      if (Config.CACHING &amp;&amp; (elements = Dom.loadResults(original, from, doc, root))) {
        return callback ? concatCall([ ], elements, callback) : elements;
      }

      if (!OPERA_QSAPI &amp;&amp; RE_SIMPLE_SELECTOR.test(selector)) {
        switch (selector.charAt(0)) {
          case &#039;#&#039;:
            if (Config.UNIQUE_ID) {
              elements = (element = _byId(selector.slice(1), from)) ? [ element ] : [ ];
            }
            break;
          case &#039;.&#039;:
            elements = _byClass(selector.slice(1), from);
            break;
          default:
            elements = _byTag(selector, from);
            break;
        }
      }

      else if (!XML_DOCUMENT &amp;&amp; Config.USE_QSAPI &amp;&amp;
        !(BUGGY_QUIRKS_QSAPI &amp;&amp; RE_CLASS.test(selector)) &amp;&amp;
        !RE_BUGGY_QSAPI.test(selector)) {
        try {
          elements = from.querySelectorAll(selector);
        } catch(e) { }
      }

      if (elements) {
        elements = callback ? concatCall([ ], elements, callback) :
          NATIVE_SLICE_PROTO ? slice.call(elements) : concatList([ ], elements);
        Config.CACHING &amp;&amp; Dom.saveResults(original, from, doc, elements);
        return elements;
      }

      selector = selector.replace(reTrimSpaces, &#039;&#039;);

      Config.SHORTCUTS &amp;&amp; (selector = Dom.shortcuts(selector, from));

      if ((changed = lastSelector != selector)) {
        // process valid selector strings
        if ((parts = selector.match(reValidator)) &amp;&amp; parts[0] == selector) {
          isSingleSelect = (parts = selector.match(reSplitGroup)).length &lt; 2;
          // save passed selector
          lastSelector = selector;
          lastPartsSelect = parts;
        } else {
          emit(&#039;The string &quot;&#039; + selector + &#039;&quot;, is not a valid CSS selector&#039;);
          return [ ];
        }
      } else parts = lastPartsSelect;

      // commas separators are treated sequentially to maintain order
      if (from.nodeType == 11) {

        elements = byTagRaw(&#039;*&#039;, from);

      } else if (!XML_DOCUMENT &amp;&amp; isSingleSelect) {

        if (changed) {
          // get right most selector token
          parts = selector.match(reSplitToken);
          token = parts[parts.length - 1];

          // only last slice before :not rules
          lastSlice = token.split(&#039;:not&#039;)[0];

          // position where token was found
          lastPosition = selector.length - token.length;
        }

        // ID optimization RTL, to reduce number of elements to visit
        if (Config.UNIQUE_ID &amp;&amp; (parts = lastSlice.match(Optimize.ID)) &amp;&amp; (token = parts[1])) {
          if ((element = _byId(token, from))) {
            if (match(element, selector)) {
              callback &amp;&amp; callback(element);
              elements = new global.Array(element);
            } else elements = new global.Array();
          }
        }

        // ID optimization LTR, to reduce selection context searches
        else if (Config.UNIQUE_ID &amp;&amp; (parts = selector.match(Optimize.ID)) &amp;&amp; (token = parts[1])) {
          if ((element = _byId(token, doc))) {
            if (&#039;#&#039; + token == selector) {
              callback &amp;&amp; callback(element);
              elements = new global.Array(element);
            } else if (/[&gt;+~]/.test(selector)) {
              from = element.parentNode;
            } else {
              from = element;
            }
          } else elements = new global.Array();
        }

        if (elements) {
          Config.CACHING &amp;&amp; Dom.saveResults(original, from, doc, elements);
          return elements;
        }

        if (!NATIVE_GEBCN &amp;&amp; (parts = lastSlice.match(Optimize.TAG)) &amp;&amp; (token = parts[1])) {
          if ((elements = _byTag(token, from)).length === 0) { return [ ]; }
          selector = selector.slice(0, lastPosition) + selector.slice(lastPosition).replace(token, &#039;*&#039;);
        }

        else if ((parts = lastSlice.match(Optimize.CLASS)) &amp;&amp; (token = parts[1])) {
          if ((elements = _byClass(token, from)).length === 0) { return [ ]; }
          if (reOptimizeSelector.test(selector.charAt(selector.indexOf(token) - 1))) {
            selector = selector.slice(0, lastPosition) + selector.slice(lastPosition).replace(&#039;.&#039; + token, &#039;&#039;);
          } else {
            selector = selector.slice(0, lastPosition) + selector.slice(lastPosition).replace(&#039;.&#039; + token, &#039;*&#039;);
          }
        }

        else if ((parts = selector.match(Optimize.CLASS)) &amp;&amp; (token = parts[1])) {
          if ((elements = _byClass(token, from)).length === 0) { return [ ]; }
          for (i = 0, els = new global.Array(); elements.length &gt; i; ++i) {
            els = concatList(els, elements[i].getElementsByTagName(&#039;*&#039;));
          }
          elements = els;
          if (reOptimizeSelector.test(selector.charAt(selector.indexOf(token) - 1))) {
            selector = selector.slice(0, lastPosition) + selector.slice(lastPosition).replace(&#039;.&#039; + token, &#039;&#039;);
          } else {
            selector = selector.slice(0, lastPosition) + selector.slice(lastPosition).replace(&#039;.&#039; + token, &#039;*&#039;);
          }
        }

        else if (NATIVE_GEBCN &amp;&amp; (parts = lastSlice.match(Optimize.TAG)) &amp;&amp; (token = parts[1])) {
          if ((elements = _byTag(token, from)).length === 0) { return [ ]; }
          selector = selector.slice(0, lastPosition) + selector.slice(lastPosition).replace(token, &#039;*&#039;);
        }

      }

      if (!elements) {
        elements = /^(?:applet|object)$/i.test(from.nodeName) ? from.childNodes : _byTag(&#039;*&#039;, from);
      }
      // end of prefiltering pass

      // compile selector resolver if necessary
      if (!selectResolvers[selector] || selectContexts[selector] !== from) {
        selectResolvers[selector] = compile(isSingleSelect ? [selector] : parts, &#039;&#039;, true);
        selectContexts[selector] = from;
      }

      elements = selectResolvers[selector](elements, Snapshot, [ ], doc, root, from, callback, new global.Object());

      Config.CACHING &amp;&amp; Dom.saveResults(original, from, doc, elements);

      return elements;
    },

  /*-------------------------------- STORAGE ---------------------------------*/

  // empty function handler
  FN = function(x) { return x; },

  // compiled match functions returning booleans
  matchContexts = new global.Object(),
  matchResolvers = new global.Object(),

  // compiled select functions returning collections
  selectContexts = new global.Object(),
  selectResolvers = new global.Object(),

  // used to pass methods to compiled functions
  Snapshot = new global.Object({

    // element indexing methods
    nthElement: nthElement,
    nthOfType: nthOfType,

    // element inspection methods
    getAttribute: getAttribute,
    hasAttribute: hasAttribute,

    // element selection methods
    byClass: _byClass,
    byName: byName,
    byTag: _byTag,
    byId: _byId,

    // helper/check methods
    contains: contains,
    isEmpty: isEmpty,
    isLink: isLink,

    // selection/matching
    select: select,
    match: match
  }),

  Tokens = new global.Object({
    prefixes: prefixes,
    encoding: encoding,
    operators: operators,
    whitespace: whitespace,
    identifier: identifier,
    attributes: attributes,
    combinators: combinators,
    pseudoclass: pseudoclass,
    pseudoparms: pseudoparms,
    quotedvalue: quotedvalue
  });

  /*------------------------------- PUBLIC API -------------------------------*/

  // code referenced by extensions
  Dom.ACCEPT_NODE = ACCEPT_NODE;

  // retrieve element by id attr
  Dom.byId = byId;

  // retrieve elements by tag name
  Dom.byTag = byTag;

  // retrieve elements by name attr
  Dom.byName = byName;

  // retrieve elements by class name
  Dom.byClass = byClass;

  // read the value of the attribute
  // as was in the original HTML code
  Dom.getAttribute = getAttribute;

  // check for the attribute presence
  // as was in the original HTML code
  Dom.hasAttribute = hasAttribute;

  // element match selector, return boolean true/false
  Dom.match = match;

  // first element match only, return element or null
  Dom.first = first;

  // elements matching selector, starting from element
  Dom.select = select;

  // compile selector into ad-hoc javascript resolver
  Dom.compile = compile;

  // check that two elements are ancestor/descendant
  Dom.contains = contains;

  // handle selector engine configuration settings
  Dom.configure = configure;

  // initialize caching for each document
  Dom.setCache = FN;

  // load previously collected result set
  Dom.loadResults = FN;

  // save previously collected result set
  Dom.saveResults = FN;

  // handle missing context in selector strings
  Dom.shortcuts = FN;

  // log resolvers errors/warnings
  Dom.emit = emit;

  // options enabing specific engine functionality
  Dom.Config = Config;

  // pass methods references to compiled resolvers
  Dom.Snapshot = Snapshot;

  // operators descriptor
  // for attribute operators extensions
  Dom.Operators = Operators;

  // selectors descriptor
  // for pseudo-class selectors extensions
  Dom.Selectors = Selectors;

  // export string patterns
  Dom.Tokens = Tokens;

  // export version string
  Dom.Version = version;

  // add or overwrite user defined operators
  Dom.registerOperator =
    function(symbol, resolver) {
      Operators[symbol] || (Operators[symbol] = resolver);
    };

  // add selector patterns for user defined callbacks
  Dom.registerSelector =
    function(name, rexp, func) {
      Selectors[name] || (Selectors[name] = new global.Object({
        Expression: rexp,
        Callback: func
      }));
    };

  /*---------------------------------- INIT ----------------------------------*/

  // init context specific variables
  switchContext(doc, true);

});</textarea>
  </div>
</div>

<footer class="footer">
  <div class="container">
    <p>.</p>
  </div>
</footer>

<script type="text/html" id="complexity-popover-template">
  <div class="complexity-notice">
    Complexity : {{ complexity.cyclomatic }} <br>
    Length : {{ complexity.halstead.length }} <br>
    Difficulty : {{ complexity.halstead.difficulty.toFixed(2) }} <br>
    Est # bugs : {{ complexity.halstead.bugs.toFixed(2) }}<br>
  </div>
</script>

<script type="text/javascript" src="../../assets/scripts/bundles/core-bundle.js"></script>
<script type="text/javascript" src="../../assets/scripts/bundles/codemirror.js"></script>
<script type="text/javascript" src="../../assets/scripts/codemirror.markpopovertext.js"></script>
<script type="text/javascript" src="report.js"></script>
<script type="text/javascript" src="report.history.js"></script>
<script type="text/javascript" src="../../assets/scripts/plato-file.js"></script>
</body>
</html>
