<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Plato - node_modules/nwmatcher/src/nwmatcher-noqsa.js</title>

  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="">
  <meta name="author" content="">

  <!--[if lt IE 9]>
  <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->

  <link href="../../assets/css/vendor/morris.css" rel="stylesheet">
  <link href="../../assets/css/vendor/bootstrap.css" rel="stylesheet">
  <link href="../../assets/css/vendor/font-awesome.css" rel="stylesheet">
  <link href="../../assets/css/vendor/codemirror.css" rel="stylesheet">
  <link href="../../assets/css/plato.css" rel="stylesheet">
  <link href="../../assets/css/plato-file.css" rel="stylesheet">

</head>

<body>

<div class="navbar navbar-fixed-top">
  <div class="container">
    <a class="navbar-brand" href="http://github.com/es-analysis/plato">Plato on Github</a>
    <ul class="nav navbar-nav">
      <li>
        <a href="../../index.html">Report Home</a>
      </li>
    </ul>
  </div>
</div>

<div class="jumbotron">
  <div class="container">
    <h1>node_modules/nwmatcher/src/nwmatcher-noqsa.js</h1>
  </div>
</div>

<div class="container aggregate-stats">
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Maintainability <a href="http://blogs.msdn.com/b/codeanalysis/archive/2007/11/20/maintainability-index-range-and-meaning.aspx"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="A value between 0 and 100 that represents the relative ease of maintaining the code. A high value means better maintainability." data-original-title="Maintainability Index"  data-container="body"></i></a></h2>
      <p class="stat">52.19</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Lines of code <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h2>
      <p class="stat">887</p>
    </div>
  </div>
  <div class="row historical">
    <div class="col-md-6">
      <p id="chart_historical_maint" class="chart"></p>
    </div>
    <div class="col-md-6">
      <p id="chart_historical_sloc" class="chart"></p>
    </div>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Difficulty  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="The difficulty measure is related to the difficulty of the program to write or understand." data-original-title="Difficulty" data-container="body"></i></a></h2>
      <p class="stat">88.78</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Estimated Errors  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Halstead's delivered bugs is an estimate for the number of errors in the implementation." data-original-title="Delivered Bugs" data-container="body"></i></a></h2>
      <p class="stat">12.32</p>
    </div>
  </div>
</div>

<div class="container charts">
  <div class="row">
    <h2 class="header">Function weight</h2>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h3 class="chart-header">By Complexity <a href="http://en.wikipedia.org/wiki/Cyclomatic_complexity"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="This metric counts the number of distinct paths through a block of code. Lower values are better." data-original-title="Cyclomatic Complexity" data-container="body"></i></a></h3>
      <div id="fn-by-complexity" class="stat"></div>
    </div>
    <div class="col-md-6">
      <h3 class="chart-header">By SLOC  <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h3>
      <div id="fn-by-sloc" class="stat"></div>
    </div>
  </div>
</div>

<div class="container">
  <div class="row">
    <textarea id="file-source" class="col-md-12">/*
 * Copyright (C) 2007-2015 Diego Perini
 * All rights reserved.
 *
 * nwmatcher-noqsa.js - A fast CSS selector engine and matcher
 *
 * Author: Diego Perini &lt;diego.perini at gmail com&gt;
 * Version: 1.3.4
 * Created: 20070722
 * Release: 20150101
 *
 * License:
 *  http://javascript.nwbox.com/NWMatcher/MIT-LICENSE
 * Download:
 *  http://javascript.nwbox.com/NWMatcher/nwmatcher.js
 */

(function(global, factory) {

  if (typeof module == &#039;object&#039; &amp;&amp; typeof exports == &#039;object&#039;) {
    module.exports = function (browserGlobal) {
      // passed global does not contain
      // references to native objects
      browserGlobal.console = console;
      browserGlobal.parseInt = parseInt;
      browserGlobal.Function = Function;
      browserGlobal.Boolean = Boolean;
      browserGlobal.Number = Number;
      browserGlobal.RegExp = RegExp;
      browserGlobal.String = String;
      browserGlobal.Object = Object;
      browserGlobal.Array = Array;
      browserGlobal.Error = Error;
      browserGlobal.Date = Date;
      browserGlobal.Math = Math;
      var exports = browserGlobal.Object();
      factory(browserGlobal, exports);
      return exports;
    };
    module.factory = factory;
  } else {
    factory(global,
      (global.NW || (global.NW = global.Object())) &amp;&amp;
      (global.NW.Dom || (global.NW.Dom = global.Object())));
    global.NW.Dom.factory = factory;
  }

})(this, function(global, exports) {

  var version = &#039;nwmatcher-1.3.4&#039;,

  Dom = exports,

  doc = global.document,
  root = doc.documentElement,

  isSingleMatch,
  isSingleSelect,

  lastSlice,
  lastContext,
  lastPosition,

  lastMatcher,
  lastSelector,

  lastPartsMatch,
  lastPartsSelect,

  operators = &#039;([~*^$|!]?={1})&#039;,
  combinators = &#039;[\\s]|[&gt;+~][^&gt;+~]&#039;,
  pseudoparms = &#039;(?:[-+]?\\d*n)?[-+]?\\d*&#039;,

  quotedvalue = &#039;&quot;[^&quot;\\\\]*(?:\\\\.[^&quot;\\\\]*)*&quot;&#039; + &quot;|&#039;[^&#039;\\\\]*(?:\\\\.[^&#039;\\\\]*)*&#039;&quot;,
  skipgroup = &#039;\\[.*\\]|\\(.*\\)|\\{.*\\}&#039;,

  encoding = &#039;(?:[-\\w]|[^\\x00-\\xa0]|\\\\.)&#039;,
  identifier = &#039;(?:-?[_a-zA-Z]{1}[-\\w]*|[^\\x00-\\xa0]+|\\\\.+)+&#039;,

  attrcheck = &#039;(&#039; + quotedvalue + &#039;|&#039; + identifier + &#039;)&#039;,
  attributes = &#039;\\s*(&#039; + encoding + &#039;*:?&#039; + encoding + &#039;+)\\s*(?:&#039; + operators + &#039;\\s*&#039; + attrcheck + &#039;)?\\s*&#039;,

  attrmatcher = attributes.replace(attrcheck, &#039;([\\x22\\x27]*)((?:\\\\?.)*?)\\3&#039;),

  pseudoclass = &#039;((?:&#039; +
    pseudoparms + &#039;|&#039; + quotedvalue + &#039;|&#039; +
    &#039;[#.:]?|&#039; + encoding + &#039;+|&#039; +
    &#039;\\[&#039; + attributes + &#039;\\]|&#039; +
    &#039;\\(.+\\)|\\s*|&#039; +
    &#039;,)+)&#039;,

  extensions = &#039;.+&#039;,

  standardValidator =
    &#039;(?=\\s*[^&gt;+~(){}&lt;&gt;])&#039; +
    &#039;(&#039; +
    &#039;\\*&#039; +
    &#039;|(?:[#.:]?&#039; + identifier + &#039;)&#039; +
    &#039;|&#039; + combinators +
    &#039;|\\[&#039; + attributes + &#039;\\]&#039; +
    &#039;|\\(&#039; + pseudoclass + &#039;\\)&#039; +
    &#039;|\\{&#039; + extensions + &#039;\\}&#039; +
    &#039;|(?:,|\\s*)&#039; +
    &#039;)+&#039;,

  extendedValidator = standardValidator.replace(pseudoclass, &#039;.*&#039;),

  reValidator = global.RegExp(standardValidator, &#039;g&#039;),

  reTrimSpaces = /^\s*|\s*$/g,

  reSimpleNot = global.RegExp(&#039;^(&#039; +
    &#039;(?!:not)&#039; +
    &#039;([#.:]?&#039; +
    &#039;|&#039; + identifier +
    &#039;|\\([^()]*\\))+&#039; +
    &#039;|\\[&#039; + attributes + &#039;\\]&#039; +
    &#039;)$&#039;),

  reSplitGroup = /([^,\\()[\]]+|\[[^[\]]*\]|\[.*\]|\([^()]+\)|\(.*\)|\{[^{}]+\}|\{.*\}|\\.)+/g,

  reSplitToken = global.RegExp(&#039;(&#039; +
    &#039;\\[&#039; + attributes + &#039;\\]|&#039; +
    &#039;\\(&#039; + pseudoclass + &#039;\\)|&#039; +
    &#039;\\\\.|[^\\s&gt;+~])+&#039;, &#039;g&#039;),

  reOptimizeSelector = global.RegExp(identifier + &#039;|^$&#039;),

  QUIRKS_MODE,
  XML_DOCUMENT,

  GEBTN = &#039;getElementsByTagName&#039; in doc,
  GEBCN = &#039;getElementsByClassName&#039; in doc,

  LINK_NODES = global.Object({ a: 1, A: 1, area: 1, AREA: 1, link: 1, LINK: 1 }),

  ATTR_BOOLEAN = global.Object({
    checked: 1, disabled: 1, ismap: 1,
    multiple: 1, readonly: 1, selected: 1
  }),

  ATTR_DEFAULT = global.Object({
    value: &#039;defaultValue&#039;,
    checked: &#039;defaultChecked&#039;,
    selected: &#039;defaultSelected&#039;
  }),

  ATTR_URIDATA = global.Object({
    action: 2, cite: 2, codebase: 2, data: 2, href: 2,
    longdesc: 2, lowsrc: 2, src: 2, usemap: 2
  }),

  Selectors = global.Object({
  }),

  Operators = global.Object({
     &#039;=&#039;: &quot;n==&#039;%m&#039;&quot;,
    &#039;^=&#039;: &quot;n.indexOf(&#039;%m&#039;)==0&quot;,
    &#039;*=&#039;: &quot;n.indexOf(&#039;%m&#039;)&gt;-1&quot;,
    &#039;|=&#039;: &quot;(n+&#039;-&#039;).indexOf(&#039;%m-&#039;)==0&quot;,
    &#039;~=&#039;: &quot;(&#039; &#039;+n+&#039; &#039;).indexOf(&#039; %m &#039;)&gt;-1&quot;,
    &#039;$=&#039;: &quot;n.substr(n.length-&#039;%m&#039;.length)==&#039;%m&#039;&quot;
  }),

  Optimize = global.Object({
    ID: global.RegExp(&#039;^\\*?#(&#039; + encoding + &#039;+)|&#039; + skipgroup),
    TAG: global.RegExp(&#039;^(&#039; + encoding + &#039;+)|&#039; + skipgroup),
    CLASS: global.RegExp(&#039;^\\*?\\.(&#039; + encoding + &#039;+$)|&#039; + skipgroup)
  }),

  Patterns = global.Object({
    spseudos: /^\:(root|empty|(?:first|last|only)(?:-child|-of-type)|nth(?:-last)?(?:-child|-of-type)\(\s*(even|odd|(?:[-+]{0,1}\d*n\s*)?[-+]{0,1}\s*\d*)\s*\))?(.*)/i,
    dpseudos: /^\:(link|visited|target|active|focus|hover|checked|disabled|enabled|selected|lang\(([-\w]{2,})\)|not\(([^()]*|.*)\))?(.*)/i,
    attribute: global.RegExp(&#039;^\\[&#039; + attrmatcher + &#039;\\](.*)&#039;),
    children: /^\s*\&gt;\s*(.*)/,
    adjacent: /^\s*\+\s*(.*)/,
    relative: /^\s*\~\s*(.*)/,
    ancestor: /^\s+(.*)/,
    universal: /^\*(.*)/,
    id: global.RegExp(&#039;^#(&#039; + encoding + &#039;+)(.*)&#039;),
    tagName: global.RegExp(&#039;^(&#039; + encoding + &#039;+)(.*)&#039;),
    className: global.RegExp(&#039;^\\.(&#039; + encoding + &#039;+)(.*)&#039;)
  }),

  concatCall =
    function(data, elements, callback) {
      var i = -1, element;
      while ((element = elements[++i])) {
        if (false === callback(data[data.length] = element)) { break; }
      }
      return data;
    },

  switchContext =
    function(from, force) {
      var oldDoc = doc;
      lastContext = from;
      doc = from.ownerDocument || from;
      if (force || oldDoc !== doc) {
        root = doc.documentElement;
        XML_DOCUMENT = doc.createElement(&#039;DiV&#039;).nodeName == &#039;DiV&#039;;
        QUIRKS_MODE = !XML_DOCUMENT &amp;&amp;
          typeof doc.compatMode == &#039;string&#039; ?
          doc.compatMode.indexOf(&#039;CSS&#039;) &lt; 0 :
          (function() {
            var style = doc.createElement(&#039;div&#039;).style;
            return style &amp;&amp; (style.width = 1) &amp;&amp; style.width == &#039;1px&#039;;
          })();

        Config.CACHING &amp;&amp; Dom.setCache(true, doc);
      }
    },

  convertEscapes =
    function(str) {
      return str.replace(/\\([0-9a-fA-F]{1,6}\x20?|.)|([\x22\x27])/g, function(substring, p1, p2) {
        var codePoint, highHex, highSurrogate, lowHex, lowSurrogate;

        if (p2) {
          return &#039;\\&#039; + p2;
        }

        if (/^[0-9a-fA-F]/.test(p1)) {
          codePoint = parseInt(p1, 16);

          if (codePoint &lt; 0 || codePoint &gt; 0x10ffff) {
            return &#039;\\ufffd&#039;;
          }

          if (codePoint &lt;= 0xffff) {
            lowHex = &#039;000&#039; + codePoint.toString(16);
            return &#039;\\u&#039; + lowHex.substr(lowHex.length - 4);
          }

          codePoint -= 0x10000;
          highSurrogate = (codePoint &gt;&gt; 10) + 0xd800;
          lowSurrogate = (codePoint % 0x400) + 0xdc00;
          highHex = &#039;000&#039; + highSurrogate.toString(16);
          lowHex = &#039;000&#039; + lowSurrogate.toString(16);

          return &#039;\\u&#039; + highHex.substr(highHex.length - 4) +
            &#039;\\u&#039; + lowHex.substr(lowHex.length - 4);
        }

        if (/^[\\\x22\x27]/.test(p1)) {
          return substring;
        }

        return p1;
      });
    },

  byIdRaw =
    function(id, elements) {
      var i = -1, element = null;
      while ((element = elements[++i])) {
        if (element.getAttribute(&#039;id&#039;) == id) {
          break;
        }
      }
      return element;
    },

  _byId = !(&#039;fileSize&#039; in doc) ?
    function(id, from) {
      id = id.replace(/\\([^\\]{1})/g, &#039;$1&#039;);
      return from.getElementById &amp;&amp; from.getElementById(id) ||
        byIdRaw(id, from.getElementsByTagName(&#039;*&#039;));
    } :
    function(id, from) {
      var element = null;
      id = id.replace(/\\([^\\]{1})/g, &#039;$1&#039;);
      if (XML_DOCUMENT || from.nodeType != 9) {
        return byIdRaw(id, from.getElementsByTagName(&#039;*&#039;));
      }
      if ((element = from.getElementById(id)) &amp;&amp;
        element.name == id &amp;&amp; from.getElementsByName) {
        return byIdRaw(id, from.getElementsByName(id));
      }
      return element;
    },

  byId =
    function(id, from) {
      from || (from = doc);
      if (lastContext !== from) { switchContext(from); }
      return _byId(id, from);
    },

  byTagRaw =
    function(tag, from) {
      var any = tag == &#039;*&#039;, element = from, elements = global.Array(), next = element.firstChild;
      any || (tag = tag.toUpperCase());
      while ((element = next)) {
        if (element.tagName &gt; &#039;@&#039; &amp;&amp; (any || element.tagName.toUpperCase() == tag)) {
          elements[elements.length] = element;
        }
        if ((next = element.firstChild || element.nextSibling)) continue;
        while (!next &amp;&amp; (element = element.parentNode) &amp;&amp; element !== from) {
          next = element.nextSibling;
        }
      }
      return elements;
    },

  contains = &#039;compareDocumentPosition&#039; in root ?
    function(container, element) {
      return (container.compareDocumentPosition(element) &amp; 16) == 16;
    } : &#039;contains&#039; in root ?
    function(container, element) {
      return element.nodeType == 1 &amp;&amp; container.contains(element);
    } :
    function(container, element) {
      while ((element = element.parentNode) &amp;&amp; element.nodeType == 1) {
        if (element === container) return true;
      }
      return false;
    },

  getAttribute =
    function(node, attribute) {
      attribute = attribute.toLowerCase();
      if (typeof node[attribute] == &#039;object&#039;) {
        return node.attributes[attribute] &amp;&amp;
          node.attributes[attribute].value || &#039;&#039;;
      }
      return (
        attribute == &#039;type&#039; ? node.getAttribute(attribute) || &#039;&#039; :
        ATTR_URIDATA[attribute] ? node.getAttribute(attribute, 2) || &#039;&#039; :
        ATTR_BOOLEAN[attribute] ? node.getAttribute(attribute) ? attribute : &#039;false&#039; :
          ((node = node.getAttributeNode(attribute)) &amp;&amp; node.value) || &#039;&#039;);
    },

  hasAttribute = root.hasAttribute ?
    function(node, attribute) {
      return node.hasAttribute(attribute);
    } :
    function(node, attribute) {
      attribute = attribute.toLowerCase();
      if (ATTR_DEFAULT[attribute]) {
        return !!node[ATTR_DEFAULT[attribute]];
      }
      node = node.getAttributeNode(attribute);
      return !!(node &amp;&amp; node.specified);
    },

  isLink =
    function(element) {
      return element.getAttribute(&#039;href&#039;) &amp;&amp; LINK_NODES[element.nodeName];
    },

  isEmpty =
    function(node) {
      node = node.firstChild;
      while (node) {
        if (node.nodeType == 3 || node.nodeName &gt; &#039;@&#039;) return false;
        node = node.nextSibling;
      }
      return true;
    },

  nthElement =
    function(element, last) {
      var count = 1, succ = last ? &#039;nextSibling&#039; : &#039;previousSibling&#039;;
      while ((element = element[succ])) {
        if (element.nodeName &gt; &#039;@&#039;) ++count;
      }
      return count;
    },

  nthOfType =
    function(element, last) {
      var count = 1, succ = last ? &#039;nextSibling&#039; : &#039;previousSibling&#039;, type = element.nodeName;
      while ((element = element[succ])) {
        if (element.nodeName == type) ++count;
      }
      return count;
    },

  configure =
    function(option) {
      if (typeof option == &#039;string&#039;) { return Config[option] || Config; }
      if (typeof option != &#039;object&#039;) { return false; }
      for (var i in option) {
        Config[i] = !!option[i];
        if (i == &#039;SIMPLENOT&#039;) {
          matchContexts = global.Object();
          matchResolvers = global.Object();
          selectContexts = global.Object();
          selectResolvers = global.Object();
        }
      }
      reValidator = global.RegExp(Config.SIMPLENOT ?
        standardValidator : extendedValidator, &#039;g&#039;);
      return true;
    },

  emit =
    function(message) {
      if (Config.VERBOSITY) { throw global.Error(message); }
      if (global.console &amp;&amp; global.console.log) {
        global.console.log(message);
      }
    },

  Config = global.Object({
    CACHING: false,
    SIMPLENOT: true,
    UNIQUE_ID: true,
    USE_HTML5: true,
    VERBOSITY: true
  }),

  IE_LT_9 = typeof doc.addEventListener != &#039;function&#039;,

  INSENSITIVE_MAP = global.Object({
    href: 1, lang: 1, src: 1, style: 1, title: 1,
    type: 1, xmlns: 1, &#039;xml:lang&#039;: 1, &#039;xml:space&#039;: 1
  }),

  TO_UPPER_CASE = IE_LT_9 ? &#039;.toUpperCase()&#039; : &#039;&#039;,

  ACCEPT_NODE = &#039;r[r.length]=c[k];if(f&amp;&amp;false===f(c[k]))break main;else continue main;&#039;,
  REJECT_NODE = IE_LT_9 ? &#039;if(e.nodeName&lt;&quot;A&quot;)continue;&#039; : &#039;&#039;,

  compile =
    function(selector, source, mode) {

      var parts = typeof selector == &#039;string&#039; ? selector.match(reSplitGroup) : selector;

      typeof source == &#039;string&#039; || (source = &#039;&#039;);

      if (parts.length == 1) {
        source += compileSelector(parts[0], mode ? ACCEPT_NODE : &#039;f&amp;&amp;f(k);return true;&#039;, mode);
      } else {
        var i = -1, seen = global.Object(), token;
        while ((token = parts[++i])) {
          token = token.replace(reTrimSpaces, &#039;&#039;);
          if (!seen[token] &amp;&amp; (seen[token] = true)) {
            source += compileSelector(token, mode ? ACCEPT_NODE : &#039;f&amp;&amp;f(k);return true;&#039;, mode);
          }
        }
      }

      if (mode) {
        return global.Function(&#039;c,s,r,d,h,g,f,v&#039;,
          &#039;var N,n,x=0,k=-1,e;main:while((e=c[++k])){&#039; + source + &#039;}return r;&#039;);
      } else {
        return global.Function(&#039;e,s,r,d,h,g,f,v&#039;,
          &#039;var N,n,x=0,k=e;&#039; + source + &#039;return false;&#039;);
      }
    },

  FILTER =
    &#039;var z=v[@]||(v[@]=[]),l=z.length-1;&#039; +
    &#039;while(l&gt;=0&amp;&amp;z[l]!==e)--l;&#039; +
    &#039;if(l!==-1){break;}&#039; +
    &#039;z[z.length]=e;&#039;,

  compileSelector =
    function(selector, source, mode) {

      var a, b, n, k = 0, expr, match, name, result, status, test, type;

      while (selector) {

        k++;

        if ((match = selector.match(Patterns.universal))) {
          expr = &#039;&#039;;
        }

        else if ((match = selector.match(Patterns.id))) {
          source = &#039;if(&#039; + (XML_DOCUMENT ?
            &#039;s.getAttribute(e,&quot;id&quot;)&#039; :
            &#039;(e.submit?s.getAttribute(e,&quot;id&quot;):e.id)&#039;) +
            &#039;==&quot;&#039; + match[1] + &#039;&quot;&#039; +
            &#039;){&#039; + source + &#039;}&#039;;
        }

        else if ((match = selector.match(Patterns.tagName))) {
          source = &#039;if(e.nodeName&#039; + (XML_DOCUMENT ?
            &#039;==&quot;&#039; + match[1] + &#039;&quot;&#039; : TO_UPPER_CASE +
            &#039;==&quot;&#039; + match[1].toUpperCase() + &#039;&quot;&#039;) +
            &#039;){&#039; + source + &#039;}&#039;;
        }

        else if ((match = selector.match(Patterns.className))) {
          source = &#039;if((n=&#039; + (XML_DOCUMENT ?
            &#039;e.getAttribute(&quot;class&quot;)&#039; : &#039;e.className&#039;) +
            &#039;)&amp;&amp;n.length&amp;&amp;(&quot; &quot;+&#039; + (QUIRKS_MODE ? &#039;n.toLowerCase()&#039; : &#039;n&#039;) +
            &#039;.replace(/\\s+/g,&quot; &quot;)+&quot; &quot;).indexOf(&quot; &#039; +
            (QUIRKS_MODE ? match[1].toLowerCase() : match[1]) + &#039; &quot;)&gt;-1&#039; +
            &#039;){&#039; + source + &#039;}&#039;;
        }

        else if ((match = selector.match(Patterns.attribute))) {
          if (match[2] &amp;&amp; !Operators[match[2]]) {
            emit(&#039;Unsupported operator in attribute selectors &quot;&#039; + selector + &#039;&quot;&#039;);
            return &#039;&#039;;
          }
          test = &#039;false&#039;;
          if (match[2] &amp;&amp; match[4] &amp;&amp; (test = Operators[match[2]])) {
            match[4] = convertEscapes(match[4]);
            type = INSENSITIVE_MAP[match[1].toLowerCase()];
            test = test.replace(/\%m/g, type ? match[4].toLowerCase() : match[4]);
          } else if (match[2] == &#039;!=&#039; || match[2] == &#039;=&#039;) {
            test = &#039;n&#039; + match[2] + &#039;=&quot;&quot;&#039;;
          }
          expr = &#039;n=s.&#039; + (match[2] ? &#039;get&#039; : &#039;has&#039;) + &#039;Attribute(e,&quot;&#039; + match[1] + &#039;&quot;)&#039; + (type &amp;&amp; match[2] ? &#039;.toLowerCase();&#039; : &#039;;&#039;);
          source = expr + &#039;if(&#039; + (match[2] ? test : &#039;n&#039;) + &#039;){&#039; + source + &#039;}&#039;;
        }

        else if ((match = selector.match(Patterns.adjacent))) {
          source = (mode ? &#039;&#039; : FILTER.replace(/@/g, k)) + source;
          source = &#039;var N&#039; + k + &#039;=e;while(e&amp;&amp;(e=e.previousSibling)){if(e.nodeName&gt;&quot;@&quot;){&#039; + source + &#039;break;}}e=N&#039; + k + &#039;;&#039;;
        }

        else if ((match = selector.match(Patterns.relative))) {
          source = (mode ? &#039;&#039; : FILTER.replace(/@/g, k)) + source;
          source = &#039;var N&#039; + k + &#039;=e;e=e.parentNode.firstChild;while(e&amp;&amp;e!==N&#039; + k + &#039;){if(e.nodeName&gt;&quot;@&quot;){&#039; + source + &#039;}e=e.nextSibling;}e=N&#039; + k + &#039;;&#039;;
        }

        else if ((match = selector.match(Patterns.children))) {
          source = (mode ? &#039;&#039; : FILTER.replace(/@/g, k)) + source;
          source = &#039;var N&#039; + k + &#039;=e;while(e&amp;&amp;e!==h&amp;&amp;e!==g&amp;&amp;(e=e.parentNode)){&#039; + source + &#039;break;}e=N&#039; + k + &#039;;&#039;;
        }

        else if ((match = selector.match(Patterns.ancestor))) {
          source = (mode ? &#039;&#039; : FILTER.replace(/@/g, k)) + source;
          source = &#039;var N&#039; + k + &#039;=e;while(e&amp;&amp;e!==h&amp;&amp;e!==g&amp;&amp;(e=e.parentNode)){&#039; + source + &#039;}e=N&#039; + k + &#039;;&#039;;
        }

        else if ((match = selector.match(Patterns.spseudos)) &amp;&amp; match[1]) {
          switch (match[1]) {
            case &#039;root&#039;:
              if (match[3]) {
                source = &#039;if(e===h||s.contains(h,e)){&#039; + source + &#039;}&#039;;
              } else {
                source = &#039;if(e===h){&#039; + source + &#039;}&#039;;
              }
              break;
            case &#039;empty&#039;:
              source = &#039;if(s.isEmpty(e)){&#039; + source + &#039;}&#039;;
              break;
            default:
              if (match[1] &amp;&amp; match[2]) {
                if (match[2] == &#039;n&#039;) {
                  source = &#039;if(e!==h){&#039; + source + &#039;}&#039;;
                  break;
                } else if (match[2] == &#039;even&#039;) {
                  a = 2;
                  b = 0;
                } else if (match[2] == &#039;odd&#039;) {
                  a = 2;
                  b = 1;
                } else {
                  b = ((n = match[2].match(/(-?\d+)$/)) ? global.parseInt(n[1], 10) : 0);
                  a = ((n = match[2].match(/(-?\d*)n/i)) ? global.parseInt(n[1], 10) : 0);
                  if (n &amp;&amp; n[1] == &#039;-&#039;) a = -1;
                }
                test = a &gt; 1 ?
                  (/last/i.test(match[1])) ? &#039;(n-(&#039; + b + &#039;))%&#039; + a + &#039;==0&#039; :
                  &#039;n&gt;=&#039; + b + &#039;&amp;&amp;(n-(&#039; + b + &#039;))%&#039; + a + &#039;==0&#039; : a &lt; -1 ?
                  (/last/i.test(match[1])) ? &#039;(n-(&#039; + b + &#039;))%&#039; + a + &#039;==0&#039; :
                  &#039;n&lt;=&#039; + b + &#039;&amp;&amp;(n-(&#039; + b + &#039;))%&#039; + a + &#039;==0&#039; : a === 0 ?
                  &#039;n==&#039; + b : a == -1 ? &#039;n&lt;=&#039; + b : &#039;n&gt;=&#039; + b;
                source =
                  &#039;if(e!==h){&#039; +
                    &#039;n=s[&#039; + (/-of-type/i.test(match[1]) ? &#039;&quot;nthOfType&quot;&#039; : &#039;&quot;nthElement&quot;&#039;) + &#039;]&#039; +
                      &#039;(e,&#039; + (/last/i.test(match[1]) ? &#039;true&#039; : &#039;false&#039;) + &#039;);&#039; +
                    &#039;if(&#039; + test + &#039;){&#039; + source + &#039;}&#039; +
                  &#039;}&#039;;
              } else {
                a = /first/i.test(match[1]) ? &#039;previous&#039; : &#039;next&#039;;
                n = /only/i.test(match[1]) ? &#039;previous&#039; : &#039;next&#039;;
                b = /first|last/i.test(match[1]);
                type = /-of-type/i.test(match[1]) ? &#039;&amp;&amp;n.nodeName!=e.nodeName&#039; : &#039;&amp;&amp;n.nodeName&lt;&quot;@&quot;&#039;;
                source = &#039;if(e!==h){&#039; +
                  ( &#039;n=e;while((n=n.&#039; + a + &#039;Sibling)&#039; + type + &#039;);if(!n){&#039; + (b ? source :
                    &#039;n=e;while((n=n.&#039; + n + &#039;Sibling)&#039; + type + &#039;);if(!n){&#039; + source + &#039;}&#039;) + &#039;}&#039; ) + &#039;}&#039;;
              }
              break;
          }
        }

        else if ((match = selector.match(Patterns.dpseudos)) &amp;&amp; match[1]) {
          switch (match[1].match(/^\w+/)[0]) {
            case &#039;not&#039;:
              expr = match[3].replace(reTrimSpaces, &#039;&#039;);
              if (Config.SIMPLENOT &amp;&amp; !reSimpleNot.test(expr)) {
                emit(&#039;Negation pseudo-class only accepts simple selectors &quot;&#039; + match.join(&#039;&#039;) + &#039;&quot;&#039;);
                return &#039;&#039;;
              } else {
                if (&#039;compatMode&#039; in doc) {
                  source = &#039;if(!&#039; + compile(expr, &#039;&#039;, false) + &#039;(e,s,r,d,h,g)){&#039; + source + &#039;}&#039;;
                } else {
                  source = &#039;if(!s.match(e, &quot;&#039; + expr.replace(/\x22/g, &#039;\\&quot;&#039;) + &#039;&quot;,g)){&#039; + source +&#039;}&#039;;
                }
              }
              break;
            case &#039;checked&#039;:
              source = &#039;if((typeof e.form!==&quot;undefined&quot;&amp;&amp;(/^(?:radio|checkbox)$/i).test(e.type)&amp;&amp;e.checked)&#039; +
                (Config.USE_HTML5 ? &#039;||(/^option$/i.test(e.nodeName)&amp;&amp;(e.selected||e.checked))&#039; : &#039;&#039;) +
                &#039;){&#039; + source + &#039;}&#039;;
              break;
            case &#039;disabled&#039;:
              source = &#039;if(((typeof e.form!==&quot;undefined&quot;&#039; +
                (Config.USE_HTML5 ? &#039;&#039; : &#039;&amp;&amp;!(/^hidden$/i).test(e.type)&#039;) +
                &#039;)||s.isLink(e))&amp;&amp;e.disabled===true){&#039; + source + &#039;}&#039;;
              break;
            case &#039;enabled&#039;:
              source = &#039;if(((typeof e.form!==&quot;undefined&quot;&#039; +
                (Config.USE_HTML5 ? &#039;&#039; : &#039;&amp;&amp;!(/^hidden$/i).test(e.type)&#039;) +
                &#039;)||s.isLink(e))&amp;&amp;e.disabled===false){&#039; + source + &#039;}&#039;;
              break;
            case &#039;lang&#039;:
              test = &#039;&#039;;
              if (match[2]) test = match[2].substr(0, 2) + &#039;-&#039;;
              source = &#039;do{(n=e.lang||&quot;&quot;).toLowerCase();&#039; +
                &#039;if((n==&quot;&quot;&amp;&amp;h.lang==&quot;&#039; + match[2].toLowerCase() + &#039;&quot;)||&#039; +
                &#039;(n&amp;&amp;(n==&quot;&#039; + match[2].toLowerCase() +
                &#039;&quot;||n.substr(0,3)==&quot;&#039; + test.toLowerCase() + &#039;&quot;)))&#039; +
                &#039;{&#039; + source + &#039;break;}}while((e=e.parentNode)&amp;&amp;e!==g);&#039;;
              break;
            case &#039;target&#039;:
              source = &#039;if(e.id==d.location.hash.slice(1)){&#039; + source + &#039;}&#039;;
              break;
            case &#039;link&#039;:
              source = &#039;if(s.isLink(e)&amp;&amp;!e.visited){&#039; + source + &#039;}&#039;;
              break;
            case &#039;visited&#039;:
              source = &#039;if(s.isLink(e)&amp;&amp;e.visited){&#039; + source + &#039;}&#039;;
              break;
            case &#039;active&#039;:
              source = &#039;if(e===d.activeElement){&#039; + source + &#039;}&#039;;
              break;
            case &#039;hover&#039;:
              source = &#039;if(e===d.hoverElement){&#039; + source + &#039;}&#039;;
              break;
            case &#039;focus&#039;:
              source = &#039;hasFocus&#039; in doc ?
                &#039;if(e===d.activeElement&amp;&amp;d.hasFocus()&amp;&amp;(e.type||e.href||typeof e.tabIndex==&quot;number&quot;)){&#039; + source + &#039;}&#039; :
                &#039;if(e===d.activeElement&amp;&amp;(e.type||e.href)){&#039; + source + &#039;}&#039;;
              break;
            case &#039;selected&#039;:
              source = &#039;if(/^option$/i.test(e.nodeName)&amp;&amp;(e.selected||e.checked)){&#039; + source + &#039;}&#039;;
              break;
            default:
              break;
          }
        }

        else {

          expr = false;
          status = false;
          for (expr in Selectors) {
            if ((match = selector.match(Selectors[expr].Expression)) &amp;&amp; match[1]) {
              result = Selectors[expr].Callback(match, source);
              source = result.source;
              status = result.status;
              if (status) { break; }
            }
          }

          if (!status) {
            emit(&#039;Unknown pseudo-class selector &quot;&#039; + selector + &#039;&quot;&#039;);
            return &#039;&#039;;
          }

          if (!expr) {
            emit(&#039;Unknown token in selector &quot;&#039; + selector + &#039;&quot;&#039;);
            return &#039;&#039;;
          }

        }

        if (!match) {
          emit(&#039;Invalid syntax in selector &quot;&#039; + selector + &#039;&quot;&#039;);
          return &#039;&#039;;
        }

        selector = match &amp;&amp; match[match.length - 1];
      }

      return source;
    },

  match =
    function(element, selector, from, callback) {

      var parts;

      if (!(element &amp;&amp; element.nodeType == 1)) {
        emit(&#039;Invalid element argument&#039;);
        return false;
      } else if (typeof selector != &#039;string&#039;) {
        emit(&#039;Invalid selector argument&#039;);
        return false;
      } else if (lastContext !== from) {
        switchContext(from || (from = element.ownerDocument));
      }

      selector = selector.replace(reTrimSpaces, &#039;&#039;);

      Config.SHORTCUTS &amp;&amp; (selector = Dom.shortcuts(selector, element, from));

      if (lastMatcher != selector) {
        if ((parts = selector.match(reValidator)) &amp;&amp; parts[0] == selector) {
          isSingleMatch = (parts = selector.match(reSplitGroup)).length &lt; 2;
          lastMatcher = selector;
          lastPartsMatch = parts;
        } else {
          emit(&#039;The string &quot;&#039; + selector + &#039;&quot;, is not a valid CSS selector&#039;);
          return false;
        }
      } else parts = lastPartsMatch;

      if (!matchResolvers[selector] || matchContexts[selector] !== from) {
        matchResolvers[selector] = compile(isSingleMatch ? [selector] : parts, &#039;&#039;, false);
        matchContexts[selector] = from;
      }

      return matchResolvers[selector](element, Snapshot, [ ], doc, root, from, callback, { });
    },

  first =
    function(selector, from) {
      return select(selector, from, function() { return false; })[0] || null;
    },

  select =
    function(selector, from, callback) {

      var i, changed, element, elements, parts, token, original = selector;

      if (arguments.length === 0) {
        emit(&#039;Not enough arguments&#039;);
        return [ ];
      } else if (typeof selector != &#039;string&#039;) {
        return [ ];
      } else if (from &amp;&amp; !(/1|9|11/).test(from.nodeType)) {
        emit(&#039;Invalid or illegal context element&#039;);
        return [ ];
      } else if (lastContext !== from) {
        switchContext(from || (from = doc));
      }

      if (Config.CACHING &amp;&amp; (elements = Dom.loadResults(original, from, doc, root))) {
        return callback ? concatCall([ ], elements, callback) : elements;
      }

      selector = selector.replace(reTrimSpaces, &#039;&#039;);

      Config.SHORTCUTS &amp;&amp; (selector = Dom.shortcuts(selector, from));

      if ((changed = lastSelector != selector)) {
        if ((parts = selector.match(reValidator)) &amp;&amp; parts[0] == selector) {
          isSingleSelect = (parts = selector.match(reSplitGroup)).length &lt; 2;
          lastSelector = selector;
          lastPartsSelect = parts;
        } else {
          emit(&#039;The string &quot;&#039; + selector + &#039;&quot;, is not a valid CSS selector&#039;);
          return [ ];
        }
      } else parts = lastPartsSelect;

      if (from.nodeType == 11) {

        elements = byTagRaw(&#039;*&#039;, from);

      } else if (isSingleSelect) {

        if (changed) {
          parts = selector.match(reSplitToken);
          token = parts[parts.length - 1];
          lastSlice = token.split(&#039;:not&#039;)[0];
          lastPosition = selector.length - token.length;
        }

        if (Config.UNIQUE_ID &amp;&amp; (parts = lastSlice.match(Optimize.ID)) &amp;&amp; (token = parts[1])) {
          if ((element = _byId(token, from))) {
            if (match(element, selector)) {
              callback &amp;&amp; callback(element);
              elements = global.Array(element);
            } else elements = global.Array();
          }
        }

        else if (Config.UNIQUE_ID &amp;&amp; (parts = selector.match(Optimize.ID)) &amp;&amp; (token = parts[1])) {
          if ((element = _byId(token, doc))) {
            if (&#039;#&#039; + token == selector) {
              callback &amp;&amp; callback(element);
              elements = global.Array(element);
            } else if (/[&gt;+~]/.test(selector)) {
              from = element.parentNode;
            } else {
              from = element;
            }
          } else elements = global.Array();
        }

        if (elements) {
          Config.CACHING &amp;&amp; Dom.saveResults(original, from, doc, elements);
          return elements;
        }

        if (!XML_DOCUMENT &amp;&amp; GEBTN &amp;&amp; (parts = lastSlice.match(Optimize.TAG)) &amp;&amp; (token = parts[1])) {
          if ((elements = from.getElementsByTagName(token)).length === 0) { return [ ]; }
          selector = selector.slice(0, lastPosition) + selector.slice(lastPosition).replace(token, &#039;*&#039;);
        }

        else if (!XML_DOCUMENT &amp;&amp; GEBCN &amp;&amp; (parts = lastSlice.match(Optimize.CLASS)) &amp;&amp; (token = parts[1])) {
          if ((elements = from.getElementsByClassName(token.replace(/\\([^\\]{1})/g, &#039;$1&#039;))).length === 0) { return [ ]; }
            selector = selector.slice(0, lastPosition) + selector.slice(lastPosition).replace(&#039;.&#039; + token,
              reOptimizeSelector.test(selector.charAt(selector.indexOf(token) - 1)) ? &#039;&#039; : &#039;*&#039;);
        }

      }

      if (!elements) {
        if (IE_LT_9) {
          elements = /^(?:applet|object)$/i.test(from.nodeName) ? from.childNodes : from.all;
        } else {
          elements = from.getElementsByTagName(&#039;*&#039;);
        }
      }

      if (!selectResolvers[selector] || selectContexts[selector] !== from) {
        selectResolvers[selector] = compile(isSingleSelect ? [selector] : parts, REJECT_NODE, true);
        selectContexts[selector] = from;
      }

      elements = selectResolvers[selector](elements, Snapshot, [ ], doc, root, from, callback, { });

      Config.CACHING &amp;&amp; Dom.saveResults(original, from, doc, elements);

      return elements;
    },

  FN = function(x) { return x; },

  matchContexts = global.Object(),
  matchResolvers = global.Object(),

  selectContexts = global.Object(),
  selectResolvers = global.Object(),

  Snapshot = global.Object({
    byId: _byId,
    match: match,
    select: select,
    isLink: isLink,
    isEmpty: isEmpty,
    contains: contains,
    nthOfType: nthOfType,
    nthElement: nthElement,
    getAttribute: getAttribute,
    hasAttribute: hasAttribute
  });

  Dom.ACCEPT_NODE = ACCEPT_NODE;

  Dom.byId = byId;
  Dom.match = match;
  Dom.first = first;
  Dom.select = select;
  Dom.compile = compile;
  Dom.contains = contains;
  Dom.configure = configure;
  Dom.getAttribute = getAttribute;
  Dom.hasAttribute = hasAttribute;

  Dom.setCache = FN;
  Dom.shortcuts = FN;
  Dom.loadResults = FN;
  Dom.saveResults = FN;

  Dom.emit = emit;
  Dom.Config = Config;
  Dom.Snapshot = Snapshot;

  Dom.Operators = Operators;
  Dom.Selectors = Selectors;

  Dom.Version = version;

  Dom.registerOperator =
    function(symbol, resolver) {
      Operators[symbol] || (Operators[symbol] = resolver);
    };

  Dom.registerSelector =
    function(name, rexp, func) {
      Selectors[name] || (Selectors[name] = global.Object({
        Expression: rexp,
        Callback: func
      }));
    };

  switchContext(doc, true);

});</textarea>
  </div>
</div>

<footer class="footer">
  <div class="container">
    <p>.</p>
  </div>
</footer>

<script type="text/html" id="complexity-popover-template">
  <div class="complexity-notice">
    Complexity : {{ complexity.cyclomatic }} <br>
    Length : {{ complexity.halstead.length }} <br>
    Difficulty : {{ complexity.halstead.difficulty.toFixed(2) }} <br>
    Est # bugs : {{ complexity.halstead.bugs.toFixed(2) }}<br>
  </div>
</script>

<script type="text/javascript" src="../../assets/scripts/bundles/core-bundle.js"></script>
<script type="text/javascript" src="../../assets/scripts/bundles/codemirror.js"></script>
<script type="text/javascript" src="../../assets/scripts/codemirror.markpopovertext.js"></script>
<script type="text/javascript" src="report.js"></script>
<script type="text/javascript" src="report.history.js"></script>
<script type="text/javascript" src="../../assets/scripts/plato-file.js"></script>
</body>
</html>
