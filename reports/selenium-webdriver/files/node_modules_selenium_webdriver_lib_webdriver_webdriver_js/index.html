<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Plato - node_modules/selenium-webdriver/lib/webdriver/webdriver.js</title>

  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="">
  <meta name="author" content="">

  <!--[if lt IE 9]>
  <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->

  <link href="../../assets/css/vendor/morris.css" rel="stylesheet">
  <link href="../../assets/css/vendor/bootstrap.css" rel="stylesheet">
  <link href="../../assets/css/vendor/font-awesome.css" rel="stylesheet">
  <link href="../../assets/css/vendor/codemirror.css" rel="stylesheet">
  <link href="../../assets/css/plato.css" rel="stylesheet">
  <link href="../../assets/css/plato-file.css" rel="stylesheet">

</head>

<body>

<div class="navbar navbar-fixed-top">
  <div class="container">
    <a class="navbar-brand" href="http://github.com/es-analysis/plato">Plato on Github</a>
    <ul class="nav navbar-nav">
      <li>
        <a href="../../index.html">Report Home</a>
      </li>
    </ul>
  </div>
</div>

<div class="jumbotron">
  <div class="container">
    <h1>node_modules/selenium-webdriver/lib/webdriver/webdriver.js</h1>
  </div>
</div>

<div class="container aggregate-stats">
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Maintainability <a href="http://blogs.msdn.com/b/codeanalysis/archive/2007/11/20/maintainability-index-range-and-meaning.aspx"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="A value between 0 and 100 that represents the relative ease of maintaining the code. A high value means better maintainability." data-original-title="Maintainability Index"  data-container="body"></i></a></h2>
      <p class="stat">78.73</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Lines of code <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h2>
      <p class="stat">2329</p>
    </div>
  </div>
  <div class="row historical">
    <div class="col-md-6">
      <p id="chart_historical_maint" class="chart"></p>
    </div>
    <div class="col-md-6">
      <p id="chart_historical_sloc" class="chart"></p>
    </div>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Difficulty  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="The difficulty measure is related to the difficulty of the program to write or understand." data-original-title="Difficulty" data-container="body"></i></a></h2>
      <p class="stat">93.32</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Estimated Errors  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Halstead's delivered bugs is an estimate for the number of errors in the implementation." data-original-title="Delivered Bugs" data-container="body"></i></a></h2>
      <p class="stat">14.22</p>
    </div>
  </div>
</div>

<div class="container charts">
  <div class="row">
    <h2 class="header">Function weight</h2>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h3 class="chart-header">By Complexity <a href="http://en.wikipedia.org/wiki/Cyclomatic_complexity"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="This metric counts the number of distinct paths through a block of code. Lower values are better." data-original-title="Cyclomatic Complexity" data-container="body"></i></a></h3>
      <div id="fn-by-complexity" class="stat"></div>
    </div>
    <div class="col-md-6">
      <h3 class="chart-header">By SLOC  <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h3>
      <div id="fn-by-sloc" class="stat"></div>
    </div>
  </div>
</div>

<div class="container">
  <div class="row">
    <textarea id="file-source" class="col-md-12">// Copyright 2011 Software Freedom Conservancy. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/**
 * @fileoverview The heart of the WebDriver JavaScript API.
 */

goog.provide(&#039;webdriver.Alert&#039;);
goog.provide(&#039;webdriver.AlertPromise&#039;);
goog.provide(&#039;webdriver.UnhandledAlertError&#039;);
goog.provide(&#039;webdriver.WebDriver&#039;);
goog.provide(&#039;webdriver.WebElement&#039;);
goog.provide(&#039;webdriver.WebElementPromise&#039;);

goog.require(&#039;bot.Error&#039;);
goog.require(&#039;bot.ErrorCode&#039;);
goog.require(&#039;bot.response&#039;);
goog.require(&#039;goog.array&#039;);
goog.require(&#039;goog.object&#039;);
goog.require(&#039;webdriver.ActionSequence&#039;);
goog.require(&#039;webdriver.Command&#039;);
goog.require(&#039;webdriver.CommandName&#039;);
goog.require(&#039;webdriver.Key&#039;);
goog.require(&#039;webdriver.Locator&#039;);
goog.require(&#039;webdriver.Session&#039;);
goog.require(&#039;webdriver.logging&#039;);
goog.require(&#039;webdriver.promise&#039;);
goog.require(&#039;webdriver.until&#039;);


//////////////////////////////////////////////////////////////////////////////
//
//  webdriver.WebDriver
//
//////////////////////////////////////////////////////////////////////////////



/**
 * Creates a new WebDriver client, which provides control over a browser.
 *
 * Every WebDriver command returns a {@code webdriver.promise.Promise} that
 * represents the result of that command. Callbacks may be registered on this
 * object to manipulate the command result or catch an expected error. Any
 * commands scheduled with a callback are considered sub-commands and will
 * execute before the next command in the current frame. For example:
 * &lt;pre&gt;&lt;code&gt;
 *   var message = [];
 *   driver.call(message.push, message, &#039;a&#039;).then(function() {
 *     driver.call(message.push, message, &#039;b&#039;);
 *   });
 *   driver.call(message.push, message, &#039;c&#039;);
 *   driver.call(function() {
 *     alert(&#039;message is abc? &#039; + (message.join(&#039;&#039;) == &#039;abc&#039;));
 *   });
 * &lt;/code&gt;&lt;/pre&gt;
 *
 * @param {!(webdriver.Session|webdriver.promise.Promise)} session Either a
 *     known session or a promise that will be resolved to a session.
 * @param {!webdriver.CommandExecutor} executor The executor to use when
 *     sending commands to the browser.
 * @param {webdriver.promise.ControlFlow=} opt_flow The flow to
 *     schedule commands through. Defaults to the active flow object.
 * @constructor
 */
webdriver.WebDriver = function(session, executor, opt_flow) {

  /** @private {!(webdriver.Session|webdriver.promise.Promise)} */
  this.session_ = session;

  /** @private {!webdriver.CommandExecutor} */
  this.executor_ = executor;

  /** @private {!webdriver.promise.ControlFlow} */
  this.flow_ = opt_flow || webdriver.promise.controlFlow();
};


/**
 * Creates a new WebDriver client for an existing session.
 * @param {!webdriver.CommandExecutor} executor Command executor to use when
 *     querying for session details.
 * @param {string} sessionId ID of the session to attach to.
 * @param {webdriver.promise.ControlFlow=} opt_flow The control flow all driver
 *     commands should execute under. Defaults to the
 *     {@link webdriver.promise.controlFlow() currently active}  control flow.
 * @return {!webdriver.WebDriver} A new client for the specified session.
 */
webdriver.WebDriver.attachToSession = function(executor, sessionId, opt_flow) {
  return webdriver.WebDriver.acquireSession_(executor,
      new webdriver.Command(webdriver.CommandName.DESCRIBE_SESSION).
          setParameter(&#039;sessionId&#039;, sessionId),
      &#039;WebDriver.attachToSession()&#039;,
      opt_flow);
};


/**
 * Creates a new WebDriver session.
 * @param {!webdriver.CommandExecutor} executor The executor to create the new
 *     session with.
 * @param {!webdriver.Capabilities} desiredCapabilities The desired
 *     capabilities for the new session.
 * @param {webdriver.promise.ControlFlow=} opt_flow The control flow all driver
 *     commands should execute under, including the initial session creation.
 *     Defaults to the {@link webdriver.promise.controlFlow() currently active} 
 *     control flow.
 * @return {!webdriver.WebDriver} The driver for the newly created session.
 */
webdriver.WebDriver.createSession = function(
    executor, desiredCapabilities, opt_flow) {
  return webdriver.WebDriver.acquireSession_(executor,
      new webdriver.Command(webdriver.CommandName.NEW_SESSION).
          setParameter(&#039;desiredCapabilities&#039;, desiredCapabilities),
      &#039;WebDriver.createSession()&#039;,
      opt_flow);
};


/**
 * Sends a command to the server that is expected to return the details for a
 * {@link webdriver.Session}. This may either be an existing session, or a
 * newly created one.
 * @param {!webdriver.CommandExecutor} executor Command executor to use when
 *     querying for session details.
 * @param {!webdriver.Command} command The command to send to fetch the session
 *     details.
 * @param {string} description A descriptive debug label for this action.
 * @param {webdriver.promise.ControlFlow=} opt_flow The control flow all driver
 *     commands should execute under. Defaults to the
 *     {@link webdriver.promise.controlFlow() currently active} control flow.
 * @return {!webdriver.WebDriver} A new WebDriver client for the session.
 * @private
 */
webdriver.WebDriver.acquireSession_ = function(
    executor, command, description, opt_flow) {
  var flow = opt_flow || webdriver.promise.controlFlow();
  var session = flow.execute(function() {
    return webdriver.WebDriver.executeCommand_(executor, command).
        then(function(response) {
          bot.response.checkResponse(response);
          return new webdriver.Session(response[&#039;sessionId&#039;],
              response[&#039;value&#039;]);
        });
  }, description);
  return new webdriver.WebDriver(session, executor, flow);
};


/**
 * Converts an object to its JSON representation in the WebDriver wire protocol.
 * When converting values of type object, the following steps will be taken:
 * &lt;ol&gt;
 * &lt;li&gt;if the object is a WebElement, the return value will be the element&#039;s
 *     server ID&lt;/li&gt;
 * &lt;li&gt;if the object provides a &quot;toJSON&quot; function, the return value of this
 *     function will be returned&lt;/li&gt;
 * &lt;li&gt;otherwise, the value of each key will be recursively converted according
 *     to the rules above.&lt;/li&gt;
 * &lt;/ol&gt;
 *
 * @param {*} obj The object to convert.
 * @return {!webdriver.promise.Promise.&lt;?&gt;} A promise that will resolve to the
 *     input value&#039;s JSON representation.
 * @private
 * @see http://code.google.com/p/selenium/wiki/JsonWireProtocol
 */
webdriver.WebDriver.toWireValue_ = function(obj) {
  if (webdriver.promise.isPromise(obj)) {
    return obj.then(webdriver.WebDriver.toWireValue_);
  }
  return webdriver.promise.fulfilled(convertValue(obj));

  function convertValue(value) {
    switch (goog.typeOf(value)) {
      case &#039;array&#039;:
        return convertKeys(value, true);
      case &#039;object&#039;:
        if (value instanceof webdriver.WebElement) {
          return value.getId();
        }
        if (goog.isFunction(value.toJSON)) {
          return value.toJSON();
        }
        if (goog.isNumber(value.nodeType) &amp;&amp; goog.isString(value.nodeName)) {
          throw new TypeError(
              &#039;Invalid argument type: &#039; + value.nodeName +
              &#039;(&#039; + value.nodeType + &#039;)&#039;);
        }
        return convertKeys(value, false);
      case &#039;function&#039;:
        return &#039;&#039; + value;
      case &#039;undefined&#039;:
        return null;
      default:
        return value;
    }
  }

  function convertKeys(obj, isArray) {
    var numKeys = isArray ? obj.length : goog.object.getCount(obj);
    var ret = isArray ? new Array(numKeys) : {};
    if (!numKeys) {
      return webdriver.promise.fulfilled(ret);
    }

    var numResolved = 0;
    var done = webdriver.promise.defer();

    // forEach will stop iteration at undefined, where we want to convert
    // these to null and keep iterating.
    var forEachKey = !isArray ? goog.object.forEach : function(arr, fn) {
      var n = arr.length;
      for (var i = 0; i &lt; n; i++) {
        fn(arr[i], i);
      }
    };

    forEachKey(obj, function(value, key) {
      if (webdriver.promise.isPromise(value)) {
        value.then(webdriver.WebDriver.toWireValue_).
            then(setValue, done.reject);
      } else {
        webdriver.promise.asap(convertValue(value), setValue, done.reject);
      }

      function setValue(value) {
        ret[key] = value;
        maybeFulfill();
      }
    });

    return done.promise;

    function maybeFulfill() {
      if (++numResolved === numKeys) {
        done.fulfill(ret);
      }
    }
  }
};


/**
 * Converts a value from its JSON representation according to the WebDriver wire
 * protocol. Any JSON object containing a
 * {@code webdriver.WebElement.ELEMENT_KEY} key will be decoded to a
 * {@code webdriver.WebElement} object. All other values will be passed through
 * as is.
 * @param {!webdriver.WebDriver} driver The driver instance to use as the
 *     parent of any unwrapped {@code webdriver.WebElement} values.
 * @param {*} value The value to convert.
 * @return {*} The converted value.
 * @see http://code.google.com/p/selenium/wiki/JsonWireProtocol
 * @private
 */
webdriver.WebDriver.fromWireValue_ = function(driver, value) {
  if (goog.isArray(value)) {
    value = goog.array.map(/**@type {goog.array.ArrayLike}*/ (value),
        goog.partial(webdriver.WebDriver.fromWireValue_, driver));
  } else if (value &amp;&amp; goog.isObject(value) &amp;&amp; !goog.isFunction(value)) {
    if (webdriver.WebElement.ELEMENT_KEY in value) {
      value = new webdriver.WebElement(driver, value);
    } else {
      value = goog.object.map(/**@type {!Object}*/ (value),
          goog.partial(webdriver.WebDriver.fromWireValue_, driver));
    }
  }
  return value;
};


/**
 * Translates a command to its wire-protocol representation before passing it
 * to the given {@code executor} for execution.
 * @param {!webdriver.CommandExecutor} executor The executor to use.
 * @param {!webdriver.Command} command The command to execute.
 * @return {!webdriver.promise.Promise} A promise that will resolve with the
 *     command response.
 * @private
 */
webdriver.WebDriver.executeCommand_ = function(executor, command) {
  return webdriver.WebDriver.toWireValue_(command.getParameters()).
      then(function(parameters) {
        command.setParameters(parameters);
        return webdriver.promise.checkedNodeCall(
            goog.bind(executor.execute, executor, command));
      });
};


/**
 * @return {!webdriver.promise.ControlFlow} The control flow used by this
 *     instance.
 */
webdriver.WebDriver.prototype.controlFlow = function() {
  return this.flow_;
};


/**
 * Schedules a {@code webdriver.Command} to be executed by this driver&#039;s
 * {@code webdriver.CommandExecutor}.
 * @param {!webdriver.Command} command The command to schedule.
 * @param {string} description A description of the command for debugging.
 * @return {!webdriver.promise.Promise.&lt;T&gt;} A promise that will be resolved
 *     with the command result.
 * @template T
 */
webdriver.WebDriver.prototype.schedule = function(command, description) {
  var self = this;

  checkHasNotQuit();
  command.setParameter(&#039;sessionId&#039;, this.session_);

  // If any of the command parameters are rejected promises, those
  // rejections may be reported as unhandled before the control flow
  // attempts to execute the command. To ensure parameters errors
  // propagate through the command itself, we resolve all of the
  // command parameters now, but suppress any errors until the ControlFlow
  // actually executes the command. This addresses scenarios like catching
  // an element not found error in:
  //
  //     driver.findElement(By.id(&#039;foo&#039;)).click().thenCatch(function(e) {
  //       if (e.code === bot.ErrorCode.NO_SUCH_ELEMENT) {
  //         // Do something.
  //       }
  //     });
  var prepCommand = webdriver.WebDriver.toWireValue_(command.getParameters());
  prepCommand.thenCatch(goog.nullFunction);

  var flow = this.flow_;
  var executor = this.executor_;
  return flow.execute(function() {
    // A call to WebDriver.quit() may have been scheduled in the same event
    // loop as this |command|, which would prevent us from detecting that the
    // driver has quit above.  Therefore, we need to make another quick check.
    // We still check above so we can fail as early as possible.
    checkHasNotQuit();

    // Retrieve resolved command parameters; any previously suppressed errors
    // will now propagate up through the control flow as part of the command
    // execution.
    return prepCommand.then(function(parameters) {
      command.setParameters(parameters);
      return webdriver.promise.checkedNodeCall(
          goog.bind(executor.execute, executor, command));
    });
  }, description).then(function(response) {
    try {
      bot.response.checkResponse(response);
    } catch (ex) {
      var value = response[&#039;value&#039;];
      if (ex.code === bot.ErrorCode.UNEXPECTED_ALERT_OPEN) {
        var text = value &amp;&amp; value[&#039;alert&#039;] ? value[&#039;alert&#039;][&#039;text&#039;] : &#039;&#039;;
        throw new webdriver.UnhandledAlertError(ex.message, text,
            new webdriver.Alert(self, text));
      }
      throw ex;
    }
    return webdriver.WebDriver.fromWireValue_(self, response[&#039;value&#039;]);
  });

  function checkHasNotQuit() {
    if (!self.session_) {
      throw new Error(&#039;This driver instance does not have a valid session ID &#039; +
                      &#039;(did you call WebDriver.quit()?) and may no longer be &#039; +
                      &#039;used.&#039;);
    }
  }
};


// ----------------------------------------------------------------------------
// Client command functions:
// ----------------------------------------------------------------------------


/**
 * @return {!webdriver.promise.Promise.&lt;!webdriver.Session&gt;} A promise for this
 *     client&#039;s session.
 */
webdriver.WebDriver.prototype.getSession = function() {
  return webdriver.promise.when(this.session_);
};


/**
 * @return {!webdriver.promise.Promise.&lt;!webdriver.Capabilities&gt;} A promise
 *     that will resolve with the this instance&#039;s capabilities.
 */
webdriver.WebDriver.prototype.getCapabilities = function() {
  return webdriver.promise.when(this.session_, function(session) {
    return session.getCapabilities();
  });
};


/**
 * Schedules a command to quit the current session. After calling quit, this
 * instance will be invalidated and may no longer be used to issue commands
 * against the browser.
 * @return {!webdriver.promise.Promise.&lt;void&gt;} A promise that will be resolved
 *     when the command has completed.
 */
webdriver.WebDriver.prototype.quit = function() {
  var result = this.schedule(
      new webdriver.Command(webdriver.CommandName.QUIT),
      &#039;WebDriver.quit()&#039;);
  // Delete our session ID when the quit command finishes; this will allow us to
  // throw an error when attemnpting to use a driver post-quit.
  return result.thenFinally(goog.bind(function() {
    delete this.session_;
  }, this));
};


/**
 * Creates a new action sequence using this driver. The sequence will not be
 * scheduled for execution until {@link webdriver.ActionSequence#perform} is
 * called. Example:
 * &lt;pre&gt;&lt;code&gt;
 *   driver.actions().
 *       mouseDown(element1).
 *       mouseMove(element2).
 *       mouseUp().
 *       perform();
 * &lt;/code&gt;&lt;/pre&gt;
 * @return {!webdriver.ActionSequence} A new action sequence for this instance.
 */
webdriver.WebDriver.prototype.actions = function() {
  return new webdriver.ActionSequence(this);
};


/**
 * Schedules a command to execute JavaScript in the context of the currently
 * selected frame or window. The script fragment will be executed as the body
 * of an anonymous function. If the script is provided as a function object,
 * that function will be converted to a string for injection into the target
 * window.
 *
 * Any arguments provided in addition to the script will be included as script
 * arguments and may be referenced using the {@code arguments} object.
 * Arguments may be a boolean, number, string, or {@code webdriver.WebElement}.
 * Arrays and objects may also be used as script arguments as long as each item
 * adheres to the types previously mentioned.
 *
 * The script may refer to any variables accessible from the current window.
 * Furthermore, the script will execute in the window&#039;s context, thus
 * {@code document} may be used to refer to the current document. Any local
 * variables will not be available once the script has finished executing,
 * though global variables will persist.
 *
 * If the script has a return value (i.e. if the script contains a return
 * statement), then the following steps will be taken for resolving this
 * functions return value:
 * &lt;ul&gt;
 * &lt;li&gt;For a HTML element, the value will resolve to a
 *     {@code webdriver.WebElement}&lt;/li&gt;
 * &lt;li&gt;Null and undefined return values will resolve to null&lt;/li&gt;
 * &lt;li&gt;Booleans, numbers, and strings will resolve as is&lt;/li&gt;
 * &lt;li&gt;Functions will resolve to their string representation&lt;/li&gt;
 * &lt;li&gt;For arrays and objects, each member item will be converted according to
 *     the rules above&lt;/li&gt;
 * &lt;/ul&gt;
 *
 * @param {!(string|Function)} script The script to execute.
 * @param {...*} var_args The arguments to pass to the script.
 * @return {!webdriver.promise.Promise.&lt;T&gt;} A promise that will resolve to the
 *    scripts return value.
 * @template T
 */
webdriver.WebDriver.prototype.executeScript = function(script, var_args) {
  if (goog.isFunction(script)) {
    script = &#039;return (&#039; + script + &#039;).apply(null, arguments);&#039;;
  }
  var args = arguments.length &gt; 1 ? goog.array.slice(arguments, 1) : [];
  return this.schedule(
      new webdriver.Command(webdriver.CommandName.EXECUTE_SCRIPT).
          setParameter(&#039;script&#039;, script).
          setParameter(&#039;args&#039;, args),
      &#039;WebDriver.executeScript()&#039;);
};


/**
 * Schedules a command to execute asynchronous JavaScript in the context of the
 * currently selected frame or window. The script fragment will be executed as
 * the body of an anonymous function. If the script is provided as a function
 * object, that function will be converted to a string for injection into the
 * target window.
 *
 * Any arguments provided in addition to the script will be included as script
 * arguments and may be referenced using the {@code arguments} object.
 * Arguments may be a boolean, number, string, or {@code webdriver.WebElement}.
 * Arrays and objects may also be used as script arguments as long as each item
 * adheres to the types previously mentioned.
 *
 * Unlike executing synchronous JavaScript with
 * {@code webdriver.WebDriver.prototype.executeScript}, scripts executed with
 * this function must explicitly signal they are finished by invoking the
 * provided callback. This callback will always be injected into the
 * executed function as the last argument, and thus may be referenced with
 * {@code arguments[arguments.length - 1]}. The following steps will be taken
 * for resolving this functions return value against the first argument to the
 * script&#039;s callback function:
 * &lt;ul&gt;
 * &lt;li&gt;For a HTML element, the value will resolve to a
 *     {@code webdriver.WebElement}&lt;/li&gt;
 * &lt;li&gt;Null and undefined return values will resolve to null&lt;/li&gt;
 * &lt;li&gt;Booleans, numbers, and strings will resolve as is&lt;/li&gt;
 * &lt;li&gt;Functions will resolve to their string representation&lt;/li&gt;
 * &lt;li&gt;For arrays and objects, each member item will be converted according to
 *     the rules above&lt;/li&gt;
 * &lt;/ul&gt;
 *
 * Example #1: Performing a sleep that is synchronized with the currently
 * selected window:
 * &lt;code&gt;&lt;pre&gt;
 * var start = new Date().getTime();
 * driver.executeAsyncScript(
 *     &#039;window.setTimeout(arguments[arguments.length - 1], 500);&#039;).
 *     then(function() {
 *       console.log(&#039;Elapsed time: &#039; + (new Date().getTime() - start) + &#039; ms&#039;);
 *     });
 * &lt;/pre&gt;&lt;/code&gt;
 *
 * Example #2: Synchronizing a test with an AJAX application:
 * &lt;code&gt;&lt;pre&gt;
 * var button = driver.findElement(By.id(&#039;compose-button&#039;));
 * button.click();
 * driver.executeAsyncScript(
 *     &#039;var callback = arguments[arguments.length - 1];&#039; +
 *     &#039;mailClient.getComposeWindowWidget().onload(callback);&#039;);
 * driver.switchTo().frame(&#039;composeWidget&#039;);
 * driver.findElement(By.id(&#039;to&#039;)).sendKeys(&#039;dog@example.com&#039;);
 * &lt;/pre&gt;&lt;/code&gt;
 *
 * Example #3: Injecting a XMLHttpRequest and waiting for the result. In this
 * example, the inject script is specified with a function literal. When using
 * this format, the function is converted to a string for injection, so it
 * should not reference any symbols not defined in the scope of the page under
 * test.
 * &lt;code&gt;&lt;pre&gt;
 * driver.executeAsyncScript(function() {
 *   var callback = arguments[arguments.length - 1];
 *   var xhr = new XMLHttpRequest();
 *   xhr.open(&quot;GET&quot;, &quot;/resource/data.json&quot;, true);
 *   xhr.onreadystatechange = function() {
 *     if (xhr.readyState == 4) {
 *       callback(xhr.responseText);
 *     }
 *   }
 *   xhr.send(&#039;&#039;);
 * }).then(function(str) {
 *   console.log(JSON.parse(str)[&#039;food&#039;]);
 * });
 * &lt;/pre&gt;&lt;/code&gt;
 *
 * @param {!(string|Function)} script The script to execute.
 * @param {...*} var_args The arguments to pass to the script.
 * @return {!webdriver.promise.Promise.&lt;T&gt;} A promise that will resolve to the
 *    scripts return value.
 * @template T
 */
webdriver.WebDriver.prototype.executeAsyncScript = function(script, var_args) {
  if (goog.isFunction(script)) {
    script = &#039;return (&#039; + script + &#039;).apply(null, arguments);&#039;;
  }
  return this.schedule(
      new webdriver.Command(webdriver.CommandName.EXECUTE_ASYNC_SCRIPT).
          setParameter(&#039;script&#039;, script).
          setParameter(&#039;args&#039;, goog.array.slice(arguments, 1)),
      &#039;WebDriver.executeScript()&#039;);
};


/**
 * Schedules a command to execute a custom function.
 * @param {function(...): (T|webdriver.promise.Promise.&lt;T&gt;)} fn The function to
 *     execute.
 * @param {Object=} opt_scope The object in whose scope to execute the function.
 * @param {...*} var_args Any arguments to pass to the function.
 * @return {!webdriver.promise.Promise.&lt;T&gt;} A promise that will be resolved&#039;
 *     with the function&#039;s result.
 * @template T
 */
webdriver.WebDriver.prototype.call = function(fn, opt_scope, var_args) {
  var args = goog.array.slice(arguments, 2);
  var flow = this.flow_;
  return flow.execute(function() {
    return webdriver.promise.fullyResolved(args).then(function(args) {
      if (webdriver.promise.isGenerator(fn)) {
        args.unshift(fn, opt_scope);
        return webdriver.promise.consume.apply(null, args);
      }
      return fn.apply(opt_scope, args);
    });
  }, &#039;WebDriver.call(&#039; + (fn.name || &#039;function&#039;) + &#039;)&#039;);
};


/**
 * Schedules a command to wait for a condition to hold, as defined by some
 * user supplied function. If any errors occur while evaluating the wait, they
 * will be allowed to propagate.
 *
 * &lt;p&gt;In the event a condition returns a {@link webdriver.promise.Promise}, the
 * polling loop will wait for it to be resolved and use the resolved value for
 * evaluating whether the condition has been satisfied. The resolution time for
 * a promise is factored into whether a wait has timed out.
 *
 * @param {!(webdriver.until.Condition.&lt;T&gt;|
 *           function(!webdriver.WebDriver): T)} condition Either a condition
 *     object, or a function to evaluate as a condition.
 * @param {number} timeout How long to wait for the condition to be true.
 * @param {string=} opt_message An optional message to use if the wait times
 *     out.
 * @return {!webdriver.promise.Promise.&lt;T&gt;} A promise that will be fulfilled
 *     with the first truthy value returned by the condition function, or
 *     rejected if the condition times out.
 * @template T
 */
webdriver.WebDriver.prototype.wait = function(
    condition, timeout, opt_message) {
  var message = opt_message;
  var fn = /** @type {!Function} */(condition);
  if (condition instanceof webdriver.until.Condition) {
    message = message || condition.description();
    fn = condition.fn;
  }

  var driver = this;
  return this.flow_.wait(function() {
    if (webdriver.promise.isGenerator(fn)) {
      return webdriver.promise.consume(fn, null, [driver]);
    }
    return fn(driver);
  }, timeout, message);
};


/**
 * Schedules a command to make the driver sleep for the given amount of time.
 * @param {number} ms The amount of time, in milliseconds, to sleep.
 * @return {!webdriver.promise.Promise.&lt;void&gt;} A promise that will be resolved
 *     when the sleep has finished.
 */
webdriver.WebDriver.prototype.sleep = function(ms) {
  return this.flow_.timeout(ms, &#039;WebDriver.sleep(&#039; + ms + &#039;)&#039;);
};


/**
 * Schedules a command to retrieve they current window handle.
 * @return {!webdriver.promise.Promise.&lt;string&gt;} A promise that will be
 *     resolved with the current window handle.
 */
webdriver.WebDriver.prototype.getWindowHandle = function() {
  return this.schedule(
      new webdriver.Command(webdriver.CommandName.GET_CURRENT_WINDOW_HANDLE),
      &#039;WebDriver.getWindowHandle()&#039;);
};


/**
 * Schedules a command to retrieve the current list of available window handles.
 * @return {!webdriver.promise.Promise.&lt;!Array.&lt;string&gt;&gt;} A promise that will
 *     be resolved with an array of window handles.
 */
webdriver.WebDriver.prototype.getAllWindowHandles = function() {
  return this.schedule(
      new webdriver.Command(webdriver.CommandName.GET_WINDOW_HANDLES),
      &#039;WebDriver.getAllWindowHandles()&#039;);
};


/**
 * Schedules a command to retrieve the current page&#039;s source. The page source
 * returned is a representation of the underlying DOM: do not expect it to be
 * formatted or escaped in the same way as the response sent from the web
 * server.
 * @return {!webdriver.promise.Promise.&lt;string&gt;} A promise that will be
 *     resolved with the current page source.
 */
webdriver.WebDriver.prototype.getPageSource = function() {
  return this.schedule(
      new webdriver.Command(webdriver.CommandName.GET_PAGE_SOURCE),
      &#039;WebDriver.getAllWindowHandles()&#039;);
};


/**
 * Schedules a command to close the current window.
 * @return {!webdriver.promise.Promise.&lt;void&gt;} A promise that will be resolved
 *     when this command has completed.
 */
webdriver.WebDriver.prototype.close = function() {
  return this.schedule(new webdriver.Command(webdriver.CommandName.CLOSE),
                       &#039;WebDriver.close()&#039;);
};


/**
 * Schedules a command to navigate to the given URL.
 * @param {string} url The fully qualified URL to open.
 * @return {!webdriver.promise.Promise.&lt;void&gt;} A promise that will be resolved
 *     when the document has finished loading.
 */
webdriver.WebDriver.prototype.get = function(url) {
  return this.navigate().to(url);
};


/**
 * Schedules a command to retrieve the URL of the current page.
 * @return {!webdriver.promise.Promise.&lt;string&gt;} A promise that will be
 *     resolved with the current URL.
 */
webdriver.WebDriver.prototype.getCurrentUrl = function() {
  return this.schedule(
      new webdriver.Command(webdriver.CommandName.GET_CURRENT_URL),
      &#039;WebDriver.getCurrentUrl()&#039;);
};


/**
 * Schedules a command to retrieve the current page&#039;s title.
 * @return {!webdriver.promise.Promise.&lt;string&gt;} A promise that will be
 *     resolved with the current page&#039;s title.
 */
webdriver.WebDriver.prototype.getTitle = function() {
  return this.schedule(new webdriver.Command(webdriver.CommandName.GET_TITLE),
                       &#039;WebDriver.getTitle()&#039;);
};


/**
 * Schedule a command to find an element on the page. If the element cannot be
 * found, a {@link bot.ErrorCode.NO_SUCH_ELEMENT} result will be returned
 * by the driver. Unlike other commands, this error cannot be suppressed. In
 * other words, scheduling a command to find an element doubles as an assert
 * that the element is present on the page. To test whether an element is
 * present on the page, use {@link #isElementPresent} instead.
 *
 * &lt;p&gt;The search criteria for an element may be defined using one of the
 * factories in the {@link webdriver.By} namespace, or as a short-hand
 * {@link webdriver.By.Hash} object. For example, the following two statements
 * are equivalent:
 * &lt;code&gt;&lt;pre&gt;
 * var e1 = driver.findElement(By.id(&#039;foo&#039;));
 * var e2 = driver.findElement({id:&#039;foo&#039;});
 * &lt;/pre&gt;&lt;/code&gt;
 *
 * &lt;p&gt;You may also provide a custom locator function, which takes as input
 * this WebDriver instance and returns a {@link webdriver.WebElement}, or a
 * promise that will resolve to a WebElement. For example, to find the first
 * visible link on a page, you could write:
 * &lt;code&gt;&lt;pre&gt;
 * var link = driver.findElement(firstVisibleLink);
 *
 * function firstVisibleLink(driver) {
 *   var links = driver.findElements(By.tagName(&#039;a&#039;));
 *   return webdriver.promise.filter(links, function(link) {
 *     return links.isDisplayed();
 *   }).then(function(visibleLinks) {
 *     return visibleLinks[0];
 *   });
 * }
 * &lt;/pre&gt;&lt;/code&gt;
 *
 * &lt;p&gt;When running in the browser, a WebDriver cannot manipulate DOM elements
 * directly; it may do so only through a {@link webdriver.WebElement} reference.
 * This function may be used to generate a WebElement from a DOM element. A
 * reference to the DOM element will be stored in a known location and this
 * driver will attempt to retrieve it through {@link #executeScript}. If the
 * element cannot be found (eg, it belongs to a different document than the
 * one this instance is currently focused on), a
 * {@link bot.ErrorCode.NO_SUCH_ELEMENT} error will be returned.
 *
 * @param {!(webdriver.Locator|webdriver.By.Hash|Element|Function)} locator The
 *     locator to use.
 * @return {!webdriver.WebElement} A WebElement that can be used to issue
 *     commands against the located element. If the element is not found, the
 *     element will be invalidated and all scheduled commands aborted.
 */
webdriver.WebDriver.prototype.findElement = function(locator) {
  var id;
  if (&#039;nodeType&#039; in locator &amp;&amp; &#039;ownerDocument&#039; in locator) {
    var element = /** @type {!Element} */ (locator);
    id = this.findDomElement_(element).then(function(element) {
      if (!element) {
        throw new bot.Error(bot.ErrorCode.NO_SUCH_ELEMENT,
            &#039;Unable to locate element. Is WebDriver focused on its &#039; +
                &#039;ownerDocument\&#039;s frame?&#039;);
      }
      return element;
    });
  } else {
    locator = webdriver.Locator.checkLocator(locator);
    if (goog.isFunction(locator)) {
      id = this.findElementInternal_(locator, this);
    } else {
      var command = new webdriver.Command(webdriver.CommandName.FIND_ELEMENT).
          setParameter(&#039;using&#039;, locator.using).
          setParameter(&#039;value&#039;, locator.value);
      id = this.schedule(command, &#039;WebDriver.findElement(&#039; + locator + &#039;)&#039;);
    }
  }
  return new webdriver.WebElementPromise(this, id);
};


/**
 * @param {!Function} locatorFn The locator function to use.
 * @param {!(webdriver.WebDriver|webdriver.WebElement)} context The search
 *     context.
 * @return {!webdriver.promise.Promise.&lt;!webdriver.WebElement&gt;} A
 *     promise that will resolve to a list of WebElements.
 * @private
 */
webdriver.WebDriver.prototype.findElementInternal_ = function(
    locatorFn, context) {
  return this.call(goog.partial(locatorFn, context)).then(function(result) {
    if (goog.isArray(result)) {
      result = result[0];
    }
    if (!(result instanceof webdriver.WebElement)) {
      throw new TypeError(&#039;Custom locator did not return a WebElement&#039;);
    }
    return result;
  });
};


/**
 * Locates a DOM element so that commands may be issued against it using the
 * {@link webdriver.WebElement} class. This is accomplished by storing a
 * reference to the element in an object on the element&#039;s ownerDocument.
 * {@link #executeScript} will then be used to create a WebElement from this
 * reference. This requires this driver to currently be focused on the
 * ownerDocument&#039;s window+frame.

 * @param {!Element} element The element to locate.
 * @return {!webdriver.promise.Promise.&lt;webdriver.WebElement&gt;} A promise that
 *     will be fulfilled with the located element, or null if the element
 *     could not be found.
 * @private
 */
webdriver.WebDriver.prototype.findDomElement_ = function(element) {
  var doc = element.ownerDocument;
  var store = doc[&#039;$webdriver$&#039;] = doc[&#039;$webdriver$&#039;] || {};
  var id = Math.floor(Math.random() * goog.now()).toString(36);
  store[id] = element;
  element[id] = id;

  function cleanUp() {
    delete store[id];
  }

  function lookupElement(id) {
    var store = document[&#039;$webdriver$&#039;];
    if (!store) {
      return null;
    }

    var element = store[id];
    if (!element || element[id] !== id) {
      return null;
    }
    return element;
  }

  /** @type {!webdriver.promise.Promise.&lt;webdriver.WebElement&gt;} */
  var foundElement = this.executeScript(lookupElement, id);
  foundElement.thenFinally(cleanUp);
  return foundElement;
};


/**
 * Schedules a command to test if an element is present on the page.
 *
 * &lt;p&gt;If given a DOM element, this function will check if it belongs to the
 * document the driver is currently focused on. Otherwise, the function will
 * test if at least one element can be found with the given search criteria.
 *
 * @param {!(webdriver.Locator|webdriver.By.Hash|Element|
 *           Function)} locatorOrElement The locator to use, or the actual
 *     DOM element to be located by the server.
 * @return {!webdriver.promise.Promise.&lt;boolean&gt;} A promise that will resolve
 *     with whether the element is present on the page.
 */
webdriver.WebDriver.prototype.isElementPresent = function(locatorOrElement) {
  if (&#039;nodeType&#039; in locatorOrElement &amp;&amp; &#039;ownerDocument&#039; in locatorOrElement) {
    return this.findDomElement_(/** @type {!Element} */ (locatorOrElement)).
        then(function(result) { return !!result; });
  } else {
    return this.findElements.apply(this, arguments).then(function(result) {
      return !!result.length;
    });
  }
};


/**
 * Schedule a command to search for multiple elements on the page.
 *
 * @param {!(webdriver.Locator|webdriver.By.Hash|Function)} locator The locator
 *     strategy to use when searching for the element.
 * @return {!webdriver.promise.Promise.&lt;!Array.&lt;!webdriver.WebElement&gt;&gt;} A
 *     promise that will resolve to an array of WebElements.
 */
webdriver.WebDriver.prototype.findElements = function(locator) {
  locator = webdriver.Locator.checkLocator(locator);
  if (goog.isFunction(locator)) {
    return this.findElementsInternal_(locator, this);
  } else {
    var command = new webdriver.Command(webdriver.CommandName.FIND_ELEMENTS).
        setParameter(&#039;using&#039;, locator.using).
        setParameter(&#039;value&#039;, locator.value);
    return this.schedule(command, &#039;WebDriver.findElements(&#039; + locator + &#039;)&#039;);
  }
};


/**
 * @param {!Function} locatorFn The locator function to use.
 * @param {!(webdriver.WebDriver|webdriver.WebElement)} context The search
 *     context.
 * @return {!webdriver.promise.Promise.&lt;!Array.&lt;!webdriver.WebElement&gt;&gt;} A
 *     promise that will resolve to an array of WebElements.
 * @private
 */
webdriver.WebDriver.prototype.findElementsInternal_ = function(
    locatorFn, context) {
  return this.call(goog.partial(locatorFn, context)).then(function(result) {
    if (result instanceof webdriver.WebElement) {
      return [result];
    }

    if (!goog.isArray(result)) {
      return [];
    }

    return goog.array.filter(result, function(item) {
      return item instanceof webdriver.WebElement;
    });
  });
};


/**
 * Schedule a command to take a screenshot. The driver makes a best effort to
 * return a screenshot of the following, in order of preference:
 * &lt;ol&gt;
 *   &lt;li&gt;Entire page
 *   &lt;li&gt;Current window
 *   &lt;li&gt;Visible portion of the current frame
 *   &lt;li&gt;The screenshot of the entire display containing the browser
 * &lt;/ol&gt;
 *
 * @return {!webdriver.promise.Promise.&lt;string&gt;} A promise that will be
 *     resolved to the screenshot as a base-64 encoded PNG.
 */
webdriver.WebDriver.prototype.takeScreenshot = function() {
  return this.schedule(new webdriver.Command(webdriver.CommandName.SCREENSHOT),
      &#039;WebDriver.takeScreenshot()&#039;);
};


/**
 * @return {!webdriver.WebDriver.Options} The options interface for this
 *     instance.
 */
webdriver.WebDriver.prototype.manage = function() {
  return new webdriver.WebDriver.Options(this);
};


/**
 * @return {!webdriver.WebDriver.Navigation} The navigation interface for this
 *     instance.
 */
webdriver.WebDriver.prototype.navigate = function() {
  return new webdriver.WebDriver.Navigation(this);
};


/**
 * @return {!webdriver.WebDriver.TargetLocator} The target locator interface for
 *     this instance.
 */
webdriver.WebDriver.prototype.switchTo = function() {
  return new webdriver.WebDriver.TargetLocator(this);
};



/**
 * Interface for navigating back and forth in the browser history.
 * @param {!webdriver.WebDriver} driver The parent driver.
 * @constructor
 */
webdriver.WebDriver.Navigation = function(driver) {

  /** @private {!webdriver.WebDriver} */
  this.driver_ = driver;
};


/**
 * Schedules a command to navigate to a new URL.
 * @param {string} url The URL to navigate to.
 * @return {!webdriver.promise.Promise.&lt;void&gt;} A promise that will be resolved
 *     when the URL has been loaded.
 */
webdriver.WebDriver.Navigation.prototype.to = function(url) {
  return this.driver_.schedule(
      new webdriver.Command(webdriver.CommandName.GET).
          setParameter(&#039;url&#039;, url),
      &#039;WebDriver.navigate().to(&#039; + url + &#039;)&#039;);
};


/**
 * Schedules a command to move backwards in the browser history.
 * @return {!webdriver.promise.Promise.&lt;void&gt;} A promise that will be resolved
 *     when the navigation event has completed.
 */
webdriver.WebDriver.Navigation.prototype.back = function() {
  return this.driver_.schedule(
      new webdriver.Command(webdriver.CommandName.GO_BACK),
      &#039;WebDriver.navigate().back()&#039;);
};


/**
 * Schedules a command to move forwards in the browser history.
 * @return {!webdriver.promise.Promise.&lt;void&gt;} A promise that will be resolved
 *     when the navigation event has completed.
 */
webdriver.WebDriver.Navigation.prototype.forward = function() {
  return this.driver_.schedule(
      new webdriver.Command(webdriver.CommandName.GO_FORWARD),
      &#039;WebDriver.navigate().forward()&#039;);
};


/**
 * Schedules a command to refresh the current page.
 * @return {!webdriver.promise.Promise.&lt;void&gt;} A promise that will be resolved
 *     when the navigation event has completed.
 */
webdriver.WebDriver.Navigation.prototype.refresh = function() {
  return this.driver_.schedule(
      new webdriver.Command(webdriver.CommandName.REFRESH),
      &#039;WebDriver.navigate().refresh()&#039;);
};



/**
 * Provides methods for managing browser and driver state.
 * @param {!webdriver.WebDriver} driver The parent driver.
 * @constructor
 */
webdriver.WebDriver.Options = function(driver) {

  /** @private {!webdriver.WebDriver} */
  this.driver_ = driver;
};


/**
 * A JSON description of a browser cookie.
 * @typedef {{
 *     name: string,
 *     value: string,
 *     path: (string|undefined),
 *     domain: (string|undefined),
 *     secure: (boolean|undefined),
 *     expiry: (number|undefined)
 * }}
 * @see http://code.google.com/p/selenium/wiki/JsonWireProtocol#Cookie_JSON_Object
 */
webdriver.WebDriver.Options.Cookie;


/**
 * Schedules a command to add a cookie.
 * @param {string} name The cookie name.
 * @param {string} value The cookie value.
 * @param {string=} opt_path The cookie path.
 * @param {string=} opt_domain The cookie domain.
 * @param {boolean=} opt_isSecure Whether the cookie is secure.
 * @param {(number|!Date)=} opt_expiry When the cookie expires. If specified as
 *     a number, should be in milliseconds since midnight, January 1, 1970 UTC.
 * @return {!webdriver.promise.Promise.&lt;void&gt;} A promise that will be resolved
 *     when the cookie has been added to the page.
 */
webdriver.WebDriver.Options.prototype.addCookie = function(
    name, value, opt_path, opt_domain, opt_isSecure, opt_expiry) {
  // We do not allow &#039;=&#039; or &#039;;&#039; in the name.
  if (/[;=]/.test(name)) {
    throw Error(&#039;Invalid cookie name &quot;&#039; + name + &#039;&quot;&#039;);
  }

  // We do not allow &#039;;&#039; in value.
  if (/;/.test(value)) {
    throw Error(&#039;Invalid cookie value &quot;&#039; + value + &#039;&quot;&#039;);
  }

  var cookieString = name + &#039;=&#039; + value +
      (opt_domain ? &#039;;domain=&#039; + opt_domain : &#039;&#039;) +
      (opt_path ? &#039;;path=&#039; + opt_path : &#039;&#039;) +
      (opt_isSecure ? &#039;;secure&#039; : &#039;&#039;);

  var expiry;
  if (goog.isDef(opt_expiry)) {
    var expiryDate;
    if (goog.isNumber(opt_expiry)) {
      expiryDate = new Date(opt_expiry);
    } else {
      expiryDate = /** @type {!Date} */ (opt_expiry);
      opt_expiry = expiryDate.getTime();
    }
    cookieString += &#039;;expires=&#039; + expiryDate.toUTCString();
    // Convert from milliseconds to seconds.
    expiry = Math.floor(/** @type {number} */ (opt_expiry) / 1000);
  }

  return this.driver_.schedule(
      new webdriver.Command(webdriver.CommandName.ADD_COOKIE).
          setParameter(&#039;cookie&#039;, {
            &#039;name&#039;: name,
            &#039;value&#039;: value,
            &#039;path&#039;: opt_path,
            &#039;domain&#039;: opt_domain,
            &#039;secure&#039;: !!opt_isSecure,
            &#039;expiry&#039;: expiry
          }),
      &#039;WebDriver.manage().addCookie(&#039; + cookieString + &#039;)&#039;);
};


/**
 * Schedules a command to delete all cookies visible to the current page.
 * @return {!webdriver.promise.Promise.&lt;void&gt;} A promise that will be resolved
 *     when all cookies have been deleted.
 */
webdriver.WebDriver.Options.prototype.deleteAllCookies = function() {
  return this.driver_.schedule(
      new webdriver.Command(webdriver.CommandName.DELETE_ALL_COOKIES),
      &#039;WebDriver.manage().deleteAllCookies()&#039;);
};


/**
 * Schedules a command to delete the cookie with the given name. This command is
 * a no-op if there is no cookie with the given name visible to the current
 * page.
 * @param {string} name The name of the cookie to delete.
 * @return {!webdriver.promise.Promise.&lt;void&gt;} A promise that will be resolved
 *     when the cookie has been deleted.
 */
webdriver.WebDriver.Options.prototype.deleteCookie = function(name) {
  return this.driver_.schedule(
      new webdriver.Command(webdriver.CommandName.DELETE_COOKIE).
          setParameter(&#039;name&#039;, name),
      &#039;WebDriver.manage().deleteCookie(&#039; + name + &#039;)&#039;);
};


/**
 * Schedules a command to retrieve all cookies visible to the current page.
 * Each cookie will be returned as a JSON object as described by the WebDriver
 * wire protocol.
 * @return {!webdriver.promise.Promise.&lt;
 *     !Array.&lt;webdriver.WebDriver.Options.Cookie&gt;&gt;} A promise that will be
 *     resolved with the cookies visible to the current page.
 * @see http://code.google.com/p/selenium/wiki/JsonWireProtocol#Cookie_JSON_Object
 */
webdriver.WebDriver.Options.prototype.getCookies = function() {
  return this.driver_.schedule(
      new webdriver.Command(webdriver.CommandName.GET_ALL_COOKIES),
      &#039;WebDriver.manage().getCookies()&#039;);
};


/**
 * Schedules a command to retrieve the cookie with the given name. Returns null
 * if there is no such cookie. The cookie will be returned as a JSON object as
 * described by the WebDriver wire protocol.
 * @param {string} name The name of the cookie to retrieve.
 * @return {!webdriver.promise.Promise.&lt;?webdriver.WebDriver.Options.Cookie&gt;} A
 *     promise that will be resolved with the named cookie, or {@code null}
 *     if there is no such cookie.
 * @see http://code.google.com/p/selenium/wiki/JsonWireProtocol#Cookie_JSON_Object
 */
webdriver.WebDriver.Options.prototype.getCookie = function(name) {
  return this.getCookies().then(function(cookies) {
    return goog.array.find(cookies, function(cookie) {
      return cookie &amp;&amp; cookie[&#039;name&#039;] == name;
    });
  });
};


/**
 * @return {!webdriver.WebDriver.Logs} The interface for managing driver
 *     logs.
 */
webdriver.WebDriver.Options.prototype.logs = function() {
  return new webdriver.WebDriver.Logs(this.driver_);
};


/**
 * @return {!webdriver.WebDriver.Timeouts} The interface for managing driver
 *     timeouts.
 */
webdriver.WebDriver.Options.prototype.timeouts = function() {
  return new webdriver.WebDriver.Timeouts(this.driver_);
};


/**
 * @return {!webdriver.WebDriver.Window} The interface for managing the
 *     current window.
 */
webdriver.WebDriver.Options.prototype.window = function() {
  return new webdriver.WebDriver.Window(this.driver_);
};



/**
 * An interface for managing timeout behavior for WebDriver instances.
 * @param {!webdriver.WebDriver} driver The parent driver.
 * @constructor
 */
webdriver.WebDriver.Timeouts = function(driver) {

  /** @private {!webdriver.WebDriver} */
  this.driver_ = driver;
};


/**
 * Specifies the amount of time the driver should wait when searching for an
 * element if it is not immediately present.
 * &lt;p/&gt;
 * When searching for a single element, the driver should poll the page
 * until the element has been found, or this timeout expires before failing
 * with a {@code bot.ErrorCode.NO_SUCH_ELEMENT} error. When searching
 * for multiple elements, the driver should poll the page until at least one
 * element has been found or this timeout has expired.
 * &lt;p/&gt;
 * Setting the wait timeout to 0 (its default value), disables implicit
 * waiting.
 * &lt;p/&gt;
 * Increasing the implicit wait timeout should be used judiciously as it
 * will have an adverse effect on test run time, especially when used with
 * slower location strategies like XPath.
 *
 * @param {number} ms The amount of time to wait, in milliseconds.
 * @return {!webdriver.promise.Promise.&lt;void&gt;} A promise that will be resolved
 *     when the implicit wait timeout has been set.
 */
webdriver.WebDriver.Timeouts.prototype.implicitlyWait = function(ms) {
  return this.driver_.schedule(
      new webdriver.Command(webdriver.CommandName.IMPLICITLY_WAIT).
          setParameter(&#039;ms&#039;, ms &lt; 0 ? 0 : ms),
      &#039;WebDriver.manage().timeouts().implicitlyWait(&#039; + ms + &#039;)&#039;);
};


/**
 * Sets the amount of time to wait, in milliseconds, for an asynchronous script
 * to finish execution before returning an error. If the timeout is less than or
 * equal to 0, the script will be allowed to run indefinitely.
 *
 * @param {number} ms The amount of time to wait, in milliseconds.
 * @return {!webdriver.promise.Promise.&lt;void&gt;} A promise that will be resolved
 *     when the script timeout has been set.
 */
webdriver.WebDriver.Timeouts.prototype.setScriptTimeout = function(ms) {
  return this.driver_.schedule(
      new webdriver.Command(webdriver.CommandName.SET_SCRIPT_TIMEOUT).
          setParameter(&#039;ms&#039;, ms &lt; 0 ? 0 : ms),
      &#039;WebDriver.manage().timeouts().setScriptTimeout(&#039; + ms + &#039;)&#039;);
};


/**
 * Sets the amount of time to wait for a page load to complete before returning
 * an error.  If the timeout is negative, page loads may be indefinite.
 * @param {number} ms The amount of time to wait, in milliseconds.
 * @return {!webdriver.promise.Promise.&lt;void&gt;} A promise that will be resolved
 *     when the timeout has been set.
 */
webdriver.WebDriver.Timeouts.prototype.pageLoadTimeout = function(ms) {
  return this.driver_.schedule(
      new webdriver.Command(webdriver.CommandName.SET_TIMEOUT).
          setParameter(&#039;type&#039;, &#039;page load&#039;).
          setParameter(&#039;ms&#039;, ms),
      &#039;WebDriver.manage().timeouts().pageLoadTimeout(&#039; + ms + &#039;)&#039;);
};



/**
 * An interface for managing the current window.
 * @param {!webdriver.WebDriver} driver The parent driver.
 * @constructor
 */
webdriver.WebDriver.Window = function(driver) {

  /** @private {!webdriver.WebDriver} */
  this.driver_ = driver;
};


/**
 * Retrieves the window&#039;s current position, relative to the top left corner of
 * the screen.
 * @return {!webdriver.promise.Promise.&lt;{x: number, y: number}&gt;} A promise that
 *     will be resolved with the window&#039;s position in the form of a
 *     {x:number, y:number} object literal.
 */
webdriver.WebDriver.Window.prototype.getPosition = function() {
  return this.driver_.schedule(
      new webdriver.Command(webdriver.CommandName.GET_WINDOW_POSITION).
          setParameter(&#039;windowHandle&#039;, &#039;current&#039;),
      &#039;WebDriver.manage().window().getPosition()&#039;);
};


/**
 * Repositions the current window.
 * @param {number} x The desired horizontal position, relative to the left side
 *     of the screen.
 * @param {number} y The desired vertical position, relative to the top of the
 *     of the screen.
 * @return {!webdriver.promise.Promise.&lt;void&gt;} A promise that will be resolved
 *     when the command has completed.
 */
webdriver.WebDriver.Window.prototype.setPosition = function(x, y) {
  return this.driver_.schedule(
      new webdriver.Command(webdriver.CommandName.SET_WINDOW_POSITION).
          setParameter(&#039;windowHandle&#039;, &#039;current&#039;).
          setParameter(&#039;x&#039;, x).
          setParameter(&#039;y&#039;, y),
      &#039;WebDriver.manage().window().setPosition(&#039; + x + &#039;, &#039; + y + &#039;)&#039;);
};


/**
 * Retrieves the window&#039;s current size.
 * @return {!webdriver.promise.Promise.&lt;{width: number, height: number}&gt;} A
 *     promise that will be resolved with the window&#039;s size in the form of a
 *     {width:number, height:number} object literal.
 */
webdriver.WebDriver.Window.prototype.getSize = function() {
  return this.driver_.schedule(
      new webdriver.Command(webdriver.CommandName.GET_WINDOW_SIZE).
          setParameter(&#039;windowHandle&#039;, &#039;current&#039;),
      &#039;WebDriver.manage().window().getSize()&#039;);
};


/**
 * Resizes the current window.
 * @param {number} width The desired window width.
 * @param {number} height The desired window height.
 * @return {!webdriver.promise.Promise.&lt;void&gt;} A promise that will be resolved
 *     when the command has completed.
 */
webdriver.WebDriver.Window.prototype.setSize = function(width, height) {
  return this.driver_.schedule(
      new webdriver.Command(webdriver.CommandName.SET_WINDOW_SIZE).
          setParameter(&#039;windowHandle&#039;, &#039;current&#039;).
          setParameter(&#039;width&#039;, width).
          setParameter(&#039;height&#039;, height),
      &#039;WebDriver.manage().window().setSize(&#039; + width + &#039;, &#039; + height + &#039;)&#039;);
};


/**
 * Maximizes the current window.
 * @return {!webdriver.promise.Promise.&lt;void&gt;} A promise that will be resolved
 *     when the command has completed.
 */
webdriver.WebDriver.Window.prototype.maximize = function() {
  return this.driver_.schedule(
      new webdriver.Command(webdriver.CommandName.MAXIMIZE_WINDOW).
          setParameter(&#039;windowHandle&#039;, &#039;current&#039;),
      &#039;WebDriver.manage().window().maximize()&#039;);
};


/**
 * Interface for managing WebDriver log records.
 * @param {!webdriver.WebDriver} driver The parent driver.
 * @constructor
 */
webdriver.WebDriver.Logs = function(driver) {

  /** @private {!webdriver.WebDriver} */
  this.driver_ = driver;
};


/**
 * Fetches available log entries for the given type.
 *
 * &lt;p/&gt;Note that log buffers are reset after each call, meaning that
 * available log entries correspond to those entries not yet returned for a
 * given log type. In practice, this means that this call will return the
 * available log entries since the last call, or from the start of the
 * session.
 *
 * @param {!webdriver.logging.Type} type The desired log type.
 * @return {!webdriver.promise.Promise.&lt;!Array.&lt;!webdriver.logging.Entry&gt;&gt;} A
 *   promise that will resolve to a list of log entries for the specified
 *   type.
 */
webdriver.WebDriver.Logs.prototype.get = function(type) {
  return this.driver_.schedule(
      new webdriver.Command(webdriver.CommandName.GET_LOG).
          setParameter(&#039;type&#039;, type),
      &#039;WebDriver.manage().logs().get(&#039; + type + &#039;)&#039;).
      then(function(entries) {
        return goog.array.map(entries, function(entry) {
          if (!(entry instanceof webdriver.logging.Entry)) {
            return new webdriver.logging.Entry(
                entry[&#039;level&#039;], entry[&#039;message&#039;], entry[&#039;timestamp&#039;],
                entry[&#039;type&#039;]);
          }
          return entry;
        });
      });
};


/**
 * Retrieves the log types available to this driver.
 * @return {!webdriver.promise.Promise.&lt;!Array.&lt;!webdriver.logging.Type&gt;&gt;} A
 *     promise that will resolve to a list of available log types.
 */
webdriver.WebDriver.Logs.prototype.getAvailableLogTypes = function() {
  return this.driver_.schedule(
      new webdriver.Command(webdriver.CommandName.GET_AVAILABLE_LOG_TYPES),
      &#039;WebDriver.manage().logs().getAvailableLogTypes()&#039;);
};



/**
 * An interface for changing the focus of the driver to another frame or window.
 * @param {!webdriver.WebDriver} driver The parent driver.
 * @constructor
 */
webdriver.WebDriver.TargetLocator = function(driver) {

  /** @private {!webdriver.WebDriver} */
  this.driver_ = driver;
};


/**
 * Schedules a command retrieve the {@code document.activeElement} element on
 * the current document, or {@code document.body} if activeElement is not
 * available.
 * @return {!webdriver.WebElementPromise} The active element.
 */
webdriver.WebDriver.TargetLocator.prototype.activeElement = function() {
  var id = this.driver_.schedule(
      new webdriver.Command(webdriver.CommandName.GET_ACTIVE_ELEMENT),
      &#039;WebDriver.switchTo().activeElement()&#039;);
  return new webdriver.WebElementPromise(this.driver_, id);
};


/**
 * Schedules a command to switch focus of all future commands to the first frame
 * on the page.
 * @return {!webdriver.promise.Promise.&lt;void&gt;} A promise that will be resolved
 *     when the driver has changed focus to the default content.
 */
webdriver.WebDriver.TargetLocator.prototype.defaultContent = function() {
  return this.driver_.schedule(
      new webdriver.Command(webdriver.CommandName.SWITCH_TO_FRAME).
          setParameter(&#039;id&#039;, null),
      &#039;WebDriver.switchTo().defaultContent()&#039;);
};


/**
 * Schedules a command to switch the focus of all future commands to another
 * frame on the page.
 * &lt;p/&gt;
 * If the frame is specified by a number, the command will switch to the frame
 * by its (zero-based) index into the {@code window.frames} collection.
 * &lt;p/&gt;
 * If the frame is specified by a string, the command will select the frame by
 * its name or ID. To select sub-frames, simply separate the frame names/IDs by
 * dots. As an example, &quot;main.child&quot; will select the frame with the name &quot;main&quot;
 * and then its child &quot;child&quot;.
 * &lt;p/&gt;
 * If the specified frame can not be found, the deferred result will errback
 * with a {@code bot.ErrorCode.NO_SUCH_FRAME} error.
 * @param {string|number} nameOrIndex The frame locator.
 * @return {!webdriver.promise.Promise.&lt;void&gt;} A promise that will be resolved
 *     when the driver has changed focus to the specified frame.
 */
webdriver.WebDriver.TargetLocator.prototype.frame = function(nameOrIndex) {
  return this.driver_.schedule(
      new webdriver.Command(webdriver.CommandName.SWITCH_TO_FRAME).
          setParameter(&#039;id&#039;, nameOrIndex),
      &#039;WebDriver.switchTo().frame(&#039; + nameOrIndex + &#039;)&#039;);
};


/**
 * Schedules a command to switch the focus of all future commands to another
 * window. Windows may be specified by their {@code window.name} attribute or
 * by its handle (as returned by {@code webdriver.WebDriver#getWindowHandles}).
 * &lt;p/&gt;
 * If the specificed window can not be found, the deferred result will errback
 * with a {@code bot.ErrorCode.NO_SUCH_WINDOW} error.
 * @param {string} nameOrHandle The name or window handle of the window to
 *     switch focus to.
 * @return {!webdriver.promise.Promise.&lt;void&gt;} A promise that will be resolved
 *     when the driver has changed focus to the specified window.
 */
webdriver.WebDriver.TargetLocator.prototype.window = function(nameOrHandle) {
  return this.driver_.schedule(
      new webdriver.Command(webdriver.CommandName.SWITCH_TO_WINDOW).
          setParameter(&#039;name&#039;, nameOrHandle),
      &#039;WebDriver.switchTo().window(&#039; + nameOrHandle + &#039;)&#039;);
};


/**
 * Schedules a command to change focus to the active alert dialog. This command
 * will return a {@link bot.ErrorCode.NO_SUCH_ALERT} error if an alert dialog
 * is not currently open.
 * @return {!webdriver.AlertPromise} The open alert.
 */
webdriver.WebDriver.TargetLocator.prototype.alert = function() {
  var text = this.driver_.schedule(
      new webdriver.Command(webdriver.CommandName.GET_ALERT_TEXT),
      &#039;WebDriver.switchTo().alert()&#039;);
  var driver = this.driver_;
  return new webdriver.AlertPromise(driver, text.then(function(text) {
    return new webdriver.Alert(driver, text);
  }));
};


/**
 * Simulate pressing many keys at once in a &quot;chord&quot;. Takes a sequence of
 * {@link webdriver.Key}s or strings, appends each of the values to a string,
 * and adds the chord termination key ({@link webdriver.Key.NULL}) and returns
 * the resultant string.
 *
 * Note: when the low-level webdriver key handlers see Keys.NULL, active
 * modifier keys (CTRL/ALT/SHIFT/etc) release via a keyup event.
 *
 * @param {...string} var_args The key sequence to concatenate.
 * @return {string} The null-terminated key sequence.
 * @see http://code.google.com/p/webdriver/issues/detail?id=79
 */
webdriver.Key.chord = function(var_args) {
  var sequence = goog.array.reduce(
      goog.array.slice(arguments, 0),
      function(str, key) {
        return str + key;
      }, &#039;&#039;);
  sequence += webdriver.Key.NULL;
  return sequence;
};


//////////////////////////////////////////////////////////////////////////////
//
//  webdriver.WebElement
//
//////////////////////////////////////////////////////////////////////////////



/**
 * Represents a DOM element. WebElements can be found by searching from the
 * document root using a {@code webdriver.WebDriver} instance, or by searching
 * under another {@code webdriver.WebElement}:
 * &lt;pre&gt;&lt;code&gt;
 *   driver.get(&#039;http://www.google.com&#039;);
 *   var searchForm = driver.findElement(By.tagName(&#039;form&#039;));
 *   var searchBox = searchForm.findElement(By.name(&#039;q&#039;));
 *   searchBox.sendKeys(&#039;webdriver&#039;);
 * &lt;/code&gt;&lt;/pre&gt;
 *
 * The WebElement is implemented as a promise for compatibility with the promise
 * API. It will always resolve itself when its internal state has been fully
 * resolved and commands may be issued against the element. This can be used to
 * catch errors when an element cannot be located on the page:
 * &lt;pre&gt;&lt;code&gt;
 *   driver.findElement(By.id(&#039;not-there&#039;)).then(function(element) {
 *     alert(&#039;Found an element that was not expected to be there!&#039;);
 *   }, function(error) {
 *     alert(&#039;The element was not found, as expected&#039;);
 *   });
 * &lt;/code&gt;&lt;/pre&gt;
 *
 * @param {!webdriver.WebDriver} driver The parent WebDriver instance for this
 *     element.
 * @param {!(webdriver.promise.Promise.&lt;webdriver.WebElement.Id&gt;|
 *           webdriver.WebElement.Id)} id The server-assigned opaque ID for the
 *     underlying DOM element.
 * @constructor
 */
webdriver.WebElement = function(driver, id) {

  /** @private {!webdriver.WebDriver} */
  this.driver_ = driver;

  /** @private {!webdriver.promise.Promise.&lt;webdriver.WebElement.Id&gt;} */
  this.id_ = id instanceof webdriver.promise.Promise ?
      id : webdriver.promise.fulfilled(id);
};


/**
 * Wire protocol definition of a WebElement ID.
 * @typedef {{ELEMENT: string}}
 * @see http://code.google.com/p/selenium/wiki/JsonWireProtocol
 */
webdriver.WebElement.Id;


/**
 * The property key used in the wire protocol to indicate that a JSON object
 * contains the ID of a WebElement.
 * @type {string}
 * @const
 */
webdriver.WebElement.ELEMENT_KEY = &#039;ELEMENT&#039;;


/**
 * Compares to WebElements for equality.
 * @param {!webdriver.WebElement} a A WebElement.
 * @param {!webdriver.WebElement} b A WebElement.
 * @return {!webdriver.promise.Promise.&lt;boolean&gt;} A promise that will be
 *     resolved to whether the two WebElements are equal.
 */
webdriver.WebElement.equals = function(a, b) {
  if (a == b) {
    return webdriver.promise.fulfilled(true);
  }
  var ids = [a.getId(), b.getId()];
  return webdriver.promise.all(ids).then(function(ids) {
    // If the two element&#039;s have the same ID, they should be considered
    // equal. Otherwise, they may still be equivalent, but we&#039;ll need to
    // ask the server to check for us.
    if (ids[0][webdriver.WebElement.ELEMENT_KEY] ==
        ids[1][webdriver.WebElement.ELEMENT_KEY]) {
      return true;
    }

    var command = new webdriver.Command(webdriver.CommandName.ELEMENT_EQUALS);
    command.setParameter(&#039;id&#039;, ids[0]);
    command.setParameter(&#039;other&#039;, ids[1]);
    return a.driver_.schedule(command, &#039;webdriver.WebElement.equals()&#039;);
  });
};


/**
 * @return {!webdriver.WebDriver} The parent driver for this instance.
 */
webdriver.WebElement.prototype.getDriver = function() {
  return this.driver_;
};


/**
 * @return {!webdriver.promise.Promise.&lt;webdriver.WebElement.Id&gt;} A promise
 *     that resolves to this element&#039;s JSON representation as defined by the
 *     WebDriver wire protocol.
 * @see http://code.google.com/p/selenium/wiki/JsonWireProtocol
 */
webdriver.WebElement.prototype.getId = function() {
  return this.id_;
};


/**
 * Schedules a command that targets this element with the parent WebDriver
 * instance. Will ensure this element&#039;s ID is included in the command parameters
 * under the &quot;id&quot; key.
 * @param {!webdriver.Command} command The command to schedule.
 * @param {string} description A description of the command for debugging.
 * @return {!webdriver.promise.Promise.&lt;T&gt;} A promise that will be resolved
 *     with the command result.
 * @template T
 * @see webdriver.WebDriver.prototype.schedule
 * @private
 */
webdriver.WebElement.prototype.schedule_ = function(command, description) {
  command.setParameter(&#039;id&#039;, this.getId());
  return this.driver_.schedule(command, description);
};


/**
 * Schedule a command to find a descendant of this element. If the element
 * cannot be found, a {@code bot.ErrorCode.NO_SUCH_ELEMENT} result will
 * be returned by the driver. Unlike other commands, this error cannot be
 * suppressed. In other words, scheduling a command to find an element doubles
 * as an assert that the element is present on the page. To test whether an
 * element is present on the page, use {@code #isElementPresent} instead.
 *
 * &lt;p&gt;The search criteria for an element may be defined using one of the
 * factories in the {@link webdriver.By} namespace, or as a short-hand
 * {@link webdriver.By.Hash} object. For example, the following two statements
 * are equivalent:
 * &lt;code&gt;&lt;pre&gt;
 * var e1 = element.findElement(By.id(&#039;foo&#039;));
 * var e2 = element.findElement({id:&#039;foo&#039;});
 * &lt;/pre&gt;&lt;/code&gt;
 *
 * &lt;p&gt;You may also provide a custom locator function, which takes as input
 * this WebDriver instance and returns a {@link webdriver.WebElement}, or a
 * promise that will resolve to a WebElement. For example, to find the first
 * visible link on a page, you could write:
 * &lt;code&gt;&lt;pre&gt;
 * var link = element.findElement(firstVisibleLink);
 *
 * function firstVisibleLink(element) {
 *   var links = element.findElements(By.tagName(&#039;a&#039;));
 *   return webdriver.promise.filter(links, function(link) {
 *     return links.isDisplayed();
 *   }).then(function(visibleLinks) {
 *     return visibleLinks[0];
 *   });
 * }
 * &lt;/pre&gt;&lt;/code&gt;
 *
 * @param {!(webdriver.Locator|webdriver.By.Hash|Function)} locator The
 *     locator strategy to use when searching for the element.
 * @return {!webdriver.WebElement} A WebElement that can be used to issue
 *     commands against the located element. If the element is not found, the
 *     element will be invalidated and all scheduled commands aborted.
 */
webdriver.WebElement.prototype.findElement = function(locator) {
  locator = webdriver.Locator.checkLocator(locator);
  var id;
  if (goog.isFunction(locator)) {
    id = this.driver_.findElementInternal_(locator, this);
  } else {
    var command = new webdriver.Command(
        webdriver.CommandName.FIND_CHILD_ELEMENT).
        setParameter(&#039;using&#039;, locator.using).
        setParameter(&#039;value&#039;, locator.value);
    id = this.schedule_(command, &#039;WebElement.findElement(&#039; + locator + &#039;)&#039;);
  }
  return new webdriver.WebElementPromise(this.driver_, id);
};


/**
 * Schedules a command to test if there is at least one descendant of this
 * element that matches the given search criteria.
 *
 * @param {!(webdriver.Locator|webdriver.By.Hash|Function)} locator The
 *     locator strategy to use when searching for the element.
 * @return {!webdriver.promise.Promise.&lt;boolean&gt;} A promise that will be
 *     resolved with whether an element could be located on the page.
 */
webdriver.WebElement.prototype.isElementPresent = function(locator) {
  return this.findElements(locator).then(function(result) {
    return !!result.length;
  });
};


/**
 * Schedules a command to find all of the descendants of this element that
 * match the given search criteria.
 *
 * @param {!(webdriver.Locator|webdriver.By.Hash|Function)} locator The
 *     locator strategy to use when searching for the elements.
 * @return {!webdriver.promise.Promise.&lt;!Array.&lt;!webdriver.WebElement&gt;&gt;} A
 *     promise that will resolve to an array of WebElements.
 */
webdriver.WebElement.prototype.findElements = function(locator) {
  locator = webdriver.Locator.checkLocator(locator);
  if (goog.isFunction(locator)) {
    return this.driver_.findElementsInternal_(locator, this);
  } else {
    var command = new webdriver.Command(
        webdriver.CommandName.FIND_CHILD_ELEMENTS).
        setParameter(&#039;using&#039;, locator.using).
        setParameter(&#039;value&#039;, locator.value);
    return this.schedule_(command, &#039;WebElement.findElements(&#039; + locator + &#039;)&#039;);
  }
};


/**
 * Schedules a command to click on this element.
 * @return {!webdriver.promise.Promise.&lt;void&gt;} A promise that will be resolved
 *     when the click command has completed.
 */
webdriver.WebElement.prototype.click = function() {
  return this.schedule_(
      new webdriver.Command(webdriver.CommandName.CLICK_ELEMENT),
      &#039;WebElement.click()&#039;);
};


/**
 * Schedules a command to type a sequence on the DOM element represented by this
 * instance.
 * &lt;p/&gt;
 * Modifier keys (SHIFT, CONTROL, ALT, META) are stateful; once a modifier is
 * processed in the keysequence, that key state is toggled until one of the
 * following occurs:
 * &lt;ul&gt;
 * &lt;li&gt;The modifier key is encountered again in the sequence. At this point the
 * state of the key is toggled (along with the appropriate keyup/down events).
 * &lt;/li&gt;
 * &lt;li&gt;The {@code webdriver.Key.NULL} key is encountered in the sequence. When
 * this key is encountered, all modifier keys current in the down state are
 * released (with accompanying keyup events). The NULL key can be used to
 * simulate common keyboard shortcuts:
 * &lt;code&gt;&lt;pre&gt;
 *     element.sendKeys(&quot;text was&quot;,
 *                      webdriver.Key.CONTROL, &quot;a&quot;, webdriver.Key.NULL,
 *                      &quot;now text is&quot;);
 *     // Alternatively:
 *     element.sendKeys(&quot;text was&quot;,
 *                      webdriver.Key.chord(webdriver.Key.CONTROL, &quot;a&quot;),
 *                      &quot;now text is&quot;);
 * &lt;/pre&gt;&lt;/code&gt;&lt;/li&gt;
 * &lt;li&gt;The end of the keysequence is encountered. When there are no more keys
 * to type, all depressed modifier keys are released (with accompanying keyup
 * events).
 * &lt;/li&gt;
 * &lt;/ul&gt;
 * &lt;strong&gt;Note:&lt;/strong&gt; On browsers where native keyboard events are not yet
 * supported (e.g. Firefox on OS X), key events will be synthesized. Special
 * punctionation keys will be synthesized according to a standard QWERTY en-us
 * keyboard layout.
 *
 * @param {...string} var_args The sequence of keys to
 *     type. All arguments will be joined into a single sequence (var_args is
 *     permitted for convenience).
 * @return {!webdriver.promise.Promise.&lt;void&gt;} A promise that will be resolved
 *     when all keys have been typed.
 */
webdriver.WebElement.prototype.sendKeys = function(var_args) {
  // Coerce every argument to a string. This protects us from users that
  // ignore the jsdoc and give us a number (which ends up causing problems on
  // the server, which requires strings).
  var keys = webdriver.promise.fullyResolved(goog.array.slice(arguments, 0)).
      then(function(args) {
        return goog.array.map(goog.array.slice(args, 0), function(key) {
          return key + &#039;&#039;;
        });
      });
  return this.schedule_(
      new webdriver.Command(webdriver.CommandName.SEND_KEYS_TO_ELEMENT).
          setParameter(&#039;value&#039;, keys),
      &#039;WebElement.sendKeys(&#039; + keys + &#039;)&#039;);
};


/**
 * Schedules a command to query for the tag/node name of this element.
 * @return {!webdriver.promise.Promise.&lt;string&gt;} A promise that will be
 *     resolved with the element&#039;s tag name.
 */
webdriver.WebElement.prototype.getTagName = function() {
  return this.schedule_(
      new webdriver.Command(webdriver.CommandName.GET_ELEMENT_TAG_NAME),
      &#039;WebElement.getTagName()&#039;);
};


/**
 * Schedules a command to query for the computed style of the element
 * represented by this instance. If the element inherits the named style from
 * its parent, the parent will be queried for its value.  Where possible, color
 * values will be converted to their hex representation (e.g. #00ff00 instead of
 * rgb(0, 255, 0)).
 * &lt;p/&gt;
 * &lt;em&gt;Warning:&lt;/em&gt; the value returned will be as the browser interprets it, so
 * it may be tricky to form a proper assertion.
 *
 * @param {string} cssStyleProperty The name of the CSS style property to look
 *     up.
 * @return {!webdriver.promise.Promise.&lt;string&gt;} A promise that will be
 *     resolved with the requested CSS value.
 */
webdriver.WebElement.prototype.getCssValue = function(cssStyleProperty) {
  var name = webdriver.CommandName.GET_ELEMENT_VALUE_OF_CSS_PROPERTY;
  return this.schedule_(
      new webdriver.Command(name).
          setParameter(&#039;propertyName&#039;, cssStyleProperty),
      &#039;WebElement.getCssValue(&#039; + cssStyleProperty + &#039;)&#039;);
};


/**
 * Schedules a command to query for the value of the given attribute of the
 * element. Will return the current value, even if it has been modified after
 * the page has been loaded. More exactly, this method will return the value of
 * the given attribute, unless that attribute is not present, in which case the
 * value of the property with the same name is returned. If neither value is
 * set, null is returned (for example, the &quot;value&quot; property of a textarea
 * element). The &quot;style&quot; attribute is converted as best can be to a
 * text representation with a trailing semi-colon. The following are deemed to
 * be &quot;boolean&quot; attributes and will return either &quot;true&quot; or null:
 *
 * &lt;p&gt;async, autofocus, autoplay, checked, compact, complete, controls, declare,
 * defaultchecked, defaultselected, defer, disabled, draggable, ended,
 * formnovalidate, hidden, indeterminate, iscontenteditable, ismap, itemscope,
 * loop, multiple, muted, nohref, noresize, noshade, novalidate, nowrap, open,
 * paused, pubdate, readonly, required, reversed, scoped, seamless, seeking,
 * selected, spellcheck, truespeed, willvalidate
 *
 * &lt;p&gt;Finally, the following commonly mis-capitalized attribute/property names
 * are evaluated as expected:
 * &lt;ul&gt;
 *   &lt;li&gt;&quot;class&quot;
 *   &lt;li&gt;&quot;readonly&quot;
 * &lt;/ul&gt;
 * @param {string} attributeName The name of the attribute to query.
 * @return {!webdriver.promise.Promise.&lt;?string&gt;} A promise that will be
 *     resolved with the attribute&#039;s value. The returned value will always be
 *     either a string or null.
 */
webdriver.WebElement.prototype.getAttribute = function(attributeName) {
  return this.schedule_(
      new webdriver.Command(webdriver.CommandName.GET_ELEMENT_ATTRIBUTE).
          setParameter(&#039;name&#039;, attributeName),
      &#039;WebElement.getAttribute(&#039; + attributeName + &#039;)&#039;);
};


/**
 * Get the visible (i.e. not hidden by CSS) innerText of this element, including
 * sub-elements, without any leading or trailing whitespace.
 * @return {!webdriver.promise.Promise.&lt;string&gt;} A promise that will be
 *     resolved with the element&#039;s visible text.
 */
webdriver.WebElement.prototype.getText = function() {
  return this.schedule_(
      new webdriver.Command(webdriver.CommandName.GET_ELEMENT_TEXT),
      &#039;WebElement.getText()&#039;);
};


/**
 * Schedules a command to compute the size of this element&#039;s bounding box, in
 * pixels.
 * @return {!webdriver.promise.Promise.&lt;{width: number, height: number}&gt;} A
 *     promise that will be resolved with the element&#039;s size as a
 *     {@code {width:number, height:number}} object.
 */
webdriver.WebElement.prototype.getSize = function() {
  return this.schedule_(
      new webdriver.Command(webdriver.CommandName.GET_ELEMENT_SIZE),
      &#039;WebElement.getSize()&#039;);
};


/**
 * Schedules a command to compute the location of this element in page space.
 * @return {!webdriver.promise.Promise.&lt;{x: number, y: number}&gt;} A promise that
 *     will be resolved to the element&#039;s location as a
 *     {@code {x:number, y:number}} object.
 */
webdriver.WebElement.prototype.getLocation = function() {
  return this.schedule_(
      new webdriver.Command(webdriver.CommandName.GET_ELEMENT_LOCATION),
      &#039;WebElement.getLocation()&#039;);
};


/**
 * Schedules a command to query whether the DOM element represented by this
 * instance is enabled, as dicted by the {@code disabled} attribute.
 * @return {!webdriver.promise.Promise.&lt;boolean&gt;} A promise that will be
 *     resolved with whether this element is currently enabled.
 */
webdriver.WebElement.prototype.isEnabled = function() {
  return this.schedule_(
      new webdriver.Command(webdriver.CommandName.IS_ELEMENT_ENABLED),
      &#039;WebElement.isEnabled()&#039;);
};


/**
 * Schedules a command to query whether this element is selected.
 * @return {!webdriver.promise.Promise.&lt;boolean&gt;} A promise that will be
 *     resolved with whether this element is currently selected.
 */
webdriver.WebElement.prototype.isSelected = function() {
  return this.schedule_(
      new webdriver.Command(webdriver.CommandName.IS_ELEMENT_SELECTED),
      &#039;WebElement.isSelected()&#039;);
};


/**
 * Schedules a command to submit the form containing this element (or this
 * element if it is a FORM element). This command is a no-op if the element is
 * not contained in a form.
 * @return {!webdriver.promise.Promise.&lt;void&gt;} A promise that will be resolved
 *     when the form has been submitted.
 */
webdriver.WebElement.prototype.submit = function() {
  return this.schedule_(
      new webdriver.Command(webdriver.CommandName.SUBMIT_ELEMENT),
      &#039;WebElement.submit()&#039;);
};


/**
 * Schedules a command to clear the {@code value} of this element. This command
 * has no effect if the underlying DOM element is neither a text INPUT element
 * nor a TEXTAREA element.
 * @return {!webdriver.promise.Promise.&lt;void&gt;} A promise that will be resolved
 *     when the element has been cleared.
 */
webdriver.WebElement.prototype.clear = function() {
  return this.schedule_(
      new webdriver.Command(webdriver.CommandName.CLEAR_ELEMENT),
      &#039;WebElement.clear()&#039;);
};


/**
 * Schedules a command to test whether this element is currently displayed.
 * @return {!webdriver.promise.Promise.&lt;boolean&gt;} A promise that will be
 *     resolved with whether this element is currently visible on the page.
 */
webdriver.WebElement.prototype.isDisplayed = function() {
  return this.schedule_(
      new webdriver.Command(webdriver.CommandName.IS_ELEMENT_DISPLAYED),
      &#039;WebElement.isDisplayed()&#039;);
};


/**
 * Schedules a command to retrieve the outer HTML of this element.
 * @return {!webdriver.promise.Promise.&lt;string&gt;} A promise that will be
 *     resolved with the element&#039;s outer HTML.
 */
webdriver.WebElement.prototype.getOuterHtml = function() {
  return this.driver_.executeScript(function() {
    var element = arguments[0];
    if (&#039;outerHTML&#039; in element) {
      return element.outerHTML;
    } else {
      var div = element.ownerDocument.createElement(&#039;div&#039;);
      div.appendChild(element.cloneNode(true));
      return div.innerHTML;
    }
  }, this);
};


/**
 * Schedules a command to retrieve the inner HTML of this element.
 * @return {!webdriver.promise.Promise.&lt;string&gt;} A promise that will be
 *     resolved with the element&#039;s inner HTML.
 */
webdriver.WebElement.prototype.getInnerHtml = function() {
  return this.driver_.executeScript(&#039;return arguments[0].innerHTML&#039;, this);
};



/**
 * WebElementPromise is a promise that will be fulfilled with a WebElement.
 * This serves as a forward proxy on WebElement, allowing calls to be
 * scheduled without directly on this instance before the underlying
 * WebElement has been fulfilled. In other words, the following two statements
 * are equivalent:
 * &lt;pre&gt;&lt;code&gt;
 *     driver.findElement({id: &#039;my-button&#039;}).click();
 *     driver.findElement({id: &#039;my-button&#039;}).then(function(el) {
 *       return el.click();
 *     });
 * &lt;/code&gt;&lt;/pre&gt;
 *
 * @param {!webdriver.WebDriver} driver The parent WebDriver instance for this
 *     element.
 * @param {!webdriver.promise.Promise.&lt;!webdriver.WebElement&gt;} el A promise
 *     that will resolve to the promised element.
 * @constructor
 * @extends {webdriver.WebElement}
 * @implements {webdriver.promise.Thenable.&lt;!webdriver.WebElement&gt;}
 * @final
 */
webdriver.WebElementPromise = function(driver, el) {
  webdriver.WebElement.call(this, driver, {&#039;ELEMENT&#039;: &#039;unused&#039;});

  /** @override */
  this.cancel = goog.bind(el.cancel, el);

  /** @override */
  this.isPending = goog.bind(el.isPending, el);

  /** @override */
  this.then = goog.bind(el.then, el);

  /** @override */
  this.thenCatch = goog.bind(el.thenCatch, el);

  /** @override */
  this.thenFinally = goog.bind(el.thenFinally, el);

  /**
   * Defers returning the element ID until the wrapped WebElement has been
   * resolved.
   * @override
   */
  this.getId = function() {
    return el.then(function(el) {
      return el.getId();
    });
  };
};
goog.inherits(webdriver.WebElementPromise, webdriver.WebElement);


/**
 * Represents a modal dialog such as {@code alert}, {@code confirm}, or
 * {@code prompt}. Provides functions to retrieve the message displayed with
 * the alert, accept or dismiss the alert, and set the response text (in the
 * case of {@code prompt}).
 * @param {!webdriver.WebDriver} driver The driver controlling the browser this
 *     alert is attached to.
 * @param {string} text The message text displayed with this alert.
 * @constructor
 */
webdriver.Alert = function(driver, text) {
  /** @private {!webdriver.WebDriver} */
  this.driver_ = driver;

  /** @private {!webdriver.promise.Promise.&lt;string&gt;} */
  this.text_ = webdriver.promise.when(text);
};


/**
 * Retrieves the message text displayed with this alert. For instance, if the
 * alert were opened with alert(&quot;hello&quot;), then this would return &quot;hello&quot;.
 * @return {!webdriver.promise.Promise.&lt;string&gt;} A promise that will be
 *     resolved to the text displayed with this alert.
 */
webdriver.Alert.prototype.getText = function() {
  return this.text_;
};


/**
 * Accepts this alert.
 * @return {!webdriver.promise.Promise.&lt;void&gt;} A promise that will be resolved
 *     when this command has completed.
 */
webdriver.Alert.prototype.accept = function() {
  return this.driver_.schedule(
      new webdriver.Command(webdriver.CommandName.ACCEPT_ALERT),
      &#039;WebDriver.switchTo().alert().accept()&#039;);
};


/**
 * Dismisses this alert.
 * @return {!webdriver.promise.Promise.&lt;void&gt;} A promise that will be resolved
 *     when this command has completed.
 */
webdriver.Alert.prototype.dismiss = function() {
  return this.driver_.schedule(
      new webdriver.Command(webdriver.CommandName.DISMISS_ALERT),
      &#039;WebDriver.switchTo().alert().dismiss()&#039;);
};


/**
 * Sets the response text on this alert. This command will return an error if
 * the underlying alert does not support response text (e.g. window.alert and
 * window.confirm).
 * @param {string} text The text to set.
 * @return {!webdriver.promise.Promise.&lt;void&gt;} A promise that will be resolved
 *     when this command has completed.
 */
webdriver.Alert.prototype.sendKeys = function(text) {
  return this.driver_.schedule(
      new webdriver.Command(webdriver.CommandName.SET_ALERT_TEXT).
          setParameter(&#039;text&#039;, text),
      &#039;WebDriver.switchTo().alert().sendKeys(&#039; + text + &#039;)&#039;);
};



/**
 * AlertPromise is a promise that will be fulfilled with an Alert. This promise
 * serves as a forward proxy on an Alert, allowing calls to be scheduled
 * directly on this instance before the underlying Alert has been fulfilled. In
 * other words, the following two statements are equivalent:
 * &lt;pre&gt;&lt;code&gt;
 *     driver.switchTo().alert().dismiss();
 *     driver.switchTo().alert().then(function(alert) {
 *       return alert.dismiss();
 *     });
 * &lt;/code&gt;&lt;/pre&gt;
 *
 * @param {!webdriver.WebDriver} driver The driver controlling the browser this
 *     alert is attached to.
 * @param {!webdriver.promise.Thenable.&lt;!webdriver.Alert&gt;} alert A thenable
 *     that will be fulfilled with the promised alert.
 * @constructor
 * @extends {webdriver.Alert}
 * @implements {webdriver.promise.Thenable.&lt;!webdriver.Alert&gt;}
 * @final
 */
webdriver.AlertPromise = function(driver, alert) {
  webdriver.Alert.call(this, driver, &#039;unused&#039;);

  /** @override */
  this.cancel = goog.bind(alert.cancel, alert);

  /** @override */
  this.isPending = goog.bind(alert.isPending, alert);

  /** @override */
  this.then = goog.bind(alert.then, alert);

  /** @override */
  this.thenCatch = goog.bind(alert.thenCatch, alert);

  /** @override */
  this.thenFinally = goog.bind(alert.thenFinally, alert);

  /**
   * Defer returning text until the promised alert has been resolved.
   * @override
   */
  this.getText = function() {
    return alert.then(function(alert) {
      return alert.getText();
    });
  };

  /**
   * Defers action until the alert has been located.
   * @override
   */
  this.accept = function() {
    return alert.then(function(alert) {
      return alert.accept();
    });
  };

  /**
   * Defers action until the alert has been located.
   * @override
   */
  this.dismiss = function() {
    return alert.then(function(alert) {
      return alert.dismiss();
    });
  };

  /**
   * Defers action until the alert has been located.
   * @override
   */
  this.sendKeys = function(text) {
    return alert.then(function(alert) {
      return alert.sendKeys(text);
    });
  };
};
goog.inherits(webdriver.AlertPromise, webdriver.Alert);



/**
 * An error returned to indicate that there is an unhandled modal dialog on the
 * current page.
 * @param {string} message The error message.
 * @param {string} text The text displayed with the unhandled alert.
 * @param {!webdriver.Alert} alert The alert handle.
 * @constructor
 * @extends {bot.Error}
 */
webdriver.UnhandledAlertError = function(message, text, alert) {
  goog.base(this, bot.ErrorCode.UNEXPECTED_ALERT_OPEN, message);

  /** @private {string} */
  this.text_ = text;

  /** @private {!webdriver.Alert} */
  this.alert_ = alert;
};
goog.inherits(webdriver.UnhandledAlertError, bot.Error);


/**
 * @return {string} The text displayed with the unhandled alert.
 */
webdriver.UnhandledAlertError.prototype.getAlertText = function() {
  return this.text_;
};


/**
 * @return {!webdriver.Alert} The open alert.
 * @deprecated Use {@link #getAlertText}. This method will be removed in
 *     2.45.0.
 */
webdriver.UnhandledAlertError.prototype.getAlert = function() {
  return this.alert_;
};</textarea>
  </div>
</div>

<footer class="footer">
  <div class="container">
    <p>.</p>
  </div>
</footer>

<script type="text/html" id="complexity-popover-template">
  <div class="complexity-notice">
    Complexity : {{ complexity.cyclomatic }} <br>
    Length : {{ complexity.halstead.length }} <br>
    Difficulty : {{ complexity.halstead.difficulty.toFixed(2) }} <br>
    Est # bugs : {{ complexity.halstead.bugs.toFixed(2) }}<br>
  </div>
</script>

<script type="text/javascript" src="../../assets/scripts/bundles/core-bundle.js"></script>
<script type="text/javascript" src="../../assets/scripts/bundles/codemirror.js"></script>
<script type="text/javascript" src="../../assets/scripts/codemirror.markpopovertext.js"></script>
<script type="text/javascript" src="report.js"></script>
<script type="text/javascript" src="report.history.js"></script>
<script type="text/javascript" src="../../assets/scripts/plato-file.js"></script>
</body>
</html>
