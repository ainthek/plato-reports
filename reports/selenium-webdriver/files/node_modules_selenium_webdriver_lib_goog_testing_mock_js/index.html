<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Plato - node_modules/selenium-webdriver/lib/goog/testing/mock.js</title>

  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="">
  <meta name="author" content="">

  <!--[if lt IE 9]>
  <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->

  <link href="../../assets/css/vendor/morris.css" rel="stylesheet">
  <link href="../../assets/css/vendor/bootstrap.css" rel="stylesheet">
  <link href="../../assets/css/vendor/font-awesome.css" rel="stylesheet">
  <link href="../../assets/css/vendor/codemirror.css" rel="stylesheet">
  <link href="../../assets/css/plato.css" rel="stylesheet">
  <link href="../../assets/css/plato-file.css" rel="stylesheet">

</head>

<body>

<div class="navbar navbar-fixed-top">
  <div class="container">
    <a class="navbar-brand" href="http://github.com/es-analysis/plato">Plato on Github</a>
    <ul class="nav navbar-nav">
      <li>
        <a href="../../index.html">Report Home</a>
      </li>
    </ul>
  </div>
</div>

<div class="jumbotron">
  <div class="container">
    <h1>node_modules/selenium-webdriver/lib/goog/testing/mock.js</h1>
  </div>
</div>

<div class="container aggregate-stats">
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Maintainability <a href="http://blogs.msdn.com/b/codeanalysis/archive/2007/11/20/maintainability-index-range-and-meaning.aspx"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="A value between 0 and 100 that represents the relative ease of maintaining the code. A high value means better maintainability." data-original-title="Maintainability Index"  data-container="body"></i></a></h2>
      <p class="stat">73.09</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Lines of code <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h2>
      <p class="stat">608</p>
    </div>
  </div>
  <div class="row historical">
    <div class="col-md-6">
      <p id="chart_historical_maint" class="chart"></p>
    </div>
    <div class="col-md-6">
      <p id="chart_historical_sloc" class="chart"></p>
    </div>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Difficulty  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="The difficulty measure is related to the difficulty of the program to write or understand." data-original-title="Difficulty" data-container="body"></i></a></h2>
      <p class="stat">59.74</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Estimated Errors  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Halstead's delivered bugs is an estimate for the number of errors in the implementation." data-original-title="Delivered Bugs" data-container="body"></i></a></h2>
      <p class="stat">3.16</p>
    </div>
  </div>
</div>

<div class="container charts">
  <div class="row">
    <h2 class="header">Function weight</h2>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h3 class="chart-header">By Complexity <a href="http://en.wikipedia.org/wiki/Cyclomatic_complexity"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="This metric counts the number of distinct paths through a block of code. Lower values are better." data-original-title="Cyclomatic Complexity" data-container="body"></i></a></h3>
      <div id="fn-by-complexity" class="stat"></div>
    </div>
    <div class="col-md-6">
      <h3 class="chart-header">By SLOC  <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h3>
      <div id="fn-by-sloc" class="stat"></div>
    </div>
  </div>
</div>

<div class="container">
  <div class="row">
    <textarea id="file-source" class="col-md-12">// Copyright 2008 The Closure Library Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an &quot;AS-IS&quot; BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/**
 * @fileoverview This file defines base classes used for creating mocks in
 * JavaScript. The API was inspired by EasyMock.
 *
 * The basic API is:
 * &lt;ul&gt;
 *   &lt;li&gt;Create an object to be mocked
 *   &lt;li&gt;Create a mock object, passing in the above object to the constructor
 *   &lt;li&gt;Set expectations by calling methods on the mock object
 *   &lt;li&gt;Call $replay() on the mock object
 *   &lt;li&gt;Pass the mock to code that will make real calls on it
 *   &lt;li&gt;Call $verify() to make sure that expectations were met
 * &lt;/ul&gt;
 *
 * For examples, please see the unit tests for LooseMock and StrictMock.
 *
 * Still TODO
 *   implement better (and pluggable) argument matching
 *   Have the exceptions for LooseMock show the number of expected/actual calls
 *   loose and strict mocks share a lot of code - move it to the base class
 *
 */

goog.provide(&#039;goog.testing.Mock&#039;);
goog.provide(&#039;goog.testing.MockExpectation&#039;);

goog.require(&#039;goog.array&#039;);
goog.require(&#039;goog.object&#039;);
goog.require(&#039;goog.testing.JsUnitException&#039;);
goog.require(&#039;goog.testing.MockInterface&#039;);
goog.require(&#039;goog.testing.mockmatchers&#039;);



/**
 * This is a class that represents an expectation.
 * @param {string} name The name of the method for this expectation.
 * @constructor
 * @final
 */
goog.testing.MockExpectation = function(name) {
  /**
   * The name of the method that is expected to be called.
   * @type {string}
   */
  this.name = name;

  /**
   * An array of error messages for expectations not met.
   * @type {Array}
   */
  this.errorMessages = [];
};


/**
 * The minimum number of times this method should be called.
 * @type {number}
 */
goog.testing.MockExpectation.prototype.minCalls = 1;


/**
  * The maximum number of times this method should be called.
  * @type {number}
  */
goog.testing.MockExpectation.prototype.maxCalls = 1;


/**
 * The value that this method should return.
 * @type {*}
 */
goog.testing.MockExpectation.prototype.returnValue;


/**
 * The value that will be thrown when the method is called
 * @type {*}
 */
goog.testing.MockExpectation.prototype.exceptionToThrow;


/**
 * The arguments that are expected to be passed to this function
 * @type {Array.&lt;*&gt;}
 */
goog.testing.MockExpectation.prototype.argumentList;


/**
 * The number of times this method is called by real code.
 * @type {number}
 */
goog.testing.MockExpectation.prototype.actualCalls = 0;


/**
 * The number of times this method is called during the verification phase.
 * @type {number}
 */
goog.testing.MockExpectation.prototype.verificationCalls = 0;


/**
 * The function which will be executed when this method is called.
 * Method arguments will be passed to this function, and return value
 * of this function will be returned by the method.
 * @type {Function}
 */
goog.testing.MockExpectation.prototype.toDo;


/**
 * Allow expectation failures to include messages.
 * @param {string} message The failure message.
 */
goog.testing.MockExpectation.prototype.addErrorMessage = function(message) {
  this.errorMessages.push(message);
};


/**
 * Get the error messages seen so far.
 * @return {string} Error messages separated by \n.
 */
goog.testing.MockExpectation.prototype.getErrorMessage = function() {
  return this.errorMessages.join(&#039;\n&#039;);
};


/**
 * Get how many error messages have been seen so far.
 * @return {number} Count of error messages.
 */
goog.testing.MockExpectation.prototype.getErrorMessageCount = function() {
  return this.errorMessages.length;
};



/**
 * The base class for a mock object.
 * @param {Object|Function} objectToMock The object that should be mocked, or
 *    the constructor of an object to mock.
 * @param {boolean=} opt_mockStaticMethods An optional argument denoting that
 *     a mock should be constructed from the static functions of a class.
 * @param {boolean=} opt_createProxy An optional argument denoting that
 *     a proxy for the target mock should be created.
 * @constructor
 * @implements {goog.testing.MockInterface}
 */
goog.testing.Mock = function(objectToMock, opt_mockStaticMethods,
    opt_createProxy) {
  if (!goog.isObject(objectToMock) &amp;&amp; !goog.isFunction(objectToMock)) {
    throw new Error(&#039;objectToMock must be an object or constructor.&#039;);
  }
  if (opt_createProxy &amp;&amp; !opt_mockStaticMethods &amp;&amp;
      goog.isFunction(objectToMock)) {
    /**
 * @constructor
 * @final
 */
    var tempCtor = function() {};
    goog.inherits(tempCtor, objectToMock);
    this.$proxy = new tempCtor();
  } else if (opt_createProxy &amp;&amp; opt_mockStaticMethods &amp;&amp;
      goog.isFunction(objectToMock)) {
    throw Error(&#039;Cannot create a proxy when opt_mockStaticMethods is true&#039;);
  } else if (opt_createProxy &amp;&amp; !goog.isFunction(objectToMock)) {
    throw Error(&#039;Must have a constructor to create a proxy&#039;);
  }

  if (goog.isFunction(objectToMock) &amp;&amp; !opt_mockStaticMethods) {
    this.$initializeFunctions_(objectToMock.prototype);
  } else {
    this.$initializeFunctions_(objectToMock);
  }
  this.$argumentListVerifiers_ = {};
};


/**
 * Option that may be passed when constructing function, method, and
 * constructor mocks. Indicates that the expected calls should be accepted in
 * any order.
 * @const
 * @type {number}
 */
goog.testing.Mock.LOOSE = 1;


/**
 * Option that may be passed when constructing function, method, and
 * constructor mocks. Indicates that the expected calls should be accepted in
 * the recorded order only.
 * @const
 * @type {number}
 */
goog.testing.Mock.STRICT = 0;


/**
 * This array contains the name of the functions that are part of the base
 * Object prototype.
 * Basically a copy of goog.object.PROTOTYPE_FIELDS_.
 * @const
 * @type {!Array.&lt;string&gt;}
 * @private
 */
goog.testing.Mock.PROTOTYPE_FIELDS_ = [
  &#039;constructor&#039;,
  &#039;hasOwnProperty&#039;,
  &#039;isPrototypeOf&#039;,
  &#039;propertyIsEnumerable&#039;,
  &#039;toLocaleString&#039;,
  &#039;toString&#039;,
  &#039;valueOf&#039;
];


/**
 * A proxy for the mock.  This can be used for dependency injection in lieu of
 * the mock if the test requires a strict instanceof check.
 * @type {Object}
 */
goog.testing.Mock.prototype.$proxy = null;


/**
 * Map of argument name to optional argument list verifier function.
 * @type {Object}
 */
goog.testing.Mock.prototype.$argumentListVerifiers_;


/**
 * Whether or not we are in recording mode.
 * @type {boolean}
 * @private
 */
goog.testing.Mock.prototype.$recording_ = true;


/**
 * The expectation currently being created. All methods that modify the
 * current expectation return the Mock object for easy chaining, so this is
 * where we keep track of the expectation that&#039;s currently being modified.
 * @type {goog.testing.MockExpectation}
 * @protected
 */
goog.testing.Mock.prototype.$pendingExpectation;


/**
 * First exception thrown by this mock; used in $verify.
 * @type {Object}
 * @private
 */
goog.testing.Mock.prototype.$threwException_ = null;


/**
 * Initializes the functions on the mock object.
 * @param {Object} objectToMock The object being mocked.
 * @private
 */
goog.testing.Mock.prototype.$initializeFunctions_ = function(objectToMock) {
  // Gets the object properties.
  var enumerableProperties = goog.object.getKeys(objectToMock);

  // The non enumerable properties are added if they override the ones in the
  // Object prototype. This is due to the fact that IE8 does not enumerate any
  // of the prototype Object functions even when overriden and mocking these is
  // sometimes needed.
  for (var i = 0; i &lt; goog.testing.Mock.PROTOTYPE_FIELDS_.length; i++) {
    var prop = goog.testing.Mock.PROTOTYPE_FIELDS_[i];
    // Look at b/6758711 if you&#039;re considering adding ALL properties to ALL
    // mocks.
    if (objectToMock[prop] !== Object.prototype[prop]) {
      enumerableProperties.push(prop);
    }
  }

  // Adds the properties to the mock.
  for (var i = 0; i &lt; enumerableProperties.length; i++) {
    var prop = enumerableProperties[i];
    if (typeof objectToMock[prop] == &#039;function&#039;) {
      this[prop] = goog.bind(this.$mockMethod, this, prop);
      if (this.$proxy) {
        this.$proxy[prop] = goog.bind(this.$mockMethod, this, prop);
      }
    }
  }
};


/**
 * Registers a verfifier function to use when verifying method argument lists.
 * @param {string} methodName The name of the method for which the verifierFn
 *     should be used.
 * @param {Function} fn Argument list verifier function.  Should take 2 argument
 *     arrays as arguments, and return true if they are considered equivalent.
 * @return {!goog.testing.Mock} This mock object.
 */
goog.testing.Mock.prototype.$registerArgumentListVerifier = function(methodName,
                                                                     fn) {
  this.$argumentListVerifiers_[methodName] = fn;
  return this;
};


/**
 * The function that replaces all methods on the mock object.
 * @param {string} name The name of the method being mocked.
 * @return {*} In record mode, returns the mock object. In replay mode, returns
 *    whatever the creator of the mock set as the return value.
 */
goog.testing.Mock.prototype.$mockMethod = function(name) {
  try {
    // Shift off the name argument so that args contains the arguments to
    // the mocked method.
    var args = goog.array.slice(arguments, 1);
    if (this.$recording_) {
      this.$pendingExpectation = new goog.testing.MockExpectation(name);
      this.$pendingExpectation.argumentList = args;
      this.$recordExpectation();
      return this;
    } else {
      return this.$recordCall(name, args);
    }
  } catch (ex) {
    this.$recordAndThrow(ex);
  }
};


/**
 * Records the currently pending expectation, intended to be overridden by a
 * subclass.
 * @protected
 */
goog.testing.Mock.prototype.$recordExpectation = function() {};


/**
 * Records an actual method call, intended to be overridden by a
 * subclass. The subclass must find the pending expectation and return the
 * correct value.
 * @param {string} name The name of the method being called.
 * @param {Array} args The arguments to the method.
 * @return {*} The return expected by the mock.
 * @protected
 */
goog.testing.Mock.prototype.$recordCall = function(name, args) {
  return undefined;
};


/**
 * If the expectation expects to throw, this method will throw.
 * @param {goog.testing.MockExpectation} expectation The expectation.
 */
goog.testing.Mock.prototype.$maybeThrow = function(expectation) {
  if (typeof expectation.exceptionToThrow != &#039;undefined&#039;) {
    throw expectation.exceptionToThrow;
  }
};


/**
 * If this expectation defines a function to be called,
 * it will be called and its result will be returned.
 * Otherwise, if the expectation expects to throw, it will throw.
 * Otherwise, this method will return defined value.
 * @param {goog.testing.MockExpectation} expectation The expectation.
 * @param {Array} args The arguments to the method.
 * @return {*} The return value expected by the mock.
 */
goog.testing.Mock.prototype.$do = function(expectation, args) {
  if (typeof expectation.toDo == &#039;undefined&#039;) {
    this.$maybeThrow(expectation);
    return expectation.returnValue;
  } else {
    return expectation.toDo.apply(this, args);
  }
};


/**
 * Specifies a return value for the currently pending expectation.
 * @param {*} val The return value.
 * @return {!goog.testing.Mock} This mock object.
 */
goog.testing.Mock.prototype.$returns = function(val) {
  this.$pendingExpectation.returnValue = val;
  return this;
};


/**
 * Specifies a value for the currently pending expectation to throw.
 * @param {*} val The value to throw.
 * @return {!goog.testing.Mock} This mock object.
 */
goog.testing.Mock.prototype.$throws = function(val) {
  this.$pendingExpectation.exceptionToThrow = val;
  return this;
};


/**
 * Specifies a function to call for currently pending expectation.
 * Note, that using this method overrides declarations made
 * using $returns() and $throws() methods.
 * @param {Function} func The function to call.
 * @return {!goog.testing.Mock} This mock object.
 */
goog.testing.Mock.prototype.$does = function(func) {
  this.$pendingExpectation.toDo = func;
  return this;
};


/**
 * Allows the expectation to be called 0 or 1 times.
 * @return {!goog.testing.Mock} This mock object.
 */
goog.testing.Mock.prototype.$atMostOnce = function() {
  this.$pendingExpectation.minCalls = 0;
  this.$pendingExpectation.maxCalls = 1;
  return this;
};


/**
 * Allows the expectation to be called any number of times, as long as it&#039;s
 * called once.
 * @return {!goog.testing.Mock} This mock object.
 */
goog.testing.Mock.prototype.$atLeastOnce = function() {
  this.$pendingExpectation.maxCalls = Infinity;
  return this;
};


/**
 * Allows the expectation to be called exactly once.
 * @return {!goog.testing.Mock} This mock object.
 */
goog.testing.Mock.prototype.$once = function() {
  this.$pendingExpectation.minCalls = 1;
  this.$pendingExpectation.maxCalls = 1;
  return this;
};


/**
 * Disallows the expectation from being called.
 * @return {!goog.testing.Mock} This mock object.
 */
goog.testing.Mock.prototype.$never = function() {
  this.$pendingExpectation.minCalls = 0;
  this.$pendingExpectation.maxCalls = 0;
  return this;
};


/**
 * Allows the expectation to be called any number of times.
 * @return {!goog.testing.Mock} This mock object.
 */
goog.testing.Mock.prototype.$anyTimes = function() {
  this.$pendingExpectation.minCalls = 0;
  this.$pendingExpectation.maxCalls = Infinity;
  return this;
};


/**
 * Specifies the number of times the expectation should be called.
 * @param {number} times The number of times this method will be called.
 * @return {!goog.testing.Mock} This mock object.
 */
goog.testing.Mock.prototype.$times = function(times) {
  this.$pendingExpectation.minCalls = times;
  this.$pendingExpectation.maxCalls = times;
  return this;
};


/**
 * Switches from recording to replay mode.
 * @override
 */
goog.testing.Mock.prototype.$replay = function() {
  this.$recording_ = false;
};


/**
 * Resets the state of this mock object. This clears all pending expectations
 * without verifying, and puts the mock in recording mode.
 * @override
 */
goog.testing.Mock.prototype.$reset = function() {
  this.$recording_ = true;
  this.$threwException_ = null;
  delete this.$pendingExpectation;
};


/**
 * Throws an exception and records that an exception was thrown.
 * @param {string} comment A short comment about the exception.
 * @param {?string=} opt_message A longer message about the exception.
 * @throws {Object} JsUnitException object.
 * @protected
 */
goog.testing.Mock.prototype.$throwException = function(comment, opt_message) {
  this.$recordAndThrow(new goog.testing.JsUnitException(comment, opt_message));
};


/**
 * Throws an exception and records that an exception was thrown.
 * @param {Object} ex Exception.
 * @throws {Object} #ex.
 * @protected
 */
goog.testing.Mock.prototype.$recordAndThrow = function(ex) {
  // If it&#039;s an assert exception, record it.
  if (ex[&#039;isJsUnitException&#039;]) {
    var testRunner = goog.global[&#039;G_testRunner&#039;];
    if (testRunner) {
      var logTestFailureFunction = testRunner[&#039;logTestFailure&#039;];
      if (logTestFailureFunction) {
        logTestFailureFunction.call(testRunner, ex);
      }
    }

    if (!this.$threwException_) {
      // Only remember first exception thrown.
      this.$threwException_ = ex;
    }
  }
  throw ex;
};


/**
 * Verify that all of the expectations were met. Should be overridden by
 * subclasses.
 * @override
 */
goog.testing.Mock.prototype.$verify = function() {
  if (this.$threwException_) {
    throw this.$threwException_;
  }
};


/**
 * Verifies that a method call matches an expectation.
 * @param {goog.testing.MockExpectation} expectation The expectation to check.
 * @param {string} name The name of the called method.
 * @param {Array.&lt;*&gt;?} args The arguments passed to the mock.
 * @return {boolean} Whether the call matches the expectation.
 */
goog.testing.Mock.prototype.$verifyCall = function(expectation, name, args) {
  if (expectation.name != name) {
    return false;
  }
  var verifierFn =
      this.$argumentListVerifiers_.hasOwnProperty(expectation.name) ?
      this.$argumentListVerifiers_[expectation.name] :
      goog.testing.mockmatchers.flexibleArrayMatcher;

  return verifierFn(expectation.argumentList, args, expectation);
};


/**
 * Render the provided argument array to a string to help
 * clients with debugging tests.
 * @param {Array.&lt;*&gt;?} args The arguments passed to the mock.
 * @return {string} Human-readable string.
 */
goog.testing.Mock.prototype.$argumentsAsString = function(args) {
  var retVal = [];
  for (var i = 0; i &lt; args.length; i++) {
    try {
      retVal.push(goog.typeOf(args[i]));
    } catch (e) {
      retVal.push(&#039;[unknown]&#039;);
    }
  }
  return &#039;(&#039; + retVal.join(&#039;, &#039;) + &#039;)&#039;;
};


/**
 * Throw an exception based on an incorrect method call.
 * @param {string} name Name of method called.
 * @param {Array.&lt;*&gt;?} args Arguments passed to the mock.
 * @param {goog.testing.MockExpectation=} opt_expectation Expected next call,
 *     if any.
 */
goog.testing.Mock.prototype.$throwCallException = function(name, args,
                                                           opt_expectation) {
  var errorStringBuffer = [];
  var actualArgsString = this.$argumentsAsString(args);
  var expectedArgsString = opt_expectation ?
      this.$argumentsAsString(opt_expectation.argumentList) : &#039;&#039;;

  if (opt_expectation &amp;&amp; opt_expectation.name == name) {
    errorStringBuffer.push(&#039;Bad arguments to &#039;, name, &#039;().\n&#039;,
                           &#039;Actual: &#039;, actualArgsString, &#039;\n&#039;,
                           &#039;Expected: &#039;, expectedArgsString, &#039;\n&#039;,
                           opt_expectation.getErrorMessage());
  } else {
    errorStringBuffer.push(&#039;Unexpected call to &#039;, name,
                           actualArgsString, &#039;.&#039;);
    if (opt_expectation) {
      errorStringBuffer.push(&#039;\nNext expected call was to &#039;,
                             opt_expectation.name,
                             expectedArgsString);
    }
  }
  this.$throwException(errorStringBuffer.join(&#039;&#039;));
};</textarea>
  </div>
</div>

<footer class="footer">
  <div class="container">
    <p>.</p>
  </div>
</footer>

<script type="text/html" id="complexity-popover-template">
  <div class="complexity-notice">
    Complexity : {{ complexity.cyclomatic }} <br>
    Length : {{ complexity.halstead.length }} <br>
    Difficulty : {{ complexity.halstead.difficulty.toFixed(2) }} <br>
    Est # bugs : {{ complexity.halstead.bugs.toFixed(2) }}<br>
  </div>
</script>

<script type="text/javascript" src="../../assets/scripts/bundles/core-bundle.js"></script>
<script type="text/javascript" src="../../assets/scripts/bundles/codemirror.js"></script>
<script type="text/javascript" src="../../assets/scripts/codemirror.markpopovertext.js"></script>
<script type="text/javascript" src="report.js"></script>
<script type="text/javascript" src="report.history.js"></script>
<script type="text/javascript" src="../../assets/scripts/plato-file.js"></script>
</body>
</html>
