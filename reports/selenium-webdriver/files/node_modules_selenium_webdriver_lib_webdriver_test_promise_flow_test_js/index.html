<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Plato - node_modules/selenium-webdriver/lib/webdriver/test/promise_flow_test.js</title>

  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="">
  <meta name="author" content="">

  <!--[if lt IE 9]>
  <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->

  <link href="../../assets/css/vendor/morris.css" rel="stylesheet">
  <link href="../../assets/css/vendor/bootstrap.css" rel="stylesheet">
  <link href="../../assets/css/vendor/font-awesome.css" rel="stylesheet">
  <link href="../../assets/css/vendor/codemirror.css" rel="stylesheet">
  <link href="../../assets/css/plato.css" rel="stylesheet">
  <link href="../../assets/css/plato-file.css" rel="stylesheet">

</head>

<body>

<div class="navbar navbar-fixed-top">
  <div class="container">
    <a class="navbar-brand" href="http://github.com/es-analysis/plato">Plato on Github</a>
    <ul class="nav navbar-nav">
      <li>
        <a href="../../index.html">Report Home</a>
      </li>
    </ul>
  </div>
</div>

<div class="jumbotron">
  <div class="container">
    <h1>node_modules/selenium-webdriver/lib/webdriver/test/promise_flow_test.js</h1>
  </div>
</div>

<div class="container aggregate-stats">
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Maintainability <a href="http://blogs.msdn.com/b/codeanalysis/archive/2007/11/20/maintainability-index-range-and-meaning.aspx"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="A value between 0 and 100 that represents the relative ease of maintaining the code. A high value means better maintainability." data-original-title="Maintainability Index"  data-container="body"></i></a></h2>
      <p class="stat">72.97</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Lines of code <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h2>
      <p class="stat">2272</p>
    </div>
  </div>
  <div class="row historical">
    <div class="col-md-6">
      <p id="chart_historical_maint" class="chart"></p>
    </div>
    <div class="col-md-6">
      <p id="chart_historical_sloc" class="chart"></p>
    </div>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Difficulty  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="The difficulty measure is related to the difficulty of the program to write or understand." data-original-title="Difficulty" data-container="body"></i></a></h2>
      <p class="stat">109.76</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Estimated Errors  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Halstead's delivered bugs is an estimate for the number of errors in the implementation." data-original-title="Delivered Bugs" data-container="body"></i></a></h2>
      <p class="stat">23.22</p>
    </div>
  </div>
</div>

<div class="container charts">
  <div class="row">
    <h2 class="header">Function weight</h2>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h3 class="chart-header">By Complexity <a href="http://en.wikipedia.org/wiki/Cyclomatic_complexity"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="This metric counts the number of distinct paths through a block of code. Lower values are better." data-original-title="Cyclomatic Complexity" data-container="body"></i></a></h3>
      <div id="fn-by-complexity" class="stat"></div>
    </div>
    <div class="col-md-6">
      <h3 class="chart-header">By SLOC  <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h3>
      <div id="fn-by-sloc" class="stat"></div>
    </div>
  </div>
</div>

<div class="container">
  <div class="row">
    <textarea id="file-source" class="col-md-12">// Copyright 2014 Software Freedom Conservancy. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

goog.require(&#039;goog.array&#039;);
goog.require(&#039;goog.functions&#039;);
goog.require(&#039;goog.string&#039;);
goog.require(&#039;goog.testing.FunctionMock&#039;);
goog.require(&#039;goog.testing.jsunit&#039;);
goog.require(&#039;goog.userAgent&#039;);
goog.require(&#039;webdriver.promise.ControlFlow&#039;);
goog.require(&#039;webdriver.stacktrace.Snapshot&#039;);
goog.require(&#039;webdriver.test.testutil&#039;);
goog.require(&#039;webdriver.testing.promise.FlowTester&#039;);

// Aliases for readability.
var STUB_ERROR = webdriver.test.testutil.STUB_ERROR,
    throwStubError = webdriver.test.testutil.throwStubError,
    assertIsStubError = webdriver.test.testutil.assertIsStubError,
    assertingMessages = webdriver.test.testutil.assertingMessages,
    callbackHelper = webdriver.test.testutil.callbackHelper,
    callbackPair = webdriver.test.testutil.callbackPair;

var clock, flow, flowHistory, flowTester;

function shouldRunTests() {
  return !goog.userAgent.IE || goog.userAgent.isVersionOrHigher(10);
}


function setUp() {
  clock = webdriver.test.testutil.createMockClock();
  flowTester = new webdriver.testing.promise.FlowTester(clock, goog.global);
  flow = webdriver.promise.controlFlow();
  webdriver.test.testutil.messages = [];
  flowHistory = [];
}


function tearDown() {
  flowTester.dispose();
  clock.dispose();
}

function schedule(msg, opt_return) {
  return scheduleAction(msg, function() {
    return opt_return;
  });
}

/**
 * @param {string} value The value to push.
 * @param {webdriver.promise.Promise=} opt_taskPromise Promise to return from
 *     the task.
 * @return {!webdriver.promise.Promise} The result.
 */
function schedulePush(value, opt_taskPromise) {
  return scheduleAction(value, function() {
    webdriver.test.testutil.messages.push(value);
    return opt_taskPromise;
  });
}

/**
 * @param {string} msg Debug message.
 * @param {!Function} actionFn The function.
 * @return {!webdriver.promise.Promise} The function result.
 */
function scheduleAction(msg, actionFn) {
  return webdriver.promise.controlFlow().execute(function() {
    flowHistory.push(msg);
    return actionFn();
  }, msg);
}

/**
 * @param {!Function} condition The condition function.
 * @param {number} timeout The timeout.
 * @param {string=} opt_message Optional message.
 * @return {!webdriver.promise.Promise} The wait result.
 */
function scheduleWait(condition, timeout, opt_message) {
  var msg = opt_message || &#039;&#039;;
  // It&#039;s not possible to hook into when the wait itself is scheduled, so
  // we record each iteration of the wait loop.
  var count = 0;
  return webdriver.promise.controlFlow().wait(function() {
    flowHistory.push((count++) + &#039;: &#039; + msg);
    return condition();
  }, timeout, msg);
}


/** @see {@link webdriver.testing.promise.FlowTester#turnEventLoop}. */
function turnEventLoop() {
  flowTester.turnEventLoop();
}


function runAndExpectSuccess(opt_callback) {
  flowTester.run();
  flowTester.verifySuccess();
  if (opt_callback) {
    opt_callback();
  }
}


function runAndExpectFailure(opt_errback) {
  flowTester.run();
  flowTester.verifyFailure();
  if (opt_errback) {
    opt_errback(flowTester.getFailure());
  }
}


function assertFlowHistory(var_args) {
  var expected = goog.array.slice(arguments, 0);
  assertArrayEquals(expected, flowHistory);
}


/**
 * @param {string=} opt_description A description of the task for debugging.
 * @return {!webdriver.promise.Task_} The new task.
 */
function createTask(opt_description) {
  return new webdriver.promise.Task_(
      webdriver.promise.controlFlow(),
      goog.nullFunction,
      opt_description || &#039;&#039;,
      new webdriver.stacktrace.Snapshot());
}

/**
 * @return {!webdriver.promise.Frame_}
 */
function createFrame() {
  return new webdriver.promise.Frame_(webdriver.promise.controlFlow());
}


function testAddChild_toEmptyFrame() {
  var frame = createFrame();

  var task1 = createTask(),
      task2 = createTask(),
      task3 = createTask();

  frame.addChild(task1);
  frame.addChild(task2);
  frame.addChild(task3);

  assertArrayEquals([task1, task2, task3], frame.children_);
}


function testAddChild_withSubframes() {
  var root = createFrame();

  var task1 = createTask(&#039;task1&#039;);
  root.addChild(task1);
  assertArrayEquals([task1], root.children_);

  var frame1 = createFrame();
  root.addChild(frame1);
  assertArrayEquals([task1, frame1], root.children_);

  var task2 = createTask(&#039;task2&#039;), task3 = createTask(&#039;task3&#039;);
  root.addChild(task2);
  root.addChild(task3);
  assertArrayEquals([task1, frame1], root.children_);
  assertArrayEquals([task2, task3], frame1.children_);

  frame1.isLocked_ = true;
  var task4 = createTask(&#039;task4&#039;), task5 = createTask(&#039;task5&#039;);
  root.addChild(task4);
  root.addChild(task5);
  assertArrayEquals([task1, frame1, task4, task5], root.children_);
  assertArrayEquals([task2, task3], frame1.children_);

  var frame2 = createFrame(),
      frame3 = createFrame(),
      task6 = createTask(&#039;task6&#039;),
      task7 = createTask(&#039;task7&#039;),
      task8 = createTask(&#039;task8&#039;);

  root.addChild(frame2);
  root.addChild(frame3);
  root.addChild(task6);
  frame3.isLocked_ = true;
  root.addChild(task7);
  frame2.isLocked_ = true;
  root.addChild(task8);

  assertArrayEquals([task1, frame1, task4, task5, frame2, task8],
      root.children_);
  assertArrayEquals([task2, task3], frame1.children_);
  assertArrayEquals([frame3, task7], frame2.children_);
  assertArrayEquals([task6], frame3.children_);
}

function testAddChild_insertingFramesIntoAnActiveFrame() {
  var root = createFrame(),
      frame2 = createFrame(),
      frame3 = createFrame(),
      task1 = createTask(&#039;task1&#039;);

  root.addChild(task1);
  root.isLocked_ = true;
  root.addChild(frame2);
  frame2.isLocked_ = true;
  root.addChild(frame3);
  frame3.isLocked_ = true;

  assertArrayEquals([frame2, frame3, task1], root.children_);
}

function testRemoveChild() {
  var frame1 = createFrame(),
      frame2 = createFrame();

  frame1.addChild(frame2);
  assertArrayEquals([frame2], frame1.children_);
  frame1.removeChild(frame2);
  assertArrayEquals([], frame1.children_);
}


function testResolveFrame() {
  var frame1 = createFrame(),
      frame2 = createFrame(),
      frame3 = createFrame();

  frame2.addChild(frame3);
  frame1.addChild(frame2);
  assertArrayEquals([frame3], frame2.children_);
  assertArrayEquals([frame2], frame1.children_);

  frame1.close = callbackHelper();
  frame2.close = callbackHelper();
  frame3.close = callbackHelper();

  var obj = {
    activeFrame_: frame2,
    commenceShutdown_: callbackHelper(),
    trimHistory_: callbackHelper(),
    history_: []
  };
  webdriver.promise.ControlFlow.prototype.resolveFrame_.call(obj, frame3);
  assertEquals(1, obj.trimHistory_.getCallCount());
  frame3.close.assertCalled(&#039;frame 3 not resolved&#039;);
  frame2.close.assertNotCalled(&#039;frame 2 should not be resolved yet&#039;);
  frame1.close.assertNotCalled(&#039;frame 1 should not be resolved yet&#039;);
  assertNull(frame3.getParent());
  assertArrayEquals([], frame2.children_);
  assertArrayEquals([frame2], frame1.children_);
  assertEquals(frame2, obj.activeFrame_);

  webdriver.promise.ControlFlow.prototype.resolveFrame_.call(obj, frame2);
  assertEquals(2, obj.trimHistory_.getCallCount());
  frame2.close.assertCalled(&#039;frame 2 not resolved&#039;);
  frame1.close.assertNotCalled(&#039;frame 1 should not be resolved yet&#039;);
  assertNull(frame2.getParent());
  assertArrayEquals([], frame1.children_);
  assertEquals(frame1, obj.activeFrame_);

  obj.commenceShutdown_.assertNotCalled();
  webdriver.promise.ControlFlow.prototype.resolveFrame_.call(obj, frame1);
  assertEquals(3, obj.trimHistory_.getCallCount());
  frame1.close.assertCalled(&#039;frame 1 not resolved&#039;);
  obj.commenceShutdown_.assertCalled();
  assertNull(frame1.getParent());
  assertNull(obj.activeFrame_);
}


function testGetNextTask() {
  var root = flow.activeFrame_ = createFrame();

  var frame1 = createFrame(),
      frame2 = createFrame(),
      frame3 = createFrame(),
      task1 = createTask(&#039;task1&#039;),
      task2 = createTask(&#039;task2&#039;),
      task3 = createTask(&#039;task3&#039;),
      task4 = createTask(&#039;task4&#039;),
      task5 = createTask(&#039;task5&#039;),
      task6 = createTask(&#039;task6&#039;),
      task7 = createTask(&#039;task7&#039;),
      task8 = createTask(&#039;task8&#039;);

  flow.commenceShutdown_ = callbackHelper();
  root.close = callbackHelper();
  frame1.close = callbackHelper();
  frame2.close = callbackHelper();
  frame3.close = callbackHelper();

  root.addChild(task1);
  root.addChild(frame1);
  root.addChild(task2);
  root.addChild(task3);
  assertArrayEquals([task1, frame1], root.children_);
  assertArrayEquals([task2, task3], frame1.children_);

  frame1.isLocked_ = true;
  root.addChild(task4);
  root.addChild(task5);
  assertArrayEquals([task1, frame1, task4, task5], root.children_);
  assertArrayEquals([task2, task3], frame1.children_);


  root.addChild(frame2);
  root.addChild(frame3);
  root.addChild(task6);
  frame3.isLocked_ = true;
  root.addChild(task7);
  frame2.isLocked_ = true;
  root.addChild(task8);

  assertArrayEquals([task1, frame1, task4, task5, frame2, task8],
      root.children_);
  assertArrayEquals([task2, task3], frame1.children_);
  assertArrayEquals([frame3, task7], frame2.children_);
  assertArrayEquals([task6], frame3.children_);

  assertEquals(task1, flow.getNextTask_());
  assertEquals(root, flow.activeFrame_);
  root.close.assertNotCalled();
  frame1.close.assertNotCalled();
  frame2.close.assertNotCalled();
  frame3.close.assertNotCalled();

  assertEquals(task2, flow.getNextTask_());
  assertEquals(frame1, flow.activeFrame_);
  root.close.assertNotCalled();
  frame1.close.assertNotCalled();
  frame2.close.assertNotCalled();
  frame3.close.assertNotCalled();

  assertEquals(task3, flow.getNextTask_());
  assertEquals(frame1, flow.activeFrame_);
  root.close.assertNotCalled();
  frame1.close.assertNotCalled();
  frame2.close.assertNotCalled();
  frame3.close.assertNotCalled();

  assertNull(flow.getNextTask_());
  assertNull(frame1.getParent());
  assertEquals(root, flow.activeFrame_);
  root.close.assertNotCalled();
  frame1.close.assertCalled();
  frame2.close.assertNotCalled();
  frame3.close.assertNotCalled();

  assertEquals(task4, flow.getNextTask_());
  assertEquals(root, flow.activeFrame_);
  root.close.assertNotCalled();
  frame2.close.assertNotCalled();
  frame3.close.assertNotCalled();

  assertEquals(task5, flow.getNextTask_());
  assertEquals(root, flow.activeFrame_);
  root.close.assertNotCalled();
  frame2.close.assertNotCalled();
  frame3.close.assertNotCalled();

  assertEquals(task6, flow.getNextTask_());
  assertEquals(frame3, flow.activeFrame_);
  root.close.assertNotCalled();
  frame2.close.assertNotCalled();
  frame3.close.assertNotCalled();

  assertNull(flow.getNextTask_());
  assertNull(frame3.getParent());
  assertEquals(frame2, flow.activeFrame_);
  root.close.assertNotCalled();
  frame2.close.assertNotCalled();
  frame3.close.assertCalled(&#039;frame3 should have been resolved&#039;);

  assertEquals(task7, flow.getNextTask_());
  assertEquals(frame2, flow.activeFrame_);
  root.close.assertNotCalled();
  frame2.close.assertNotCalled();

  assertNull(flow.getNextTask_());
  assertNull(frame2.getParent());
  assertEquals(root, flow.activeFrame_);
  root.close.assertNotCalled();
  frame2.close.assertCalled(&#039;frame2 should have been resolved&#039;);

  assertEquals(task8, flow.getNextTask_());
  assertEquals(root, flow.activeFrame_);
  root.close.assertNotCalled();

  flow.commenceShutdown_.assertNotCalled();
  assertNull(flow.getNextTask_());
  assertNull(flow.activeFrame_);
  root.close.assertCalled(&#039;Root should have been resolved&#039;);
  flow.commenceShutdown_.assertCalled();
}


function testAbortFrame_noActiveFrame() {
  flow.abortFrame_(STUB_ERROR);
  assertIsStubError(flowTester.getFailure());
  assertNull(flow.activeFrame_);
}


function testAbortFrame_activeIsOnlyFrame() {
  // Make the ControlFlow think the flow is not-idle.
  flow.emit(webdriver.promise.ControlFlow.EventType.SCHEDULE_TASK);

  flow.activeFrame_ = createFrame();
  flow.abortFrame_(STUB_ERROR);
  assertNull(flow.activeFrame_);
  flowTester.assertStillRunning();

  clock.tick();
  assertIsStubError(flowTester.getFailure());
}


function testAbortFrame_unhandledAbortionsBubbleUp() {
  var root = flow.activeFrame_ = createFrame(),
      frame1 = createFrame(),
      frame2 = createFrame(),
      frame3 = createFrame(),
      task = createTask();

  var rootHelper = installResolveHelper(root),
      frame1Helper = installResolveHelper(frame1),
      frame2Helper = installResolveHelper(frame2),
      frame3Helper = installResolveHelper(frame3);

  flow.abortNow_ = callbackHelper(assertIsStubError);

  root.addChild(frame1);
  root.addChild(frame2);
  root.addChild(frame3);
  root.addChild(task);

  assertArrayEquals([task], frame3.children_);
  assertArrayEquals([frame3], frame2.children_);
  assertArrayEquals([frame2], frame1.children_);
  assertArrayEquals([frame1], root.children_);

  assertEquals(task, flow.getNextTask_());
  assertEquals(frame3, flow.activeFrame_);
  flow.abortNow_.assertNotCalled();
  rootHelper.assertNeither();
  frame1Helper.assertNeither();
  frame2Helper.assertNeither();
  frame3Helper.assertNeither();

  flow.abortFrame_(STUB_ERROR);
  assertEquals(frame2, flow.activeFrame_);
  flow.abortNow_.assertNotCalled();
  rootHelper.assertNeither();
  frame1Helper.assertNeither();
  frame2Helper.assertNeither();
  frame3Helper.assertErrback();

  clock.tick();
  assertEquals(frame1, flow.activeFrame_);
  flow.abortNow_.assertNotCalled();
  rootHelper.assertNeither();
  frame1Helper.assertNeither();
  frame2Helper.assertErrback();

  clock.tick();
  assertEquals(root, flow.activeFrame_);
  flow.abortNow_.assertNotCalled();
  rootHelper.assertNeither();
  frame1Helper.assertErrback();

  clock.tick();
  assertNull(flow.activeFrame_);
  flow.abortNow_.assertNotCalled();
  rootHelper.assertErrback();

  clock.tick();
  assertNull(flow.activeFrame_);
  flow.abortNow_.assertCalled();

  function installResolveHelper(frame) {
    var abort = goog.bind(frame.abort, frame);
    var close = goog.bind(frame.close, frame);
    var pair = callbackPair(close, function(e) {
      assertIsStubError(e);
      abort(e);
    });
    frame.close = pair.callback;
    frame.abort = pair.errback;
    return pair;
  }
}


function testRunInNewFrame_nothingScheduledInFunction() {
  var root = flow.activeFrame_ = createFrame(),
      task1 = createTask(),
      task2 = createTask();

  root.addChild(task1);
  root.addChild(task2);
  assertArrayEquals([task1, task2], root.children_);

  assertEquals(task1, flow.getNextTask_());
  assertEquals(root, flow.activeFrame_);
  assertArrayEquals([task2], root.children_);

  var pair = callbackPair(assertUndefined);
  flow.runInNewFrame_(goog.nullFunction, pair.callback, pair.errback);
  pair.assertCallback();
  assertEquals(root, flow.activeFrame_);
  assertArrayEquals([task2], root.children_);
}


function testRunInNewFrame_functionThrows() {
  var root = flow.activeFrame_ = createFrame(),
      task1 = createTask(),
      task2 = createTask();

  root.addChild(task1);
  root.addChild(task2);
  assertArrayEquals([task1, task2], root.children_);

  assertEquals(task1, flow.getNextTask_());
  assertEquals(root, flow.activeFrame_);
  assertArrayEquals([task2], root.children_);

  var pair = callbackPair(null, assertIsStubError);
  flow.runInNewFrame_(throwStubError, pair.callback, pair.errback);
  pair.assertErrback();
  assertEquals(root, flow.activeFrame_);
  assertArrayEquals([task2], root.children_);
}


function testRunInNewFrame_functionThrowsAfterSchedulingTasks() {
  var root = flow.activeFrame_ = createFrame(),
      task1 = createTask(&#039;task1&#039;),
      task2 = createTask(&#039;task2&#039;);

  root.addChild(task1);
  root.addChild(task2);
  assertArrayEquals([task1, task2], root.children_);

  assertEquals(task1, flow.getNextTask_());
  assertEquals(root, flow.activeFrame_);
  assertArrayEquals([task2], root.children_);

  var pair = callbackPair(null, assertIsStubError);
  flow.runInNewFrame_(function() {
    flow.execute(goog.nullFunction);
    throw STUB_ERROR;
  }, pair.callback, pair.errback);
  pair.assertErrback();
  assertEquals(root, flow.activeFrame_);
  assertArrayEquals([task2], root.children_);
}


function testRunInNewFrame_whenThereIsNoCurrentActiveFrame_noopFunc() {
  var pair = callbackPair(assertUndefined);
  flow.runInNewFrame_(goog.nullFunction, pair.callback, pair.errback);
  pair.assertCallback();
  assertNull(flow.activeFrame_);
  assertEquals(&#039;[]&#039;, flow.getSchedule());
}


function testRunInNewFrame_whenThereIsNoCurrentActiveFrame_funcThrows() {
  var pair = callbackPair(null, assertIsStubError);
  flow.runInNewFrame_(throwStubError, pair.callback, pair.errback);
  pair.assertErrback();
  assertNull(flow.activeFrame_);
  assertEquals(&#039;[]&#039;, flow.getSchedule());
}


function
    testRunInNewFrame_whenThereIsNoCurrentActiveFrame_throwsAfterSchedule() {
  var pair = callbackPair(null, assertIsStubError);
  flow.runInNewFrame_(function() {
    flow.execute(&#039;task3&#039;, goog.nullFunction);
    throwStubError();
  }, pair.callback, pair.errback);
  pair.assertErrback();
  assertNull(flow.activeFrame_);
  assertEquals(&#039;[]&#039;, flow.getSchedule());
}


function testRunInNewFrame_returnsPrimitiveFunctionResultImmediately() {
  var pair = callbackPair(goog.partial(assertEquals, 23));
  flow.runInNewFrame_(function() {
    return 23;
  }, pair.callback, pair.errback);
  pair.assertCallback();
}


function testRunInNewFrame_updatesSchedulingFrameForContextOfFunction() {
  var root = flow.activeFrame_ = createFrame();

  var pair = callbackPair();
  flow.runInNewFrame_(function() {
    assertNotNull(flow.activeFrame_);
    assertNotNull(flow.schedulingFrame_);
    assertNotEquals(root, flow.schedulingFrame_);
    assertArrayEquals([flow.schedulingFrame_], root.children_);
    assertEquals(root, flow.schedulingFrame_.getParent());
  }, pair.callback, pair.errback);
  pair.assertCallback();

  assertEquals(&#039;Did not restore active frame&#039;, root, flow.activeFrame_);
}


function testRunInNewFrame_doesNotReturnUntilScheduledFrameResolved() {
  var root = flow.activeFrame_ = createFrame(),
      task1 = createTask(&#039;task1&#039;),
      task2 = createTask(&#039;task2&#039;);

  root.addChild(task1);
  root.addChild(task2);
  assertArrayEquals([task1, task2], root.children_);

  assertEquals(task1, flow.getNextTask_());
  assertEquals(root, flow.activeFrame_);
  assertArrayEquals([task2], root.children_);

  var pair = callbackPair();
  flow.runInNewFrame_(function() {
    schedule(&#039;task3&#039;);
  }, pair.callback, pair.errback);

  pair.assertNeither(&#039;active frame not resolved yet&#039;);
  assertEquals(root, flow.activeFrame_);

  var task = flow.getNextTask_();
  assertEquals(&#039;task3&#039;, task.getDescription());
  assertEquals(root.children_[0], flow.activeFrame_);
  pair.assertNeither(&#039;active frame still not resolved yet&#039;);

  assertNull(flow.getNextTask_());
  clock.tick();
  pair.assertCallback();
  assertEquals(root, flow.activeFrame_);
  assertEquals(task2, flow.getNextTask_());
}


function testRunInNewFrame_doesNotReturnUntilScheduledFrameResolved_nested() {
  var root = flow.activeFrame_ = createFrame();

  schedule(&#039;task1&#039;);
  schedule(&#039;task2&#039;);
  assertEquals(&#039;task1&#039;, flow.getNextTask_().getDescription());

  var pair1 = callbackPair(), pair2 = callbackPair();
  flow.runInNewFrame_(function() {
    schedule(&#039;task3&#039;);
    flow.runInNewFrame_(function() {
      schedule(&#039;task4&#039;);
    }, pair2.callback, pair2.errback);
  }, pair1.callback, pair1.errback);

  pair1.assertNeither();
  pair2.assertNeither();
  assertEquals(&#039;task3&#039;, flow.getNextTask_().getDescription());
  assertEquals(&#039;task4&#039;, flow.getNextTask_().getDescription());
  assertNull(flow.getNextTask_());
  clock.tick();
  pair1.assertNeither();
  pair2.assertCallback();
  assertNull(flow.getNextTask_());
  clock.tick();
  pair1.assertCallback();

  assertEquals(root, flow.activeFrame_);
  assertEquals(&#039;task2&#039;, flow.getNextTask_().getDescription());
}


function testScheduling_aSimpleFunction() {
  schedule(&#039;go&#039;);
  runAndExpectSuccess();
  assertFlowHistory(&#039;go&#039;);
}


function testScheduling_aSimpleSequence() {
  schedule(&#039;a&#039;);
  schedule(&#039;b&#039;);
  schedule(&#039;c&#039;);
  runAndExpectSuccess();
  assertFlowHistory(&#039;a&#039;, &#039;b&#039;, &#039;c&#039;);
}


function testScheduling_invokesCallbacksWhenTaskIsDone() {
  var callback;
  var d = new webdriver.promise.Deferred();
  schedule(&#039;a&#039;, d.promise).then(callback = callbackHelper(function(value) {
    assertEquals(123, value);
  }));
  callback.assertNotCalled(&#039;Callback should not have been called yet&#039;);

  turnEventLoop();
  callback.assertNotCalled(&#039;Task has not completed yet!&#039;);

  d.fulfill(123);
  callback.assertCalled(&#039;Callback should have been called!&#039;);
  runAndExpectSuccess();
  assertFlowHistory(&#039;a&#039;);
}


function testScheduling_blocksUntilPromiseReturnedByTaskIsResolved() {
  var d = new webdriver.promise.Deferred();
  schedule(&#039;a&#039;, d.promise);
  schedule(&#039;b&#039;);

  assertFlowHistory();
  turnEventLoop(); assertFlowHistory(&#039;a&#039;);
  turnEventLoop(); assertFlowHistory(&#039;a&#039;);  // Task &#039;a&#039; is still running.
  turnEventLoop(); assertFlowHistory(&#039;a&#039;);  // Task &#039;a&#039; is still running.

  d.fulfill(123);
  runAndExpectSuccess();
  assertFlowHistory(&#039;a&#039;, &#039;b&#039;);
}


function testScheduling_waitsForReturnedPromisesToResolve() {
  var d1 = new webdriver.promise.Deferred();
  var d2 = new webdriver.promise.Deferred();

  var callback;
  schedule(&#039;a&#039;, d1.promise).then(callback = callbackHelper(function(value) {
    assertEquals(&#039;fluffy bunny&#039;, value);
  }));

  callback.assertNotCalled(&#039;d1 not resolved yet&#039;);

  d1.fulfill(d2);
  callback.assertNotCalled(&#039;Should not be called yet; blocked on d2&#039;);

  d2.fulfill(&#039;fluffy bunny&#039;);

  runAndExpectSuccess();
  callback.assertCalled(&#039;d2 has been resolved&#039;);
  assertFlowHistory(&#039;a&#039;);
}


function testScheduling_executesTasksInAFutureTurnAfterTheyAreScheduled() {
  var count = 0;
  function incr() { count++; }

  scheduleAction(&#039;&#039;, incr);

  assertEquals(0, count);

  turnEventLoop();
  assertEquals(1, count);

  runAndExpectSuccess();
}


function testScheduling_executesOneTaskPerTurnOfTheEventLoop() {
  var count = 0;
  function incr() { count++; }

  scheduleAction(&#039;&#039;, incr);
  scheduleAction(&#039;&#039;, incr);

  assertEquals(0, count);
  turnEventLoop();
  assertEquals(1, count);
  turnEventLoop();
  assertEquals(2, count);

  runAndExpectSuccess();
}


function testScheduling_firstScheduledTaskIsWithinACallback() {
  webdriver.promise.fulfilled().then(function() {
    schedule(&#039;a&#039;);
    schedule(&#039;b&#039;);
    schedule(&#039;c&#039;);
  });
  runAndExpectSuccess();
  assertFlowHistory(&#039;a&#039;, &#039;b&#039;, &#039;c&#039;);
}


function testFraming_callbacksRunInANewFrame() {
  schedule(&#039;a&#039;).then(function() {
    schedule(&#039;c&#039;);
  });
  schedule(&#039;b&#039;);

  runAndExpectSuccess();
  assertFlowHistory(&#039;a&#039;, &#039;c&#039;, &#039;b&#039;);
}


function testFraming_lotsOfNesting() {
  schedule(&#039;a&#039;).then(function() {
    schedule(&#039;c&#039;).then(function() {
      schedule(&#039;e&#039;).then(function() {
        schedule(&#039;g&#039;);
      });
      schedule(&#039;f&#039;);
    });
    schedule(&#039;d&#039;);
  });
  schedule(&#039;b&#039;);

  runAndExpectSuccess();
  assertFlowHistory(&#039;a&#039;, &#039;c&#039;, &#039;e&#039;, &#039;g&#039;, &#039;f&#039;, &#039;d&#039;, &#039;b&#039;);
}


function testFraming_eachCallbackWaitsForAllScheduledTasksToComplete() {
  schedule(&#039;a&#039;).
      then(function() {
        schedule(&#039;b&#039;);
        schedule(&#039;c&#039;);
      }).
      then(function() {
        schedule(&#039;d&#039;);
      });
  schedule(&#039;e&#039;);

  runAndExpectSuccess();
  assertFlowHistory(&#039;a&#039;, &#039;b&#039;, &#039;c&#039;, &#039;d&#039;, &#039;e&#039;);
}


function testFraming_eachCallbackWaitsForReturnTasksToComplete() {
  schedule(&#039;a&#039;).
      then(function() {
        schedule(&#039;b&#039;);
        return schedule(&#039;c&#039;);
      }).
      then(function() {
        schedule(&#039;d&#039;);
      });
  schedule(&#039;e&#039;);

  runAndExpectSuccess();
  assertFlowHistory(&#039;a&#039;, &#039;b&#039;, &#039;c&#039;, &#039;d&#039;, &#039;e&#039;);
}


function testFraming_promiseCallbacks() {
  webdriver.promise.fulfilled().then(function() {
    schedule(&#039;b&#039;);
  });
  schedule(&#039;a&#039;);

  runAndExpectSuccess();
  assertFlowHistory(&#039;b&#039;, &#039;a&#039;);
}


function testFraming_allCallbacksInAFrameAreScheduledWhenPromiseIsResolved() {
  var a = schedule(&#039;a&#039;);
  a.then(function() { schedule(&#039;b&#039;); });
  schedule(&#039;c&#039;);
  a.then(function() { schedule(&#039;d&#039;); });
  schedule(&#039;e&#039;);

  runAndExpectSuccess();
  assertFlowHistory(&#039;a&#039;, &#039;b&#039;, &#039;d&#039;, &#039;c&#039;, &#039;e&#039;);
}


function testFraming_tasksScheduledInInActiveFrameDoNotGetPrecedence() {
  var d = new webdriver.promise.Deferred();

  schedule(&#039;a&#039;);
  schedule(&#039;b&#039;);
  d.then(function() { schedule(&#039;c&#039;); });

  d.fulfill();
  runAndExpectSuccess();
  assertFlowHistory(&#039;a&#039;, &#039;b&#039;, &#039;c&#039;);
}


function testFraming_tasksScheduledInAFrameGetPrecedence_1() {
  var a = schedule(&#039;a&#039;);
  schedule(&#039;b&#039;).then(function() {
    a.then(function() {
      schedule(&#039;c&#039;);
      schedule(&#039;d&#039;);
    });
    var e = schedule(&#039;e&#039;);
    a.then(function() {
      // When this function runs, |e| will not be resolved yet, so |f| and
      // |h| will be resolved first.  After |e| is resolved, |g| will be
      // scheduled in a new frame, resulting in: [j][f, h, i][g], so |g| is
      // expected to execute first.
      schedule(&#039;f&#039;);
      e.then(function() {
        schedule(&#039;g&#039;);
      });
      schedule(&#039;h&#039;);
    });
    schedule(&#039;i&#039;);
  });
  schedule(&#039;j&#039;);

  runAndExpectSuccess();
  assertFlowHistory(&#039;a&#039;, &#039;b&#039;, &#039;c&#039;, &#039;d&#039;, &#039;e&#039;, &#039;g&#039;, &#039;f&#039;, &#039;h&#039;, &#039;i&#039;, &#039;j&#039;);
}


function testErrorHandling_thrownErrorsArePassedToTaskErrback() {
  var callbacks = callbackPair(null, assertIsStubError);
  scheduleAction(&#039;function that throws&#039;, throwStubError).
      then(callbacks.callback, callbacks.errback);
  runAndExpectSuccess(callbacks.assertErrback);
}


function testErrorHandling_thrownErrorsPropagateThroughPromiseChain() {
  var callbacks = callbackPair(null, assertIsStubError);
  scheduleAction(&#039;function that throws&#039;, throwStubError).
      then(callbacks.callback).
      then(null, callbacks.errback);
  runAndExpectSuccess(callbacks.assertErrback);
}


function testErrorHandling_catchesErrorsFromFailedTasksInAFrame() {
  var errback;

  schedule(&#039;a&#039;).
      then(function() {
        schedule(&#039;b&#039;);
        scheduleAction(&#039;function that throws&#039;, throwStubError);
      }).
      then(null, errback = callbackHelper(assertIsStubError));

  runAndExpectSuccess();
  errback.assertCalled();
}


function testErrorHandling_abortsIfOnlyTaskThrowsAnError() {
  scheduleAction(&#039;function that throws&#039;, throwStubError);
  runAndExpectFailure(assertIsStubError);
}


function testErrorHandling_abortsIfOnlyTaskReturnsAnUnhandledRejection() {
  var rejected = webdriver.promise.rejected(STUB_ERROR);
  scheduleAction(&#039;function that throws&#039;, function() { return rejected; });
  runAndExpectFailure(assertIsStubError);
}


function testErrorHandling_abortsIfThereIsAnUnhandledRejection() {
  webdriver.promise.rejected(STUB_ERROR);
  schedule(&#039;this should not run&#039;);
  runAndExpectFailure(assertIsStubError);
  assertFlowHistory();
}


function testErrorHandling_abortsSequenceIfATaskFails() {
  schedule(&#039;a&#039;);
  schedule(&#039;b&#039;);
  scheduleAction(&#039;c&#039;, throwStubError);
  schedule(&#039;d&#039;);  // Should never execute.

  runAndExpectFailure(assertIsStubError);
  assertFlowHistory(&#039;a&#039;, &#039;b&#039;, &#039;c&#039;);
}


function testErrorHandling_abortsFromUnhandledFramedTaskFailures_1() {
  schedule(&#039;outer task&#039;).then(function() {
    scheduleAction(&#039;inner task&#039;, throwStubError);
  });
  schedule(&#039;this should not run&#039;);
  runAndExpectFailure(assertIsStubError);
  assertFlowHistory(&#039;outer task&#039;, &#039;inner task&#039;);
}


function testErrorHandling_abortsFromUnhandledFramedTaskFailures_2() {
  schedule(&#039;a&#039;).then(function() {
    schedule(&#039;b&#039;).then(function() {
      scheduleAction(&#039;c&#039;, throwStubError);
      // This should not execute.
      schedule(&#039;d&#039;);
    });
  });

  runAndExpectFailure(assertIsStubError);
  assertFlowHistory(&#039;a&#039;, &#039;b&#039;, &#039;c&#039;);
}


function testErrorHandling_abortsWhenErrorBubblesUpFromFullyResolvingAnObject() {
  var obj = {&#039;foo&#039;: webdriver.promise.rejected(STUB_ERROR)};
  scheduleAction(&#039;&#039;, function() {
    return webdriver.promise.fullyResolved(obj).
        then(function() {
          // Should never get here; STUB_ERROR should abort the flow above.
          return webdriver.promise.rejected(&#039;rejected 2&#039;);
        });
  });
  runAndExpectFailure(assertIsStubError);
}


function testErrorHandling_abortsWhenErrorBubblesUpFromFullyResolvingAnObject_withCallback() {
  var obj = {&#039;foo&#039;: webdriver.promise.rejected(STUB_ERROR)};
  var callback;
  scheduleAction(&#039;&#039;, function() {
    return webdriver.promise.fullyResolved(obj).
        then(function() {
          // Should never get here; STUB_ERROR should abort the flow above.
          return webdriver.promise.rejected(&#039;rejected 2&#039;);
        });
  }).then(callback = callbackHelper());

  callback.assertNotCalled();
  runAndExpectFailure(assertIsStubError);
}


function testErrorHandling_canCatchErrorsFromNestedTasks() {
  var errback;
  schedule(&#039;a&#039;).
      then(function() {
        return scheduleAction(&#039;b&#039;, throwStubError);
      }).
      thenCatch(errback = callbackHelper(assertIsStubError));
  runAndExpectSuccess();
  errback.assertCalled();
}


function testErrorHandling_nestedCommandFailuresCanBeCaughtAndSuppressed() {
  var errback;
  schedule(&#039;a&#039;).then(function() {
    return schedule(&#039;b&#039;).then(function() {
      return schedule(&#039;c&#039;).then(function() {
        throw STUB_ERROR;
      });
    });
  }).thenCatch(errback = callbackHelper(assertIsStubError));
  schedule(&#039;d&#039;);
  runAndExpectSuccess();
  assertFlowHistory(&#039;a&#039;, &#039;b&#039;, &#039;c&#039;, &#039;d&#039;);
  errback.assertCalled();
}


function testErrorHandling_aTaskWithAnUnhandledPromiseRejection() {
  schedule(&#039;a&#039;);
  scheduleAction(&#039;sub-tasks&#039;, function() {
    webdriver.promise.rejected(STUB_ERROR);
  });
  schedule(&#039;should never run&#039;);

  runAndExpectFailure(assertIsStubError);
  assertFlowHistory(&#039;a&#039;, &#039;sub-tasks&#039;);
}

function testErrorHandling_aTaskThatReutrnsARejectedPromise() {
  schedule(&#039;a&#039;);
  scheduleAction(&#039;sub-tasks&#039;, function() {
    return webdriver.promise.rejected(STUB_ERROR);
  });
  schedule(&#039;should never run&#039;);

  runAndExpectFailure(assertIsStubError);
  assertFlowHistory(&#039;a&#039;, &#039;sub-tasks&#039;)
}


function testErrorHandling_discardsSubtasksIfTaskThrows() {
  var pair = callbackPair(null, assertIsStubError);
  scheduleAction(&#039;a&#039;, function() {
    schedule(&#039;b&#039;);
    schedule(&#039;c&#039;);
    throwStubError();
  }).then(pair.callback, pair.errback);
  schedule(&#039;d&#039;);

  runAndExpectSuccess();
  pair.assertErrback();
  assertFlowHistory(&#039;a&#039;, &#039;d&#039;);
}


function testErrorHandling_discardsRemainingSubtasksIfASubtaskFails() {
  var pair = callbackPair(null, assertIsStubError);
  scheduleAction(&#039;a&#039;, function() {
    schedule(&#039;b&#039;);
    scheduleAction(&#039;c&#039;, throwStubError);
    schedule(&#039;d&#039;);
  }).then(pair.callback, pair.errback);
  schedule(&#039;e&#039;);

  runAndExpectSuccess();
  pair.assertErrback();
  assertFlowHistory(&#039;a&#039;, &#039;b&#039;, &#039;c&#039;, &#039;e&#039;);
}


function testTryFinally_happyPath() {
  /* Model:
     try {
       doFoo();
       doBar();
     } finally {
       doBaz();
     }
   */
  schedulePush(&#039;foo&#039;).
      then(goog.partial(schedulePush, &#039;bar&#039;)).
      thenFinally(goog.partial(schedulePush, &#039;baz&#039;));
  runAndExpectSuccess(assertingMessages(&#039;foo&#039;, &#039;bar&#039;, &#039;baz&#039;));
  assertFlowHistory(&#039;foo&#039;, &#039;bar&#039;, &#039;baz&#039;);
}


function testTryFinally_firstTryFails() {
  /* Model:
     try {
       doFoo();
       doBar();
     } finally {
       doBaz();
     }
   */

  scheduleAction(&#039;doFoo and throw&#039;, function() {
    webdriver.test.testutil.messages.push(&#039;foo&#039;);
    throw STUB_ERROR;
  }).then(goog.partial(schedulePush, &#039;bar&#039;)).
      thenFinally(goog.partial(schedulePush, &#039;baz&#039;));
  runAndExpectFailure(function(e) {
    assertIsStubError(e);
    webdriver.test.testutil.assertMessages(&#039;foo&#039;, &#039;baz&#039;);
  });
}


function testTryFinally_secondTryFails() {
  /* Model:
     try {
       doFoo();
       doBar();
     } finally {
       doBaz();
     }
   */

  schedulePush(&#039;foo&#039;).
      then(function() {
        return scheduleAction(&#039;doBar and throw&#039;, function() {
          webdriver.test.testutil.messages.push(&#039;bar&#039;);
          throw STUB_ERROR;
        });
      }).
      thenFinally(function() {
        return schedulePush(&#039;baz&#039;);
      });
  runAndExpectFailure(function(e) {
    assertIsStubError(e);
    webdriver.test.testutil.assertMessages(&#039;foo&#039;, &#039;bar&#039; , &#039;baz&#039;);
  });
}


function testDelayedNesting_1() {
  var a = schedule(&#039;a&#039;);
  schedule(&#039;b&#039;).then(function() {
    a.then(function() { schedule(&#039;c&#039;); });
    schedule(&#039;d&#039;);
  });
  schedule(&#039;e&#039;);

  runAndExpectSuccess();
  assertFlowHistory(&#039;a&#039;, &#039;b&#039;, &#039;c&#039;, &#039;d&#039;, &#039;e&#039;);
}


function testDelayedNesting_2() {
  var a = schedule(&#039;a&#039;);
  schedule(&#039;b&#039;).then(function() {
    a.then(function() { schedule(&#039;c&#039;); });
    schedule(&#039;d&#039;);
    a.then(function() { schedule(&#039;e&#039;); });
  });
  schedule(&#039;f&#039;);

  runAndExpectSuccess();
  assertFlowHistory(&#039;a&#039;, &#039;b&#039;, &#039;c&#039;, &#039;d&#039;, &#039;e&#039;, &#039;f&#039;);
}


function testDelayedNesting_3() {
  var a = schedule(&#039;a&#039;);
  schedule(&#039;b&#039;).then(function() {
    a.then(function() { schedule(&#039;c&#039;); });
    a.then(function() { schedule(&#039;d&#039;); });
  });
  schedule(&#039;e&#039;);

  runAndExpectSuccess();
  assertFlowHistory(&#039;a&#039;, &#039;b&#039;, &#039;c&#039;, &#039;d&#039;, &#039;e&#039;);
}


function testDelayedNesting_4() {
  var a = schedule(&#039;a&#039;);
  schedule(&#039;b&#039;).then(function() {
    a.then(function() { schedule(&#039;c&#039;); }).then(function() {
      schedule(&#039;d&#039;);
    });
    a.then(function() { schedule(&#039;e&#039;); });
  });
  schedule(&#039;f&#039;);

  runAndExpectSuccess();
  assertFlowHistory(&#039;a&#039;, &#039;b&#039;, &#039;c&#039;, &#039;d&#039;, &#039;e&#039;, &#039;f&#039;);
}


function testDelayedNesting_5() {
  var a = schedule(&#039;a&#039;);
  schedule(&#039;b&#039;).then(function() {
    var c;
    a.then(function() { c = schedule(&#039;c&#039;); }).then(function() {
      schedule(&#039;d&#039;);
      a.then(function() { schedule(&#039;e&#039;); });
      c.then(function() { schedule(&#039;f&#039;); });
      schedule(&#039;g&#039;);
    });
    a.then(function() { schedule(&#039;h&#039;); });
  });
  schedule(&#039;i&#039;);

  runAndExpectSuccess();
  assertFlowHistory(&#039;a&#039;, &#039;b&#039;, &#039;c&#039;, &#039;d&#039;, &#039;e&#039;, &#039;f&#039;, &#039;g&#039;, &#039;h&#039;, &#039;i&#039;);
}


function testCancelsTerminationEventIfNewCommandIsScheduled() {
  schedule(&#039;a&#039;);
  turnEventLoop();
  assertFlowHistory(&#039;a&#039;);
  flowTester.assertStillRunning();
  turnEventLoop();
  schedule(&#039;b&#039;);

  runAndExpectSuccess();
  assertFlowHistory(&#039;a&#039;, &#039;b&#039;);
}

function testWaiting_onAConditionThatIsAlwaysTrue() {
  scheduleWait(function() { return true;}, 0, &#039;waiting on true&#039;);
  runAndExpectSuccess();
  assertFlowHistory(&#039;0: waiting on true&#039;);
}


function testWaiting_aSimpleCountingCondition() {
  var count = 0;
  scheduleWait(function() {
    return ++count == 3;
  }, 200, &#039;counting to 3&#039;);

  turnEventLoop();  // Start the flow; triggers first condition poll.
  assertEquals(1, count);
  clock.tick(100);  // Poll 2 more times.
  clock.tick(100);
  assertEquals(3, count);

  runAndExpectSuccess();
}


function testWaiting_aConditionThatReturnsAPromise() {
  var d = new webdriver.promise.Deferred();

  scheduleWait(function() {
    return d.promise;
  }, 0, &#039;waiting for promise&#039;);

  turnEventLoop();
  flowTester.assertStillRunning();

  // Should be able to turn the event loop a few times since we&#039;re blocked
  // on our wait condition.
  turnEventLoop();
  turnEventLoop();

  d.fulfill(123);
  runAndExpectSuccess();
}


function testWaiting_aConditionThatReturnsAPromise_2() {
  var count = 0;
  scheduleWait(function() {
    return webdriver.promise.fulfilled(++count == 3);
  }, 200, &#039;waiting for promise&#039;);

  turnEventLoop();  // Start the flow; triggers first condition poll.
  clock.tick(100);  // Poll 2 more times.
  clock.tick(100);
  assertEquals(3, count);

  runAndExpectSuccess();
}


function testWaiting_aConditionThatReturnsATaskResult() {
  var count = 0;
  scheduleWait(function() {
    return scheduleAction(&#039;increment count&#039;, function() {
      return ++count == 3;
    });
  }, 200, &#039;counting to 3&#039;);
  schedule(&#039;post wait&#039;);

  turnEventLoop();
  assertEquals(0, count);
  assertFlowHistory(&#039;0: counting to 3&#039;);

  turnEventLoop();  // Runs scheduled task.
  turnEventLoop();
  assertFlowHistory(
      &#039;0: counting to 3&#039;, &#039;increment count&#039;);
  assertEquals(1, count);

  clock.tick(100);  // Advance clock for next polling pass.
  assertEquals(1, count);
  turnEventLoop();
  clock.tick();
  assertEquals(2, count);
  turnEventLoop();
  assertFlowHistory(
      &#039;0: counting to 3&#039;, &#039;increment count&#039;,
      &#039;1: counting to 3&#039;, &#039;increment count&#039;);

  clock.tick(100);  // Advance clock for next polling pass.
  assertEquals(2, count);
  turnEventLoop();
  clock.tick();
  assertEquals(3, count);
  turnEventLoop();
  assertFlowHistory(
      &#039;0: counting to 3&#039;, &#039;increment count&#039;,
      &#039;1: counting to 3&#039;, &#039;increment count&#039;,
      &#039;2: counting to 3&#039;, &#039;increment count&#039;);

  runAndExpectSuccess();
  assertEquals(3, count);
  assertFlowHistory(
      &#039;0: counting to 3&#039;, &#039;increment count&#039;,
      &#039;1: counting to 3&#039;, &#039;increment count&#039;,
      &#039;2: counting to 3&#039;, &#039;increment count&#039;,
      &#039;post wait&#039;);
}


function testWaiting_conditionContainsASubtask() {
  var count = 0;
  scheduleWait(function() {
    schedule(&#039;sub task&#039;);
    return ++count == 3;
  }, 200, &#039;counting to 3&#039;);
  schedule(&#039;post wait&#039;);

  runAndExpectSuccess();
  assertEquals(3, count);
  assertFlowHistory(
      &#039;0: counting to 3&#039;, &#039;sub task&#039;,
      &#039;1: counting to 3&#039;, &#039;sub task&#039;,
      &#039;2: counting to 3&#039;, &#039;sub task&#039;,
      &#039;post wait&#039;);
}


function testWaiting_cancelsWaitIfScheduledTaskFails() {
  var pair = callbackPair(null, assertIsStubError);
  scheduleWait(function() {
    scheduleAction(&#039;boom&#039;, throwStubError);
    schedule(&#039;this should not run&#039;);
    return true;
  }, 200, &#039;waiting to go boom&#039;).then(pair.callback, pair.errback);
  schedule(&#039;post wait&#039;);

  runAndExpectSuccess();
  assertFlowHistory(
      &#039;0: waiting to go boom&#039;, &#039;boom&#039;,
      &#039;post wait&#039;);
}


function testWaiting_failsIfConditionThrows() {
  var callbacks = callbackPair(null, assertIsStubError);
  scheduleWait(throwStubError, 0, &#039;goes boom&#039;).
      then(callbacks.callback, callbacks.errback);
  schedule(&#039;post wait&#039;);
  runAndExpectSuccess();
  assertFlowHistory(&#039;0: goes boom&#039;, &#039;post wait&#039;);
  callbacks.assertErrback();
}


function testWaiting_failsIfConditionReturnsARejectedPromise() {
  var callbacks = callbackPair(null, assertIsStubError);
  scheduleWait(function() {
    return webdriver.promise.rejected(STUB_ERROR);
  }, 0, &#039;goes boom&#039;).then(callbacks.callback, callbacks.errback);
  schedule(&#039;post wait&#039;);
  runAndExpectSuccess();
  assertFlowHistory(&#039;0: goes boom&#039;, &#039;post wait&#039;);
  callbacks.assertErrback();
}


function testWaiting_failsIfConditionHasUnhandledRejection() {
  var callbacks = callbackPair(null, assertIsStubError);
  scheduleWait(function() {
    webdriver.promise.controlFlow().execute(throwStubError);
  }, 0, &#039;goes boom&#039;).then(callbacks.callback, callbacks.errback);
  schedule(&#039;post wait&#039;);
  runAndExpectSuccess();
  assertFlowHistory(&#039;0: goes boom&#039;, &#039;post wait&#039;);
  callbacks.assertErrback();
}


function testWaiting_failsIfConditionHasAFailedSubtask() {
  var callbacks = callbackPair(null, assertIsStubError);
  var count = 0;
  scheduleWait(function() {
    scheduleAction(&#039;maybe throw&#039;, function() {
      if (++count == 2) {
        throw STUB_ERROR;
      }
    });
  }, 200, &#039;waiting&#039;).then(callbacks.callback, callbacks.errback);
  schedule(&#039;post wait&#039;);

  turnEventLoop();
  assertEquals(0, count);

  turnEventLoop();  // Runs scheduled task.
  assertEquals(1, count);

  clock.tick(100);  // Advance clock for next polling pass.
  assertEquals(1, count);

  runAndExpectSuccess();
  assertEquals(2, count);
  assertFlowHistory(
      &#039;0: waiting&#039;, &#039;maybe throw&#039;,
      &#039;1: waiting&#039;, &#039;maybe throw&#039;,
      &#039;post wait&#039;);
}


function testWaiting_pollingLoopWaitsForAllScheduledTasksInCondition() {
  var count = 0;
  scheduleWait(function() {
    scheduleAction(&#039;increment count&#039;, function() { ++count; });
    return count &gt;= 3;
  }, 350, &#039;counting to 3&#039;);
  schedule(&#039;post wait&#039;);

  turnEventLoop();
  assertEquals(0, count);

  turnEventLoop();  // Runs scheduled task.
  turnEventLoop();
  assertEquals(1, count);

  clock.tick(100);  // Advance clock for next polling pass.
  assertEquals(1, count);
  turnEventLoop();
  clock.tick();
  assertEquals(2, count);

  clock.tick(100);  // Advance clock for next polling pass.
  assertEquals(2, count);

  runAndExpectSuccess();
  assertEquals(4, count);
  assertFlowHistory(
      &#039;0: counting to 3&#039;, &#039;increment count&#039;,
      &#039;1: counting to 3&#039;, &#039;increment count&#039;,
      &#039;2: counting to 3&#039;, &#039;increment count&#039;,
      &#039;3: counting to 3&#039;, &#039;increment count&#039;,
      &#039;post wait&#039;);
}


function testWaiting_blocksNextTaskOnWait() {
  var count = 0;
  scheduleWait(function() {
    return ++count == 3;
  }, 200, &#039;counting to 3&#039;);
  schedule(&#039;post wait&#039;);

  turnEventLoop();  // Start the flow; triggers first condition poll.
  assertFlowHistory(&#039;0: counting to 3&#039;);
  assertEquals(1, count);
  clock.tick(100);  // Poll 2 more times.
  assertFlowHistory(
      &#039;0: counting to 3&#039;,
      &#039;1: counting to 3&#039;);
  clock.tick(100);
  assertFlowHistory(
      &#039;0: counting to 3&#039;,
      &#039;1: counting to 3&#039;,
      &#039;2: counting to 3&#039;);
  assertEquals(3, count);

  runAndExpectSuccess();
  assertFlowHistory(
      &#039;0: counting to 3&#039;,
      &#039;1: counting to 3&#039;,
      &#039;2: counting to 3&#039;,
      &#039;post wait&#039;);
}


function testWaiting_timesOut_zeroTimeout() {
  scheduleWait(function() { return false; }, 0, &#039;always false&#039;);
  runAndExpectFailure(goog.nullFunction);
}

function testWaiting_timesOut_nonZeroTimeout() {
  var count = 0;
  scheduleWait(function() {
    return ++count == 3;
  }, 100, &#039;counting to 3&#039;);

  turnEventLoop();  // Start the flow; triggers first condition poll.
  clock.tick(100);  // Poll 2 more times.
  assertEquals(2, count);

  runAndExpectFailure(function() {
    assertFlowHistory(&#039;0: counting to 3&#039;, &#039;1: counting to 3&#039;);
    assertEquals(2, count);
  });
}


function testWaiting_shouldFailIfConditionReturnsARejectedPromise() {
  var count = 0;
  scheduleWait(function() {
    return webdriver.promise.rejected(STUB_ERROR);
  }, 100, &#039;counting to 3&#039;);

  runAndExpectFailure(assertIsStubError);
}


function testWaiting_callbacks() {
  var pair = callbackPair();

  scheduleWait(function() { return true;}, 0, &#039;waiting on true&#039;).
      then(pair.callback, pair.errback);
  pair.assertNeither(&#039;Wait not expected to be done yet&#039;);
  turnEventLoop();
  pair.assertCallback(&#039;Wait callback not called!&#039;);
  runAndExpectSuccess();
}


function testWaiting_errbacks() {
  scheduleWait(function() { return false; }, 0, &#039;always false&#039;);

  runAndExpectFailure();
}


function testWaiting_scheduleWithIntermittentWaits() {
  schedule(&#039;a&#039;);
  scheduleWait(function() { return true; }, 0, &#039;wait 1&#039;);
  schedule(&#039;b&#039;);
  scheduleWait(function() { return true; }, 0, &#039;wait 2&#039;);
  schedule(&#039;c&#039;);
  scheduleWait(function() { return true; }, 0, &#039;wait 3&#039;);

  runAndExpectSuccess();
  assertFlowHistory(&#039;a&#039;, &#039;0: wait 1&#039;, &#039;b&#039;, &#039;0: wait 2&#039;, &#039;c&#039;, &#039;0: wait 3&#039;);
}


function testWaiting_scheduleWithIntermittentAndNestedWaits() {
  schedule(&#039;a&#039;);
  scheduleWait(function() { return true; }, 0, &#039;wait 1&#039;).
      then(function() {
        schedule(&#039;d&#039;);
        scheduleWait(function() { return true; }, 0, &#039;wait 2&#039;);
        schedule(&#039;e&#039;);
      });
  schedule(&#039;b&#039;);
  scheduleWait(function() { return true; }, 0, &#039;wait 3&#039;);
  schedule(&#039;c&#039;);
  scheduleWait(function() { return true; }, 0, &#039;wait 4&#039;);

  runAndExpectSuccess();
  assertFlowHistory(
      &#039;a&#039;, &#039;0: wait 1&#039;, &#039;d&#039;, &#039;0: wait 2&#039;, &#039;e&#039;, &#039;b&#039;, &#039;0: wait 3&#039;, &#039;c&#039;,
      &#039;0: wait 4&#039;);
}


function testSubtasks() {
  schedule(&#039;a&#039;);
  scheduleAction(&#039;sub-tasks&#039;, function() {
    schedule(&#039;c&#039;);
    schedule(&#039;d&#039;);
  });
  schedule(&#039;b&#039;);

  runAndExpectSuccess();
  assertFlowHistory(&#039;a&#039;, &#039;sub-tasks&#039;, &#039;c&#039;, &#039;d&#039;, &#039;b&#039;);
}


function testSubtasks_nesting() {
  schedule(&#039;a&#039;);
  scheduleAction(&#039;sub-tasks&#039;, function() {
    schedule(&#039;b&#039;);
    scheduleAction(&#039;sub-sub-tasks&#039;, function() {
      schedule(&#039;c&#039;);
      schedule(&#039;d&#039;);
    });
    schedule(&#039;e&#039;);
  });
  schedule(&#039;f&#039;);

  runAndExpectSuccess();
  assertFlowHistory(
      &#039;a&#039;, &#039;sub-tasks&#039;, &#039;b&#039;, &#039;sub-sub-tasks&#039;, &#039;c&#039;, &#039;d&#039;, &#039;e&#039;, &#039;f&#039;);
}


function testSubtasks_taskReturnsSubTaskResult_1() {
  schedule(&#039;a&#039;);
  scheduleAction(&#039;sub-tasks&#039;, function() {
    return schedule(&#039;c&#039;);
  });
  schedule(&#039;b&#039;);

  runAndExpectSuccess();
  assertFlowHistory(&#039;a&#039;, &#039;sub-tasks&#039;, &#039;c&#039;, &#039;b&#039;);
}


function testSubtasks_taskReturnsSubTaskResult_2() {
  var callback;
  schedule(&#039;a&#039;);
  schedule(&#039;sub-tasks&#039;, webdriver.promise.fulfilled(123)).
      then(callback = callbackHelper(function(value) {
        assertEquals(123, value);
      }));
  schedule(&#039;b&#039;);

  runAndExpectSuccess();
  assertFlowHistory(&#039;a&#039;, &#039;sub-tasks&#039;,&#039;b&#039;);
  callback.assertCalled();
}


function testSubtasks_subTaskFails_1() {
  schedule(&#039;a&#039;);
  scheduleAction(&#039;sub-tasks&#039;, function() {
    scheduleAction(&#039;sub-task that fails&#039;, throwStubError);
  });
  schedule(&#039;should never execute&#039;);

  runAndExpectFailure(assertIsStubError);
  assertFlowHistory(&#039;a&#039;, &#039;sub-tasks&#039;, &#039;sub-task that fails&#039;);
}


function testSubtasks_subTaskFails_2() {
  schedule(&#039;a&#039;);
  scheduleAction(&#039;sub-tasks&#039;, function() {
    return webdriver.promise.rejected(STUB_ERROR);
  });
  schedule(&#039;should never execute&#039;);

  runAndExpectFailure(assertIsStubError);
  assertFlowHistory(&#039;a&#039;, &#039;sub-tasks&#039;);
}


function testSubtasks_subTaskFails_3() {
  var callbacks = callbackPair(null, assertIsStubError);

  schedule(&#039;a&#039;);
  scheduleAction(&#039;sub-tasks&#039;, function() {
    return webdriver.promise.rejected(STUB_ERROR);
  }).then(callbacks.callback, callbacks.errback);
  schedule(&#039;b&#039;);

  runAndExpectSuccess();
  assertFlowHistory(&#039;a&#039;, &#039;sub-tasks&#039;, &#039;b&#039;);
  callbacks.assertErrback();
}


function testEventLoopWaitsOnPendingPromiseRejections_oneRejection() {
  var d = new webdriver.promise.Deferred;
  scheduleAction(&#039;one&#039;, function() {
    return d.promise;
  });
  scheduleAction(&#039;two&#039;, goog.nullFunction);

  turn();
  assertFlowHistory(&#039;one&#039;);
  turn(-1);
  d.reject(STUB_ERROR);
  clock.tick(1);
  assertFlowHistory(&#039;one&#039;);
  runAndExpectFailure(assertIsStubError);
  assertFlowHistory(&#039;one&#039;);

  function turn(opt_minusN) {
    var n = webdriver.promise.ControlFlow.EVENT_LOOP_FREQUENCY;
    if (opt_minusN) n -= Math.abs(opt_minusN);
    clock.tick(n);
  }
}


function testEventLoopWaitsOnPendingPromiseRejections_multipleRejections() {
  var once = Error(&#039;once&#039;);
  var twice = Error(&#039;twice&#039;);
  var onError = new goog.testing.FunctionMock(&#039;onError&#039;,
      goog.testing.Mock.LOOSE);
  onError(once);
  onError(twice);
  onError.$replay();

  flow.on(
      webdriver.promise.ControlFlow.EventType.UNCAUGHT_EXCEPTION, onError);

  scheduleAction(&#039;one&#039;, goog.nullFunction);
  scheduleAction(&#039;two&#039;, goog.nullFunction);

  turn();
  assertFlowHistory(&#039;one&#039;);
  turn(-1);
  webdriver.promise.rejected(once);
  webdriver.promise.rejected(twice);
  clock.tick(1);
  assertFlowHistory(&#039;one&#039;);
  turn();
  onError.$verify();

  function turn(opt_minusN) {
    var n = webdriver.promise.ControlFlow.EVENT_LOOP_FREQUENCY;
    if (opt_minusN) n -= Math.abs(opt_minusN);
    clock.tick(n);
  }
}

function testCancelsPromiseReturnedByCallbackIfFrameFails_promiseCallback() {
  var isCancellationError = function(e) {
    assertEquals(&#039;CancellationError: Error: ouch&#039;, e.toString());
  };

  var chainPair = callbackPair(null, isCancellationError);
  var deferredPair = callbackPair(null, isCancellationError);

  var d = new webdriver.promise.Deferred();
  d.then(deferredPair.callback, deferredPair.errback);

  webdriver.promise.fulfilled().
      then(function() {
        scheduleAction(&#039;boom&#039;, throwStubError);
        schedule(&#039;this should not run&#039;);
        return d.promise;
      }).
      then(chainPair.callback, chainPair.errback);

  runAndExpectSuccess();
  assertFlowHistory(&#039;boom&#039;);
  chainPair.assertErrback(&#039;chain errback not invoked&#039;);
  deferredPair.assertErrback(&#039;deferred errback not invoked&#039;);
}

function testCancelsPromiseReturnedByCallbackIfFrameFails_taskCallback() {
  var isCancellationError = function(e) {
    assertEquals(&#039;CancellationError: Error: ouch&#039;, e.toString());
  };

  var chainPair = callbackPair(null, isCancellationError);
  var deferredPair = callbackPair(null, isCancellationError);

  var d = new webdriver.promise.Deferred();
  d.then(deferredPair.callback, deferredPair.errback);

  schedule(&#039;a&#039;).
      then(function() {
        scheduleAction(&#039;boom&#039;, throwStubError);
        schedule(&#039;this should not run&#039;);
        return d.promise;
      }).
      then(chainPair.callback, chainPair.errback);

  runAndExpectSuccess();
  assertFlowHistory(&#039;a&#039;, &#039;boom&#039;);
  chainPair.assertErrback(&#039;chain errback not invoked&#039;);
  deferredPair.assertErrback(&#039;deferred errback not invoked&#039;);
}

function testMaintainsOrderInCallbacksWhenATaskReturnsAPromise() {
  schedule(&#039;__start__&#039;, webdriver.promise.fulfilled()).
      then(function() {
        webdriver.test.testutil.messages.push(&#039;a&#039;);
        schedulePush(&#039;b&#039;);
        webdriver.test.testutil.messages.push(&#039;c&#039;);
      }).
      then(function() {
        webdriver.test.testutil.messages.push(&#039;d&#039;);
      });
  schedulePush(&#039;e&#039;);

  runAndExpectSuccess();
  assertFlowHistory(&#039;__start__&#039;, &#039;b&#039;, &#039;e&#039;);
  webdriver.test.testutil.assertMessages(&#039;a&#039;, &#039;c&#039;, &#039;b&#039;, &#039;d&#039;, &#039;e&#039;);
}

function assertFrame(description, frame) {
  var regexp = new RegExp(&#039;^&#039; + description + &#039;(\\n    at .*)*$&#039;);
  assertTrue(
      &#039;Frame did not match expected regex:&#039; +
          &#039;\n expected: &#039; + regexp +
          &#039;\n was: &#039; + frame,
     regexp.test(frame));
}

function testHistory_removesLastTaskEachTimeANewTaskIsStarted() {
  schedule(&#039;one&#039;).then(function() {
    var flowHistory = webdriver.promise.controlFlow().getHistory();
    assertEquals(1, flowHistory.length);
    assertFrame(&#039;one&#039;, flowHistory[0]);
  });
  schedule(&#039;two&#039;).then(function() {
    var flowHistory = webdriver.promise.controlFlow().getHistory();
    assertEquals(1, flowHistory.length);
    assertFrame(&#039;two&#039;, flowHistory[0]);
  });
  schedule(&#039;three&#039;).then(function() {
    var flowHistory = webdriver.promise.controlFlow().getHistory();
    assertEquals(1, flowHistory.length);
    assertFrame(&#039;three&#039;, flowHistory[0]);
  });
  runAndExpectSuccess();
  assertEquals(0, webdriver.promise.controlFlow().getHistory().length);
}

function testHistory_clearsSubtaskHistoryWhenParentTaskCompletes() {
  scheduleAction(&#039;one&#039;, function() {
    schedule(&#039;two&#039;).then(function() {
      var flowHistory = webdriver.promise.controlFlow().getHistory();
      assertEquals(2, flowHistory.length);
      assertFrame(&#039;two&#039;, flowHistory[0]);
      assertFrame(&#039;one&#039;, flowHistory[1]);
    });
  }).then(function() {
    var flowHistory = webdriver.promise.controlFlow().getHistory();
    assertEquals(1, flowHistory.length);
    assertFrame(&#039;one&#039;, flowHistory[0]);
  });
  runAndExpectSuccess();
  assertFlowHistory(&#039;one&#039;, &#039;two&#039;);
  assertEquals(0, webdriver.promise.controlFlow().getHistory().length);
}

function testHistory_preservesHistoryWhenChildTaskFails() {
  scheduleAction(&#039;one&#039;, function() {
    scheduleAction(&#039;two&#039;, function() {
      scheduleAction(&#039;three&#039;, throwStubError);
    });
  }).then(fail, function() {
    var flowHistory = webdriver.promise.controlFlow().getHistory();
    assertEquals(3, flowHistory.length);
    assertFrame(&#039;three&#039;, flowHistory[0]);
    assertFrame(&#039;two&#039;, flowHistory[1]);
    assertFrame(&#039;one&#039;, flowHistory[2]);
  });
  runAndExpectSuccess();
  assertFlowHistory(&#039;one&#039;, &#039;two&#039;, &#039;three&#039;);
  assertEquals(0, webdriver.promise.controlFlow().getHistory().length);
}

function testHistory_subtaskFailureIsIgnoredByErrback() {
  scheduleAction(&#039;one&#039;, function() {

    scheduleAction(&#039;two&#039;, function() {
      scheduleAction(&#039;three&#039;, throwStubError);
    }).thenCatch(goog.nullFunction);

    schedule(&#039;post error&#039;).then(function() {
      var flowHistory = webdriver.promise.controlFlow().getHistory();
      assertEquals(2, flowHistory.length);
      assertFrame(&#039;post error&#039;, flowHistory[0]);
      assertFrame(&#039;one&#039;, flowHistory[1]);
    });
  });
  runAndExpectSuccess();
  assertFlowHistory(&#039;one&#039;, &#039;two&#039;, &#039;three&#039;, &#039;post error&#039;);
  assertEquals(0, webdriver.promise.controlFlow().getHistory().length);
}

function assertFlowIs(flow) {
  assertEquals(flow, webdriver.promise.controlFlow());
}

function testOwningFlowIsActivatedForExecutingTasks() {
  var defaultFlow = webdriver.promise.controlFlow();

  webdriver.promise.createFlow(function(flow) {
    assertFlowIs(flow);

    defaultFlow.execute(function() {
      assertFlowIs(defaultFlow);
    });
  });

  runAndExpectSuccess();
  assertFlowIs(defaultFlow);
}

function testCreateFlowReturnsPromisePairedWithCreatedFlow() {
  var defaultFlow = webdriver.promise.controlFlow();

  var newFlow;
  webdriver.promise.createFlow(function(flow) {
    newFlow = flow;
    assertFlowIs(newFlow);
  }).then(function() {
    assertFlowIs(newFlow);
  });

  runAndExpectSuccess();
}

function testDeferredFactoriesCreateForActiveFlow() {
  var e = Error();
  var defaultFlow = webdriver.promise.controlFlow();
  webdriver.promise.fulfilled().then(function() {
    assertFlowIs(defaultFlow);
  });
  webdriver.promise.rejected(e).then(null, function(err) {
    assertEquals(e, err);
    assertFlowIs(defaultFlow);
  });
  webdriver.promise.defer().then(function() {
    assertFlowIs(defaultFlow);
  });

  var newFlow;
  webdriver.promise.createFlow(function(flow) {
    newFlow = flow;
    webdriver.promise.fulfilled().then(function() {
      assertFlowIs(flow);
    });
    webdriver.promise.rejected(e).then(null, function(err) {
      assertEquals(e, err);
      assertFlowIs(flow);
    });
    webdriver.promise.defer().then(function() {
      assertFlowIs(flow);
    });
  }).then(function() {
    assertFlowIs(newFlow);
  });

  runAndExpectSuccess();
}

function testFlowsSynchronizeWithThemselvesNotEachOther() {
  var defaultFlow = webdriver.promise.controlFlow();
  schedulePush(&#039;a&#039;, &#039;a&#039;);
  webdriver.promise.controlFlow().timeout(250);
  schedulePush(&#039;b&#039;, &#039;b&#039;);

  webdriver.promise.createFlow(function() {
    schedulePush(&#039;c&#039;, &#039;c&#039;);
    schedulePush(&#039;d&#039;, &#039;d&#039;);
  });

  runAndExpectSuccess();
  webdriver.test.testutil.assertMessages(&#039;a&#039;, &#039;c&#039;, &#039;d&#039;, &#039;b&#039;);
}

function testUnhandledErrorsAreReportedToTheOwningFlow() {
  var error1 = Error();
  var error2 = Error();
  var defaultFlow = webdriver.promise.controlFlow();

  var newFlow;
  webdriver.promise.createFlow(function(flow) {
    newFlow = flow;
    webdriver.promise.rejected(error1);

    defaultFlow.execute(function() {
      webdriver.promise.rejected(error2);
    });
  });

  flowTester.run();
  assertEquals(error2, flowTester.getFailure(defaultFlow));
  assertEquals(error1, flowTester.getFailure(newFlow));
}

function testCanSynchronizeFlowsByReturningPromiseFromOneToAnother() {
  var defaultFlow = webdriver.promise.controlFlow();
  schedulePush(&#039;a&#039;, &#039;a&#039;);
  webdriver.promise.controlFlow().timeout(250);
  schedulePush(&#039;b&#039;, &#039;b&#039;);

  webdriver.promise.createFlow(function() {
    schedulePush(&#039;c&#039;, &#039;c&#039;);
    scheduleAction(&#039;&#039;, function() {
      return defaultFlow.execute(function() {
        assertFlowIs(defaultFlow);
        return schedulePush(&#039;e&#039;, &#039;e&#039;);
      });
    });
    schedulePush(&#039;d&#039;, &#039;d&#039;);
  });

  runAndExpectSuccess();
  webdriver.test.testutil.assertMessages(&#039;a&#039;, &#039;c&#039;, &#039;b&#039;, &#039;e&#039;, &#039;d&#039;);
}

function testFramesWaitToCompleteForPendingRejections() {
  webdriver.promise.controlFlow().execute(function() {
    webdriver.promise.rejected(STUB_ERROR);
  });

  runAndExpectFailure(assertIsStubError);
}

function testSynchronizeErrorsPropagateToOuterFlow() {
  var defaultFlow = webdriver.promise.controlFlow();

  var newFlow;
  webdriver.promise.createFlow(function(flow) {
    newFlow = flow;
    return defaultFlow.execute(function() {
      webdriver.promise.rejected(STUB_ERROR);
    });
  });

  flowTester.run();
  assertIsStubError(flowTester.getFailure(defaultFlow));
  flowTester.verifySuccess(newFlow);  // Error was transferred to new flow.
}

function testFailsIfErrbackThrows() {
  webdriver.promise.rejected(&#039;&#039;).then(null, throwStubError);
  runAndExpectFailure(assertIsStubError);
}

function testFailsIfCallbackReturnsRejectedPromise() {
  webdriver.promise.fulfilled().then(function() {
    return webdriver.promise.rejected(STUB_ERROR);
  });
  runAndExpectFailure(assertIsStubError);
}

function testAbortsFrameIfTaskFails() {
  webdriver.promise.fulfilled().then(function() {
    webdriver.promise.controlFlow().execute(throwStubError);
  });
  runAndExpectFailure(assertIsStubError);
}

function testAbortsFramePromisedChainedFromTaskIsNotHandled() {
  webdriver.promise.fulfilled().then(function() {
    webdriver.promise.controlFlow().execute(goog.nullFunction).
        then(throwStubError);
  });
  runAndExpectFailure(assertIsStubError);
}

function testTrapsChainedUnhandledRejectionsWithinAFrame() {
  var pair = callbackPair(null, assertIsStubError);
  webdriver.promise.fulfilled().then(function() {
    webdriver.promise.controlFlow().execute(goog.nullFunction).
        then(throwStubError);
  }).then(pair.callback, pair.errback);

  runAndExpectSuccess();
  pair.assertErrback();
}


function testCancelsRemainingTasksIfFrameThrowsDuringScheduling() {
  var task1, task2;
  var pair = callbackPair(null, assertIsStubError);
  var flow = webdriver.promise.controlFlow();
  flow.execute(function() {
    task1 = flow.execute(goog.nullFunction);
    task2 = flow.execute(goog.nullFunction);
    throw STUB_ERROR;
  }).then(pair.callback, pair.errback);

  runAndExpectSuccess();
  pair.assertErrback();

  assertFalse(task1.isPending());
  pair = callbackPair();
  task1.then(pair.callback, pair.errback);
  pair.assertErrback();

  assertFalse(task2.isPending());
  pair = callbackPair();
  task2.then(pair.callback, pair.errback);
  pair.assertErrback();
}

function testCancelsRemainingTasksInFrameIfATaskFails() {
  var task;
  var pair = callbackPair(null, assertIsStubError);
  var flow = webdriver.promise.controlFlow();
  flow.execute(function() {
    flow.execute(throwStubError);
    task = flow.execute(goog.nullFunction);
  }).then(pair.callback, pair.errback);

  runAndExpectSuccess();
  pair.assertErrback();

  assertFalse(task.isPending());
  pair = callbackPair();
  task.then(pair.callback, pair.errback);
  pair.assertErrback();
}

function testAnnotatesRejectedPromiseErrorsWithFlowState() {
  var error = Error(&#039;original message&#039;);
  var originalStack = webdriver.stacktrace.format(error).stack;

  var pair = callbackPair(null, function(e) {
    assertEquals(error, e);
    assertEquals(&#039;original message&#039;, e.message);
    assertTrue(
      &#039;Expected to start with: &#039; + originalStack,
      goog.string.startsWith(e.stack, originalStack));

    var parts = e.stack.split(&#039;\n==== async task ====\n&#039;);
    assertEquals(2, parts.length);
    assertEquals(originalStack, parts[0]);
  });

  webdriver.promise.createFlow(function(flow) {
    var d = webdriver.promise.defer();
    d.reject(error);
    d.then(pair.callback, pair.errback);
  });

  runAndExpectSuccess();
  pair.assertErrback();
}

function testAnnotatesChainedErrors() {
  var error = Error(&#039;original message&#039;);
  var originalStack = webdriver.stacktrace.format(error).stack;

  var pair = callbackPair(null, function(e) {
    assertEquals(error, e);
    assertEquals(&#039;original message&#039;, e.message);
    assertTrue(
      &#039;Expected to start with: &#039; + originalStack,
      goog.string.startsWith(e.stack, originalStack));

    var parts = e.stack.split(&#039;\n==== async task ====\n&#039;);
    assertEquals(2, parts.length);
    assertEquals(originalStack, parts[0]);
  });

  webdriver.promise.createFlow(function(flow) {
    var rejected = webdriver.promise.rejected(error);
    webdriver.promise.fulfilled(rejected).
        then(pair.callback, pair.errback);
  });

  runAndExpectSuccess();
  pair.assertErrback();
}

function testAnnotatesRejectedPromiseErrorsWithFlowState_taskErrorBubblesUp() {
  var error = Error(&#039;original message&#039;);
  var originalStack = webdriver.stacktrace.format(error).stack;
  var pair = callbackPair(null, function(e) {
    assertEquals(error, e);
    assertEquals(&#039;original message&#039;, e.message);
    assertTrue(
      &#039;Expected to start with: &#039; + originalStack,
      goog.string.startsWith(e.stack, originalStack));

    var parts = e.stack.split(&#039;\n==== async task ====\n&#039;);
    assertEquals(3, parts.length);
    assertEquals(originalStack, parts[0]);
  });

  webdriver.promise.createFlow(function(flow) {
    flow.execute(function() { throw error; });
  }).then(pair.callback, pair.errback);

  runAndExpectSuccess();
  pair.assertErrback();
}

function testDoesNotAnnotatedRejectedPromisesIfGivenNonErrorValue() {
  var error = {};

  var pair = callbackPair(null, function(e) {
    assertEquals(error, e);
    for (var val in error) {
      fail(&#039;Did not expect error to be modified&#039;);
    }
  });

  webdriver.promise.createFlow(function(flow) {
    var d = webdriver.promise.defer();
    d.reject(error);
    d.then(pair.callback, pair.errback);
  });

  runAndExpectSuccess();
  pair.assertErrback();
}

function testDoesNotModifyRejectionErrorIfPromiseNotInsideAFlow() {
  var error = Error(&#039;original message&#039;);
  var originalStack = error.stack;
  var originalStr = error.toString();

  var pair = callbackPair(null, function(e) {
    assertEquals(error, e);
    assertEquals(&#039;original message&#039;, e.message);
    assertEquals(originalStack, e.stack);
    assertEquals(originalStr, e.toString());
  });

  webdriver.promise.rejected(error).then(pair.callback, pair.errback);
  pair.assertErrback();
}</textarea>
  </div>
</div>

<footer class="footer">
  <div class="container">
    <p>.</p>
  </div>
</footer>

<script type="text/html" id="complexity-popover-template">
  <div class="complexity-notice">
    Complexity : {{ complexity.cyclomatic }} <br>
    Length : {{ complexity.halstead.length }} <br>
    Difficulty : {{ complexity.halstead.difficulty.toFixed(2) }} <br>
    Est # bugs : {{ complexity.halstead.bugs.toFixed(2) }}<br>
  </div>
</script>

<script type="text/javascript" src="../../assets/scripts/bundles/core-bundle.js"></script>
<script type="text/javascript" src="../../assets/scripts/bundles/codemirror.js"></script>
<script type="text/javascript" src="../../assets/scripts/codemirror.markpopovertext.js"></script>
<script type="text/javascript" src="report.js"></script>
<script type="text/javascript" src="report.history.js"></script>
<script type="text/javascript" src="../../assets/scripts/plato-file.js"></script>
</body>
</html>
