<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Plato - node_modules/selenium-webdriver/lib/webdriver/test/promise_test.js</title>

  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="">
  <meta name="author" content="">

  <!--[if lt IE 9]>
  <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->

  <link href="../../assets/css/vendor/morris.css" rel="stylesheet">
  <link href="../../assets/css/vendor/bootstrap.css" rel="stylesheet">
  <link href="../../assets/css/vendor/font-awesome.css" rel="stylesheet">
  <link href="../../assets/css/vendor/codemirror.css" rel="stylesheet">
  <link href="../../assets/css/plato.css" rel="stylesheet">
  <link href="../../assets/css/plato-file.css" rel="stylesheet">

</head>

<body>

<div class="navbar navbar-fixed-top">
  <div class="container">
    <a class="navbar-brand" href="http://github.com/es-analysis/plato">Plato on Github</a>
    <ul class="nav navbar-nav">
      <li>
        <a href="../../index.html">Report Home</a>
      </li>
    </ul>
  </div>
</div>

<div class="jumbotron">
  <div class="container">
    <h1>node_modules/selenium-webdriver/lib/webdriver/test/promise_test.js</h1>
  </div>
</div>

<div class="container aggregate-stats">
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Maintainability <a href="http://blogs.msdn.com/b/codeanalysis/archive/2007/11/20/maintainability-index-range-and-meaning.aspx"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="A value between 0 and 100 that represents the relative ease of maintaining the code. A high value means better maintainability." data-original-title="Maintainability Index"  data-container="body"></i></a></h2>
      <p class="stat">74.71</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Lines of code <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h2>
      <p class="stat">1627</p>
    </div>
  </div>
  <div class="row historical">
    <div class="col-md-6">
      <p id="chart_historical_maint" class="chart"></p>
    </div>
    <div class="col-md-6">
      <p id="chart_historical_sloc" class="chart"></p>
    </div>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Difficulty  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="The difficulty measure is related to the difficulty of the program to write or understand." data-original-title="Difficulty" data-container="body"></i></a></h2>
      <p class="stat">139.06</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Estimated Errors  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Halstead's delivered bugs is an estimate for the number of errors in the implementation." data-original-title="Delivered Bugs" data-container="body"></i></a></h2>
      <p class="stat">17.23</p>
    </div>
  </div>
</div>

<div class="container charts">
  <div class="row">
    <h2 class="header">Function weight</h2>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h3 class="chart-header">By Complexity <a href="http://en.wikipedia.org/wiki/Cyclomatic_complexity"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="This metric counts the number of distinct paths through a block of code. Lower values are better." data-original-title="Cyclomatic Complexity" data-container="body"></i></a></h3>
      <div id="fn-by-complexity" class="stat"></div>
    </div>
    <div class="col-md-6">
      <h3 class="chart-header">By SLOC  <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h3>
      <div id="fn-by-sloc" class="stat"></div>
    </div>
  </div>
</div>

<div class="container">
  <div class="row">
    <textarea id="file-source" class="col-md-12">// Copyright 2014 Software Freedom Conservancy. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

goog.require(&#039;goog.testing.jsunit&#039;);
goog.require(&#039;webdriver.promise&#039;);
goog.require(&#039;webdriver.promise.Deferred&#039;);
goog.require(&#039;webdriver.test.testutil&#039;);

// Aliases for readability.
var assertIsPromise = webdriver.test.testutil.assertIsPromise,
    assertNotPromise = webdriver.test.testutil.assertNotPromise,
    callbackHelper = webdriver.test.testutil.callbackHelper,
    callbackPair = webdriver.test.testutil.callbackPair,
    assertIsStubError = webdriver.test.testutil.assertIsStubError,
    throwStubError = webdriver.test.testutil.throwStubError,
    STUB_ERROR = webdriver.test.testutil.STUB_ERROR;

var app, clock, uncaughtExceptions;

function setUp() {
  clock = webdriver.test.testutil.createMockClock();
  uncaughtExceptions = [];

  app = webdriver.promise.controlFlow();
  app.on(webdriver.promise.ControlFlow.EventType.UNCAUGHT_EXCEPTION,
         goog.bind(uncaughtExceptions.push, uncaughtExceptions));

  // The application timer defaults to a protected copies of the native
  // timing functions. Reset it to use |window|, which has been modified
  // by the MockClock above.
  app.timer = window;
}


function tearDown() {
  webdriver.test.testutil.consumeTimeouts();
  clock.dispose();
  app.reset();
  assertArrayEquals(
      &#039;Did not expect any uncaught exceptions&#039;, [], uncaughtExceptions);
}


function testCanDetectPromiseLikeObjects() {
  assertIsPromise(new webdriver.promise.Promise());
  assertIsPromise(new webdriver.promise.Deferred());
  assertIsPromise(new webdriver.promise.Deferred().promise);
  assertIsPromise({then:function() {}});

  assertNotPromise(undefined);
  assertNotPromise(null);
  assertNotPromise(&#039;&#039;);
  assertNotPromise(true);
  assertNotPromise(false);
  assertNotPromise(1);
  assertNotPromise({});
  assertNotPromise({then:1});
  assertNotPromise({then:true});
  assertNotPromise({then:&#039;&#039;});

}


function testSimpleResolveScenario() {
  var callback = callbackHelper(function(value) {
    assertEquals(123, value);
  });

  var deferred = new webdriver.promise.Deferred();
  deferred.then(callback);

  callback.assertNotCalled();
  deferred.fulfill(123);
  callback.assertCalled();
}


function testRegisteringACallbackPostResolution() {
  var callback, deferred = new webdriver.promise.Deferred();

  deferred.then((callback = callbackHelper(function(value) {
    assertEquals(123, value);
  })));
  deferred.fulfill(123);
  callback.assertCalled();

  deferred.then((callback = callbackHelper(function(value) {
    assertEquals(123, value);
  })));
  callback.assertCalled();
}


function testRegisterACallbackViaDeferredPromise() {
  var callback, deferred = new webdriver.promise.Deferred();

  deferred.promise.then((callback = callbackHelper(function(value) {
    assertEquals(123, value);
  })));
  deferred.fulfill(123);
  callback.assertCalled();

  deferred.promise.then((callback = callbackHelper(function(value) {
    assertEquals(123, value);
  })));
  callback.assertCalled();
}


function testTwoStepResolvedChain() {
  var callback, start = new webdriver.promise.Deferred();

  var next = start.then((callback = callbackHelper(function(value) {
    assertEquals(123, value);
    return value + 1;
  })));

  assertIsPromise(next);

  callback.assertNotCalled();
  start.fulfill(123);
  callback.assertCalled();

  next.then((callback = callbackHelper(function(value) {
    assertEquals(124, value);
  })));
  callback.assertCalled();
}


function testCanResolveOnlyOnce_resolved() {
  var deferred = new webdriver.promise.Deferred();
  deferred.fulfill(1);
  deferred.fulfill(2);
  deferred.reject(3);

  var callback;
  deferred.then(callback = callbackHelper(function(value) {
    assertEquals(1, value);
  }));
  callback.assertCalled();
}


function testCanResolveOnlyOnce_rejected() {
  var deferred = new webdriver.promise.Deferred();
  deferred.reject(STUB_ERROR);
  deferred.fulfill(1);
  deferred.reject(2);

  var callback;
  deferred.then(null, callback = callbackHelper(assertIsStubError));
  callback.assertCalled();
}


function testIfFulfilledWithOtherPromiseCannotChangeValueWhileWaiting() {
  var deferred = webdriver.promise.defer();
  var other = webdriver.promise.defer();

  debugger;
  deferred.fulfill(other.promise);
  deferred.fulfill(&#039;different value&#039;);

  var callback = callbackHelper(function(value) {
    assertEquals(123, value);
  });

  deferred.then(callback);
  callback.assertNotCalled();

  other.fulfill(123);
  callback.assertCalled();
}


function testOnlyGoesDownListenerPath_resolved() {
  var callback = callbackHelper();
  var errback = callbackHelper();

  webdriver.promise.fulfilled().then(callback, errback);
  callback.assertCalled();
  errback.assertNotCalled();
}


function testOnlyGoesDownListenerPath_rejected() {
  var callback = callbackHelper();
  var errback = callbackHelper();

  webdriver.promise.rejected().then(callback, errback);
  callback.assertNotCalled();
  errback.assertCalled();
}


function testCatchingAndSuppressingRejectionErrors() {
  var errback = callbackHelper(assertIsStubError);
  var callback = callbackHelper(function() {
    assertUndefined(arguments[0]);
  });

  webdriver.promise.rejected(STUB_ERROR).
      thenCatch(errback).
      then(callback);
  errback.assertCalled();
  callback.assertCalled();
}


function testThrowingNewRejectionErrors() {
  var errback1 = callbackHelper(assertIsStubError);
  var error2 = Error(&#039;hi&#039;);
  var errback2 = callbackHelper(function(error) {
    assertEquals(error2, error);
  });

  webdriver.promise.rejected(STUB_ERROR).
      thenCatch(function(error) {
        errback1(error);
        throw error2;
      }).
      thenCatch(errback2);
  errback1.assertCalled();
  errback2.assertCalled();
}


function testThenFinally_nonFailingCallbackDoesNotSuppressOriginalError() {
  var done = callbackHelper(assertIsStubError);
  webdriver.promise.rejected(STUB_ERROR).
      thenFinally(goog.nullFunction).
      thenCatch(done);
  done.assertCalled();
}


function testThenFinally_failingCallbackSuppressesOriginalError() {
  var done = callbackHelper(assertIsStubError);
  webdriver.promise.rejected(new Error(&#039;original&#039;)).
      thenFinally(throwStubError).
      thenCatch(done);
  done.assertCalled();
}


function testThenFinally_callbackThrowsAfterFulfilledPromise() {
  var done = callbackHelper(assertIsStubError);
  webdriver.promise.fulfilled().
      thenFinally(throwStubError).
      thenCatch(done);
  done.assertCalled();
}


function testThenFinally_callbackReturnsRejectedPromise() {
  var done = callbackHelper(assertIsStubError);
  webdriver.promise.fulfilled().
      thenFinally(function() {
        return webdriver.promise.rejected(STUB_ERROR);
      }).
      thenCatch(done);
  done.assertCalled();
}


function testChainingThen_AllResolved() {
  var callbacks = [
    callbackHelper(function(value) {
      assertEquals(128, value);
      return value * 2;
    }),
    callbackHelper(function(value) {
      assertEquals(256, value);
      return value * 2;
    }),
    callbackHelper(function(value) {
      assertEquals(512, value);
    })
  ];

  var deferred = new webdriver.promise.Deferred();
  deferred.
      then(callbacks[0]).
      then(callbacks[1]).
      then(callbacks[2]);

  callbacks[0].assertNotCalled();
  callbacks[1].assertNotCalled();
  callbacks[2].assertNotCalled();

  deferred.fulfill(128);

  callbacks[0].assertCalled();
  callbacks[1].assertCalled();
  callbacks[2].assertCalled();
}


function testWhen_ReturnsAResolvedPromiseIfGivenANonPromiseValue() {
  var ret = webdriver.promise.when(&#039;abc&#039;);
  assertIsPromise(ret);

  var callback;
  ret.then(callback = callbackHelper(function (value) {
    assertEquals(&#039;abc&#039;, value);
  }));
  callback.assertCalled();
}


function testWhen_PassesRawErrorsToCallbacks() {
  var error = new Error(&#039;boo!&#039;), callback;
  webdriver.promise.when(error, callback = callbackHelper(function(value) {
    assertEquals(error, value);
  }));
  callback.assertCalled();
}


function testWhen_WaitsForValueToBeResolvedBeforeInvokingCallback() {
  var d = new webdriver.promise.Deferred(), callback;
  webdriver.promise.when(d, callback = callbackHelper(function(value) {
    assertEquals(&#039;hi&#039;, value);
  }));
  callback.assertNotCalled();
  d.fulfill(&#039;hi&#039;);
  callback.assertCalled();
}


function testWhen_canCancelReturnedPromise() {
  var callbacks = callbackPair(null, function(e) {
    assertTrue(e instanceof webdriver.promise.CancellationError);
    assertEquals(&#039;just because&#039;, e.message);
  });

  var promiseLike = {
    then: function(cb, eb) {
      this.callback = cb;
      this.errback = eb;
    }
  };

  var promise = webdriver.promise.when(promiseLike,
      callbacks.callback, callbacks.errback);

  assertTrue(promise.isPending());
  promise.cancel(&#039;just because&#039;);
  callbacks.assertErrback();

  // The following should have no effect.
  promiseLike.callback();
  promiseLike.errback();
}


function testFiresUncaughtExceptionEventIfRejectionNeverHandled() {
  webdriver.promise.rejected(STUB_ERROR);
  var handler = callbackHelper(assertIsStubError);

  // so tearDown() doesn&#039;t throw
  app.reset();
  app.on(webdriver.promise.ControlFlow.EventType.UNCAUGHT_EXCEPTION, handler);
  clock.tick();
  handler.assertCalled();
}


function testWaitsIfCallbackReturnsAPromiseObject() {
  var callback1, callback2;
  var callback1Return = new webdriver.promise.Deferred();

  webdriver.promise.fulfilled(&#039;hi&#039;).
      then(callback1 = callbackHelper(function(value) {
        assertEquals(&#039;hi&#039;, value);
        return callback1Return;
      })).
      then(callback2 = callbackHelper(function(value) {
        assertEquals(&#039;bye&#039;, value);
      }));

  callback1.assertCalled();
  callback2.assertNotCalled();
  callback1Return.fulfill(&#039;bye&#039;);
  callback2.assertCalled();
}


function testWaitsIfCallbackReturnsAPromiseLikeObject() {
  var callback1, callback2;
  var callback1Return = {
    then: function(callback) {
      this.callback = callback;
    },
    fulfill: function(value) {
      this.callback(value);
    }
  };

  webdriver.promise.fulfilled(&#039;hi&#039;).
      then(callback1 = callbackHelper(function(value) {
        assertEquals(&#039;hi&#039;, value);
        return callback1Return;
      })).
      then(callback2 = callbackHelper(function(value) {
        assertEquals(&#039;bye&#039;, value);
      }));

  callback1.assertCalled();
  callback2.assertNotCalled();
  callback1Return.fulfill(&#039;bye&#039;);
  callback2.assertCalled();
}


function testResolvingAPromiseWithAnotherPromiseCreatesAChain_ourPromise() {
  var d1 = new webdriver.promise.Deferred();
  var d2 = new webdriver.promise.Deferred();
  var callback1, callback2;

  d1.then(callback1 = callbackHelper(function(value) {
    assertEquals(4, value);
  }));

  var d2promise = d2.then(callback2 = callbackHelper(function(value) {
    assertEquals(2, value);
    return value * 2;
  }));

  callback1.assertNotCalled();
  callback2.assertNotCalled();

  d2.fulfill(2);
  callback1.assertNotCalled();
  callback2.assertCalled();

  d1.fulfill(d2promise);
  callback1.assertCalled();
  callback2.assertCalled();
}


function testResolvingAPromiseWithAnotherPromiseCreatesAChain_otherPromise() {
  var d = new webdriver.promise.Deferred(), callback;
  d.then(callback = callbackHelper(function(value) {
    assertEquals(4, value);
  }));

  var otherPromise = {
    then: function(callback) {
      this.callback = callback;
    },
    fulfill: function(value) {
      this.callback(value);
    }
  };

  callback.assertNotCalled();
  d.fulfill(otherPromise);
  otherPromise.fulfill(4);
  callback.assertCalled();
}


function testRejectingAPromiseWithAnotherPromiseCreatesAChain_ourPromise() {
  var d1 = new webdriver.promise.Deferred();
  var d2 = new webdriver.promise.Deferred();
  var callback1, errback1, callback2;

  d1.then(callback1 = callbackHelper(),
          errback1 = callbackHelper(assertIsStubError));

  var d2promise = d2.then(callback2 = callbackHelper(function(value) {
    assertEquals(2, value);
    return STUB_ERROR;
  }));

  callback1.assertNotCalled();
  errback1.assertNotCalled();
  callback2.assertNotCalled();

  d2.fulfill(2);
  callback1.assertNotCalled();
  errback1.assertNotCalled();
  callback2.assertCalled();

  d1.reject(d2promise);
  callback1.assertNotCalled();
  errback1.assertCalled();
  callback2.assertCalled();
}


function testRejectingAPromiseWithAnotherPromiseCreatesAChain_otherPromise() {
  var d = new webdriver.promise.Deferred(), callback, errback;
  d.then(callback = callbackHelper(),
         errback = callbackHelper(assertIsStubError));

  var otherPromise = {
    then: function(callback) {
      this.callback = callback;
    },
    fulfill: function(value) {
      this.callback(value);
    }
  };

  d.reject(otherPromise);
  callback.assertNotCalled();
  errback.assertNotCalled();

  otherPromise.fulfill(STUB_ERROR);
  callback.assertNotCalled();
  errback.assertCalled();
}


function testResolvingADeferredWithAnotherCopiesTheResolvedValue() {
  var d1 = new webdriver.promise.Deferred();
  var d2 = new webdriver.promise.Deferred();
  var callback1, callback2;

  d1.then(callback1 = callbackHelper(function(value) {
    assertEquals(2, value);
  }));

  d2.then(callback2 = callbackHelper(function(value) {
    assertEquals(2, value);
    return 4;
  }));

  d1.fulfill(d2);
  callback1.assertNotCalled();
  callback2.assertNotCalled();

  d2.fulfill(2);
  callback1.assertCalled();
  callback2.assertCalled();
}


function testCannotResolveADeferredWithItself() {
  var deferred = new webdriver.promise.Deferred();
  assertThrows(goog.bind(deferred.fulfill, deferred, deferred));
}


function testSkipsNullPointsInPromiseChain_callbacks() {
  var errback1, errback2, callback;
  webdriver.promise.fulfilled(&#039;hi&#039;).
      thenCatch(errback1 = callbackHelper()).
      thenCatch(errback2 = callbackHelper()).
      then(callback = callbackHelper(function(value) {
        assertEquals(&#039;hi&#039;, value);
      }));

  errback1.assertNotCalled();
  errback2.assertNotCalled();
  callback.assertCalled();
}


function testSkipsNullPointsInPromiseChain_errbacks() {
  var errback1, errback2, callback;
  webdriver.promise.fulfilled(&#039;hi&#039;).
      thenCatch(errback1 = callbackHelper()).
      thenCatch(errback2 = callbackHelper()).
      then(callback = callbackHelper(function(value) {
        assertEquals(&#039;hi&#039;, value);
      }));

  errback1.assertNotCalled();
  errback2.assertNotCalled();
  callback.assertCalled();
}


function testFullyResolved_primitives() {
  function runTest(value) {
    var callback, errback;
    webdriver.promise.fullyResolved(value).then(
        callback = callbackHelper(function(resolved) {
          assertEquals(value, resolved);
        }),
        errback = callbackHelper());

    errback.assertNotCalled(
        &#039;Did not expect errback to be called for: &#039; + value);
    callback.assertCalled(&#039;Expected callback to be called for: &#039; + value);
  }

  runTest(true);
  runTest(goog.nullFunction);
  runTest(null);
  runTest(123);
  runTest(&#039;foo bar&#039;);
  runTest(undefined);
}


function testFullyResolved_arrayOfPrimitives() {
  var array = [true, goog.nullFunction, null, 123, &#039;&#039;, undefined, 1];
  var callbacks = callbackPair(function(resolved) {
    assertEquals(array, resolved);
    assertArrayEquals([true, goog.nullFunction, null, 123, &#039;&#039;, undefined, 1],
        resolved);
  });

  webdriver.promise.fullyResolved(array).then(
      callbacks.callback, callbacks.errback);

  callbacks.assertCallback();
}

function testFullyResolved_nestedArrayOfPrimitives() {
  var array = [true, [goog.nullFunction, null, 123], &#039;&#039;, undefined];
  var callback, errback;
  webdriver.promise.fullyResolved(array).then(
      callback = callbackHelper(function(resolved) {
        assertEquals(array, resolved);
        assertArrayEquals([true, [goog.nullFunction, null, 123], &#039;&#039;, undefined],
            resolved);
        assertArrayEquals([goog.nullFunction, null, 123], resolved[1]);
      }),
      errback = callbackHelper());

  errback.assertNotCalled();
  callback.assertCalled();
}


function testFullyResolved_arrayWithPromisedPrimitive() {
  var callback, errback;
  webdriver.promise.fullyResolved([webdriver.promise.fulfilled(123)]).then(
      callback = callbackHelper(function(resolved) {
        assertArrayEquals([123], resolved);
      }),
      errback = callbackHelper());
  errback.assertNotCalled();
  callback.assertCalled();
}


function testFullyResolved_promiseResolvesToPrimitive() {
  var promise = webdriver.promise.fulfilled(123);
  var callback, errback;
  webdriver.promise.fullyResolved(promise).then(
      callback = callbackHelper(function(resolved) {
        assertEquals(123, resolved);
      }),
      errback = callbackHelper());

  errback.assertNotCalled();
  callback.assertCalled();
}


function testFullyResolved_promiseResolvesToArray() {
  var array = [true, [goog.nullFunction, null, 123], &#039;&#039;, undefined];
  var promise = webdriver.promise.fulfilled(array);
  var callback, errback;
  webdriver.promise.fullyResolved(promise).then(
      callback = callbackHelper(function(resolved) {
        assertEquals(array, resolved);
        assertArrayEquals([true, [goog.nullFunction, null, 123], &#039;&#039;, undefined],
            resolved);
        assertArrayEquals([goog.nullFunction, null, 123], resolved[1]);
      }),
      errback = callbackHelper());

  errback.assertNotCalled();
  callback.assertCalled();
}


function testFullyResolved_promiseResolvesToArrayWithPromises() {
  var nestedPromise = webdriver.promise.fulfilled(123);
  var promise = webdriver.promise.fulfilled([true, nestedPromise]);

  var callback, errback;
  webdriver.promise.fullyResolved(promise).then(
      callback = callbackHelper(function(resolved) {
        assertArrayEquals([true, 123], resolved);
      }),
      errback = callbackHelper());

  errback.assertNotCalled();
  callback.assertCalled();
}


function testFullyResolved_rejectsIfArrayPromiseRejects() {
  var e = new Error(&#039;foo&#039;);
  var nestedPromise = webdriver.promise.rejected(e);
  var promise = webdriver.promise.fulfilled([true, nestedPromise]);

  var pair = callbackPair(null, function(error) {
    assertEquals(e, error);
  });
  webdriver.promise.fullyResolved(promise).then(pair.callback, pair.errback);

  clock.tick();
  pair.assertErrback();
}


function testFullyResolved_rejectsOnFirstArrayRejection() {
  var e1 = new Error(&#039;foo&#039;);
  var e2 = new Error(&#039;bar&#039;);
  var promise = webdriver.promise.fulfilled([
    webdriver.promise.rejected(e1),
    webdriver.promise.rejected(e2)
  ]);

  var pair = callbackPair(null, function(error) {
    assertEquals(e1, error);
  });
  webdriver.promise.fullyResolved(promise).then(pair.callback, pair.errback);

  clock.tick();
  pair.assertErrback();
}


function testFullyResolved_rejectsIfNestedArrayPromiseRejects() {
  var e = new Error(&#039;foo&#039;);
  var promise = webdriver.promise.fulfilled([
    webdriver.promise.fulfilled([
      webdriver.promise.rejected(e)
    ])
  ]);

  var pair = callbackPair(null, function(error) {
    assertEquals(e, error);
  });
  webdriver.promise.fullyResolved(promise).then(pair.callback, pair.errback);

  clock.tick();
  clock.tick();
  clock.tick();
  pair.assertErrback();
}


function testFullyResolved_simpleHash() {
  var hash = {&#039;a&#039;: 123};

  var callback, errback;
  webdriver.promise.fullyResolved(hash).then(
      callback = callbackHelper(function(resolved) {
        assertEquals(hash, resolved);
        webdriver.test.testutil.assertObjectEquals({&#039;a&#039;: 123}, resolved);
      }),
      errback = callbackHelper());

  errback.assertNotCalled();
  callback.assertCalled();
}


function testFullyResolved_nestedHash() {
  var nestedHash = {&#039;foo&#039;:&#039;bar&#039;};
  var hash = {&#039;a&#039;: 123, &#039;b&#039;: nestedHash};

  var callback, errback;
  webdriver.promise.fullyResolved(hash).then(
      callback = callbackHelper(function(resolved) {
        assertEquals(hash, resolved);
        webdriver.test.testutil.assertObjectEquals(
            {&#039;a&#039;: 123, &#039;b&#039;: {&#039;foo&#039;: &#039;bar&#039;}}, resolved);
        webdriver.test.testutil.assertObjectEquals(nestedHash, resolved[&#039;b&#039;]);
      }),
      errback = callbackHelper());

  errback.assertNotCalled();
  callback.assertCalled();
}


function testFullyResolved_promiseResolvesToSimpleHash() {
  var hash = {&#039;a&#039;: 123};
  var promise = webdriver.promise.fulfilled(hash);

  var callback, errback;
  webdriver.promise.fullyResolved(promise).then(
      callback = callbackHelper(function(resolved) {
        webdriver.test.testutil.assertObjectEquals(hash, resolved);
      }),
      errback = callbackHelper());

  errback.assertNotCalled();
  callback.assertCalled();
}


function testFullyResolved_promiseResolvesToNestedHash() {
  var nestedHash = {&#039;foo&#039;:&#039;bar&#039;};
  var hash = {&#039;a&#039;: 123, &#039;b&#039;: nestedHash};
  var promise = webdriver.promise.fulfilled(hash);

  var callback, errback;
  webdriver.promise.fullyResolved(promise).then(
      callback = callbackHelper(function(resolved) {
        webdriver.test.testutil.assertObjectEquals(hash, resolved);
        webdriver.test.testutil.assertObjectEquals(nestedHash, resolved[&#039;b&#039;]);
      }),
      errback = callbackHelper());

  errback.assertNotCalled();
  callback.assertCalled();
}


function testFullyResolved_promiseResolvesToHashWithPromises() {
  var promise = webdriver.promise.fulfilled({
      &#039;a&#039;: webdriver.promise.fulfilled(123)
  });

  var callback, errback;
  webdriver.promise.fullyResolved(promise).then(
      callback = callbackHelper(function(resolved) {
        webdriver.test.testutil.assertObjectEquals({&#039;a&#039;: 123}, resolved);
      }),
      errback = callbackHelper());

  errback.assertNotCalled();
  callback.assertCalled();
}


function testFullyResolved_rejectsIfHashPromiseRejects() {
  var e = new Error(&#039;foo&#039;);
  var promise = webdriver.promise.fulfilled({
      &#039;a&#039;: webdriver.promise.rejected(e)
  });

  var pair = callbackPair(null, function(error) {
    assertEquals(e, error);
  });
  webdriver.promise.fullyResolved(promise).then(pair.callback, pair.errback);

  clock.tick();
  pair.assertErrback();
}

function testFullyResolved_rejectsIfNestedHashPromiseRejects() {
  var e = new Error(&#039;foo&#039;);
  var promise = webdriver.promise.fulfilled({
      &#039;a&#039;: {&#039;b&#039;: webdriver.promise.rejected(e)}
  });

  var pair = callbackPair(null, function(error) {
    assertEquals(e, error);
  });
  webdriver.promise.fullyResolved(promise).then(pair.callback, pair.errback);

  clock.tick();
  pair.assertErrback();
}


function testFullyResolved_instantiatedObject() {
  function Foo() {
    this.bar = &#039;baz&#039;;
  }
  var foo = new Foo;

  var callback, errback;
  webdriver.promise.fullyResolved(foo).then(
    callback = callbackHelper(function(resolvedFoo) {
      assertEquals(foo, resolvedFoo);
      assertTrue(resolvedFoo instanceof Foo);
      webdriver.test.testutil.assertObjectEquals(new Foo, resolvedFoo);
    }),
    errback = callbackHelper());
  errback.assertNotCalled();
  callback.assertCalled();
}


function testFullyResolved_withEmptyArray() {
  var callback, errback;
  webdriver.promise.fullyResolved([]).then(
    callback = callbackHelper(function(resolved) {
      assertArrayEquals([], resolved);
    }),
    errback = callbackHelper());
  errback.assertNotCalled();
  callback.assertCalled();
}


function testFullyResolved_withEmptyHash() {
  var callback, errback;
  webdriver.promise.fullyResolved({}).then(
    callback = callbackHelper(function(resolved) {
      webdriver.test.testutil.assertObjectEquals({}, resolved);
    }),
    errback = callbackHelper());
  errback.assertNotCalled();
  callback.assertCalled();
}


function testFullyResolved_arrayWithPromisedHash() {
  var obj = {&#039;foo&#039;: &#039;bar&#039;};
  var promise = webdriver.promise.fulfilled(obj);
  var array = [promise];

  var callback, errback;
  webdriver.promise.fullyResolved(array).then(
      callback = callbackHelper(function(resolved) {
        webdriver.test.testutil.assertObjectEquals(resolved, [obj]);
      }),
      errback = callbackHelper());

  errback.assertNotCalled();
  callback.assertCalled();
}


function testFullyResolved_aDomElement() {
  var e = document.createElement(&#039;div&#039;);
  var callbacks = callbackPair(function(resolved) {
    assertEquals(e, resolved);
  });

  webdriver.promise.fullyResolved(e).
      then(callbacks.callback, callbacks.errback);
  callbacks.assertCallback();
}


function testCallbackChain_nonSplit() {
  var stage1 = callbackPair(),
      stage2 = callbackPair(),
      stage3 = callbackPair();

  webdriver.promise.rejected(&#039;foo&#039;).
      then(stage1.callback, stage1.errback).
      then(stage2.callback, stage2.errback).
      then(stage3.callback, stage3.errback);

  stage1.assertErrback(&#039;Wrong function for stage 1&#039;);
  stage2.assertCallback(&#039;Wrong function for stage 2&#039;);
  stage3.assertCallback(&#039;Wrong function for final stage&#039;);
}


function testCallbackChain_split() {
  var stage1 = callbackPair(),
      stage2 = callbackPair(),
      stage3 = callbackPair();

  webdriver.promise.rejected(&#039;foo&#039;).
      then(stage1.callback).
      thenCatch(stage1.errback).
      then(stage2.callback).
      thenCatch(stage2.errback).
      then(stage3.callback, stage3.errback);

  stage1.assertErrback(&#039;Wrong function for stage 1&#039;);
  stage2.assertCallback(&#039;Wrong function for stage 2&#039;);
  stage3.assertCallback(&#039;Wrong function for final stage&#039;);
}


function testCheckedNodeCall_functionThrows() {
  var error = new Error(&#039;boom&#039;);
  var pair = callbackPair(null, function(e) {
    assertEquals(error, e);
  });

  webdriver.promise.checkedNodeCall(function() {
    throw error;
  }).then(pair.callback, pair.errback);

  pair.assertErrback();
}


function testCheckedNodeCall_functionReturnsAnError() {
  var error = new Error(&#039;boom&#039;);
  var pair = callbackPair(null, function(e) {
    assertEquals(error, e);
  });
  webdriver.promise.checkedNodeCall(function(callback) {
    callback(error);
  }).then(pair.callback, pair.errback);
  pair.assertErrback();
}


function testCheckedNodeCall_functionReturnsSuccess() {
  var success = &#039;success!&#039;;
  var pair = callbackPair(function(value) {
    assertEquals(success, value);
  });
  webdriver.promise.checkedNodeCall(function(callback) {
    callback(null, success);
  }).then(pair.callback, pair.errback);
  pair.assertCallback();
}


function testCheckedNodeCall_functionReturnsAndThrows() {
  var error = new Error(&#039;boom&#039;);
  var error2 = new Error(&#039;boom again&#039;);
  var pair = callbackPair(null, function(e) {
    assertEquals(error, e);
  });
  webdriver.promise.checkedNodeCall(function(callback) {
    callback(error);
    throw error2;
  }).then(pair.callback, pair.errback);
  pair.assertErrback();
}


function testCheckedNodeCall_functionThrowsAndReturns() {
  var error = new Error(&#039;boom&#039;);
  var error2 = new Error(&#039;boom again&#039;);
  var pair = callbackPair(null, function(e) {
    assertEquals(error2, e);
  });
  webdriver.promise.checkedNodeCall(function(callback) {
    setTimeout(goog.partial(callback, error), 0);
    throw error2;
  }).then(pair.callback, pair.errback);
  pair.assertErrback();
  pair.reset();
  webdriver.test.testutil.consumeTimeouts();
  pair.assertNeither();
}


function testCancel_passesTheCancellationReasonToReject() {
  var pair = callbackPair(null, function(e) {
    assertTrue(e instanceof webdriver.promise.CancellationError);
    assertEquals(&#039;because i said so&#039;, e.message);
  });
  var d = new webdriver.promise.Deferred();
  d.then(pair.callback, pair.errback);
  d.cancel(&#039;because i said so&#039;);
  pair.assertErrback();
}


function testCancel_canCancelADeferredFromAChainedPromise() {
  var pair1 = callbackPair(null, function(e) {
    assertTrue(e instanceof webdriver.promise.CancellationError);
    assertEquals(&#039;because i said so&#039;, e.message);
  });
  var pair2 = callbackPair();

  var d = new webdriver.promise.Deferred();
  var p = d.then(pair1.callback, pair1.errback);
  p.then(pair2.callback, pair2.errback);

  p.cancel(&#039;because i said so&#039;);
  pair1.assertErrback(&#039;The first errback should have fired.&#039;);
  pair2.assertCallback();
}


function testCancel_canCancelATimeout() {
  var pair = callbackPair(null, function(e) {
    assertTrue(e instanceof webdriver.promise.CancellationError);
  });
  var p = webdriver.promise.delayed(250).
      then(pair.callback, pair.errback);
  p.cancel();
  pair.assertErrback();
  clock.tick(250);  // Just to make sure nothing happens.
  pair.assertErrback();
}


function testCancel_cancelIsANoopOnceAPromiseHasBeenFulfilled() {
  var p = webdriver.promise.fulfilled(123);
  p.cancel();

  var pair = callbackPair(goog.partial(assertEquals, 123));
  p.then(pair.callback, pair.errback);
  pair.assertCallback();
}


function testCancel_cancelIsANoopOnceAPromiseHasBeenRejected() {
  var p = webdriver.promise.rejected(STUB_ERROR);
  p.cancel();

  var pair = callbackPair(null, assertIsStubError);
  p.then(pair.callback, pair.errback);
  pair.assertErrback();
}


function testCancel_noopCancelTriggeredOnCallbackOfResolvedPromise() {
  var d = webdriver.promise.defer();
  var p = d.then();

  d.fulfill();
  p.cancel();  // This should not throw.
}


function testCallbackRegistersAnotherListener_callbacksConfiguredPreResolve() {
  var messages = [];
  var d = new webdriver.promise.Deferred();
  d.then(function() {
    messages.push(&#039;a&#039;);
    d.then(function() {
      messages.push(&#039;c&#039;);
    });
  });
  d.then(function() {
    messages.push(&#039;b&#039;);
  });
  d.fulfill();
  assertArrayEquals([&#039;a&#039;, &#039;c&#039;, &#039;b&#039;], messages);
}


function testCallbackRegistersAnotherListener_callbacksConfiguredPostResolve() {
  var messages = [];
  var d = webdriver.promise.fulfilled();
  d.then(function() {
    messages.push(&#039;a&#039;);
    d.then(function() {
      messages.push(&#039;c&#039;);
    });
  });
  d.then(function() {
    messages.push(&#039;b&#039;);
  });
  assertArrayEquals([&#039;a&#039;, &#039;c&#039;, &#039;b&#039;], messages);
}


function testCallbackRegistersAnotherListener_recursiveCallbacks() {
  var messages = [];
  var start = 97;  // &#039;a&#039;

  var p = webdriver.promise.fulfilled();
  p.then(push).then(function() {
    messages.push(&#039;done&#039;);
  });

  function push() {
    messages.push(String.fromCharCode(start++));
    if (start != 101) {  // &#039;d&#039;
      p.then(push);
    }
  }

  assertArrayEquals([&#039;a&#039;, &#039;b&#039;, &#039;c&#039;, &#039;d&#039;, &#039;done&#039;], messages);
}


function testThenReturnsOwnPromiseIfNoCallbacksWereGiven() {
  var deferred = new webdriver.promise.Deferred();
  assertEquals(deferred.promise, deferred.then());
  assertEquals(deferred.promise, deferred.promise.then());
  assertEquals(deferred.promise, webdriver.promise.when(deferred));
  assertEquals(deferred.promise, webdriver.promise.when(deferred.promise));
}


function testIsStillConsideredUnHandledIfNoCallbacksWereGivenOnCallsToThen() {
  webdriver.promise.rejected(STUB_ERROR).then();
  var handler = callbackHelper(assertIsStubError);

  // so tearDown() doesn&#039;t throw
  app.reset();
  app.on(webdriver.promise.ControlFlow.EventType.UNCAUGHT_EXCEPTION, handler);
  clock.tick();
  handler.assertCalled();
}

function testResolvedReturnsInputValueIfItIsAPromise() {
  var input = webdriver.promise.fulfilled(&#039;a&#039;);
  var output = webdriver.promise.fulfilled(input);
  assertEquals(input, output);
}


function testADeferredsParentControlFlowIsActiveForCallbacks() {
  var flow = new webdriver.promise.ControlFlow();
  var d = new webdriver.promise.Deferred(flow);
  d.fulfill();

  var flow2 = new webdriver.promise.ControlFlow();
  var d2 = new webdriver.promise.Deferred(flow2);
  d2.fulfill();

  assertIsFlow(webdriver.promise.defaultFlow_)();

  var callbacks = callbackPair();
  d.then(assertIsFlow(flow)).
      then(assertIsFlow(flow)).
      then(function() {
        return d2.then(assertIsFlow(flow2));
      }).
      then(assertIsFlow(flow)).
      then(callbacks.callback, callbacks.errback);

  callbacks.assertCallback();
  assertIsFlow(webdriver.promise.defaultFlow_)();

  function assertIsFlow(flow) {
    return function() {
      assertEquals(flow, webdriver.promise.controlFlow());
    };
  }
}


function testPromiseAll_emptyArray() {
  var pair = callbackPair(function(value) {
    assertArrayEquals([], value);
  });

  webdriver.promise.all([]).then(pair.callback, pair.errback);
  pair.assertCallback();
}


function testPromiseAll() {
  var a = [
      0, 1,
      webdriver.promise.defer(),
      webdriver.promise.defer(),
      4, 5, 6
  ];
  delete a[5];

  var pair = callbackPair(function(value) {
    var expected = [0, 1, 2, 3, 4, 5, 6];
    delete expected[5];
    assertArrayEquals(expected, value);
  });

  webdriver.promise.all(a).then(pair.callback, pair.errback);
  pair.assertNeither();

  a[2].fulfill(2);
  pair.assertNeither();

  a[3].fulfill(3);
  pair.assertCallback();
}


function testPromiseAll_usesFirstRejection() {
  var a = [
    webdriver.promise.defer(),
    webdriver.promise.defer()
  ];

  var pair = callbackPair(null, assertIsStubError);

  webdriver.promise.all(a).then(pair.callback, pair.errback);
  pair.assertNeither();

  a[1].reject(STUB_ERROR);
  pair.assertErrback();

  a[0].reject(Error(&#039;ignored&#039;));
}


function testMappingAnArray() {
  var a = [1, 2, 3];
  var result = webdriver.promise.map(a, function(value, index, a2) {
    assertEquals(a, a2);
    assertEquals(&#039;not a number&#039;, &#039;number&#039;, typeof index);
    return value + 1;
  });

  var pair = callbackPair(function(value) {
    assertArrayEquals([2, 3, 4], value);
  });

  result.then(pair.callback, pair.errback);
  pair.assertCallback();
}


function testMappingAnArray_omitsDeleted() {
  var a = [0, 1, 2, 3, 4, 5, 6];
  delete a[1];
  delete a[3];
  delete a[4];
  delete a[6];

  var result = webdriver.promise.map(a, function(value) {
    return value * value;
  });

  var expected = [0, 1, 4, 9, 16, 25, 36];
  delete expected[1];
  delete expected[3];
  delete expected[4];
  delete expected[6];

  var pair = callbackPair(function(value) {
    assertArrayEquals(expected, value);
  });

  result.then(pair.callback, pair.errback);
  pair.assertCallback();
}


function testMappingAnArray_emptyArray() {
  var result = webdriver.promise.map([], function(value) {
    return value + 1;
  });

  var pair = callbackPair(function(value) {
    assertArrayEquals([], value);
  });

  result.then(pair.callback, pair.errback);
  pair.assertCallback();
}


function testMappingAnArray_inputIsPromise() {
  var input = webdriver.promise.defer();
  var result = webdriver.promise.map(input, function(value) {
    return value + 1;
  });

  var pair = callbackPair(function(value) {
    assertArrayEquals([2, 3, 4], value);
  });

  result.then(pair.callback, pair.errback);
  pair.assertNeither();
  input.fulfill([1, 2, 3]);
  pair.assertCallback();
}


function testMappingAnArray_waitsForFunctionResultToResolve() {
  var innerResults = [
    webdriver.promise.defer(),
    webdriver.promise.defer()
  ];

  var result = webdriver.promise.map([1, 2], function(value, index) {
    return innerResults[index].promise;
  });

  var pair = callbackPair(function(value) {
    assertArrayEquals([&#039;a&#039;, &#039;b&#039;], value);
  });

  result.then(pair.callback, pair.errback);
  pair.assertNeither();

  innerResults[0].fulfill(&#039;a&#039;);
  pair.assertNeither();

  innerResults[1].fulfill(&#039;b&#039;);
  pair.assertCallback();
}


function testMappingAnArray_rejectsPromiseIfFunctionThrows() {
  var result = webdriver.promise.map([1], throwStubError);
  var pair = callbackPair(null, assertIsStubError);
  result.then(pair.callback, pair.errback);
  pair.assertErrback();
}


function testMappingAnArray_rejectsPromiseIfFunctionReturnsRejectedPromise() {
  var result = webdriver.promise.map([1], function() {
    return webdriver.promise.rejected(STUB_ERROR);
  });

  var pair = callbackPair(null, assertIsStubError);
  result.then(pair.callback, pair.errback);
  pair.assertErrback();
}


function testMappingAnArray_stopsCallingFunctionIfPreviousIterationFailed() {
  var count = 0;
  var result = webdriver.promise.map([1, 2, 3, 4], function() {
    count++;
    if (count == 3) {
      throw STUB_ERROR;
    }
  });

  var pair = callbackPair(null, assertIsStubError);
  result.then(pair.callback, pair.errback);
  pair.assertErrback();
  assertEquals(3, count);
}


function testMappingAnArray_rejectsWithFirstRejectedPromise() {
  var innerResult = [
      webdriver.promise.defer(),
      webdriver.promise.defer(),
      webdriver.promise.defer(),
      webdriver.promise.defer()
  ];
  var result = webdriver.promise.map([1, 2, 3, 4], function(value, index) {
    return innerResult[index].promise;
  });

  var pair = callbackPair(null, assertIsStubError);
  result.then(pair.callback, pair.errback);
  pair.assertNeither();

  innerResult[2].reject(STUB_ERROR);
  innerResult[1].reject(Error(&#039;other error&#039;));  // Should be ignored.

  pair.assertErrback();

  innerResult[0].reject(&#039;should also be ignored&#039;);
}


function testMappingAnArray_preservesOrderWhenMapReturnsPromise() {
  var deferreds = [
    webdriver.promise.defer(),
    webdriver.promise.defer(),
    webdriver.promise.defer(),
    webdriver.promise.defer()
  ];
  var result = webdriver.promise.map(deferreds, function(value) {
    return value.promise;
  });

  var pair = callbackPair(function(value) {
    assertArrayEquals([0, 1, 2, 3], value);
  });
  result.then(pair.callback, pair.errback);
  pair.assertNeither();

  goog.array.forEachRight(deferreds, function(d, i) {
    d.fulfill(i);
  });
  pair.assertCallback();
}


function testFilteringAnArray() {
  var a = [0, 1, 2, 3];
  var result = webdriver.promise.filter(a, function(val, index, a2) {
    assertEquals(a, a2);
    assertEquals(&#039;not a number&#039;, &#039;number&#039;, typeof index);
    return val &gt; 1;
  });

  var pair = callbackPair(function(val) {
    assertArrayEquals([2, 3], val);
  });
  result.then(pair.callback, pair.errback);
  pair.assertCallback();
}


function testFilteringAnArray_omitsDeleted() {
  var a = [0, 1, 2, 3, 4, 5, 6];
  delete a[3];
  delete a[4];

  var result = webdriver.promise.filter(a, function(value) {
    return value &gt; 1 &amp;&amp; value &lt; 6;
  });

  var pair = callbackPair(function(val) {
    assertArrayEquals([2, 5], val);
  });
  result.then(pair.callback, pair.errback);
  pair.assertCallback();
}


function testFilteringAnArray_preservesInputs() {
  var a = [0, 1, 2, 3];

  var result = webdriver.promise.filter(a, function(value, i, a2) {
    assertEquals(a, a2);
    // Even if a function modifies the input array, the original value
    // should be inserted into the new array.
    a2[i] = a2[i] - 1;
    return a2[i] &gt;= 1;
  });

  var pair = callbackPair(function(val) {
    assertArrayEquals([2, 3], val);
  });
  result.then(pair.callback, pair.errback);
  pair.assertCallback();
}


function testFilteringAnArray_inputIsPromise() {
  var input = webdriver.promise.defer();
  var result = webdriver.promise.filter(input, function(value) {
    return value &gt; 1 &amp;&amp; value &lt; 3;
  });

  var pair = callbackPair(function(value) {
    assertArrayEquals([2], value);
  });

  result.then(pair.callback, pair.errback);
  pair.assertNeither();
  input.fulfill([1, 2, 3]);
  pair.assertCallback();
}


function testFilteringAnArray_waitsForFunctionResultToResolve() {
  var innerResults = [
    webdriver.promise.defer(),
    webdriver.promise.defer()
  ];

  var result = webdriver.promise.filter([1, 2], function(value, index) {
    return innerResults[index].promise;
  });

  var pair = callbackPair(function(value) {
    assertArrayEquals([2], value);
  });

  result.then(pair.callback, pair.errback);
  pair.assertNeither();

  innerResults[0].fulfill(false);
  pair.assertNeither();

  innerResults[1].fulfill(true);
  pair.assertCallback();
}


function testFilteringAnArray_rejectsPromiseIfFunctionReturnsRejectedPromise() {
  var result = webdriver.promise.filter([1], function() {
    return webdriver.promise.rejected(STUB_ERROR);
  });

  var pair = callbackPair(null, assertIsStubError);
  result.then(pair.callback, pair.errback);
  pair.assertErrback();
}


function testFilteringAnArray_stopsCallingFunctionIfPreviousIterationFailed() {
  var count = 0;
  var result = webdriver.promise.filter([1, 2, 3, 4], function() {
    count++;
    if (count == 3) {
      throw STUB_ERROR;
    }
  });

  var pair = callbackPair(null, assertIsStubError);
  result.then(pair.callback, pair.errback);
  pair.assertErrback();
  assertEquals(3, count);
}


function testFilteringAnArray_rejectsWithFirstRejectedPromise() {
  var innerResult = [
    webdriver.promise.defer(),
    webdriver.promise.defer(),
    webdriver.promise.defer(),
    webdriver.promise.defer()
  ];
  var result = webdriver.promise.filter([1, 2, 3, 4], function(value, index) {
    return innerResult[index].promise;
  });

  var pair = callbackPair(null, assertIsStubError);
  result.then(pair.callback, pair.errback);
  pair.assertNeither();

  innerResult[2].reject(STUB_ERROR);
  innerResult[1].reject(Error(&#039;other error&#039;));  // Should be ignored.

  pair.assertErrback();

  innerResult[0].reject(&#039;should also be ignored&#039;);
}


function testFilteringAnArray_preservesOrderWhenFilterReturnsPromise() {
  var deferreds = [
    webdriver.promise.defer(),
    webdriver.promise.defer(),
    webdriver.promise.defer(),
    webdriver.promise.defer()
  ];
  var result = webdriver.promise.filter([0, 1, 2, 3], function(value, index) {
    return deferreds[index].promise;
  });

  var pair = callbackPair(function(value) {
    assertArrayEquals([1, 2], value);
  });
  result.then(pair.callback, pair.errback);
  pair.assertNeither();

  goog.array.forEachRight(deferreds, function(d, i) {
    d.fulfill(i &gt; 0 &amp;&amp; i &lt; 3);
  });
  pair.assertCallback();
}


function testAddThenableImplementation() {
  function tmp() {}
  assertFalse(webdriver.promise.Thenable.isImplementation(new tmp()));
  webdriver.promise.Thenable.addImplementation(tmp);
  assertTrue(webdriver.promise.Thenable.isImplementation(new tmp()));
}</textarea>
  </div>
</div>

<footer class="footer">
  <div class="container">
    <p>.</p>
  </div>
</footer>

<script type="text/html" id="complexity-popover-template">
  <div class="complexity-notice">
    Complexity : {{ complexity.cyclomatic }} <br>
    Length : {{ complexity.halstead.length }} <br>
    Difficulty : {{ complexity.halstead.difficulty.toFixed(2) }} <br>
    Est # bugs : {{ complexity.halstead.bugs.toFixed(2) }}<br>
  </div>
</script>

<script type="text/javascript" src="../../assets/scripts/bundles/core-bundle.js"></script>
<script type="text/javascript" src="../../assets/scripts/bundles/codemirror.js"></script>
<script type="text/javascript" src="../../assets/scripts/codemirror.markpopovertext.js"></script>
<script type="text/javascript" src="report.js"></script>
<script type="text/javascript" src="report.history.js"></script>
<script type="text/javascript" src="../../assets/scripts/plato-file.js"></script>
</body>
</html>
