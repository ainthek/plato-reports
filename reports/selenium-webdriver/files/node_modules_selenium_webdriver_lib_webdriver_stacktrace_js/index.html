<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Plato - node_modules/selenium-webdriver/lib/webdriver/stacktrace.js</title>

  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="">
  <meta name="author" content="">

  <!--[if lt IE 9]>
  <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->

  <link href="../../assets/css/vendor/morris.css" rel="stylesheet">
  <link href="../../assets/css/vendor/bootstrap.css" rel="stylesheet">
  <link href="../../assets/css/vendor/font-awesome.css" rel="stylesheet">
  <link href="../../assets/css/vendor/codemirror.css" rel="stylesheet">
  <link href="../../assets/css/plato.css" rel="stylesheet">
  <link href="../../assets/css/plato-file.css" rel="stylesheet">

</head>

<body>

<div class="navbar navbar-fixed-top">
  <div class="container">
    <a class="navbar-brand" href="http://github.com/es-analysis/plato">Plato on Github</a>
    <ul class="nav navbar-nav">
      <li>
        <a href="../../index.html">Report Home</a>
      </li>
    </ul>
  </div>
</div>

<div class="jumbotron">
  <div class="container">
    <h1>node_modules/selenium-webdriver/lib/webdriver/stacktrace.js</h1>
  </div>
</div>

<div class="container aggregate-stats">
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Maintainability <a href="http://blogs.msdn.com/b/codeanalysis/archive/2007/11/20/maintainability-index-range-and-meaning.aspx"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="A value between 0 and 100 that represents the relative ease of maintaining the code. A high value means better maintainability." data-original-title="Maintainability Index"  data-container="body"></i></a></h2>
      <p class="stat">66.14</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Lines of code <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h2>
      <p class="stat">643</p>
    </div>
  </div>
  <div class="row historical">
    <div class="col-md-6">
      <p id="chart_historical_maint" class="chart"></p>
    </div>
    <div class="col-md-6">
      <p id="chart_historical_sloc" class="chart"></p>
    </div>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Difficulty  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="The difficulty measure is related to the difficulty of the program to write or understand." data-original-title="Difficulty" data-container="body"></i></a></h2>
      <p class="stat">59.94</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Estimated Errors  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Halstead's delivered bugs is an estimate for the number of errors in the implementation." data-original-title="Delivered Bugs" data-container="body"></i></a></h2>
      <p class="stat">3.77</p>
    </div>
  </div>
</div>

<div class="container charts">
  <div class="row">
    <h2 class="header">Function weight</h2>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h3 class="chart-header">By Complexity <a href="http://en.wikipedia.org/wiki/Cyclomatic_complexity"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="This metric counts the number of distinct paths through a block of code. Lower values are better." data-original-title="Cyclomatic Complexity" data-container="body"></i></a></h3>
      <div id="fn-by-complexity" class="stat"></div>
    </div>
    <div class="col-md-6">
      <h3 class="chart-header">By SLOC  <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h3>
      <div id="fn-by-sloc" class="stat"></div>
    </div>
  </div>
</div>

<div class="container">
  <div class="row">
    <textarea id="file-source" class="col-md-12">// Copyright 2009 The Closure Library Authors. All Rights Reserved.
// Copyright 2012 Selenium comitters
// Copyright 2012 Software Freedom Conservancy
//
// Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an &quot;AS-IS&quot; BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/**
 * @fileoverview Tools for parsing and pretty printing error stack traces. This
 * file is based on goog.testing.stacktrace.
 */

goog.provide(&#039;webdriver.stacktrace&#039;);
goog.provide(&#039;webdriver.stacktrace.Snapshot&#039;);

goog.require(&#039;goog.array&#039;);
goog.require(&#039;goog.string&#039;);
goog.require(&#039;goog.userAgent&#039;);



/**
 * Stores a snapshot of the stack trace at the time this instance was created.
 * The stack trace will always be adjusted to exclude this function call.
 * @param {number=} opt_slice The number of frames to remove from the top of
 *     the generated stack trace.
 * @constructor
 */
webdriver.stacktrace.Snapshot = function(opt_slice) {

  /** @private {number} */
  this.slice_ = opt_slice || 0;

  var error;
  if (webdriver.stacktrace.CAN_CAPTURE_STACK_TRACE_) {
    error = Error();
    Error.captureStackTrace(error, webdriver.stacktrace.Snapshot);
  } else {
    // Remove 1 extra frame for the call to this constructor.
    this.slice_ += 1;
    // IE will only create a stack trace when the Error is thrown.
    // We use null.x() to throw an exception instead of throw this.error_
    // because the closure compiler may optimize throws to a function call
    // in an attempt to minimize the binary size which in turn has the side
    // effect of adding an unwanted stack frame.
    try {
      null.x();
    } catch (e) {
      error = e;
    }
  }

  /**
   * The error&#039;s stacktrace.  This must be accessed immediately to ensure Opera
   * computes the context correctly.
   * @private {string}
   */
  this.stack_ = webdriver.stacktrace.getStack_(error);
};


/**
 * Whether the current environment supports the Error.captureStackTrace
 * function (as of 10/17/2012, only V8).
 * @private {boolean}
 * @const
 */
webdriver.stacktrace.CAN_CAPTURE_STACK_TRACE_ =
    goog.isFunction(Error.captureStackTrace);


/**
 * Whether the current browser supports stack traces.
 *
 * @type {boolean}
 * @const
 */
webdriver.stacktrace.BROWSER_SUPPORTED =
    webdriver.stacktrace.CAN_CAPTURE_STACK_TRACE_ || (function() {
      try {
        throw Error();
      } catch (e) {
        return !!e.stack;
      }
    })();


/**
 * The parsed stack trace. This list is lazily generated the first time it is
 * accessed.
 * @private {Array.&lt;!webdriver.stacktrace.Frame&gt;}
 */
webdriver.stacktrace.Snapshot.prototype.parsedStack_ = null;


/**
 * @return {!Array.&lt;!webdriver.stacktrace.Frame&gt;} The parsed stack trace.
 */
webdriver.stacktrace.Snapshot.prototype.getStacktrace = function() {
  if (goog.isNull(this.parsedStack_)) {
    this.parsedStack_ = webdriver.stacktrace.parse_(this.stack_);
    if (this.slice_) {
      this.parsedStack_ = goog.array.slice(this.parsedStack_, this.slice_);
    }
    delete this.slice_;
    delete this.stack_;
  }
  return this.parsedStack_;
};



/**
 * Class representing one stack frame.
 * @param {(string|undefined)} context Context object, empty in case of global
 *     functions or if the browser doesn&#039;t provide this information.
 * @param {(string|undefined)} name Function name, empty in case of anonymous
 *     functions.
 * @param {(string|undefined)} alias Alias of the function if available. For
 *     example the function name will be &#039;c&#039; and the alias will be &#039;b&#039; if the
 *     function is defined as &lt;code&gt;a.b = function c() {};&lt;/code&gt;.
 * @param {(string|undefined)} path File path or URL including line number and
 *     optionally column number separated by colons.
 * @constructor
 */
webdriver.stacktrace.Frame = function(context, name, alias, path) {

  /** @private {string} */
  this.context_ = context || &#039;&#039;;

  /** @private {string} */
  this.name_ = name || &#039;&#039;;

  /** @private {string} */
  this.alias_ = alias || &#039;&#039;;

  /** @private {string} */
  this.path_ = path || &#039;&#039;;

  /** @private {string} */
  this.url_ = this.path_;

  /** @private {number} */
  this.line_ = -1;

  /** @private {number} */
  this.column_ = -1;

  if (path) {
    var match = /:(\d+)(?::(\d+))?$/.exec(path);
    if (match) {
      this.line_ = Number(match[1]);
      this.column = Number(match[2] || -1);
      this.url_ = path.substr(0, match.index);
    }
  }
};


/**
 * Constant for an anonymous frame.
 * @private {!webdriver.stacktrace.Frame}
 * @const
 */
webdriver.stacktrace.ANONYMOUS_FRAME_ =
    new webdriver.stacktrace.Frame(&#039;&#039;, &#039;&#039;, &#039;&#039;, &#039;&#039;);


/**
 * @return {string} The function name or empty string if the function is
 *     anonymous and the object field which it&#039;s assigned to is unknown.
 */
webdriver.stacktrace.Frame.prototype.getName = function() {
  return this.name_;
};


/**
 * @return {string} The url or empty string if it is unknown.
 */
webdriver.stacktrace.Frame.prototype.getUrl = function() {
  return this.url_;
};


/**
 * @return {number} The line number if known or -1 if it is unknown.
 */
webdriver.stacktrace.Frame.prototype.getLine = function() {
  return this.line_;
};


/**
 * @return {number} The column number if known and -1 if it is unknown.
 */
webdriver.stacktrace.Frame.prototype.getColumn = function() {
  return this.column_;
};


/**
 * @return {boolean} Whether the stack frame contains an anonymous function.
 */
webdriver.stacktrace.Frame.prototype.isAnonymous = function() {
  return !this.name_ || this.context_ == &#039;[object Object]&#039;;
};


/**
 * Converts this frame to its string representation using V8&#039;s stack trace
 * format: http://code.google.com/p/v8/wiki/JavaScriptStackTraceApi
 * @return {string} The string representation of this frame.
 * @override
 */
webdriver.stacktrace.Frame.prototype.toString = function() {
  var context = this.context_;
  if (context &amp;&amp; context !== &#039;new &#039;) {
    context += &#039;.&#039;;
  }
  context += this.name_;
  context += this.alias_ ? &#039; [as &#039; + this.alias_ + &#039;]&#039; : &#039;&#039;;

  var path = this.path_ || &#039;&lt;anonymous&gt;&#039;;
  return &#039;    at &#039; + (context ? context + &#039; (&#039; + path + &#039;)&#039; : path);
};


/**
 * Maximum length of a string that can be matched with a RegExp on
 * Firefox 3x. Exceeding this approximate length will cause string.match
 * to exceed Firefox&#039;s stack quota. This situation can be encountered
 * when goog.globalEval is invoked with a long argument; such as
 * when loading a module.
 * @private {number}
 * @const
 */
webdriver.stacktrace.MAX_FIREFOX_FRAMESTRING_LENGTH_ = 500000;


/**
 * RegExp pattern for JavaScript identifiers. We don&#039;t support Unicode
 * identifiers defined in ECMAScript v3.
 * @private {string}
 * @const
 */
webdriver.stacktrace.IDENTIFIER_PATTERN_ = &#039;[a-zA-Z_$][\\w$]*&#039;;


/**
 * Pattern for a matching the type on a fully-qualified name. Forms an
 * optional sub-match on the type. For example, in &quot;foo.bar.baz&quot;, will match on
 * &quot;foo.bar&quot;.
 * @private {string}
 * @const
 */
webdriver.stacktrace.CONTEXT_PATTERN_ =
    &#039;(&#039; + webdriver.stacktrace.IDENTIFIER_PATTERN_ +
    &#039;(?:\\.&#039; + webdriver.stacktrace.IDENTIFIER_PATTERN_ + &#039;)*)\\.&#039;;


/**
 * Pattern for matching a fully qualified name. Will create two sub-matches:
 * the type (optional), and the name. For example, in &quot;foo.bar.baz&quot;, will
 * match on [&quot;foo.bar&quot;, &quot;baz&quot;].
 * @private {string}
 * @const
 */
webdriver.stacktrace.QUALIFIED_NAME_PATTERN_ =
    &#039;(?:&#039; + webdriver.stacktrace.CONTEXT_PATTERN_ + &#039;)?&#039; +
    &#039;(&#039; + webdriver.stacktrace.IDENTIFIER_PATTERN_ + &#039;)&#039;;


/**
 * RegExp pattern for function name alias in the V8 stack trace.
 * @private {string}
 * @const
 */
webdriver.stacktrace.V8_ALIAS_PATTERN_ =
    &#039;(?: \\[as (&#039; + webdriver.stacktrace.IDENTIFIER_PATTERN_ + &#039;)\\])?&#039;;


/**
 * RegExp pattern for function names and constructor calls in the V8 stack
 * trace.
 * @private {string}
 * @const
 */
webdriver.stacktrace.V8_FUNCTION_NAME_PATTERN_ =
    &#039;(?:&#039; + webdriver.stacktrace.IDENTIFIER_PATTERN_ + &#039;|&lt;anonymous&gt;)&#039;;


/**
 * RegExp pattern for the context of a function call in V8. Creates two
 * submatches, only one of which will ever match: either the namespace
 * identifier (with optional &quot;new&quot; keyword in the case of a constructor call),
 * or just the &quot;new &quot; phrase for a top level constructor call.
 * @private {string}
 * @const
 */
webdriver.stacktrace.V8_CONTEXT_PATTERN_ =
    &#039;(?:((?:new )?(?:\\[object Object\\]|&#039; +
    webdriver.stacktrace.IDENTIFIER_PATTERN_ +
    &#039;(?:\\.&#039; + webdriver.stacktrace.IDENTIFIER_PATTERN_ + &#039;)*)&#039; +
    &#039;)\\.|(new ))&#039;;


/**
 * RegExp pattern for function call in the V8 stack trace.
 * Creates 3 submatches with context object (optional), function name and
 * function alias (optional).
 * @private {string}
 * @const
 */
webdriver.stacktrace.V8_FUNCTION_CALL_PATTERN_ =
    &#039; (?:&#039; + webdriver.stacktrace.V8_CONTEXT_PATTERN_ + &#039;)?&#039; +
    &#039;(&#039; + webdriver.stacktrace.V8_FUNCTION_NAME_PATTERN_ + &#039;)&#039; +
    webdriver.stacktrace.V8_ALIAS_PATTERN_;


/**
 * RegExp pattern for an URL + position inside the file.
 * @private {string}
 * @const
 */
webdriver.stacktrace.URL_PATTERN_ =
    &#039;((?:http|https|file)://[^\\s]+|javascript:.*)&#039;;


/**
 * RegExp pattern for a location string in a V8 stack frame. Creates two
 * submatches for the location, one for enclosed in parentheticals and on
 * where the location appears alone (which will only occur if the location is
 * the only information in the frame).
 * @private {string}
 * @const
 * @see http://code.google.com/p/v8/wiki/JavaScriptStackTraceApi
 */
webdriver.stacktrace.V8_LOCATION_PATTERN_ = &#039; (?:\\((.*)\\)|(.*))&#039;;


/**
 * Regular expression for parsing one stack frame in V8.
 * @private {!RegExp}
 * @const
 */
webdriver.stacktrace.V8_STACK_FRAME_REGEXP_ = new RegExp(&#039;^\\s+at&#039; +
    // Prevent intersections with IE10 stack frame regex.
    &#039;(?! (?:Anonymous function|Global code|eval code) )&#039; +
    &#039;(?:&#039; + webdriver.stacktrace.V8_FUNCTION_CALL_PATTERN_ + &#039;)?&#039; +
    webdriver.stacktrace.V8_LOCATION_PATTERN_ + &#039;$&#039;);


/**
 * RegExp pattern for function names in the Firefox stack trace.
 * Firefox has extended identifiers to deal with inner functions and anonymous
 * functions: https://bugzilla.mozilla.org/show_bug.cgi?id=433529#c9
 * @private {string}
 * @const
 */
webdriver.stacktrace.FIREFOX_FUNCTION_NAME_PATTERN_ =
    webdriver.stacktrace.IDENTIFIER_PATTERN_ + &#039;[\\w./&lt;$]*&#039;;


/**
 * RegExp pattern for function call in the Firefox stack trace.
 * Creates a submatch for the function name.
 * @private {string}
 * @const
 */
webdriver.stacktrace.FIREFOX_FUNCTION_CALL_PATTERN_ =
    &#039;(&#039; + webdriver.stacktrace.FIREFOX_FUNCTION_NAME_PATTERN_ + &#039;)?&#039; +
    &#039;(?:\\(.*\\))?@&#039;;


/**
 * Regular expression for parsing one stack frame in Firefox.
 * @private {!RegExp}
 * @const
 */
webdriver.stacktrace.FIREFOX_STACK_FRAME_REGEXP_ = new RegExp(&#039;^&#039; +
    webdriver.stacktrace.FIREFOX_FUNCTION_CALL_PATTERN_ +
    &#039;(?::0|&#039; + webdriver.stacktrace.URL_PATTERN_ + &#039;)$&#039;);


/**
 * RegExp pattern for an anonymous function call in an Opera stack frame.
 * Creates 2 (optional) submatches: the context object and function name.
 * @private {string}
 * @const
 */
webdriver.stacktrace.OPERA_ANONYMOUS_FUNCTION_NAME_PATTERN_ =
    &#039;&lt;anonymous function(?:\\: &#039; +
    webdriver.stacktrace.QUALIFIED_NAME_PATTERN_ + &#039;)?&gt;&#039;;


/**
 * RegExp pattern for a function call in an Opera stack frame.
 * Creates 3 (optional) submatches: the function name (if not anonymous),
 * the aliased context object and the function name (if anonymous).
 * @private {string}
 * @const
 */
webdriver.stacktrace.OPERA_FUNCTION_CALL_PATTERN_ =
    &#039;(?:(?:(&#039; + webdriver.stacktrace.IDENTIFIER_PATTERN_ + &#039;)|&#039; +
    webdriver.stacktrace.OPERA_ANONYMOUS_FUNCTION_NAME_PATTERN_ +
    &#039;)(?:\\(.*\\)))?@&#039;;


/**
 * Regular expression for parsing on stack frame in Opera 11.68+
 * @private {!RegExp}
 * @const
 */
webdriver.stacktrace.OPERA_STACK_FRAME_REGEXP_ = new RegExp(&#039;^&#039; +
    webdriver.stacktrace.OPERA_FUNCTION_CALL_PATTERN_ +
    webdriver.stacktrace.URL_PATTERN_ + &#039;?$&#039;);


/**
 * RegExp pattern for function call in a Chakra (IE) stack trace. This
 * expression creates 2 submatches on the (optional) context and function name,
 * matching identifiers like &#039;foo.Bar.prototype.baz&#039;, &#039;Anonymous function&#039;,
 * &#039;eval code&#039;, and &#039;Global code&#039;.
 * @private {string}
 * @const
 */
webdriver.stacktrace.CHAKRA_FUNCTION_CALL_PATTERN_ =
    &#039;(?:(&#039; + webdriver.stacktrace.IDENTIFIER_PATTERN_ +
    &#039;(?:\\.&#039; + webdriver.stacktrace.IDENTIFIER_PATTERN_ + &#039;)*)\\.)?&#039; +
    &#039;(&#039; + webdriver.stacktrace.IDENTIFIER_PATTERN_ + &#039;(?:\\s+\\w+)*)&#039;;


/**
 * Regular expression for parsing on stack frame in Chakra (IE).
 * @private {!RegExp}
 * @const
 */
webdriver.stacktrace.CHAKRA_STACK_FRAME_REGEXP_ = new RegExp(&#039;^   at &#039; +
    webdriver.stacktrace.CHAKRA_FUNCTION_CALL_PATTERN_ +
    &#039;\\s*(?:\\((.*)\\))$&#039;);


/**
 * Placeholder for an unparsable frame in a stack trace generated by
 * {@link goog.testing.stacktrace}.
 * @private {string}
 * @const
 */
webdriver.stacktrace.UNKNOWN_CLOSURE_FRAME_ = &#039;&gt; (unknown)&#039;;


/**
 * Representation of an anonymous frame in a stack trace generated by
 * {@link goog.testing.stacktrace}.
 * @private {string}
 * @const
 */
webdriver.stacktrace.ANONYMOUS_CLOSURE_FRAME_ = &#039;&gt; anonymous&#039;;


/**
 * Pattern for a function call in a Closure stack trace. Creates three optional
 * submatches: the context, function name, and alias.
 * @private {string}
 * @const
 */
webdriver.stacktrace.CLOSURE_FUNCTION_CALL_PATTERN_ =
    webdriver.stacktrace.QUALIFIED_NAME_PATTERN_ +
    &#039;(?:\\(.*\\))?&#039; +  // Ignore arguments if present.
    webdriver.stacktrace.V8_ALIAS_PATTERN_;


/**
 * Regular expression for parsing a stack frame generated by Closure&#039;s
 * {@link goog.testing.stacktrace}.
 * @private {!RegExp}
 * @const
 */
webdriver.stacktrace.CLOSURE_STACK_FRAME_REGEXP_ = new RegExp(&#039;^&gt; &#039; +
    &#039;(?:&#039; + webdriver.stacktrace.CLOSURE_FUNCTION_CALL_PATTERN_ +
    &#039;(?: at )?)?&#039; +
    &#039;(?:(.*:\\d+:\\d+)|&#039; + webdriver.stacktrace.URL_PATTERN_ + &#039;)?$&#039;);


/**
 * Parses one stack frame.
 * @param {string} frameStr The stack frame as string.
 * @return {webdriver.stacktrace.Frame} Stack frame object or null if the
 *     parsing failed.
 * @private
 */
webdriver.stacktrace.parseStackFrame_ = function(frameStr) {
  var m = frameStr.match(webdriver.stacktrace.V8_STACK_FRAME_REGEXP_);
  if (m) {
    return new webdriver.stacktrace.Frame(
        m[1] || m[2], m[3], m[4], m[5] || m[6]);
  }

  if (frameStr.length &gt;
      webdriver.stacktrace.MAX_FIREFOX_FRAMESTRING_LENGTH_) {
    return webdriver.stacktrace.parseLongFirefoxFrame_(frameStr);
  }

  m = frameStr.match(webdriver.stacktrace.FIREFOX_STACK_FRAME_REGEXP_);
  if (m) {
    return new webdriver.stacktrace.Frame(&#039;&#039;, m[1], &#039;&#039;, m[2]);
  }

  m = frameStr.match(webdriver.stacktrace.OPERA_STACK_FRAME_REGEXP_);
  if (m) {
    return new webdriver.stacktrace.Frame(m[2], m[1] || m[3], &#039;&#039;, m[4]);
  }

  m = frameStr.match(webdriver.stacktrace.CHAKRA_STACK_FRAME_REGEXP_);
  if (m) {
    return new webdriver.stacktrace.Frame(m[1], m[2], &#039;&#039;, m[3]);
  }

  if (frameStr == webdriver.stacktrace.UNKNOWN_CLOSURE_FRAME_ ||
      frameStr == webdriver.stacktrace.ANONYMOUS_CLOSURE_FRAME_) {
    return webdriver.stacktrace.ANONYMOUS_FRAME_;
  }

  m = frameStr.match(webdriver.stacktrace.CLOSURE_STACK_FRAME_REGEXP_);
  if (m) {
    return new webdriver.stacktrace.Frame(m[1], m[2], m[3], m[4] || m[5]);
  }

  return null;
};


/**
 * Parses a long firefox stack frame.
 * @param {string} frameStr The stack frame as string.
 * @return {!webdriver.stacktrace.Frame} Stack frame object.
 * @private
 */
webdriver.stacktrace.parseLongFirefoxFrame_ = function(frameStr) {
  var firstParen = frameStr.indexOf(&#039;(&#039;);
  var lastAmpersand = frameStr.lastIndexOf(&#039;@&#039;);
  var lastColon = frameStr.lastIndexOf(&#039;:&#039;);
  var functionName = &#039;&#039;;
  if ((firstParen &gt;= 0) &amp;&amp; (firstParen &lt; lastAmpersand)) {
    functionName = frameStr.substring(0, firstParen);
  }
  var loc = &#039;&#039;;
  if ((lastAmpersand &gt;= 0) &amp;&amp; (lastAmpersand + 1 &lt; lastColon)) {
    loc = frameStr.substring(lastAmpersand + 1);
  }
  return new webdriver.stacktrace.Frame(&#039;&#039;, functionName, &#039;&#039;, loc);
};


/**
 * Get an error&#039;s stack trace with the error string trimmed.
 * V8 prepends the string representation of an error to its stack trace.
 * This function trims the string so that the stack trace can be parsed
 * consistently with the other JS engines.
 * @param {(Error|goog.testing.JsUnitException)} error The error.
 * @return {string} The stack trace string.
 * @private
 */
webdriver.stacktrace.getStack_ = function(error) {
  if (!error) {
    return &#039;&#039;;
  }
  var stack = error.stack || error.stackTrace || &#039;&#039;;
  var errorStr = error + &#039;\n&#039;;
  if (goog.string.startsWith(stack, errorStr)) {
    stack = stack.substring(errorStr.length);
  }
  return stack;
};


/**
 * Formats an error&#039;s stack trace.
 * @param {!(Error|goog.testing.JsUnitException)} error The error to format.
 * @return {!(Error|goog.testing.JsUnitException)} The formatted error.
 */
webdriver.stacktrace.format = function(error) {
  var stack = webdriver.stacktrace.getStack_(error);
  var frames = webdriver.stacktrace.parse_(stack);

  // If the original stack is in an unexpected format, our formatted stack
  // trace will be a bunch of &quot;    at &lt;anonymous&gt;&quot; lines. If this is the case,
  // just return the error unmodified to avoid losing information. This is
  // necessary since the user may have defined a custom stack formatter in
  // V8 via Error.prepareStackTrace. See issue 7994.
  var isAnonymousFrame = function(frame) {
    return frame.toString() === &#039;    at &lt;anonymous&gt;&#039;;
  };
  if (frames.length &amp;&amp; goog.array.every(frames, isAnonymousFrame)) {
    return error;
  }

  // Older versions of IE simply return [object Error] for toString(), so
  // only use that as a last resort.
  var errorStr = &#039;&#039;;
  if (error.message) {
    errorStr = (error.name ? error.name + &#039;: &#039; : &#039;&#039;) + error.message;
  } else {
    errorStr = error.toString();
  }

  // Ensure the error is in the V8 style with the error&#039;s string representation
  // prepended to the stack.
  error.stack = errorStr + &#039;\n&#039; + frames.join(&#039;\n&#039;);
  return error;
};


/**
 * Parses an Error object&#039;s stack trace.
 * @param {string} stack The stack trace.
 * @return {!Array.&lt;!webdriver.stacktrace.Frame&gt;} Stack frames. The
 *     unrecognized frames will be nulled out.
 * @private
 */
webdriver.stacktrace.parse_ = function(stack) {
  if (!stack) {
    return [];
  }

  var lines = stack.
      replace(/\s*$/, &#039;&#039;).
      split(&#039;\n&#039;);
  var frames = [];
  for (var i = 0; i &lt; lines.length; i++) {
    var frame = webdriver.stacktrace.parseStackFrame_(lines[i]);
    // The first two frames will be:
    //   webdriver.stacktrace.Snapshot()
    //   webdriver.stacktrace.get()
    // In the case of Opera, sometimes an extra frame is injected in the next
    // frame with a reported line number of zero. The next line detects that
    // case and skips that frame.
    if (!(goog.userAgent.OPERA &amp;&amp; i == 2 &amp;&amp; frame.getLine() == 0)) {
      frames.push(frame || webdriver.stacktrace.ANONYMOUS_FRAME_);
    }
  }
  return frames;
};


/**
 * Gets the native stack trace if available otherwise follows the call chain.
 * The generated trace will exclude all frames up to and including the call to
 * this function.
 * @return {!Array.&lt;!webdriver.stacktrace.Frame&gt;} The frames of the stack trace.
 */
webdriver.stacktrace.get = function() {
  return new webdriver.stacktrace.Snapshot(1).getStacktrace();
};</textarea>
  </div>
</div>

<footer class="footer">
  <div class="container">
    <p>.</p>
  </div>
</footer>

<script type="text/html" id="complexity-popover-template">
  <div class="complexity-notice">
    Complexity : {{ complexity.cyclomatic }} <br>
    Length : {{ complexity.halstead.length }} <br>
    Difficulty : {{ complexity.halstead.difficulty.toFixed(2) }} <br>
    Est # bugs : {{ complexity.halstead.bugs.toFixed(2) }}<br>
  </div>
</script>

<script type="text/javascript" src="../../assets/scripts/bundles/core-bundle.js"></script>
<script type="text/javascript" src="../../assets/scripts/bundles/codemirror.js"></script>
<script type="text/javascript" src="../../assets/scripts/codemirror.markpopovertext.js"></script>
<script type="text/javascript" src="report.js"></script>
<script type="text/javascript" src="report.history.js"></script>
<script type="text/javascript" src="../../assets/scripts/plato-file.js"></script>
</body>
</html>
