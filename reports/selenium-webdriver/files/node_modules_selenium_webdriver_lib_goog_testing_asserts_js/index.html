<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Plato - node_modules/selenium-webdriver/lib/goog/testing/asserts.js</title>

  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="">
  <meta name="author" content="">

  <!--[if lt IE 9]>
  <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->

  <link href="../../assets/css/vendor/morris.css" rel="stylesheet">
  <link href="../../assets/css/vendor/bootstrap.css" rel="stylesheet">
  <link href="../../assets/css/vendor/font-awesome.css" rel="stylesheet">
  <link href="../../assets/css/vendor/codemirror.css" rel="stylesheet">
  <link href="../../assets/css/plato.css" rel="stylesheet">
  <link href="../../assets/css/plato-file.css" rel="stylesheet">

</head>

<body>

<div class="navbar navbar-fixed-top">
  <div class="container">
    <a class="navbar-brand" href="http://github.com/es-analysis/plato">Plato on Github</a>
    <ul class="nav navbar-nav">
      <li>
        <a href="../../index.html">Report Home</a>
      </li>
    </ul>
  </div>
</div>

<div class="jumbotron">
  <div class="container">
    <h1>node_modules/selenium-webdriver/lib/goog/testing/asserts.js</h1>
  </div>
</div>

<div class="container aggregate-stats">
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Maintainability <a href="http://blogs.msdn.com/b/codeanalysis/archive/2007/11/20/maintainability-index-range-and-meaning.aspx"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="A value between 0 and 100 that represents the relative ease of maintaining the code. A high value means better maintainability." data-original-title="Maintainability Index"  data-container="body"></i></a></h2>
      <p class="stat">66.04</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Lines of code <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h2>
      <p class="stat">1248</p>
    </div>
  </div>
  <div class="row historical">
    <div class="col-md-6">
      <p id="chart_historical_maint" class="chart"></p>
    </div>
    <div class="col-md-6">
      <p id="chart_historical_sloc" class="chart"></p>
    </div>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Difficulty  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="The difficulty measure is related to the difficulty of the program to write or understand." data-original-title="Difficulty" data-container="body"></i></a></h2>
      <p class="stat">123.92</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Estimated Errors  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Halstead's delivered bugs is an estimate for the number of errors in the implementation." data-original-title="Delivered Bugs" data-container="body"></i></a></h2>
      <p class="stat">10.39</p>
    </div>
  </div>
</div>

<div class="container charts">
  <div class="row">
    <h2 class="header">Function weight</h2>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h3 class="chart-header">By Complexity <a href="http://en.wikipedia.org/wiki/Cyclomatic_complexity"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="This metric counts the number of distinct paths through a block of code. Lower values are better." data-original-title="Cyclomatic Complexity" data-container="body"></i></a></h3>
      <div id="fn-by-complexity" class="stat"></div>
    </div>
    <div class="col-md-6">
      <h3 class="chart-header">By SLOC  <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h3>
      <div id="fn-by-sloc" class="stat"></div>
    </div>
  </div>
</div>

<div class="container">
  <div class="row">
    <textarea id="file-source" class="col-md-12">// Copyright 2010 The Closure Library Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an &quot;AS-IS&quot; BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
goog.provide(&#039;goog.testing.JsUnitException&#039;);
goog.provide(&#039;goog.testing.asserts&#039;);

goog.require(&#039;goog.testing.stacktrace&#039;);

// TODO(user): Copied from JsUnit with some small modifications, we should
// reimplement the asserters.


/**
 * @typedef {Array|NodeList|Arguments|{length: number}}
 */
goog.testing.asserts.ArrayLike;

var DOUBLE_EQUALITY_PREDICATE = function(var1, var2) {
  return var1 == var2;
};
var JSUNIT_UNDEFINED_VALUE;
var TO_STRING_EQUALITY_PREDICATE = function(var1, var2) {
  return var1.toString() === var2.toString();
};

var PRIMITIVE_EQUALITY_PREDICATES = {
  &#039;String&#039;: DOUBLE_EQUALITY_PREDICATE,
  &#039;Number&#039;: DOUBLE_EQUALITY_PREDICATE,
  &#039;Boolean&#039;: DOUBLE_EQUALITY_PREDICATE,
  &#039;Date&#039;: function(date1, date2) {
    return date1.getTime() == date2.getTime();
  },
  &#039;RegExp&#039;: TO_STRING_EQUALITY_PREDICATE,
  &#039;Function&#039;: TO_STRING_EQUALITY_PREDICATE
};


/**
 * Compares equality of two numbers, allowing them to differ up to a given
 * tolerance.
 * @param {number} var1 A number.
 * @param {number} var2 A number.
 * @param {number} tolerance the maximum allowed difference.
 * @return {boolean} Whether the two variables are sufficiently close.
 * @private
 */
goog.testing.asserts.numberRoughEqualityPredicate_ = function(
    var1, var2, tolerance) {
  return Math.abs(var1 - var2) &lt;= tolerance;
};


/**
 * @type {Object.&lt;string, function(*, *, number): boolean&gt;}
 * @private
 */
goog.testing.asserts.primitiveRoughEqualityPredicates_ = {
  &#039;Number&#039;: goog.testing.asserts.numberRoughEqualityPredicate_
};


var _trueTypeOf = function(something) {
  var result = typeof something;
  try {
    switch (result) {
      case &#039;string&#039;:
        break;
      case &#039;boolean&#039;:
        break;
      case &#039;number&#039;:
        break;
      case &#039;object&#039;:
        if (something == null) {
          result = &#039;null&#039;;
          break;
        }
      case &#039;function&#039;:
        switch (something.constructor) {
          case new String(&#039;&#039;).constructor:
            result = &#039;String&#039;;
            break;
          case new Boolean(true).constructor:
            result = &#039;Boolean&#039;;
            break;
          case new Number(0).constructor:
            result = &#039;Number&#039;;
            break;
          case new Array().constructor:
            result = &#039;Array&#039;;
            break;
          case new RegExp().constructor:
            result = &#039;RegExp&#039;;
            break;
          case new Date().constructor:
            result = &#039;Date&#039;;
            break;
          case Function:
            result = &#039;Function&#039;;
            break;
          default:
            var m = something.constructor.toString().match(
                /function\s*([^( ]+)\(/);
            if (m) {
              result = m[1];
            } else {
              break;
            }
        }
        break;
    }
  } catch (e) {

  } finally {
    result = result.substr(0, 1).toUpperCase() + result.substr(1);
  }
  return result;
};

var _displayStringForValue = function(aVar) {
  var result;
  try {
    result = &#039;&lt;&#039; + String(aVar) + &#039;&gt;&#039;;
  } catch (ex) {
    result = &#039;&lt;toString failed: &#039; + ex.message + &#039;&gt;&#039;;
    // toString does not work on this object :-(
  }
  if (!(aVar === null || aVar === JSUNIT_UNDEFINED_VALUE)) {
    result += &#039; (&#039; + _trueTypeOf(aVar) + &#039;)&#039;;
  }
  return result;
};

var fail = function(failureMessage) {
  goog.testing.asserts.raiseException(&#039;Call to fail()&#039;, failureMessage);
};

var argumentsIncludeComments = function(expectedNumberOfNonCommentArgs, args) {
  return args.length == expectedNumberOfNonCommentArgs + 1;
};

var commentArg = function(expectedNumberOfNonCommentArgs, args) {
  if (argumentsIncludeComments(expectedNumberOfNonCommentArgs, args)) {
    return args[0];
  }

  return null;
};

var nonCommentArg = function(desiredNonCommentArgIndex,
    expectedNumberOfNonCommentArgs, args) {
  return argumentsIncludeComments(expectedNumberOfNonCommentArgs, args) ?
      args[desiredNonCommentArgIndex] :
      args[desiredNonCommentArgIndex - 1];
};

var _validateArguments = function(expectedNumberOfNonCommentArgs, args) {
  var valid = args.length == expectedNumberOfNonCommentArgs ||
      args.length == expectedNumberOfNonCommentArgs + 1 &amp;&amp;
      goog.isString(args[0]);
  _assert(null, valid, &#039;Incorrect arguments passed to assert function&#039;);
};

var _assert = function(comment, booleanValue, failureMessage) {
  if (!booleanValue) {
    goog.testing.asserts.raiseException(comment, failureMessage);
  }
};


/**
 * @param {*} expected The expected value.
 * @param {*} actual The actual value.
 * @return {string} A failure message of the values don&#039;t match.
 * @private
 */
goog.testing.asserts.getDefaultErrorMsg_ = function(expected, actual) {
  var msg = &#039;Expected &#039; + _displayStringForValue(expected) + &#039; but was &#039; +
      _displayStringForValue(actual);
  if ((typeof expected == &#039;string&#039;) &amp;&amp; (typeof actual == &#039;string&#039;)) {
    // Try to find a human-readable difference.
    var limit = Math.min(expected.length, actual.length);
    var commonPrefix = 0;
    while (commonPrefix &lt; limit &amp;&amp;
        expected.charAt(commonPrefix) == actual.charAt(commonPrefix)) {
      commonPrefix++;
    }

    var commonSuffix = 0;
    while (commonSuffix &lt; limit &amp;&amp;
        expected.charAt(expected.length - commonSuffix - 1) ==
            actual.charAt(actual.length - commonSuffix - 1)) {
      commonSuffix++;
    }

    if (commonPrefix + commonSuffix &gt; limit) {
      commonSuffix = 0;
    }

    if (commonPrefix &gt; 2 || commonSuffix &gt; 2) {
      var printString = function(str) {
        var startIndex = Math.max(0, commonPrefix - 2);
        var endIndex = Math.min(str.length, str.length - (commonSuffix - 2));
        return (startIndex &gt; 0 ? &#039;...&#039; : &#039;&#039;) +
            str.substring(startIndex, endIndex) +
            (endIndex &lt; str.length ? &#039;...&#039; : &#039;&#039;);
      };

      msg += &#039;\nDifference was at position &#039; + commonPrefix +
          &#039;. Expected [&#039; + printString(expected) +
          &#039;] vs. actual [&#039; + printString(actual) + &#039;]&#039;;
    }
  }
  return msg;
};


/**
 * @param {*} a The value to assert (1 arg) or debug message (2 args).
 * @param {*=} opt_b The value to assert (2 args only).
 */
var assert = function(a, opt_b) {
  _validateArguments(1, arguments);
  var comment = commentArg(1, arguments);
  var booleanValue = nonCommentArg(1, 1, arguments);

  _assert(comment, goog.isBoolean(booleanValue),
      &#039;Bad argument to assert(boolean)&#039;);
  _assert(comment, booleanValue, &#039;Call to assert(boolean) with false&#039;);
};


/**
 * Asserts that the function throws an error.
 *
 * @param {!(string|Function)} a The assertion comment or the function to call.
 * @param {!Function=} opt_b The function to call (if the first argument of
 *     {@code assertThrows} was the comment).
 * @return {*} The error thrown by the function.
 * @throws {goog.testing.JsUnitException} If the assertion failed.
 */
var assertThrows = function(a, opt_b) {
  _validateArguments(1, arguments);
  var func = nonCommentArg(1, 1, arguments);
  var comment = commentArg(1, arguments);
  _assert(comment, typeof func == &#039;function&#039;,
      &#039;Argument passed to assertThrows is not a function&#039;);

  try {
    func();
  } catch (e) {
    if (e &amp;&amp; goog.isString(e[&#039;stacktrace&#039;]) &amp;&amp; goog.isString(e[&#039;message&#039;])) {
      // Remove the stack trace appended to the error message by Opera 10.0
      var startIndex = e[&#039;message&#039;].length - e[&#039;stacktrace&#039;].length;
      if (e[&#039;message&#039;].indexOf(e[&#039;stacktrace&#039;], startIndex) == startIndex) {
        e[&#039;message&#039;] = e[&#039;message&#039;].substr(0, startIndex - 14);
      }
    }
    return e;
  }
  goog.testing.asserts.raiseException(comment,
      &#039;No exception thrown from function passed to assertThrows&#039;);
};


/**
 * Asserts that the function does not throw an error.
 *
 * @param {!(string|Function)} a The assertion comment or the function to call.
 * @param {!Function=} opt_b The function to call (if the first argument of
 *     {@code assertNotThrows} was the comment).
 * @return {*} The return value of the function.
 * @throws {goog.testing.JsUnitException} If the assertion failed.
 */
var assertNotThrows = function(a, opt_b) {
  _validateArguments(1, arguments);
  var comment = commentArg(1, arguments);
  var func = nonCommentArg(1, 1, arguments);
  _assert(comment, typeof func == &#039;function&#039;,
      &#039;Argument passed to assertNotThrows is not a function&#039;);

  try {
    return func();
  } catch (e) {
    comment = comment ? (comment + &#039;\n&#039;) : &#039;&#039;;
    comment += &#039;A non expected exception was thrown from function passed to &#039; +
               &#039;assertNotThrows&#039;;
    // Some browsers don&#039;t have a stack trace so at least have the error
    // description.
    var stackTrace = e[&#039;stack&#039;] || e[&#039;stacktrace&#039;] || e.toString();
    goog.testing.asserts.raiseException(comment, stackTrace);
  }
};


/**
 * Asserts that the given callback function results in a JsUnitException when
 * called, and that the resulting failure message matches the given expected
 * message.
 * @param {function() : void} callback Function to be run expected to result
 *     in a JsUnitException (usually contains a call to an assert).
 * @param {string=} opt_expectedMessage Failure message expected to be given
 *     with the exception.
 */
var assertThrowsJsUnitException = function(callback, opt_expectedMessage) {
  var failed = false;
  try {
    goog.testing.asserts.callWithoutLogging(callback);
  } catch (ex) {
    if (!ex.isJsUnitException) {
      fail(&#039;Expected a JsUnitException&#039;);
    }
    if (typeof opt_expectedMessage != &#039;undefined&#039; &amp;&amp;
        ex.message != opt_expectedMessage) {
      fail(&#039;Expected message [&#039; + opt_expectedMessage + &#039;] but got [&#039; +
          ex.message + &#039;]&#039;);
    }
    failed = true;
  }
  if (!failed) {
    fail(&#039;Expected a failure: &#039; + opt_expectedMessage);
  }
};


/**
 * @param {*} a The value to assert (1 arg) or debug message (2 args).
 * @param {*=} opt_b The value to assert (2 args only).
 */
var assertTrue = function(a, opt_b) {
  _validateArguments(1, arguments);
  var comment = commentArg(1, arguments);
  var booleanValue = nonCommentArg(1, 1, arguments);

  _assert(comment, goog.isBoolean(booleanValue),
      &#039;Bad argument to assertTrue(boolean)&#039;);
  _assert(comment, booleanValue, &#039;Call to assertTrue(boolean) with false&#039;);
};


/**
 * @param {*} a The value to assert (1 arg) or debug message (2 args).
 * @param {*=} opt_b The value to assert (2 args only).
 */
var assertFalse = function(a, opt_b) {
  _validateArguments(1, arguments);
  var comment = commentArg(1, arguments);
  var booleanValue = nonCommentArg(1, 1, arguments);

  _assert(comment, goog.isBoolean(booleanValue),
      &#039;Bad argument to assertFalse(boolean)&#039;);
  _assert(comment, !booleanValue, &#039;Call to assertFalse(boolean) with true&#039;);
};


/**
 * @param {*} a The expected value (2 args) or the debug message (3 args).
 * @param {*} b The actual value (2 args) or the expected value (3 args).
 * @param {*=} opt_c The actual value (3 args only).
 */
var assertEquals = function(a, b, opt_c) {
  _validateArguments(2, arguments);
  var var1 = nonCommentArg(1, 2, arguments);
  var var2 = nonCommentArg(2, 2, arguments);
  _assert(commentArg(2, arguments), var1 === var2,
          goog.testing.asserts.getDefaultErrorMsg_(var1, var2));
};


/**
 * @param {*} a The expected value (2 args) or the debug message (3 args).
 * @param {*} b The actual value (2 args) or the expected value (3 args).
 * @param {*=} opt_c The actual value (3 args only).
 */
var assertNotEquals = function(a, b, opt_c) {
  _validateArguments(2, arguments);
  var var1 = nonCommentArg(1, 2, arguments);
  var var2 = nonCommentArg(2, 2, arguments);
  _assert(commentArg(2, arguments), var1 !== var2,
      &#039;Expected not to be &#039; + _displayStringForValue(var2));
};


/**
 * @param {*} a The value to assert (1 arg) or debug message (2 args).
 * @param {*=} opt_b The value to assert (2 args only).
 */
var assertNull = function(a, opt_b) {
  _validateArguments(1, arguments);
  var aVar = nonCommentArg(1, 1, arguments);
  _assert(commentArg(1, arguments), aVar === null,
      goog.testing.asserts.getDefaultErrorMsg_(null, aVar));
};


/**
 * @param {*} a The value to assert (1 arg) or debug message (2 args).
 * @param {*=} opt_b The value to assert (2 args only).
 */
var assertNotNull = function(a, opt_b) {
  _validateArguments(1, arguments);
  var aVar = nonCommentArg(1, 1, arguments);
  _assert(commentArg(1, arguments), aVar !== null,
      &#039;Expected not to be &#039; + _displayStringForValue(null));
};


/**
 * @param {*} a The value to assert (1 arg) or debug message (2 args).
 * @param {*=} opt_b The value to assert (2 args only).
 */
var assertUndefined = function(a, opt_b) {
  _validateArguments(1, arguments);
  var aVar = nonCommentArg(1, 1, arguments);
  _assert(commentArg(1, arguments), aVar === JSUNIT_UNDEFINED_VALUE,
      goog.testing.asserts.getDefaultErrorMsg_(JSUNIT_UNDEFINED_VALUE, aVar));
};


/**
 * @param {*} a The value to assert (1 arg) or debug message (2 args).
 * @param {*=} opt_b The value to assert (2 args only).
 */
var assertNotUndefined = function(a, opt_b) {
  _validateArguments(1, arguments);
  var aVar = nonCommentArg(1, 1, arguments);
  _assert(commentArg(1, arguments), aVar !== JSUNIT_UNDEFINED_VALUE,
      &#039;Expected not to be &#039; + _displayStringForValue(JSUNIT_UNDEFINED_VALUE));
};


/**
 * @param {*} a The value to assert (1 arg) or debug message (2 args).
 * @param {*=} opt_b The value to assert (2 args only).
 */
var assertNotNullNorUndefined = function(a, opt_b) {
  _validateArguments(1, arguments);
  assertNotNull.apply(null, arguments);
  assertNotUndefined.apply(null, arguments);
};


/**
 * @param {*} a The value to assert (1 arg) or debug message (2 args).
 * @param {*=} opt_b The value to assert (2 args only).
 */
var assertNonEmptyString = function(a, opt_b) {
  _validateArguments(1, arguments);
  var aVar = nonCommentArg(1, 1, arguments);
  _assert(commentArg(1, arguments),
      aVar !== JSUNIT_UNDEFINED_VALUE &amp;&amp; aVar !== null &amp;&amp;
      typeof aVar == &#039;string&#039; &amp;&amp; aVar !== &#039;&#039;,
      &#039;Expected non-empty string but was &#039; + _displayStringForValue(aVar));
};


/**
 * @param {*} a The value to assert (1 arg) or debug message (2 args).
 * @param {*=} opt_b The value to assert (2 args only).
 */
var assertNaN = function(a, opt_b) {
  _validateArguments(1, arguments);
  var aVar = nonCommentArg(1, 1, arguments);
  _assert(commentArg(1, arguments), isNaN(aVar), &#039;Expected NaN&#039;);
};


/**
 * @param {*} a The value to assert (1 arg) or debug message (2 args).
 * @param {*=} opt_b The value to assert (2 args only).
 */
var assertNotNaN = function(a, opt_b) {
  _validateArguments(1, arguments);
  var aVar = nonCommentArg(1, 1, arguments);
  _assert(commentArg(1, arguments), !isNaN(aVar), &#039;Expected not NaN&#039;);
};


/**
 * Runs a function in an environment where test failures are not logged. This is
 * useful for testing test code, where failures can be a normal part of a test.
 * @param {function() : void} fn Function to run without logging failures.
 */
goog.testing.asserts.callWithoutLogging = function(fn) {
  var testRunner = goog.global[&#039;G_testRunner&#039;];
  var oldLogTestFailure = testRunner[&#039;logTestFailure&#039;];
  try {
    // Any failures in the callback shouldn&#039;t be recorded.
    testRunner[&#039;logTestFailure&#039;] = undefined;
    fn();
  } finally {
    testRunner[&#039;logTestFailure&#039;] = oldLogTestFailure;
  }
};


/**
 * The return value of the equality predicate passed to findDifferences below,
 * in cases where the predicate can&#039;t test the input variables for equality.
 * @type {?string}
 */
goog.testing.asserts.EQUALITY_PREDICATE_CANT_PROCESS = null;


/**
 * The return value of the equality predicate passed to findDifferences below,
 * in cases where the input vriables are equal.
 * @type {?string}
 */
goog.testing.asserts.EQUALITY_PREDICATE_VARS_ARE_EQUAL = &#039;&#039;;


/**
 * Determines if two items of any type match, and formulates an error message
 * if not.
 * @param {*} expected Expected argument to match.
 * @param {*} actual Argument as a result of performing the test.
 * @param {(function(string, *, *): ?string)=} opt_equalityPredicate An optional
 *     function that can be used to check equality of variables. It accepts 3
 *     arguments: type-of-variables, var1, var2 (in that order) and returns an
 *     error message if the variables are not equal,
 *     goog.testing.asserts.EQUALITY_PREDICATE_VARS_ARE_EQUAL if the variables
 *     are equal, or
 *     goog.testing.asserts.EQUALITY_PREDICATE_CANT_PROCESS if the predicate
 *     couldn&#039;t check the input variables. The function will be called only if
 *     the types of var1 and var2 are identical.
 * @return {?string} Null on success, error message on failure.
 */
goog.testing.asserts.findDifferences = function(expected, actual,
    opt_equalityPredicate) {
  var failures = [];
  var seen1 = [];
  var seen2 = [];

  // To avoid infinite recursion when the two parameters are self-referential
  // along the same path of properties, keep track of the object pairs already
  // seen in this call subtree, and abort when a cycle is detected.
  function innerAssert(var1, var2, path) {
    // This is used for testing, so we can afford to be slow (but more
    // accurate). So we just check whether var1 is in seen1. If we
    // found var1 in index i, we simply need to check whether var2 is
    // in seen2[i]. If it is, we do not recurse to check var1/var2. If
    // it isn&#039;t, we know that the structures of the two objects must be
    // different.
    //
    // This is based on the fact that values at index i in seen1 and
    // seen2 will be checked for equality eventually (when
    // innerAssert_(seen1[i], seen2[i], path) finishes).
    for (var i = 0; i &lt; seen1.length; ++i) {
      var match1 = seen1[i] === var1;
      var match2 = seen2[i] === var2;
      if (match1 || match2) {
        if (!match1 || !match2) {
          // Asymmetric cycles, so the objects have different structure.
          failures.push(&#039;Asymmetric cycle detected at &#039; + path);
        }
        return;
      }
    }

    seen1.push(var1);
    seen2.push(var2);
    innerAssert_(var1, var2, path);
    seen1.pop();
    seen2.pop();
  }

  var equalityPredicate = opt_equalityPredicate || function(type, var1, var2) {
    var typedPredicate = PRIMITIVE_EQUALITY_PREDICATES[type];
    if (!typedPredicate) {
      return goog.testing.asserts.EQUALITY_PREDICATE_CANT_PROCESS;
    }
    var equal = typedPredicate(var1, var2);
    return equal ? goog.testing.asserts.EQUALITY_PREDICATE_VARS_ARE_EQUAL :
        goog.testing.asserts.getDefaultErrorMsg_(var1, var2);
  };

  /**
   * @param {*} var1 An item in the expected object.
   * @param {*} var2 The corresponding item in the actual object.
   * @param {string} path Their path in the objects.
   * @suppress {missingProperties} The map_ property is unknown to the compiler
   *     unless goog.structs.Map is loaded.
   */
  function innerAssert_(var1, var2, path) {
    if (var1 === var2) {
      return;
    }

    var typeOfVar1 = _trueTypeOf(var1);
    var typeOfVar2 = _trueTypeOf(var2);

    if (typeOfVar1 == typeOfVar2) {
      var isArray = typeOfVar1 == &#039;Array&#039;;
      var errorMessage = equalityPredicate(typeOfVar1, var1, var2);
      if (errorMessage !=
          goog.testing.asserts.EQUALITY_PREDICATE_CANT_PROCESS) {
        if (errorMessage !=
            goog.testing.asserts.EQUALITY_PREDICATE_VARS_ARE_EQUAL) {
          failures.push(path + &#039;: &#039; + errorMessage);
        }
      } else if (isArray &amp;&amp; var1.length != var2.length) {
        failures.push(path + &#039;: Expected &#039; + var1.length + &#039;-element array &#039; +
                      &#039;but got a &#039; + var2.length + &#039;-element array&#039;);
      } else {
        var childPath = path + (isArray ? &#039;[%s]&#039; : (path ? &#039;.%s&#039; : &#039;%s&#039;));

        // if an object has an __iterator__ property, we have no way of
        // actually inspecting its raw properties, and JS 1.7 doesn&#039;t
        // overload [] to make it possible for someone to generically
        // use what the iterator returns to compare the object-managed
        // properties. This gets us into deep poo with things like
        // goog.structs.Map, at least on systems that support iteration.
        if (!var1[&#039;__iterator__&#039;]) {
          for (var prop in var1) {
            if (isArray &amp;&amp; goog.testing.asserts.isArrayIndexProp_(prop)) {
              // Skip array indices for now. We&#039;ll handle them later.
              continue;
            }

            if (prop in var2) {
              innerAssert(var1[prop], var2[prop],
                          childPath.replace(&#039;%s&#039;, prop));
            } else {
              failures.push(&#039;property &#039; + prop +
                            &#039; not present in actual &#039; + (path || typeOfVar2));
            }
          }
          // make sure there aren&#039;t properties in var2 that are missing
          // from var1. if there are, then by definition they don&#039;t
          // match.
          for (var prop in var2) {
            if (isArray &amp;&amp; goog.testing.asserts.isArrayIndexProp_(prop)) {
              // Skip array indices for now. We&#039;ll handle them later.
              continue;
            }

            if (!(prop in var1)) {
              failures.push(&#039;property &#039; + prop +
                            &#039; not present in expected &#039; +
                            (path || typeOfVar1));
            }
          }

          // Handle array indices by iterating from 0 to arr.length.
          //
          // Although all browsers allow holes in arrays, browsers
          // are inconsistent in what they consider a hole. For example,
          // &quot;[0,undefined,2]&quot; has a hole on IE but not on Firefox.
          //
          // Because our style guide bans for...in iteration over arrays,
          // we assume that most users don&#039;t care about holes in arrays,
          // and that it is ok to say that a hole is equivalent to a slot
          // populated with &#039;undefined&#039;.
          if (isArray) {
            for (prop = 0; prop &lt; var1.length; prop++) {
              innerAssert(var1[prop], var2[prop],
                          childPath.replace(&#039;%s&#039;, String(prop)));
            }
          }
        } else {
          // special-case for closure objects that have iterators
          if (goog.isFunction(var1.equals)) {
            // use the object&#039;s own equals function, assuming it accepts an
            // object and returns a boolean
            if (!var1.equals(var2)) {
              failures.push(&#039;equals() returned false for &#039; +
                            (path || typeOfVar1));
            }
          } else if (var1.map_) {
            // assume goog.structs.Map or goog.structs.Set, where comparing
            // their private map_ field is sufficient
            innerAssert(var1.map_, var2.map_, childPath.replace(&#039;%s&#039;, &#039;map_&#039;));
          } else {
            // else die, so user knows we can&#039;t do anything
            failures.push(&#039;unable to check &#039; + (path || typeOfVar1) +
                          &#039; for equality: it has an iterator we do not &#039; +
                          &#039;know how to handle. please add an equals method&#039;);
          }
        }
      }
    } else {
      failures.push(path + &#039; &#039; +
          goog.testing.asserts.getDefaultErrorMsg_(var1, var2));
    }
  }

  innerAssert(expected, actual, &#039;&#039;);
  return failures.length == 0 ? null :
      goog.testing.asserts.getDefaultErrorMsg_(expected, actual) +
          &#039;\n   &#039; + failures.join(&#039;\n   &#039;);
};


/**
 * Notes:
 * Object equality has some nasty browser quirks, and this implementation is
 * not 100% correct. For example,
 *
 * &lt;code&gt;
 * var a = [0, 1, 2];
 * var b = [0, 1, 2];
 * delete a[1];
 * b[1] = undefined;
 * assertObjectEquals(a, b); // should fail, but currently passes
 * &lt;/code&gt;
 *
 * See asserts_test.html for more interesting edge cases.
 *
 * The first comparison object provided is the expected value, the second is
 * the actual.
 *
 * @param {*} a Assertion message or comparison object.
 * @param {*} b Comparison object.
 * @param {*=} opt_c Comparison object, if an assertion message was provided.
 */
var assertObjectEquals = function(a, b, opt_c) {
  _validateArguments(2, arguments);
  var v1 = nonCommentArg(1, 2, arguments);
  var v2 = nonCommentArg(2, 2, arguments);
  var failureMessage = commentArg(2, arguments) ? commentArg(2, arguments) : &#039;&#039;;
  var differences = goog.testing.asserts.findDifferences(v1, v2);

  _assert(failureMessage, !differences, differences);
};


/**
 * Similar to assertObjectEquals above, but accepts a tolerance margin.
 *
 * @param {*} a Assertion message or comparison object.
 * @param {*} b Comparison object.
 * @param {*} c Comparison object or tolerance.
 * @param {*=} opt_d Tolerance, if an assertion message was provided.
 */
var assertObjectRoughlyEquals = function(a, b, c, opt_d) {
  _validateArguments(3, arguments);
  var v1 = nonCommentArg(1, 3, arguments);
  var v2 = nonCommentArg(2, 3, arguments);
  var tolerance = nonCommentArg(3, 3, arguments);
  var failureMessage = commentArg(3, arguments) ? commentArg(3, arguments) : &#039;&#039;;
  var equalityPredicate = function(type, var1, var2) {
    var typedPredicate =
        goog.testing.asserts.primitiveRoughEqualityPredicates_[type];
    if (!typedPredicate) {
      return goog.testing.asserts.EQUALITY_PREDICATE_CANT_PROCESS;
    }
    var equal = typedPredicate(var1, var2, tolerance);
    return equal ? goog.testing.asserts.EQUALITY_PREDICATE_VARS_ARE_EQUAL :
        goog.testing.asserts.getDefaultErrorMsg_(var1, var2) +
        &#039; which was more than &#039; + tolerance + &#039; away&#039;;
  };
  var differences = goog.testing.asserts.findDifferences(
      v1, v2, equalityPredicate);

  _assert(failureMessage, !differences, differences);
};


/**
 * Compares two arbitrary objects for non-equalness.
 *
 * All the same caveats as for assertObjectEquals apply here:
 * Undefined values may be confused for missing values, or vice versa.
 *
 * @param {*} a Assertion message or comparison object.
 * @param {*} b Comparison object.
 * @param {*=} opt_c Comparison object, if an assertion message was provided.
 */
var assertObjectNotEquals = function(a, b, opt_c) {
  _validateArguments(2, arguments);
  var v1 = nonCommentArg(1, 2, arguments);
  var v2 = nonCommentArg(2, 2, arguments);
  var failureMessage = commentArg(2, arguments) ? commentArg(2, arguments) : &#039;&#039;;
  var differences = goog.testing.asserts.findDifferences(v1, v2);

  _assert(failureMessage, differences, &#039;Objects should not be equal&#039;);
};


/**
 * Compares two arrays ignoring negative indexes and extra properties on the
 * array objects. Use case: Internet Explorer adds the index, lastIndex and
 * input enumerable fields to the result of string.match(/regexp/g), which makes
 * assertObjectEquals fail.
 * @param {*} a The expected array (2 args) or the debug message (3 args).
 * @param {*} b The actual array (2 args) or the expected array (3 args).
 * @param {*=} opt_c The actual array (3 args only).
 */
var assertArrayEquals = function(a, b, opt_c) {
  _validateArguments(2, arguments);
  var v1 = nonCommentArg(1, 2, arguments);
  var v2 = nonCommentArg(2, 2, arguments);
  var failureMessage = commentArg(2, arguments) ? commentArg(2, arguments) : &#039;&#039;;

  var typeOfVar1 = _trueTypeOf(v1);
  _assert(failureMessage,
          typeOfVar1 == &#039;Array&#039;,
          &#039;Expected an array for assertArrayEquals but found a &#039; + typeOfVar1);

  var typeOfVar2 = _trueTypeOf(v2);
  _assert(failureMessage,
          typeOfVar2 == &#039;Array&#039;,
          &#039;Expected an array for assertArrayEquals but found a &#039; + typeOfVar2);

  assertObjectEquals(failureMessage,
      Array.prototype.concat.call(v1), Array.prototype.concat.call(v2));
};


/**
 * Compares two objects that can be accessed like an array and assert that
 * each element is equal.
 * @param {string|Object} a Failure message (3 arguments)
 *     or object #1 (2 arguments).
 * @param {Object} b Object #1 (2 arguments) or object #2 (3 arguments).
 * @param {Object=} opt_c Object #2 (3 arguments).
 */
var assertElementsEquals = function(a, b, opt_c) {
  _validateArguments(2, arguments);

  var v1 = nonCommentArg(1, 2, arguments);
  var v2 = nonCommentArg(2, 2, arguments);
  var failureMessage = commentArg(2, arguments) ? commentArg(2, arguments) : &#039;&#039;;

  if (!v1) {
    assert(failureMessage, !v2);
  } else {
    assertEquals(&#039;length mismatch: &#039; + failureMessage, v1.length, v2.length);
    for (var i = 0; i &lt; v1.length; ++i) {
      assertEquals(
          &#039;mismatch at index &#039; + i + &#039;: &#039; + failureMessage, v1[i], v2[i]);
    }
  }
};


/**
 * Compares two objects that can be accessed like an array and assert that
 * each element is roughly equal.
 * @param {string|Object} a Failure message (4 arguments)
 *     or object #1 (3 arguments).
 * @param {Object} b Object #1 (4 arguments) or object #2 (3 arguments).
 * @param {Object|number} c Object #2 (4 arguments) or tolerance (3 arguments).
 * @param {number=} opt_d tolerance (4 arguments).
 */
var assertElementsRoughlyEqual = function(a, b, c, opt_d) {
  _validateArguments(3, arguments);

  var v1 = nonCommentArg(1, 3, arguments);
  var v2 = nonCommentArg(2, 3, arguments);
  var tolerance = nonCommentArg(3, 3, arguments);
  var failureMessage = commentArg(3, arguments) ? commentArg(3, arguments) : &#039;&#039;;

  if (!v1) {
    assert(failureMessage, !v2);
  } else {
    assertEquals(&#039;length mismatch: &#039; + failureMessage, v1.length, v2.length);
    for (var i = 0; i &lt; v1.length; ++i) {
      assertRoughlyEquals(failureMessage, v1[i], v2[i], tolerance);
    }
  }
};


/**
 * Compares two array-like objects without taking their order into account.
 * @param {string|goog.testing.asserts.ArrayLike} a Assertion message or the
 *     expected elements.
 * @param {goog.testing.asserts.ArrayLike} b Expected elements or the actual
 *     elements.
 * @param {goog.testing.asserts.ArrayLike=} opt_c Actual elements.
 */
var assertSameElements = function(a, b, opt_c) {
  _validateArguments(2, arguments);
  var expected = nonCommentArg(1, 2, arguments);
  var actual = nonCommentArg(2, 2, arguments);
  var message = commentArg(2, arguments);

  assertTrue(&#039;Bad arguments to assertSameElements(opt_message, expected: &#039; +
      &#039;ArrayLike, actual: ArrayLike)&#039;,
      goog.isArrayLike(expected) &amp;&amp; goog.isArrayLike(actual));

  // Clones expected and actual and converts them to real arrays.
  expected = goog.testing.asserts.toArray_(expected);
  actual = goog.testing.asserts.toArray_(actual);
  // TODO(user): It would be great to show only the difference
  // between the expected and actual elements.
  _assert(message, expected.length == actual.length,
      &#039;Expected &#039; + expected.length + &#039; elements: [&#039; + expected + &#039;], &#039; +
      &#039;got &#039; + actual.length + &#039; elements: [&#039; + actual + &#039;]&#039;);

  var toFind = goog.testing.asserts.toArray_(expected);
  for (var i = 0; i &lt; actual.length; i++) {
    var index = goog.testing.asserts.indexOf_(toFind, actual[i]);
    _assert(message, index != -1, &#039;Expected [&#039; + expected + &#039;], got [&#039; +
        actual + &#039;]&#039;);
    toFind.splice(index, 1);
  }
};


/**
 * @param {*} a The value to assert (1 arg) or debug message (2 args).
 * @param {*=} opt_b The value to assert (2 args only).
 */
var assertEvaluatesToTrue = function(a, opt_b) {
  _validateArguments(1, arguments);
  var value = nonCommentArg(1, 1, arguments);
  if (!value) {
    _assert(commentArg(1, arguments), false, &#039;Expected to evaluate to true&#039;);
  }
};


/**
 * @param {*} a The value to assert (1 arg) or debug message (2 args).
 * @param {*=} opt_b The value to assert (2 args only).
 */
var assertEvaluatesToFalse = function(a, opt_b) {
  _validateArguments(1, arguments);
  var value = nonCommentArg(1, 1, arguments);
  if (value) {
    _assert(commentArg(1, arguments), false, &#039;Expected to evaluate to false&#039;);
  }
};


/**
 * Compares two HTML snippets.
 *
 * Take extra care if attributes are involved. {@code assertHTMLEquals}&#039;s
 * implementation isn&#039;t prepared for complex cases. For example, the following
 * comparisons erroneously fail:
 * &lt;pre&gt;
 * assertHTMLEquals(&#039;&lt;a href=&quot;x&quot; target=&quot;y&quot;&gt;&#039;, &#039;&lt;a target=&quot;y&quot; href=&quot;x&quot;&gt;&#039;);
 * assertHTMLEquals(&#039;&lt;div classname=&quot;a b&quot;&gt;&#039;, &#039;&lt;div classname=&quot;b a&quot;&gt;&#039;);
 * assertHTMLEquals(&#039;&lt;input disabled&gt;&#039;, &#039;&lt;input disabled=&quot;disabled&quot;&gt;&#039;);
 * &lt;/pre&gt;
 *
 * When in doubt, use {@code goog.testing.dom.assertHtmlMatches}.
 *
 * @param {*} a The expected value (2 args) or the debug message (3 args).
 * @param {*} b The actual value (2 args) or the expected value (3 args).
 * @param {*=} opt_c The actual value (3 args only).
 */
var assertHTMLEquals = function(a, b, opt_c) {
  _validateArguments(2, arguments);
  var var1 = nonCommentArg(1, 2, arguments);
  var var2 = nonCommentArg(2, 2, arguments);
  var var1Standardized = standardizeHTML(var1);
  var var2Standardized = standardizeHTML(var2);

  _assert(commentArg(2, arguments), var1Standardized === var2Standardized,
          goog.testing.asserts.getDefaultErrorMsg_(
              var1Standardized, var2Standardized));
};


/**
 * Compares two CSS property values to make sure that they represent the same
 * things. This will normalize values in the browser. For example, in Firefox,
 * this assertion will consider &quot;rgb(0, 0, 255)&quot; and &quot;#0000ff&quot; to be identical
 * values for the &quot;color&quot; property. This function won&#039;t normalize everything --
 * for example, in most browsers, &quot;blue&quot; will not match &quot;#0000ff&quot;. It is
 * intended only to compensate for unexpected normalizations performed by
 * the browser that should also affect your expected value.
 * @param {string} a Assertion message, or the CSS property name.
 * @param {string} b CSS property name, or the expected value.
 * @param {string} c The expected value, or the actual value.
 * @param {string=} opt_d The actual value.
 */
var assertCSSValueEquals = function(a, b, c, opt_d) {
  _validateArguments(3, arguments);
  var propertyName = nonCommentArg(1, 3, arguments);
  var expectedValue = nonCommentArg(2, 3, arguments);
  var actualValue = nonCommentArg(3, 3, arguments);
  var expectedValueStandardized =
      standardizeCSSValue(propertyName, expectedValue);
  var actualValueStandardized =
      standardizeCSSValue(propertyName, actualValue);

  _assert(commentArg(3, arguments),
          expectedValueStandardized == actualValueStandardized,
          goog.testing.asserts.getDefaultErrorMsg_(
              expectedValueStandardized, actualValueStandardized));
};


/**
 * @param {*} a The expected value (2 args) or the debug message (3 args).
 * @param {*} b The actual value (2 args) or the expected value (3 args).
 * @param {*=} opt_c The actual value (3 args only).
 */
var assertHashEquals = function(a, b, opt_c) {
  _validateArguments(2, arguments);
  var var1 = nonCommentArg(1, 2, arguments);
  var var2 = nonCommentArg(2, 2, arguments);
  var message = commentArg(2, arguments);
  for (var key in var1) {
    _assert(message,
        key in var2, &#039;Expected hash had key &#039; + key + &#039; that was not found&#039;);
    _assert(message, var1[key] == var2[key], &#039;Value for key &#039; + key +
        &#039; mismatch - expected = &#039; + var1[key] + &#039;, actual = &#039; + var2[key]);
  }

  for (var key in var2) {
    _assert(message, key in var1, &#039;Actual hash had key &#039; + key +
        &#039; that was not expected&#039;);
  }
};


/**
 * @param {*} a The expected value (3 args) or the debug message (4 args).
 * @param {*} b The actual value (3 args) or the expected value (4 args).
 * @param {*} c The tolerance (3 args) or the actual value (4 args).
 * @param {*=} opt_d The tolerance (4 args only).
 */
var assertRoughlyEquals = function(a, b, c, opt_d) {
  _validateArguments(3, arguments);
  var expected = nonCommentArg(1, 3, arguments);
  var actual = nonCommentArg(2, 3, arguments);
  var tolerance = nonCommentArg(3, 3, arguments);
  _assert(commentArg(3, arguments),
      goog.testing.asserts.numberRoughEqualityPredicate_(
          expected, actual, tolerance),
      &#039;Expected &#039; + expected + &#039;, but got &#039; + actual +
      &#039; which was more than &#039; + tolerance + &#039; away&#039;);
};


/**
 * Checks if the given element is the member of the given container.
 * @param {*} a Failure message (3 arguments) or the contained element
 *     (2 arguments).
 * @param {*} b The contained element (3 arguments) or the container
 *     (2 arguments).
 * @param {*=} opt_c The container.
 */
var assertContains = function(a, b, opt_c) {
  _validateArguments(2, arguments);
  var contained = nonCommentArg(1, 2, arguments);
  var container = nonCommentArg(2, 2, arguments);
  _assert(commentArg(2, arguments),
      goog.testing.asserts.contains_(container, contained),
      &#039;Expected \&#039;&#039; + container + &#039;\&#039; to contain \&#039;&#039; + contained + &#039;\&#039;&#039;);
};


/**
 * Checks if the given element is not the member of the given container.
 * @param {*} a Failure message (3 arguments) or the contained element
 *     (2 arguments).
 * @param {*} b The contained element (3 arguments) or the container
 *     (2 arguments).
 * @param {*=} opt_c The container.
 */
var assertNotContains = function(a, b, opt_c) {
  _validateArguments(2, arguments);
  var contained = nonCommentArg(1, 2, arguments);
  var container = nonCommentArg(2, 2, arguments);
  _assert(commentArg(2, arguments),
      !goog.testing.asserts.contains_(container, contained),
      &#039;Expected \&#039;&#039; + container + &#039;\&#039; not to contain \&#039;&#039; + contained + &#039;\&#039;&#039;);
};


/**
 * Checks if the given string matches the given regular expression.
 * @param {*} a Failure message (3 arguments) or the expected regular
 *     expression as a string or RegExp (2 arguments).
 * @param {*} b The regular expression (3 arguments) or the string to test
 *     (2 arguments).
 * @param {*=} opt_c The string to test.
 */
var assertRegExp = function(a, b, opt_c) {
  _validateArguments(2, arguments);
  var regexp = nonCommentArg(1, 2, arguments);
  var string = nonCommentArg(2, 2, arguments);
  if (typeof(regexp) == &#039;string&#039;) {
    regexp = new RegExp(regexp);
  }
  _assert(commentArg(2, arguments),
      regexp.test(string),
      &#039;Expected \&#039;&#039; + string + &#039;\&#039; to match RegExp &#039; + regexp.toString());
};


/**
 * Converts an array like object to array or clones it if it&#039;s already array.
 * @param {goog.testing.asserts.ArrayLike} arrayLike The collection.
 * @return {!Array} Copy of the collection as array.
 * @private
 */
goog.testing.asserts.toArray_ = function(arrayLike) {
  var ret = [];
  for (var i = 0; i &lt; arrayLike.length; i++) {
    ret[i] = arrayLike[i];
  }
  return ret;
};


/**
 * Finds the position of the first occurrence of an element in a container.
 * @param {goog.testing.asserts.ArrayLike} container
 *     The array to find the element in.
 * @param {*} contained Element to find.
 * @return {number} Index of the first occurrence or -1 if not found.
 * @private
 */
goog.testing.asserts.indexOf_ = function(container, contained) {
  if (container.indexOf) {
    return container.indexOf(contained);
  } else {
    // IE6/7 do not have indexOf so do a search.
    for (var i = 0; i &lt; container.length; i++) {
      if (container[i] === contained) {
        return i;
      }
    }
    return -1;
  }
};


/**
 * Tells whether the array contains the given element.
 * @param {goog.testing.asserts.ArrayLike} container The array to
 *     find the element in.
 * @param {*} contained Element to find.
 * @return {boolean} Whether the element is in the array.
 * @private
 */
goog.testing.asserts.contains_ = function(container, contained) {
  // TODO(user): Can we check for container.contains as well?
  // That would give us support for most goog.structs (though weird results
  // with anything else with a contains method, like goog.math.Range). Falling
  // back with container.some would catch all iterables, too.
  return goog.testing.asserts.indexOf_(container, contained) != -1;
};

var standardizeHTML = function(html) {
  var translator = document.createElement(&#039;DIV&#039;);
  translator.innerHTML = html;

  // Trim whitespace from result (without relying on goog.string)
  return translator.innerHTML.replace(/^\s+|\s+$/g, &#039;&#039;);
};


/**
 * Standardizes a CSS value for a given property by applying it to an element
 * and then reading it back.
 * @param {string} propertyName CSS property name.
 * @param {string} value CSS value.
 * @return {string} Normalized CSS value.
 */
var standardizeCSSValue = function(propertyName, value) {
  var styleDeclaration = document.createElement(&#039;DIV&#039;).style;
  styleDeclaration[propertyName] = value;
  return styleDeclaration[propertyName];
};


/**
 * Raises a JsUnit exception with the given comment.
 * @param {string} comment A summary for the exception.
 * @param {string=} opt_message A description of the exception.
 */
goog.testing.asserts.raiseException = function(comment, opt_message) {
  throw new goog.testing.JsUnitException(comment, opt_message);
};


/**
 * Helper function for assertObjectEquals.
 * @param {string} prop A property name.
 * @return {boolean} If the property name is an array index.
 * @private
 */
goog.testing.asserts.isArrayIndexProp_ = function(prop) {
  return (prop | 0) == prop;
};



/**
 * @param {string} comment A summary for the exception.
 * @param {?string=} opt_message A description of the exception.
 * @constructor
 * @extends {Error}
 * @final
 */
goog.testing.JsUnitException = function(comment, opt_message) {
  this.isJsUnitException = true;
  this.message = (comment ? comment : &#039;&#039;) +
                 (comment &amp;&amp; opt_message ? &#039;\n&#039; : &#039;&#039;) +
                 (opt_message ? opt_message : &#039;&#039;);
  this.stackTrace = goog.testing.stacktrace.get();
  // These fields are for compatibility with jsUnitTestManager.
  this.comment = comment || null;
  this.jsUnitMessage = opt_message || &#039;&#039;;

  // Ensure there is a stack trace.
  if (Error.captureStackTrace) {
    Error.captureStackTrace(this, goog.testing.JsUnitException);
  } else {
    this.stack = new Error().stack || &#039;&#039;;
  }
};
goog.inherits(goog.testing.JsUnitException, Error);


/** @override */
goog.testing.JsUnitException.prototype.toString = function() {
  return this.message;
};


goog.exportSymbol(&#039;fail&#039;, fail);
goog.exportSymbol(&#039;assert&#039;, assert);
goog.exportSymbol(&#039;assertThrows&#039;, assertThrows);
goog.exportSymbol(&#039;assertNotThrows&#039;, assertNotThrows);
goog.exportSymbol(&#039;assertTrue&#039;, assertTrue);
goog.exportSymbol(&#039;assertFalse&#039;, assertFalse);
goog.exportSymbol(&#039;assertEquals&#039;, assertEquals);
goog.exportSymbol(&#039;assertNotEquals&#039;, assertNotEquals);
goog.exportSymbol(&#039;assertNull&#039;, assertNull);
goog.exportSymbol(&#039;assertNotNull&#039;, assertNotNull);
goog.exportSymbol(&#039;assertUndefined&#039;, assertUndefined);
goog.exportSymbol(&#039;assertNotUndefined&#039;, assertNotUndefined);
goog.exportSymbol(&#039;assertNotNullNorUndefined&#039;, assertNotNullNorUndefined);
goog.exportSymbol(&#039;assertNonEmptyString&#039;, assertNonEmptyString);
goog.exportSymbol(&#039;assertNaN&#039;, assertNaN);
goog.exportSymbol(&#039;assertNotNaN&#039;, assertNotNaN);
goog.exportSymbol(&#039;assertObjectEquals&#039;, assertObjectEquals);
goog.exportSymbol(&#039;assertObjectRoughlyEquals&#039;, assertObjectRoughlyEquals);
goog.exportSymbol(&#039;assertObjectNotEquals&#039;, assertObjectNotEquals);
goog.exportSymbol(&#039;assertArrayEquals&#039;, assertArrayEquals);
goog.exportSymbol(&#039;assertElementsEquals&#039;, assertElementsEquals);
goog.exportSymbol(&#039;assertElementsRoughlyEqual&#039;, assertElementsRoughlyEqual);
goog.exportSymbol(&#039;assertSameElements&#039;, assertSameElements);
goog.exportSymbol(&#039;assertEvaluatesToTrue&#039;, assertEvaluatesToTrue);
goog.exportSymbol(&#039;assertEvaluatesToFalse&#039;, assertEvaluatesToFalse);
goog.exportSymbol(&#039;assertHTMLEquals&#039;, assertHTMLEquals);
goog.exportSymbol(&#039;assertHashEquals&#039;, assertHashEquals);
goog.exportSymbol(&#039;assertRoughlyEquals&#039;, assertRoughlyEquals);
goog.exportSymbol(&#039;assertContains&#039;, assertContains);
goog.exportSymbol(&#039;assertNotContains&#039;, assertNotContains);
goog.exportSymbol(&#039;assertRegExp&#039;, assertRegExp);</textarea>
  </div>
</div>

<footer class="footer">
  <div class="container">
    <p>.</p>
  </div>
</footer>

<script type="text/html" id="complexity-popover-template">
  <div class="complexity-notice">
    Complexity : {{ complexity.cyclomatic }} <br>
    Length : {{ complexity.halstead.length }} <br>
    Difficulty : {{ complexity.halstead.difficulty.toFixed(2) }} <br>
    Est # bugs : {{ complexity.halstead.bugs.toFixed(2) }}<br>
  </div>
</script>

<script type="text/javascript" src="../../assets/scripts/bundles/core-bundle.js"></script>
<script type="text/javascript" src="../../assets/scripts/bundles/codemirror.js"></script>
<script type="text/javascript" src="../../assets/scripts/codemirror.markpopovertext.js"></script>
<script type="text/javascript" src="report.js"></script>
<script type="text/javascript" src="report.history.js"></script>
<script type="text/javascript" src="../../assets/scripts/plato-file.js"></script>
</body>
</html>
