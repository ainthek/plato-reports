<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Plato - node_modules/selenium-webdriver/lib/webdriver/until.js</title>

  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="">
  <meta name="author" content="">

  <!--[if lt IE 9]>
  <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->

  <link href="../../assets/css/vendor/morris.css" rel="stylesheet">
  <link href="../../assets/css/vendor/bootstrap.css" rel="stylesheet">
  <link href="../../assets/css/vendor/font-awesome.css" rel="stylesheet">
  <link href="../../assets/css/vendor/codemirror.css" rel="stylesheet">
  <link href="../../assets/css/plato.css" rel="stylesheet">
  <link href="../../assets/css/plato-file.css" rel="stylesheet">

</head>

<body>

<div class="navbar navbar-fixed-top">
  <div class="container">
    <a class="navbar-brand" href="http://github.com/es-analysis/plato">Plato on Github</a>
    <ul class="nav navbar-nav">
      <li>
        <a href="../../index.html">Report Home</a>
      </li>
    </ul>
  </div>
</div>

<div class="jumbotron">
  <div class="container">
    <h1>node_modules/selenium-webdriver/lib/webdriver/until.js</h1>
  </div>
</div>

<div class="container aggregate-stats">
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Maintainability <a href="http://blogs.msdn.com/b/codeanalysis/archive/2007/11/20/maintainability-index-range-and-meaning.aspx"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="A value between 0 and 100 that represents the relative ease of maintaining the code. A high value means better maintainability." data-original-title="Maintainability Index"  data-container="body"></i></a></h2>
      <p class="stat">85.12</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Lines of code <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h2>
      <p class="stat">368</p>
    </div>
  </div>
  <div class="row historical">
    <div class="col-md-6">
      <p id="chart_historical_maint" class="chart"></p>
    </div>
    <div class="col-md-6">
      <p id="chart_historical_sloc" class="chart"></p>
    </div>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Difficulty  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="The difficulty measure is related to the difficulty of the program to write or understand." data-original-title="Difficulty" data-container="body"></i></a></h2>
      <p class="stat">38.36</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Estimated Errors  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Halstead's delivered bugs is an estimate for the number of errors in the implementation." data-original-title="Delivered Bugs" data-container="body"></i></a></h2>
      <p class="stat">1.66</p>
    </div>
  </div>
</div>

<div class="container charts">
  <div class="row">
    <h2 class="header">Function weight</h2>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h3 class="chart-header">By Complexity <a href="http://en.wikipedia.org/wiki/Cyclomatic_complexity"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="This metric counts the number of distinct paths through a block of code. Lower values are better." data-original-title="Cyclomatic Complexity" data-container="body"></i></a></h3>
      <div id="fn-by-complexity" class="stat"></div>
    </div>
    <div class="col-md-6">
      <h3 class="chart-header">By SLOC  <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h3>
      <div id="fn-by-sloc" class="stat"></div>
    </div>
  </div>
</div>

<div class="container">
  <div class="row">
    <textarea id="file-source" class="col-md-12">// Copyright 2014 Software Freedom Conservancy. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/**
 * @fileoverview Defines common conditions for use with
 * {@link webdriver.WebDriver#wait WebDriver wait}.
 *
 * &lt;p&gt;Sample usage:
 * &lt;code&gt;&lt;pre&gt;
 *   driver.get(&#039;http://www.google.com/ncr&#039;);
 *
 *   var query = driver.wait(until.elementLocated(By.name(&#039;q&#039;)));
 *   query.sendKeys(&#039;webdriver\n&#039;);
 *
 *   driver.wait(until.titleIs(&#039;webdriver - Google Search&#039;));
 * &lt;/pre&gt;&lt;/code&gt;
 *
 * &lt;p&gt;To define a custom condition, simply call WebDriver.wait with a function
 * that will eventually return a truthy-value (neither null, undefined, false,
 * 0, or the empty string):
 * &lt;code&gt;&lt;pre&gt;
 *   driver.wait(function() {
 *     return driver.getTitle().then(function(title) {
 *       return title === &#039;webdriver - Google Search&#039;;
 *     });
 *   }, 1000);
 * &lt;/pre&gt;&lt;/code&gt;
 */

goog.provide(&#039;webdriver.until&#039;);

goog.require(&#039;bot.ErrorCode&#039;);
goog.require(&#039;goog.array&#039;);
goog.require(&#039;goog.string&#039;);



goog.scope(function() {

var until = webdriver.until;


/**
 * Defines a condition to 
 * @param {string} message A descriptive error message. Should complete the
 *     sentence &quot;Waiting [...]&quot;
 * @param {function(!webdriver.WebDriver): OUT} fn The condition function to
 *     evaluate on each iteration of the wait loop.
 * @constructor
 * @struct
 * @final
 * @template OUT
 */
until.Condition = function(message, fn) {
  /** @private {string} */
  this.description_ = &#039;Waiting &#039; + message;

  /** @type {function(!webdriver.WebDriver): OUT} */
  this.fn = fn;
};


/** @return {string} A description of this condition. */
until.Condition.prototype.description = function() {
  return this.description_;
};


/**
 * Creates a condition that will wait until the input driver is able to switch
 * to the designated frame. The target frame may be specified as:
 * &lt;ol&gt;
 *   &lt;li&gt;A numeric index into {@code window.frames} for the currently selected
 *       frame.
 *   &lt;li&gt;A {@link webdriver.WebElement}, which must reference a FRAME or IFRAME
 *       element on the current page.
 *   &lt;li&gt;A locator which may be used to first locate a FRAME or IFRAME on the
 *       current page before attempting to switch to it.
 * &lt;/ol&gt;
 *
 * &lt;p&gt;Upon successful resolution of this condition, the driver will be left
 * focused on the new frame.
 *
 * @param {!(number|webdriver.WebElement|
 *           webdriver.Locator|webdriver.By.Hash|
 *           function(!webdriver.WebDriver): !webdriver.WebElement)} frame
 *     The frame identifier.
 * @return {!until.Condition.&lt;boolean&gt;} A new condition.
 */
until.ableToSwitchToFrame = function(frame) {
  var condition;
  if (goog.isNumber(frame) || frame instanceof webdriver.WebElement) {
    condition = attemptToSwitchFrames;
  } else {
    condition = function(driver) {
      var locator =
          /** @type {!(webdriver.Locator|webdriver.By.Hash|Function)} */(frame);
      return driver.findElements(locator).then(function(els) {
        if (els.length) {
          return attemptToSwitchFrames(driver, els[0]);
        }
      });
    };
  }

  return new until.Condition(&#039;to be able to switch to frame&#039;, condition);

  function attemptToSwitchFrames(driver, frame) {
    return driver.switchTo().frame(frame).then(
        function() { return true; },
        function(e) {
          if (e &amp;&amp; e.code !== bot.ErrorCode.NO_SUCH_FRAME) {
            throw e;
          }
        });
  }
};


/**
 * Creates a condition that waits for an alert to be opened. Upon success, the
 * returned promise will be fulfilled with the handle for the opened alert.
 *
 * @return {!until.Condition.&lt;!webdriver.Alert&gt;} The new condition.
 */
until.alertIsPresent = function() {
  return new until.Condition(&#039;for alert to be present&#039;, function(driver) {
    return driver.switchTo().alert().thenCatch(function(e) {
      if (e &amp;&amp; e.code !== bot.ErrorCode.NO_SUCH_ALERT) {
        throw e;
      }
    });
  });
};


/**
 * Creates a condition that will wait for the current page&#039;s title to match the
 * given value.
 *
 * @param {string} title The expected page title.
 * @return {!until.Condition.&lt;boolean&gt;} The new condition.
 */
until.titleIs = function(title) {
  return new until.Condition(
      &#039;for title to be &#039; + goog.string.quote(title),
      function(driver) {
        return driver.getTitle().then(function(t) {
          return t === title;
        });
      });
};


/**
 * Creates a condition that will wait for the current page&#039;s title to contain
 * the given substring.
 *
 * @param {string} substr The substring that should be present in the page
 *     title.
 * @return {!until.Condition.&lt;boolean&gt;} The new condition.
 */
until.titleContains = function(substr) {
  return new until.Condition(
      &#039;for title to contain &#039; + goog.string.quote(substr),
      function(driver) {
        return driver.getTitle().then(function(title) {
          return title.indexOf(substr) !== -1;
        });
      });
};


/**
 * Creates a condition that will wait for the current page&#039;s title to match the
 * given regular expression.
 *
 * @param {!RegExp} regex The regular expression to test against.
 * @return {!until.Condition.&lt;boolean&gt;} The new condition.
 */
until.titleMatches = function(regex) {
  return new until.Condition(&#039;for title to match &#039; + regex, function(driver) {
    return driver.getTitle().then(function(title) {
      return regex.test(title);
    });
  });
};


/**
 * Creates a condition that will loop until an element is
 * {@link webdriver.WebDriver#findElement found} with the given locator.
 *
 * @param {!(webdriver.Locator|webdriver.By.Hash|Function)} locator The locator
 *     to use.
 * @return {!until.Condition.&lt;!webdriver.WebElement&gt;} The new condition.
 */
until.elementLocated = function(locator) {
  var locatorStr = goog.isFunction(locator) ? &#039;function()&#039; : locator + &#039;&#039;;
  return new until.Condition(&#039;element to be located by &#039; + locatorStr,
      function(driver) {
        return driver.findElements(locator).then(function(elements) {
          return elements[0];
        });
      });
};


/**
 * Creates a condition that will loop until at least one element is
 * {@link webdriver.WebDriver#findElement found} with the given locator.
 *
 * @param {!(webdriver.Locator|webdriver.By.Hash|Function)} locator The locator
 *     to use.
 * @return {!until.Condition.&lt;!Array.&lt;!webdriver.WebElement&gt;&gt;} The new
 *     condition.
 */
until.elementsLocated = function(locator) {
  var locatorStr = goog.isFunction(locator) ? &#039;function()&#039; : locator + &#039;&#039;;
  return new until.Condition(
      &#039;at least one element to be located by &#039; + locatorStr,
      function(driver) {
        return driver.findElements(locator).then(function(elements) {
          return elements.length &gt; 0 ? elements : null;
        });
      });
};


/**
 * Creates a condition that will wait for the given element to become stale. An
 * element is considered stale once it is removed from the DOM, or a new page
 * has loaded.
 *
 * @param {!webdriver.WebElement} element The element that should become stale.
 * @return {!until.Condition.&lt;boolean&gt;} The new condition.
 */
until.stalenessOf = function(element) {
  return new until.Condition(&#039;element to become stale&#039;, function() {
    return element.getTagName().then(
        function() { return false; },
        function(e) {
          if (e.code === bot.ErrorCode.STALE_ELEMENT_REFERENCE) {
            return true;
          }
          throw e;
        });
  });
};


/**
 * Creates a condition that will wait for the given element to become visible.
 *
 * @param {!webdriver.WebElement} element The element to test.
 * @return {!until.Condition.&lt;boolean&gt;} The new condition.
 * @see webdriver.WebDriver#isDisplayed
 */
until.elementIsVisible = function(element) {
  return new until.Condition(&#039;until element is visible&#039;, function() {
    return element.isDisplayed();
  });
};


/**
 * Creates a condition that will wait for the given element to be in the DOM,
 * yet not visible to the user.
 *
 * @param {!webdriver.WebElement} element The element to test.
 * @return {!until.Condition.&lt;boolean&gt;} The new condition.
 * @see webdriver.WebDriver#isDisplayed
 */
until.elementIsNotVisible = function(element) {
  return new until.Condition(&#039;until element is not visible&#039;, function() {
    return element.isDisplayed().then(function(v) {
      return !v;
    });
  });
};


/**
 * Creates a condition that will wait for the given element to be enabled.
 *
 * @param {!webdriver.WebElement} element The element to test.
 * @return {!until.Condition.&lt;boolean&gt;} The new condition.
 * @see webdriver.WebDriver#isEnabled
 */
until.elementIsEnabled = function(element) {
  return new until.Condition(&#039;until element is enabled&#039;, function() {
    return element.isEnabled();
  });
};


/**
 * Creates a condition that will wait for the given element to be disabled.
 *
 * @param {!webdriver.WebElement} element The element to test.
 * @return {!until.Condition.&lt;boolean&gt;} The new condition.
 * @see webdriver.WebDriver#isEnabled
 */
until.elementIsDisabled = function(element) {
  return new until.Condition(&#039;until element is disabled&#039;, function() {
    return element.isEnabled().then(function(v) {
      return !v;
    });
  });
};


/**
 * Creates a condition that will wait for the given element to be selected.
 * @param {!webdriver.WebElement} element The element to test.
 * @return {!until.Condition.&lt;boolean&gt;} The new condition.
 * @see webdriver.WebDriver#isSelected
 */
until.elementIsSelected = function(element) {
  return new until.Condition(&#039;until element is selected&#039;, function() {
    return element.isSelected();
  });
};


/**
 * Creates a condition that will wait for the given element to be deselected.
 *
 * @param {!webdriver.WebElement} element The element to test.
 * @return {!until.Condition.&lt;boolean&gt;} The new condition.
 * @see webdriver.WebDriver#isSelected
 */
until.elementIsNotSelected = function(element) {
  return new until.Condition(&#039;until element is not selected&#039;, function() {
    return element.isSelected().then(function(v) {
      return !v;
    });
  });
};


/**
 * Creates a condition that will wait for the given element&#039;s
 * {@link webdriver.WebDriver#getText visible text} to match the given
 * {@code text} exactly.
 *
 * @param {!webdriver.WebElement} element The element to test.
 * @param {string} text The expected text.
 * @return {!until.Condition.&lt;boolean&gt;} The new condition.
 * @see webdriver.WebDriver#getText
 */
until.elementTextIs = function(element, text) {
  return new until.Condition(&#039;until element text is&#039;, function() {
    return element.getText().then(function(t) {
      return t === text;
    });
  });
};


/**
 * Creates a condition that will wait for the given element&#039;s
 * {@link webdriver.WebDriver#getText visible text} to contain the given
 * substring.
 *
 * @param {!webdriver.WebElement} element The element to test.
 * @param {string} substr The substring to search for.
 * @return {!until.Condition.&lt;boolean&gt;} The new condition.
 * @see webdriver.WebDriver#getText
 */
until.elementTextContains = function(element, substr) {
  return new until.Condition(&#039;until element text contains&#039;, function() {
    return element.getText().then(function(t) {
      return t.indexOf(substr) != -1;
    });
  });
};


/**
 * Creates a condition that will wait for the given element&#039;s
 * {@link webdriver.WebDriver#getText visible text} to match a regular
 * expression.
 *
 * @param {!webdriver.WebElement} element The element to test.
 * @param {!RegExp} regex The regular expression to test against.
 * @return {!until.Condition.&lt;boolean&gt;} The new condition.
 * @see webdriver.WebDriver#getText
 */
until.elementTextMatches = function(element, regex) {
  return new until.Condition(&#039;until element text matches&#039;, function() {
    return element.getText().then(function(t) {
      return regex.test(t);
    });
  });
};
});  // goog.scope</textarea>
  </div>
</div>

<footer class="footer">
  <div class="container">
    <p>.</p>
  </div>
</footer>

<script type="text/html" id="complexity-popover-template">
  <div class="complexity-notice">
    Complexity : {{ complexity.cyclomatic }} <br>
    Length : {{ complexity.halstead.length }} <br>
    Difficulty : {{ complexity.halstead.difficulty.toFixed(2) }} <br>
    Est # bugs : {{ complexity.halstead.bugs.toFixed(2) }}<br>
  </div>
</script>

<script type="text/javascript" src="../../assets/scripts/bundles/core-bundle.js"></script>
<script type="text/javascript" src="../../assets/scripts/bundles/codemirror.js"></script>
<script type="text/javascript" src="../../assets/scripts/codemirror.markpopovertext.js"></script>
<script type="text/javascript" src="report.js"></script>
<script type="text/javascript" src="report.history.js"></script>
<script type="text/javascript" src="../../assets/scripts/plato-file.js"></script>
</body>
</html>
