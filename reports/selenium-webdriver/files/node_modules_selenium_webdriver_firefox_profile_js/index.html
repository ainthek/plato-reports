<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Plato - node_modules/selenium-webdriver/firefox/profile.js</title>

  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="">
  <meta name="author" content="">

  <!--[if lt IE 9]>
  <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->

  <link href="../../assets/css/vendor/morris.css" rel="stylesheet">
  <link href="../../assets/css/vendor/bootstrap.css" rel="stylesheet">
  <link href="../../assets/css/vendor/font-awesome.css" rel="stylesheet">
  <link href="../../assets/css/vendor/codemirror.css" rel="stylesheet">
  <link href="../../assets/css/plato.css" rel="stylesheet">
  <link href="../../assets/css/plato-file.css" rel="stylesheet">

</head>

<body>

<div class="navbar navbar-fixed-top">
  <div class="container">
    <a class="navbar-brand" href="http://github.com/es-analysis/plato">Plato on Github</a>
    <ul class="nav navbar-nav">
      <li>
        <a href="../../index.html">Report Home</a>
      </li>
    </ul>
  </div>
</div>

<div class="jumbotron">
  <div class="container">
    <h1>node_modules/selenium-webdriver/firefox/profile.js</h1>
  </div>
</div>

<div class="container aggregate-stats">
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Maintainability <a href="http://blogs.msdn.com/b/codeanalysis/archive/2007/11/20/maintainability-index-range-and-meaning.aspx"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="A value between 0 and 100 that represents the relative ease of maintaining the code. A high value means better maintainability." data-original-title="Maintainability Index"  data-container="body"></i></a></h2>
      <p class="stat">79.52</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Lines of code <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h2>
      <p class="stat">393</p>
    </div>
  </div>
  <div class="row historical">
    <div class="col-md-6">
      <p id="chart_historical_maint" class="chart"></p>
    </div>
    <div class="col-md-6">
      <p id="chart_historical_sloc" class="chart"></p>
    </div>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Difficulty  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="The difficulty measure is related to the difficulty of the program to write or understand." data-original-title="Difficulty" data-container="body"></i></a></h2>
      <p class="stat">37.53</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Estimated Errors  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Halstead's delivered bugs is an estimate for the number of errors in the implementation." data-original-title="Delivered Bugs" data-container="body"></i></a></h2>
      <p class="stat">2.36</p>
    </div>
  </div>
</div>

<div class="container charts">
  <div class="row">
    <h2 class="header">Function weight</h2>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h3 class="chart-header">By Complexity <a href="http://en.wikipedia.org/wiki/Cyclomatic_complexity"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="This metric counts the number of distinct paths through a block of code. Lower values are better." data-original-title="Cyclomatic Complexity" data-container="body"></i></a></h3>
      <div id="fn-by-complexity" class="stat"></div>
    </div>
    <div class="col-md-6">
      <h3 class="chart-header">By SLOC  <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h3>
      <div id="fn-by-sloc" class="stat"></div>
    </div>
  </div>
</div>

<div class="container">
  <div class="row">
    <textarea id="file-source" class="col-md-12">// Copyright 2014 Selenium committers
// Copyright 2014 Software Freedom Conservancy
//
// Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
// you may not use this file except in compliance with the License.
//     You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

&#039;use strict&#039;;

var AdmZip = require(&#039;adm-zip&#039;),
    fs = require(&#039;fs&#039;),
    path = require(&#039;path&#039;),
    vm = require(&#039;vm&#039;);

var promise = require(&#039;..&#039;).promise,
    _base = require(&#039;../_base&#039;),
    io = require(&#039;../io&#039;),
    extension = require(&#039;./extension&#039;);


/** @const */
var WEBDRIVER_PREFERENCES_PATH = _base.isDevMode()
    ? path.join(__dirname, &#039;../../../firefox-driver/webdriver.json&#039;)
    : path.join(__dirname, &#039;../lib/firefox/webdriver.json&#039;);

/** @const */
var WEBDRIVER_EXTENSION_PATH = _base.isDevMode()
    ? path.join(__dirname,
        &#039;../../../../build/javascript/firefox-driver/webdriver.xpi&#039;)
    : path.join(__dirname, &#039;../lib/firefox/webdriver.xpi&#039;);

/** @const */
var WEBDRIVER_EXTENSION_NAME = &#039;fxdriver@googlecode.com&#039;;



/** @type {Object} */
var defaultPreferences = null;

/**
 * Synchronously loads the default preferences used for the FirefoxDriver.
 * @return {!Object} The default preferences JSON object.
 */
function getDefaultPreferences() {
  if (!defaultPreferences) {
    var contents = fs.readFileSync(WEBDRIVER_PREFERENCES_PATH, &#039;utf8&#039;);
    defaultPreferences = JSON.parse(contents);
  }
  return defaultPreferences;
}


/**
 * Parses a user.js file in a Firefox profile directory.
 * @param {string} f Path to the file to parse.
 * @return {!promise.Promise.&lt;!Object&gt;} A promise for the parsed preferences as
 *     a JSON object. If the file does not exist, an empty object will be
 *     returned.
 */
function loadUserPrefs(f) {
  var done = promise.defer();
  fs.readFile(f, function(err, contents) {
    if (err &amp;&amp; err.code === &#039;ENOENT&#039;) {
      done.fulfill({});
      return;
    }

    if (err) {
      done.reject(err);
      return;
    }

    var prefs = {};
    var context = vm.createContext({
      &#039;user_pref&#039;: function(key, value) {
        prefs[key] = value;
      }
    });

    vm.runInContext(contents, context, f);
    done.fulfill(prefs);
  });
  return done.promise;
}


/**
 * Copies the properties of one object into another.
 * @param {!Object} a The destination object.
 * @param {!Object} b The source object to apply as a mixin.
 */
function mixin(a, b) {
  Object.keys(b).forEach(function(key) {
    a[key] = b[key];
  });
}


/**
 * @param {!Object} defaults The default preferences to write. Will be
 *     overridden by user.js preferences in the template directory and the
 *     frozen preferences required by WebDriver.
 * @param {string} dir Path to the directory write the file to.
 * @return {!promise.Promise.&lt;string&gt;} A promise for the profile directory,
 *     to be fulfilled when user preferences have been written.
 */
function writeUserPrefs(prefs, dir) {
  var userPrefs = path.join(dir, &#039;user.js&#039;);
  return loadUserPrefs(userPrefs).then(function(overrides) {
    mixin(prefs, overrides);
    mixin(prefs, getDefaultPreferences()[&#039;frozen&#039;]);

    var contents = Object.keys(prefs).map(function(key) {
      return &#039;user_pref(&#039; + JSON.stringify(key) + &#039;, &#039; +
          JSON.stringify(prefs[key]) + &#039;);&#039;;
    }).join(&#039;\n&#039;);

    var done = promise.defer();
    fs.writeFile(userPrefs, contents, function(err) {
      err &amp;&amp; done.reject(err) || done.fulfill(dir);
    });
    return done.promise;
  });
};


/**
 * Installs a group of extensions in the given profile directory. If the
 * WebDriver extension is not included in this set, the default version
 * bundled with this package will be installed.
 * @param {!Array.&lt;string&gt;} extensions The extensions to install, as a
 *     path to an unpacked extension directory or a path to a xpi file.
 * @param {string} dir The profile directory to install to.
 * @param {boolean=} opt_excludeWebDriverExt Whether to skip installation of
 *     the default WebDriver extension.
 * @return {!promise.Promise.&lt;string&gt;} A promise for the main profile directory
 *     once all extensions have been installed.
 */
function installExtensions(extensions, dir, opt_excludeWebDriverExt) {
  var hasWebDriver = !!opt_excludeWebDriverExt;
  var next = 0;
  var extensionDir = path.join(dir, &#039;extensions&#039;);
  var done = promise.defer();

  return io.exists(extensionDir).then(function(exists) {
    if (!exists) {
      return promise.checkedNodeCall(fs.mkdir, extensionDir);
    }
  }).then(function() {
    installNext();
    return done.promise;
  });

  function installNext() {
    if (!done.isPending()) {
      return;
    }

    if (next &gt;= extensions.length) {
      if (hasWebDriver) {
        done.fulfill(dir);
      } else {
        install(WEBDRIVER_EXTENSION_PATH);
      }
    } else {
      install(extensions[next++]);
    }
  }

  function install(ext) {
    extension.install(ext, extensionDir).then(function(id) {
      hasWebDriver = hasWebDriver || (id === WEBDRIVER_EXTENSION_NAME);
      installNext();
    }, done.reject);
 }
}


/**
 * Decodes a base64 encoded profile.
 * @param {string} data The base64 encoded string.
 * @return {!promise.Promise.&lt;string&gt;} A promise for the path to the decoded
 *     profile directory.
 */
function decode(data) {
  return io.tmpFile().then(function(file) {
    var buf = new Buffer(data, &#039;base64&#039;);
    return promise.checkedNodeCall(fs.writeFile, file, buf).then(function() {
      return io.tmpDir();
    }).then(function(dir) {
      var zip = new AdmZip(file);
      zip.extractAllTo(dir);  // Sync only? Why?? :-(
      return dir;
    });
  });
}



/**
 * Models a Firefox proifle directory for use with the FirefoxDriver. The
 * {@code Proifle} directory uses an in-memory model until {@link #writeToDisk}
 * is called.
 * @param {string=} opt_dir Path to an existing Firefox profile directory to
 *     use a template for this profile. If not specified, a blank profile will
 *     be used.
 * @constructor
 */
var Profile = function(opt_dir) {
  /** @private {!Object} */
  this.preferences_ = {};

  mixin(this.preferences_, getDefaultPreferences()[&#039;mutable&#039;]);
  mixin(this.preferences_, getDefaultPreferences()[&#039;frozen&#039;]);

  /** @private {boolean} */
  this.nativeEventsEnabled_ = true;

  /** @private {(string|undefined)} */
  this.template_ = opt_dir;

  /** @private {number} */
  this.port_ = 0;

  /** @private {!Array.&lt;string&gt;} */
  this.extensions_ = [];
};


/**
 * Registers an extension to be included with this profile.
 * @param {string} extension Path to the extension to include, as either an
 *     unpacked extension directory or the path to a xpi file.
 */
Profile.prototype.addExtension = function(extension) {
  this.extensions_.push(extension);
};


/**
 * Sets a desired preference for this profile.
 * @param {string} key The preference key.
 * @param {(string|number|boolean)} value The preference value.
 * @throws {Error} If attempting to set a frozen preference.
 */
Profile.prototype.setPreference = function(key, value) {
  var frozen = getDefaultPreferences()[&#039;frozen&#039;];
  if (frozen.hasOwnProperty(key) &amp;&amp; frozen[key] !== value) {
    throw Error(&#039;You may not set &#039; + key + &#039;=&#039; + JSON.stringify(value)
        + &#039;; value is frozen for proper WebDriver functionality (&#039;
        + key + &#039;=&#039; + JSON.stringify(frozen[key]) + &#039;)&#039;);
  }
  this.preferences_[key] = value;
};


/**
 * Returns the currently configured value of a profile preference. This does
 * not include any defaults defined in the profile&#039;s template directory user.js
 * file (if a template were specified on construction).
 * @param {string} key The desired preference.
 * @return {(string|number|boolean|undefined)} The current value of the
 *     requested preference.
 */
Profile.prototype.getPreference = function(key) {
  return this.preferences_[key];
};


/**
 * @return {number} The port this profile is currently configured to use, or
 *     0 if the port will be selected at random when the profile is written
 *     to disk.
 */
Profile.prototype.getPort = function() {
  return this.port_;
};


/**
 * Sets the port to use for the WebDriver extension loaded by this profile.
 * @param {number} port The desired port, or 0 to use any free port.
 */
Profile.prototype.setPort = function(port) {
  this.port_ = port;
};


/**
 * @return {boolean} Whether the FirefoxDriver is configured to automatically
 *     accept untrusted SSL certificates.
 */
Profile.prototype.acceptUntrustedCerts = function() {
  return !!this.preferences_[&#039;webdriver_accept_untrusted_certs&#039;];
};


/**
 * Sets whether the FirefoxDriver should automatically accept untrusted SSL
 * certificates.
 * @param {boolean} value .
 */
Profile.prototype.setAcceptUntrustedCerts = function(value) {
  this.preferences_[&#039;webdriver_accept_untrusted_certs&#039;] = !!value;
};


/**
 * Sets whether to assume untrusted certificates come from untrusted issuers.
 * @param {boolean} value .
 */
Profile.prototype.setAssumeUntrustedCertIssuer = function(value) {
  this.preferences_[&#039;webdriver_assume_untrusted_issuer&#039;] = !!value;
};


/**
 * @return {boolean} Whether to assume untrusted certs come from untrusted
 *     issuers.
 */
Profile.prototype.assumeUntrustedCertIssuer = function() {
  return !!this.preferences_[&#039;webdriver_assume_untrusted_issuer&#039;];
};


/**
 * Sets whether to use native events with this profile.
 * @param {boolean} enabled .
 */
Profile.prototype.setNativeEventsEnabled = function(enabled) {
  this.nativeEventsEnabled_ = enabled;
};


/**
 * Returns whether native events are enabled in this profile.
 * @return {boolean} .
 */
Profile.prototype.nativeEventsEnabled = function() {
  return this.nativeEventsEnabled_;
};


/**
 * Writes this profile to disk.
 * @param {boolean=} opt_excludeWebDriverExt Whether to exclude the WebDriver
 *     extension from the generated profile. Used to reduce the size of an
 *     {@link #encode() encoded profile} since the server will always install
 *     the extension itself.
 * @return {!promise.Promise.&lt;string&gt;} A promise for the path to the new
 *     profile directory.
 */
Profile.prototype.writeToDisk = function(opt_excludeWebDriverExt) {
  var profileDir = io.tmpDir();
  if (this.template_) {
    profileDir = profileDir.then(function(dir) {
      return io.copyDir(
          this.template_, dir, /(parent\.lock|lock|\.parentlock)/);
    }.bind(this));
  }

  // Freeze preferences for async operations.
  var prefs = {};
  mixin(prefs, this.preferences_);

  // Freeze extensions for async operations.
  var extensions = this.extensions_.concat();

  return profileDir.then(function(dir) {
    return writeUserPrefs(prefs, dir);
  }).then(function(dir) {
    return installExtensions(extensions, dir, !!opt_excludeWebDriverExt);
  });
};


/**
 * Encodes this profile as a zipped, base64 encoded directory.
 * @return {!promise.Promise.&lt;string&gt;} A promise for the encoded profile.
 */
Profile.prototype.encode = function() {
  return this.writeToDisk(true).then(function(dir) {
    var zip = new AdmZip();
    zip.addLocalFolder(dir, &#039;&#039;);
    return io.tmpFile().then(function(file) {
      zip.writeZip(file);  // Sync! Why oh why :-(
      return promise.checkedNodeCall(fs.readFile, file);
    });
  }).then(function(data) {
    return new Buffer(data).toString(&#039;base64&#039;);
  });
};


// PUBLIC API


exports.Profile = Profile;
exports.decode = decode;
exports.loadUserPrefs = loadUserPrefs;</textarea>
  </div>
</div>

<footer class="footer">
  <div class="container">
    <p>.</p>
  </div>
</footer>

<script type="text/html" id="complexity-popover-template">
  <div class="complexity-notice">
    Complexity : {{ complexity.cyclomatic }} <br>
    Length : {{ complexity.halstead.length }} <br>
    Difficulty : {{ complexity.halstead.difficulty.toFixed(2) }} <br>
    Est # bugs : {{ complexity.halstead.bugs.toFixed(2) }}<br>
  </div>
</script>

<script type="text/javascript" src="../../assets/scripts/bundles/core-bundle.js"></script>
<script type="text/javascript" src="../../assets/scripts/bundles/codemirror.js"></script>
<script type="text/javascript" src="../../assets/scripts/codemirror.markpopovertext.js"></script>
<script type="text/javascript" src="report.js"></script>
<script type="text/javascript" src="report.history.js"></script>
<script type="text/javascript" src="../../assets/scripts/plato-file.js"></script>
</body>
</html>
