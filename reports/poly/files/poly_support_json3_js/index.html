<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Plato - poly/support/json3.js</title>

  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="">
  <meta name="author" content="">

  <!--[if lt IE 9]>
  <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->

  <link href="../../assets/css/vendor/morris.css" rel="stylesheet">
  <link href="../../assets/css/vendor/bootstrap.css" rel="stylesheet">
  <link href="../../assets/css/vendor/font-awesome.css" rel="stylesheet">
  <link href="../../assets/css/vendor/codemirror.css" rel="stylesheet">
  <link href="../../assets/css/plato.css" rel="stylesheet">
  <link href="../../assets/css/plato-file.css" rel="stylesheet">

</head>

<body>

<div class="navbar navbar-fixed-top">
  <div class="container">
    <a class="navbar-brand" href="http://github.com/es-analysis/plato">Plato on Github</a>
    <ul class="nav navbar-nav">
      <li>
        <a href="../../index.html">Report Home</a>
      </li>
    </ul>
  </div>
</div>

<div class="jumbotron">
  <div class="container">
    <h1>poly/support/json3.js</h1>
  </div>
</div>

<div class="container aggregate-stats">
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Maintainability <a href="http://blogs.msdn.com/b/codeanalysis/archive/2007/11/20/maintainability-index-range-and-meaning.aspx"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="A value between 0 and 100 that represents the relative ease of maintaining the code. A high value means better maintainability." data-original-title="Maintainability Index"  data-container="body"></i></a></h2>
      <p class="stat">52.42</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Lines of code <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h2>
      <p class="stat">782</p>
    </div>
  </div>
  <div class="row historical">
    <div class="col-md-6">
      <p id="chart_historical_maint" class="chart"></p>
    </div>
    <div class="col-md-6">
      <p id="chart_historical_sloc" class="chart"></p>
    </div>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Difficulty  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="The difficulty measure is related to the difficulty of the program to write or understand." data-original-title="Difficulty" data-container="body"></i></a></h2>
      <p class="stat">136.30</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Estimated Errors  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Halstead's delivered bugs is an estimate for the number of errors in the implementation." data-original-title="Delivered Bugs" data-container="body"></i></a></h2>
      <p class="stat">7.27</p>
    </div>
  </div>
</div>

<div class="container charts">
  <div class="row">
    <h2 class="header">Function weight</h2>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h3 class="chart-header">By Complexity <a href="http://en.wikipedia.org/wiki/Cyclomatic_complexity"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="This metric counts the number of distinct paths through a block of code. Lower values are better." data-original-title="Cyclomatic Complexity" data-container="body"></i></a></h3>
      <div id="fn-by-complexity" class="stat"></div>
    </div>
    <div class="col-md-6">
      <h3 class="chart-header">By SLOC  <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h3>
      <div id="fn-by-sloc" class="stat"></div>
    </div>
  </div>
</div>

<div class="container">
  <div class="row">
    <textarea id="file-source" class="col-md-12">/*! JSON v3.2.4 | http://bestiejs.github.com/json3 | Copyright 2012, Kit Cambridge | http://kit.mit-license.org */
;(function () {
  // Convenience aliases.
  var getClass = {}.toString, isProperty, forEach, undef;

  // Detect the `define` function exposed by asynchronous module loaders. The
  // strict `define` check is necessary for compatibility with `r.js`.
  var isLoader = typeof define === &quot;function&quot; &amp;&amp; define.amd, JSON3 = !isLoader &amp;&amp; typeof exports == &quot;object&quot; &amp;&amp; exports;

  if (JSON3 || isLoader) {
    if (typeof JSON == &quot;object&quot; &amp;&amp; JSON) {
      // Delegate to the native `stringify` and `parse` implementations in
      // asynchronous module loaders and CommonJS environments.
      if (isLoader) {
        JSON3 = JSON;
      } else {
        JSON3.stringify = JSON.stringify;
        JSON3.parse = JSON.parse;
      }
    } else if (isLoader) {
      JSON3 = this.JSON = {};
    }
  } else {
    // Export for web browsers and JavaScript engines.
    JSON3 = this.JSON || (this.JSON = {});
  }

  // Local variables.
  var Escapes, toPaddedString, quote, serialize;
  var fromCharCode, Unescapes, abort, lex, get, walk, update, Index, Source;

  // Test the `Date#getUTC*` methods. Based on work by @Yaffle.
  var isExtended = new Date(-3509827334573292), floor, Months, getDay;

  try {
    // The `getUTCFullYear`, `Month`, and `Date` methods return nonsensical
    // results for certain dates in Opera &gt;= 10.53.
    isExtended = isExtended.getUTCFullYear() == -109252 &amp;&amp; isExtended.getUTCMonth() === 0 &amp;&amp; isExtended.getUTCDate() == 1 &amp;&amp;
      // Safari &lt; 2.0.2 stores the internal millisecond time value correctly,
      // but clips the values returned by the date methods to the range of
      // signed 32-bit integers ([-2 ** 31, 2 ** 31 - 1]).
      isExtended.getUTCHours() == 10 &amp;&amp; isExtended.getUTCMinutes() == 37 &amp;&amp; isExtended.getUTCSeconds() == 6 &amp;&amp; isExtended.getUTCMilliseconds() == 708;
  } catch (exception) {}

  // Internal: Determines whether the native `JSON.stringify` and `parse`
  // implementations are spec-compliant. Based on work by Ken Snyder.
  function has(name) {
    var stringifySupported, parseSupported, value, serialized = &#039;{&quot;A&quot;:[1,true,false,null,&quot;\\u0000\\b\\n\\f\\r\\t&quot;]}&#039;, all = name == &quot;json&quot;;
    if (all || name == &quot;json-stringify&quot; || name == &quot;json-parse&quot;) {
      // Test `JSON.stringify`.
      if (name == &quot;json-stringify&quot; || all) {
        if ((stringifySupported = typeof JSON3.stringify == &quot;function&quot; &amp;&amp; isExtended)) {
          // A test function object with a custom `toJSON` method.
          (value = function () {
            return 1;
          }).toJSON = value;
          try {
            stringifySupported =
              // Firefox 3.1b1 and b2 serialize string, number, and boolean
              // primitives as object literals.
              JSON3.stringify(0) === &quot;0&quot; &amp;&amp;
              // FF 3.1b1, b2, and JSON 2 serialize wrapped primitives as object
              // literals.
              JSON3.stringify(new Number()) === &quot;0&quot; &amp;&amp;
              JSON3.stringify(new String()) == &#039;&quot;&quot;&#039; &amp;&amp;
              // FF 3.1b1, 2 throw an error if the value is `null`, `undefined`, or
              // does not define a canonical JSON representation (this applies to
              // objects with `toJSON` properties as well, *unless* they are nested
              // within an object or array).
              JSON3.stringify(getClass) === undef &amp;&amp;
              // IE 8 serializes `undefined` as `&quot;undefined&quot;`. Safari &lt;= 5.1.7 and
              // FF 3.1b3 pass this test.
              JSON3.stringify(undef) === undef &amp;&amp;
              // Safari &lt;= 5.1.7 and FF 3.1b3 throw `Error`s and `TypeError`s,
              // respectively, if the value is omitted entirely.
              JSON3.stringify() === undef &amp;&amp;
              // FF 3.1b1, 2 throw an error if the given value is not a number,
              // string, array, object, Boolean, or `null` literal. This applies to
              // objects with custom `toJSON` methods as well, unless they are nested
              // inside object or array literals. YUI 3.0.0b1 ignores custom `toJSON`
              // methods entirely.
              JSON3.stringify(value) === &quot;1&quot; &amp;&amp;
              JSON3.stringify([value]) == &quot;[1]&quot; &amp;&amp;
              // Prototype &lt;= 1.6.1 serializes `[undefined]` as `&quot;[]&quot;` instead of
              // `&quot;[null]&quot;`.
              JSON3.stringify([undef]) == &quot;[null]&quot; &amp;&amp;
              // YUI 3.0.0b1 fails to serialize `null` literals.
              JSON3.stringify(null) == &quot;null&quot; &amp;&amp;
              // FF 3.1b1, 2 halts serialization if an array contains a function:
              // `[1, true, getClass, 1]` serializes as &quot;[1,true,],&quot;. These versions
              // of Firefox also allow trailing commas in JSON objects and arrays.
              // FF 3.1b3 elides non-JSON values from objects and arrays, unless they
              // define custom `toJSON` methods.
              JSON3.stringify([undef, getClass, null]) == &quot;[null,null,null]&quot; &amp;&amp;
              // Simple serialization test. FF 3.1b1 uses Unicode escape sequences
              // where character escape codes are expected (e.g., `\b` =&gt; `\u0008`).
              JSON3.stringify({ &quot;A&quot;: [value, true, false, null, &quot;\0\b\n\f\r\t&quot;] }) == serialized &amp;&amp;
              // FF 3.1b1 and b2 ignore the `filter` and `width` arguments.
              JSON3.stringify(null, value) === &quot;1&quot; &amp;&amp;
              JSON3.stringify([1, 2], null, 1) == &quot;[\n 1,\n 2\n]&quot; &amp;&amp;
              // JSON 2, Prototype &lt;= 1.7, and older WebKit builds incorrectly
              // serialize extended years.
              JSON3.stringify(new Date(-8.64e15)) == &#039;&quot;-271821-04-20T00:00:00.000Z&quot;&#039; &amp;&amp;
              // The milliseconds are optional in ES 5, but required in 5.1.
              JSON3.stringify(new Date(8.64e15)) == &#039;&quot;+275760-09-13T00:00:00.000Z&quot;&#039; &amp;&amp;
              // Firefox &lt;= 11.0 incorrectly serializes years prior to 0 as negative
              // four-digit years instead of six-digit years. Credits: @Yaffle.
              JSON3.stringify(new Date(-621987552e5)) == &#039;&quot;-000001-01-01T00:00:00.000Z&quot;&#039; &amp;&amp;
              // Safari &lt;= 5.1.5 and Opera &gt;= 10.53 incorrectly serialize millisecond
              // values less than 1000. Credits: @Yaffle.
              JSON3.stringify(new Date(-1)) == &#039;&quot;1969-12-31T23:59:59.999Z&quot;&#039;;
          } catch (exception) {
            stringifySupported = false;
          }
        }
        if (!all) {
          return stringifySupported;
        }
      }
      // Test `JSON.parse`.
      if (name == &quot;json-parse&quot; || all) {
        if (typeof JSON3.parse == &quot;function&quot;) {
          try {
            // FF 3.1b1, b2 will throw an exception if a bare literal is provided.
            // Conforming implementations should also coerce the initial argument to
            // a string prior to parsing.
            if (JSON3.parse(&quot;0&quot;) === 0 &amp;&amp; !JSON3.parse(false)) {
              // Simple parsing test.
              value = JSON3.parse(serialized);
              if ((parseSupported = value.A.length == 5 &amp;&amp; value.A[0] == 1)) {
                try {
                  // Safari &lt;= 5.1.2 and FF 3.1b1 allow unescaped tabs in strings.
                  parseSupported = !JSON3.parse(&#039;&quot;\t&quot;&#039;);
                } catch (exception) {}
                if (parseSupported) {
                  try {
                    // FF 4.0 and 4.0.1 allow leading `+` signs, and leading and
                    // trailing decimal points. FF 4.0, 4.0.1, and IE 9-10 also
                    // allow certain octal literals.
                    parseSupported = JSON3.parse(&quot;01&quot;) != 1;
                  } catch (exception) {}
                }
              }
            }
          } catch (exception) {
            parseSupported = false;
          }
        }
        if (!all) {
          return parseSupported;
        }
      }
      return stringifySupported &amp;&amp; parseSupported;
    }
  }

  if (!has(&quot;json&quot;)) {
    // Define additional utility methods if the `Date` methods are buggy.
    if (!isExtended) {
      floor = Math.floor;
      // A mapping between the months of the year and the number of days between
      // January 1st and the first of the respective month.
      Months = [0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334];
      // Internal: Calculates the number of days between the Unix epoch and the
      // first day of the given month.
      getDay = function (year, month) {
        return Months[month] + 365 * (year - 1970) + floor((year - 1969 + (month = +(month &gt; 1))) / 4) - floor((year - 1901 + month) / 100) + floor((year - 1601 + month) / 400);
      };
    }
    
    // Internal: Determines if a property is a direct property of the given
    // object. Delegates to the native `Object#hasOwnProperty` method.
    if (!(isProperty = {}.hasOwnProperty)) {
      isProperty = function (property) {
        var members = {}, constructor;
        if ((members.__proto__ = null, members.__proto__ = {
          // The *proto* property cannot be set multiple times in recent
          // versions of Firefox and SeaMonkey.
          &quot;toString&quot;: 1
        }, members).toString != getClass) {
          // Safari &lt;= 2.0.3 doesn&#039;t implement `Object#hasOwnProperty`, but
          // supports the mutable *proto* property.
          isProperty = function (property) {
            // Capture and break the object&#039;s prototype chain (see section 8.6.2
            // of the ES 5.1 spec). The parenthesized expression prevents an
            // unsafe transformation by the Closure Compiler.
            var original = this.__proto__, result = property in (this.__proto__ = null, this);
            // Restore the original prototype chain.
            this.__proto__ = original;
            return result;
          };
        } else {
          // Capture a reference to the top-level `Object` constructor.
          constructor = members.constructor;
          // Use the `constructor` property to simulate `Object#hasOwnProperty` in
          // other environments.
          isProperty = function (property) {
            var parent = (this.constructor || constructor).prototype;
            return property in this &amp;&amp; !(property in parent &amp;&amp; this[property] === parent[property]);
          };
        }
        members = null;
        return isProperty.call(this, property);
      };
    }

    // Internal: Normalizes the `for...in` iteration algorithm across
    // environments. Each enumerated key is yielded to a `callback` function.
    forEach = function (object, callback) {
      var size = 0, Properties, members, property, forEach;

      // Tests for bugs in the current environment&#039;s `for...in` algorithm. The
      // `valueOf` property inherits the non-enumerable flag from
      // `Object.prototype` in older versions of IE, Netscape, and Mozilla.
      (Properties = function () {
        this.valueOf = 0;
      }).prototype.valueOf = 0;

      // Iterate over a new instance of the `Properties` class.
      members = new Properties();
      for (property in members) {
        // Ignore all properties inherited from `Object.prototype`.
        if (isProperty.call(members, property)) {
          size++;
        }
      }
      Properties = members = null;

      // Normalize the iteration algorithm.
      if (!size) {
        // A list of non-enumerable properties inherited from `Object.prototype`.
        members = [&quot;valueOf&quot;, &quot;toString&quot;, &quot;toLocaleString&quot;, &quot;propertyIsEnumerable&quot;, &quot;isPrototypeOf&quot;, &quot;hasOwnProperty&quot;, &quot;constructor&quot;];
        // IE &lt;= 8, Mozilla 1.0, and Netscape 6.2 ignore shadowed non-enumerable
        // properties.
        forEach = function (object, callback) {
          var isFunction = getClass.call(object) == &quot;[object Function]&quot;, property, length;
          for (property in object) {
            // Gecko &lt;= 1.0 enumerates the `prototype` property of functions under
            // certain conditions; IE does not.
            if (!(isFunction &amp;&amp; property == &quot;prototype&quot;) &amp;&amp; isProperty.call(object, property)) {
              callback(property);
            }
          }
          // Manually invoke the callback for each non-enumerable property.
          for (length = members.length; property = members[--length]; isProperty.call(object, property) &amp;&amp; callback(property));
        };
      } else if (size == 2) {
        // Safari &lt;= 2.0.4 enumerates shadowed properties twice.
        forEach = function (object, callback) {
          // Create a set of iterated properties.
          var members = {}, isFunction = getClass.call(object) == &quot;[object Function]&quot;, property;
          for (property in object) {
            // Store each property name to prevent double enumeration. The
            // `prototype` property of functions is not enumerated due to cross-
            // environment inconsistencies.
            if (!(isFunction &amp;&amp; property == &quot;prototype&quot;) &amp;&amp; !isProperty.call(members, property) &amp;&amp; (members[property] = 1) &amp;&amp; isProperty.call(object, property)) {
              callback(property);
            }
          }
        };
      } else {
        // No bugs detected; use the standard `for...in` algorithm.
        forEach = function (object, callback) {
          var isFunction = getClass.call(object) == &quot;[object Function]&quot;, property, isConstructor;
          for (property in object) {
            if (!(isFunction &amp;&amp; property == &quot;prototype&quot;) &amp;&amp; isProperty.call(object, property) &amp;&amp; !(isConstructor = property === &quot;constructor&quot;)) {
              callback(property);
            }
          }
          // Manually invoke the callback for the `constructor` property due to
          // cross-environment inconsistencies.
          if (isConstructor || isProperty.call(object, (property = &quot;constructor&quot;))) {
            callback(property);
          }
        };
      }
      return forEach(object, callback);
    };

    // Public: Serializes a JavaScript `value` as a JSON string. The optional
    // `filter` argument may specify either a function that alters how object and
    // array members are serialized, or an array of strings and numbers that
    // indicates which properties should be serialized. The optional `width`
    // argument may be either a string or number that specifies the indentation
    // level of the output.
    if (!has(&quot;json-stringify&quot;)) {
      // Internal: A map of control characters and their escaped equivalents.
      Escapes = {
        &quot;\\&quot;: &quot;\\\\&quot;,
        &#039;&quot;&#039;: &#039;\\&quot;&#039;,
        &quot;\b&quot;: &quot;\\b&quot;,
        &quot;\f&quot;: &quot;\\f&quot;,
        &quot;\n&quot;: &quot;\\n&quot;,
        &quot;\r&quot;: &quot;\\r&quot;,
        &quot;\t&quot;: &quot;\\t&quot;
      };

      // Internal: Converts `value` into a zero-padded string such that its
      // length is at least equal to `width`. The `width` must be &lt;= 6.
      toPaddedString = function (width, value) {
        // The `|| 0` expression is necessary to work around a bug in
        // Opera &lt;= 7.54u2 where `0 == -0`, but `String(-0) !== &quot;0&quot;`.
        return (&quot;000000&quot; + (value || 0)).slice(-width);
      };

      // Internal: Double-quotes a string `value`, replacing all ASCII control
      // characters (characters with code unit values between 0 and 31) with
      // their escaped equivalents. This is an implementation of the
      // `Quote(value)` operation defined in ES 5.1 section 15.12.3.
      quote = function (value) {
        var result = &#039;&quot;&#039;, index = 0, symbol;
        for (; symbol = value.charAt(index); index++) {
          // Escape the reverse solidus, double quote, backspace, form feed, line
          // feed, carriage return, and tab characters.
          result += &#039;\\&quot;\b\f\n\r\t&#039;.indexOf(symbol) &gt; -1 ? Escapes[symbol] :
            // If the character is a control character, append its Unicode escape
            // sequence; otherwise, append the character as-is.
            (Escapes[symbol] = symbol &lt; &quot; &quot; ? &quot;\\u00&quot; + toPaddedString(2, symbol.charCodeAt(0).toString(16)) : symbol);
        }
        return result + &#039;&quot;&#039;;
      };

      // Internal: Recursively serializes an object. Implements the
      // `Str(key, holder)`, `JO(value)`, and `JA(value)` operations.
      serialize = function (property, object, callback, properties, whitespace, indentation, stack) {
        var value = object[property], className, year, month, date, time, hours, minutes, seconds, milliseconds, results, element, index, length, prefix, any, result;
        if (typeof value == &quot;object&quot; &amp;&amp; value) {
          className = getClass.call(value);
          if (className == &quot;[object Date]&quot; &amp;&amp; !isProperty.call(value, &quot;toJSON&quot;)) {
            if (value &gt; -1 / 0 &amp;&amp; value &lt; 1 / 0) {
              // Dates are serialized according to the `Date#toJSON` method
              // specified in ES 5.1 section 15.9.5.44. See section 15.9.1.15
              // for the ISO 8601 date time string format.
              if (getDay) {
                // Manually compute the year, month, date, hours, minutes,
                // seconds, and milliseconds if the `getUTC*` methods are
                // buggy. Adapted from @Yaffle&#039;s `date-shim` project.
                date = floor(value / 864e5);
                for (year = floor(date / 365.2425) + 1970 - 1; getDay(year + 1, 0) &lt;= date; year++);
                for (month = floor((date - getDay(year, 0)) / 30.42); getDay(year, month + 1) &lt;= date; month++);
                date = 1 + date - getDay(year, month);
                // The `time` value specifies the time within the day (see ES
                // 5.1 section 15.9.1.2). The formula `(A % B + B) % B` is used
                // to compute `A modulo B`, as the `%` operator does not
                // correspond to the `modulo` operation for negative numbers.
                time = (value % 864e5 + 864e5) % 864e5;
                // The hours, minutes, seconds, and milliseconds are obtained by
                // decomposing the time within the day. See section 15.9.1.10.
                hours = floor(time / 36e5) % 24;
                minutes = floor(time / 6e4) % 60;
                seconds = floor(time / 1e3) % 60;
                milliseconds = time % 1e3;
              } else {
                year = value.getUTCFullYear();
                month = value.getUTCMonth();
                date = value.getUTCDate();
                hours = value.getUTCHours();
                minutes = value.getUTCMinutes();
                seconds = value.getUTCSeconds();
                milliseconds = value.getUTCMilliseconds();
              }
              // Serialize extended years correctly.
              value = (year &lt;= 0 || year &gt;= 1e4 ? (year &lt; 0 ? &quot;-&quot; : &quot;+&quot;) + toPaddedString(6, year &lt; 0 ? -year : year) : toPaddedString(4, year)) +
                &quot;-&quot; + toPaddedString(2, month + 1) + &quot;-&quot; + toPaddedString(2, date) +
                // Months, dates, hours, minutes, and seconds should have two
                // digits; milliseconds should have three.
                &quot;T&quot; + toPaddedString(2, hours) + &quot;:&quot; + toPaddedString(2, minutes) + &quot;:&quot; + toPaddedString(2, seconds) +
                // Milliseconds are optional in ES 5.0, but required in 5.1.
                &quot;.&quot; + toPaddedString(3, milliseconds) + &quot;Z&quot;;
            } else {
              value = null;
            }
          } else if (typeof value.toJSON == &quot;function&quot; &amp;&amp; ((className != &quot;[object Number]&quot; &amp;&amp; className != &quot;[object String]&quot; &amp;&amp; className != &quot;[object Array]&quot;) || isProperty.call(value, &quot;toJSON&quot;))) {
            // Prototype &lt;= 1.6.1 adds non-standard `toJSON` methods to the
            // `Number`, `String`, `Date`, and `Array` prototypes. JSON 3
            // ignores all `toJSON` methods on these objects unless they are
            // defined directly on an instance.
            value = value.toJSON(property);
          }
        }
        if (callback) {
          // If a replacement function was provided, call it to obtain the value
          // for serialization.
          value = callback.call(object, property, value);
        }
        if (value === null) {
          return &quot;null&quot;;
        }
        className = getClass.call(value);
        if (className == &quot;[object Boolean]&quot;) {
          // Booleans are represented literally.
          return &quot;&quot; + value;
        } else if (className == &quot;[object Number]&quot;) {
          // JSON numbers must be finite. `Infinity` and `NaN` are serialized as
          // `&quot;null&quot;`.
          return value &gt; -1 / 0 &amp;&amp; value &lt; 1 / 0 ? &quot;&quot; + value : &quot;null&quot;;
        } else if (className == &quot;[object String]&quot;) {
          // Strings are double-quoted and escaped.
          return quote(value);
        }
        // Recursively serialize objects and arrays.
        if (typeof value == &quot;object&quot;) {
          // Check for cyclic structures. This is a linear search; performance
          // is inversely proportional to the number of unique nested objects.
          for (length = stack.length; length--;) {
            if (stack[length] === value) {
              // Cyclic structures cannot be serialized by `JSON.stringify`.
              throw TypeError();
            }
          }
          // Add the object to the stack of traversed objects.
          stack.push(value);
          results = [];
          // Save the current indentation level and indent one additional level.
          prefix = indentation;
          indentation += whitespace;
          if (className == &quot;[object Array]&quot;) {
            // Recursively serialize array elements.
            for (index = 0, length = value.length; index &lt; length; any || (any = true), index++) {
              element = serialize(index, value, callback, properties, whitespace, indentation, stack);
              results.push(element === undef ? &quot;null&quot; : element);
            }
            result = any ? (whitespace ? &quot;[\n&quot; + indentation + results.join(&quot;,\n&quot; + indentation) + &quot;\n&quot; + prefix + &quot;]&quot; : (&quot;[&quot; + results.join(&quot;,&quot;) + &quot;]&quot;)) : &quot;[]&quot;;
          } else {
            // Recursively serialize object members. Members are selected from
            // either a user-specified list of property names, or the object
            // itself.
            forEach(properties || value, function (property) {
              var element = serialize(property, value, callback, properties, whitespace, indentation, stack);
              if (element !== undef) {
                // According to ES 5.1 section 15.12.3: &quot;If `gap` {whitespace}
                // is not the empty string, let `member` {quote(property) + &quot;:&quot;}
                // be the concatenation of `member` and the `space` character.&quot;
                // The &quot;`space` character&quot; refers to the literal space
                // character, not the `space` {width} argument provided to
                // `JSON.stringify`.
                results.push(quote(property) + &quot;:&quot; + (whitespace ? &quot; &quot; : &quot;&quot;) + element);
              }
              any || (any = true);
            });
            result = any ? (whitespace ? &quot;{\n&quot; + indentation + results.join(&quot;,\n&quot; + indentation) + &quot;\n&quot; + prefix + &quot;}&quot; : (&quot;{&quot; + results.join(&quot;,&quot;) + &quot;}&quot;)) : &quot;{}&quot;;
          }
          // Remove the object from the traversed object stack.
          stack.pop();
          return result;
        }
      };

      // Public: `JSON.stringify`. See ES 5.1 section 15.12.3.
      JSON3.stringify = function (source, filter, width) {
        var whitespace, callback, properties, index, length, value;
        if (typeof filter == &quot;function&quot; || typeof filter == &quot;object&quot; &amp;&amp; filter) {
          if (getClass.call(filter) == &quot;[object Function]&quot;) {
            callback = filter;
          } else if (getClass.call(filter) == &quot;[object Array]&quot;) {
            // Convert the property names array into a makeshift set.
            properties = {};
            for (index = 0, length = filter.length; index &lt; length; value = filter[index++], ((getClass.call(value) == &quot;[object String]&quot; || getClass.call(value) == &quot;[object Number]&quot;) &amp;&amp; (properties[value] = 1)));
          }
        }
        if (width) {
          if (getClass.call(width) == &quot;[object Number]&quot;) {
            // Convert the `width` to an integer and create a string containing
            // `width` number of space characters.
            if ((width -= width % 1) &gt; 0) {
              for (whitespace = &quot;&quot;, width &gt; 10 &amp;&amp; (width = 10); whitespace.length &lt; width; whitespace += &quot; &quot;);
            }
          } else if (getClass.call(width) == &quot;[object String]&quot;) {
            whitespace = width.length &lt;= 10 ? width : width.slice(0, 10);
          }
        }
        // Opera &lt;= 7.54u2 discards the values associated with empty string keys
        // (`&quot;&quot;`) only if they are used directly within an object member list
        // (e.g., `!(&quot;&quot; in { &quot;&quot;: 1})`).
        return serialize(&quot;&quot;, (value = {}, value[&quot;&quot;] = source, value), callback, properties, whitespace, &quot;&quot;, []);
      };
    }

    // Public: Parses a JSON source string.
    if (!has(&quot;json-parse&quot;)) {
      fromCharCode = String.fromCharCode;
      // Internal: A map of escaped control characters and their unescaped
      // equivalents.
      Unescapes = {
        &quot;\\&quot;: &quot;\\&quot;,
        &#039;&quot;&#039;: &#039;&quot;&#039;,
        &quot;/&quot;: &quot;/&quot;,
        &quot;b&quot;: &quot;\b&quot;,
        &quot;t&quot;: &quot;\t&quot;,
        &quot;n&quot;: &quot;\n&quot;,
        &quot;f&quot;: &quot;\f&quot;,
        &quot;r&quot;: &quot;\r&quot;
      };

      // Internal: Resets the parser state and throws a `SyntaxError`.
      abort = function() {
        Index = Source = null;
        throw SyntaxError();
      };

      // Internal: Returns the next token, or `&quot;$&quot;` if the parser has reached
      // the end of the source string. A token may be a string, number, `null`
      // literal, or Boolean literal.
      lex = function () {
        var source = Source, length = source.length, symbol, value, begin, position, sign;
        while (Index &lt; length) {
          symbol = source.charAt(Index);
          if (&quot;\t\r\n &quot;.indexOf(symbol) &gt; -1) {
            // Skip whitespace tokens, including tabs, carriage returns, line
            // feeds, and space characters.
            Index++;
          } else if (&quot;{}[]:,&quot;.indexOf(symbol) &gt; -1) {
            // Parse a punctuator token at the current position.
            Index++;
            return symbol;
          } else if (symbol == &#039;&quot;&#039;) {
            // Advance to the next character and parse a JSON string at the
            // current position. String tokens are prefixed with the sentinel
            // `@` character to distinguish them from punctuators.
            for (value = &quot;@&quot;, Index++; Index &lt; length;) {
              symbol = source.charAt(Index);
              if (symbol &lt; &quot; &quot;) {
                // Unescaped ASCII control characters are not permitted.
                abort();
              } else if (symbol == &quot;\\&quot;) {
                // Parse escaped JSON control characters, `&quot;`, `\`, `/`, and
                // Unicode escape sequences.
                symbol = source.charAt(++Index);
                if (&#039;\\&quot;/btnfr&#039;.indexOf(symbol) &gt; -1) {
                  // Revive escaped control characters.
                  value += Unescapes[symbol];
                  Index++;
                } else if (symbol == &quot;u&quot;) {
                  // Advance to the first character of the escape sequence.
                  begin = ++Index;
                  // Validate the Unicode escape sequence.
                  for (position = Index + 4; Index &lt; position; Index++) {
                    symbol = source.charAt(Index);
                    // A valid sequence comprises four hexdigits that form a
                    // single hexadecimal value.
                    if (!(symbol &gt;= &quot;0&quot; &amp;&amp; symbol &lt;= &quot;9&quot; || symbol &gt;= &quot;a&quot; &amp;&amp; symbol &lt;= &quot;f&quot; || symbol &gt;= &quot;A&quot; &amp;&amp; symbol &lt;= &quot;F&quot;)) {
                      // Invalid Unicode escape sequence.
                      abort();
                    }
                  }
                  // Revive the escaped character.
                  value += fromCharCode(&quot;0x&quot; + source.slice(begin, Index));
                } else {
                  // Invalid escape sequence.
                  abort();
                }
              } else {
                if (symbol == &#039;&quot;&#039;) {
                  // An unescaped double-quote character marks the end of the
                  // string.
                  break;
                }
                // Append the original character as-is.
                value += symbol;
                Index++;
              }
            }
            if (source.charAt(Index) == &#039;&quot;&#039;) {
              Index++;
              // Return the revived string.
              return value;
            }
            // Unterminated string.
            abort();
          } else {
            // Parse numbers and literals.
            begin = Index;
            // Advance the scanner&#039;s position past the sign, if one is
            // specified.
            if (symbol == &quot;-&quot;) {
              sign = true;
              symbol = source.charAt(++Index);
            }
            // Parse an integer or floating-point value.
            if (symbol &gt;= &quot;0&quot; &amp;&amp; symbol &lt;= &quot;9&quot;) {
              // Leading zeroes are interpreted as octal literals.
              if (symbol == &quot;0&quot; &amp;&amp; (symbol = source.charAt(Index + 1), symbol &gt;= &quot;0&quot; &amp;&amp; symbol &lt;= &quot;9&quot;)) {
                // Illegal octal literal.
                abort();
              }
              sign = false;
              // Parse the integer component.
              for (; Index &lt; length &amp;&amp; (symbol = source.charAt(Index), symbol &gt;= &quot;0&quot; &amp;&amp; symbol &lt;= &quot;9&quot;); Index++);
              // Floats cannot contain a leading decimal point; however, this
              // case is already accounted for by the parser.
              if (source.charAt(Index) == &quot;.&quot;) {
                position = ++Index;
                // Parse the decimal component.
                for (; position &lt; length &amp;&amp; (symbol = source.charAt(position), symbol &gt;= &quot;0&quot; &amp;&amp; symbol &lt;= &quot;9&quot;); position++);
                if (position == Index) {
                  // Illegal trailing decimal.
                  abort();
                }
                Index = position;
              }
              // Parse exponents.
              symbol = source.charAt(Index);
              if (symbol == &quot;e&quot; || symbol == &quot;E&quot;) {
                // Skip past the sign following the exponent, if one is
                // specified.
                symbol = source.charAt(++Index);
                if (symbol == &quot;+&quot; || symbol == &quot;-&quot;) {
                  Index++;
                }
                // Parse the exponential component.
                for (position = Index; position &lt; length &amp;&amp; (symbol = source.charAt(position), symbol &gt;= &quot;0&quot; &amp;&amp; symbol &lt;= &quot;9&quot;); position++);
                if (position == Index) {
                  // Illegal empty exponent.
                  abort();
                }
                Index = position;
              }
              // Coerce the parsed value to a JavaScript number.
              return +source.slice(begin, Index);
            }
            // A negative sign may only precede numbers.
            if (sign) {
              abort();
            }
            // `true`, `false`, and `null` literals.
            if (source.slice(Index, Index + 4) == &quot;true&quot;) {
              Index += 4;
              return true;
            } else if (source.slice(Index, Index + 5) == &quot;false&quot;) {
              Index += 5;
              return false;
            } else if (source.slice(Index, Index + 4) == &quot;null&quot;) {
              Index += 4;
              return null;
            }
            // Unrecognized token.
            abort();
          }
        }
        // Return the sentinel `$` character if the parser has reached the end
        // of the source string.
        return &quot;$&quot;;
      };

      // Internal: Parses a JSON `value` token.
      get = function (value) {
        var results, any, key;
        if (value == &quot;$&quot;) {
          // Unexpected end of input.
          abort();
        }
        if (typeof value == &quot;string&quot;) {
          if (value.charAt(0) == &quot;@&quot;) {
            // Remove the sentinel `@` character.
            return value.slice(1);
          }
          // Parse object and array literals.
          if (value == &quot;[&quot;) {
            // Parses a JSON array, returning a new JavaScript array.
            results = [];
            for (;; any || (any = true)) {
              value = lex();
              // A closing square bracket marks the end of the array literal.
              if (value == &quot;]&quot;) {
                break;
              }
              // If the array literal contains elements, the current token
              // should be a comma separating the previous element from the
              // next.
              if (any) {
                if (value == &quot;,&quot;) {
                  value = lex();
                  if (value == &quot;]&quot;) {
                    // Unexpected trailing `,` in array literal.
                    abort();
                  }
                } else {
                  // A `,` must separate each array element.
                  abort();
                }
              }
              // Elisions and leading commas are not permitted.
              if (value == &quot;,&quot;) {
                abort();
              }
              results.push(get(value));
            }
            return results;
          } else if (value == &quot;{&quot;) {
            // Parses a JSON object, returning a new JavaScript object.
            results = {};
            for (;; any || (any = true)) {
              value = lex();
              // A closing curly brace marks the end of the object literal.
              if (value == &quot;}&quot;) {
                break;
              }
              // If the object literal contains members, the current token
              // should be a comma separator.
              if (any) {
                if (value == &quot;,&quot;) {
                  value = lex();
                  if (value == &quot;}&quot;) {
                    // Unexpected trailing `,` in object literal.
                    abort();
                  }
                } else {
                  // A `,` must separate each object member.
                  abort();
                }
              }
              // Leading commas are not permitted, object property names must be
              // double-quoted strings, and a `:` must separate each property
              // name and value.
              if (value == &quot;,&quot; || typeof value != &quot;string&quot; || value.charAt(0) != &quot;@&quot; || lex() != &quot;:&quot;) {
                abort();
              }
              results[value.slice(1)] = get(lex());
            }
            return results;
          }
          // Unexpected token encountered.
          abort();
        }
        return value;
      };

      // Internal: Updates a traversed object member.
      update = function(source, property, callback) {
        var element = walk(source, property, callback);
        if (element === undef) {
          delete source[property];
        } else {
          source[property] = element;
        }
      };

      // Internal: Recursively traverses a parsed JSON object, invoking the
      // `callback` function for each value. This is an implementation of the
      // `Walk(holder, name)` operation defined in ES 5.1 section 15.12.2.
      walk = function (source, property, callback) {
        var value = source[property], length;
        if (typeof value == &quot;object&quot; &amp;&amp; value) {
          if (getClass.call(value) == &quot;[object Array]&quot;) {
            for (length = value.length; length--;) {
              update(value, length, callback);
            }
          } else {
            // `forEach` can&#039;t be used to traverse an array in Opera &lt;= 8.54,
            // as `Object#hasOwnProperty` returns `false` for array indices
            // (e.g., `![1, 2, 3].hasOwnProperty(&quot;0&quot;)`).
            forEach(value, function (property) {
              update(value, property, callback);
            });
          }
        }
        return callback.call(source, property, value);
      };

      // Public: `JSON.parse`. See ES 5.1 section 15.12.2.
      JSON3.parse = function (source, callback) {
        var result, value;
        Index = 0;
        Source = source;
        result = get(lex());
        // If a JSON string contains multiple tokens, it is invalid.
        if (lex() != &quot;$&quot;) {
          abort();
        }
        // Reset the parser state.
        Index = Source = null;
        return callback &amp;&amp; getClass.call(callback) == &quot;[object Function]&quot; ? walk((value = {}, value[&quot;&quot;] = result, value), &quot;&quot;, callback) : result;
      };
    }
  }

  // Export for asynchronous module loaders.
  if (isLoader) {
    define(function () {
      return JSON3;
    });
  }
}).call(this);</textarea>
  </div>
</div>

<footer class="footer">
  <div class="container">
    <p>.</p>
  </div>
</footer>

<script type="text/html" id="complexity-popover-template">
  <div class="complexity-notice">
    Complexity : {{ complexity.cyclomatic }} <br>
    Length : {{ complexity.halstead.length }} <br>
    Difficulty : {{ complexity.halstead.difficulty.toFixed(2) }} <br>
    Est # bugs : {{ complexity.halstead.bugs.toFixed(2) }}<br>
  </div>
</script>

<script type="text/javascript" src="../../assets/scripts/bundles/core-bundle.js"></script>
<script type="text/javascript" src="../../assets/scripts/bundles/codemirror.js"></script>
<script type="text/javascript" src="../../assets/scripts/codemirror.markpopovertext.js"></script>
<script type="text/javascript" src="report.js"></script>
<script type="text/javascript" src="report.history.js"></script>
<script type="text/javascript" src="../../assets/scripts/plato-file.js"></script>
</body>
</html>
