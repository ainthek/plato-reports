<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Plato - node_modules/wire/aop.js</title>

  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="">
  <meta name="author" content="">

  <!--[if lt IE 9]>
  <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->

  <link href="../../assets/css/vendor/morris.css" rel="stylesheet">
  <link href="../../assets/css/vendor/bootstrap.css" rel="stylesheet">
  <link href="../../assets/css/vendor/font-awesome.css" rel="stylesheet">
  <link href="../../assets/css/vendor/codemirror.css" rel="stylesheet">
  <link href="../../assets/css/plato.css" rel="stylesheet">
  <link href="../../assets/css/plato-file.css" rel="stylesheet">

</head>

<body>

<div class="navbar navbar-fixed-top">
  <div class="container">
    <a class="navbar-brand" href="http://github.com/es-analysis/plato">Plato on Github</a>
    <ul class="nav navbar-nav">
      <li>
        <a href="../../index.html">Report Home</a>
      </li>
    </ul>
  </div>
</div>

<div class="jumbotron">
  <div class="container">
    <h1>node_modules/wire/aop.js</h1>
  </div>
</div>

<div class="container aggregate-stats">
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Maintainability <a href="http://blogs.msdn.com/b/codeanalysis/archive/2007/11/20/maintainability-index-range-and-meaning.aspx"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="A value between 0 and 100 that represents the relative ease of maintaining the code. A high value means better maintainability." data-original-title="Maintainability Index"  data-container="body"></i></a></h2>
      <p class="stat">74.61</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Lines of code <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h2>
      <p class="stat">244</p>
    </div>
  </div>
  <div class="row historical">
    <div class="col-md-6">
      <p id="chart_historical_maint" class="chart"></p>
    </div>
    <div class="col-md-6">
      <p id="chart_historical_sloc" class="chart"></p>
    </div>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Difficulty  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="The difficulty measure is related to the difficulty of the program to write or understand." data-original-title="Difficulty" data-container="body"></i></a></h2>
      <p class="stat">49.43</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Estimated Errors  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Halstead's delivered bugs is an estimate for the number of errors in the implementation." data-original-title="Delivered Bugs" data-container="body"></i></a></h2>
      <p class="stat">1.68</p>
    </div>
  </div>
</div>

<div class="container charts">
  <div class="row">
    <h2 class="header">Function weight</h2>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h3 class="chart-header">By Complexity <a href="http://en.wikipedia.org/wiki/Cyclomatic_complexity"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="This metric counts the number of distinct paths through a block of code. Lower values are better." data-original-title="Cyclomatic Complexity" data-container="body"></i></a></h3>
      <div id="fn-by-complexity" class="stat"></div>
    </div>
    <div class="col-md-6">
      <h3 class="chart-header">By SLOC  <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h3>
      <div id="fn-by-sloc" class="stat"></div>
    </div>
  </div>
</div>

<div class="container">
  <div class="row">
    <textarea id="file-source" class="col-md-12">/** @license MIT License (c) copyright B Cavalier &amp; J Hann */

/**
 * wire/aop plugin
 * Provides AOP for components created via wire, including Decorators,
 * Introductions (mixins), and Pointcut-based Aspect Weaving.
 *
 * wire is part of the cujo.js family of libraries (http://cujojs.com/)
 *
 * Licensed under the MIT License at:
 * http://www.opensource.org/licenses/mit-license.php
 */
(function(define) { &#039;use strict&#039;;
define(function(require) {

	var meld, when, sequence, connection, adviceTypes, adviceStep, undef;

	meld = require(&#039;meld&#039;);
	when = require(&#039;when&#039;);
	sequence = require(&#039;when/sequence&#039;);
	connection = require(&#039;./lib/connection&#039;);

	// &quot;after&quot; is not included in these standard advice types because
	// it is created as promise-aware advice.
	adviceTypes = [&#039;before&#039;, &#039;around&#039;, &#039;afterReturning&#039;, &#039;afterThrowing&#039;];
	adviceStep = &#039;connect:before&#039;;

    //
    // Decoration
    //

    function applyDecorator(target, Decorator, args) {
        args = args ? [target].concat(args) : [target];

        Decorator.apply(null, args);
    }

    function makeDecorator(decorator, args, wire) {
		return function(target) {
			function apply(Decorator) {
				return args
					? when(wire(args), function (resolvedArgs) {
					applyDecorator(target, Decorator, resolvedArgs);
				})
					: applyDecorator(target, Decorator);
			}

			return when(wire.resolveRef(decorator), apply);
		};
    }

    function decorateFacet(resolver, facet, wire) {
        var target, options, tasks;

        target = facet.target;
        options = facet.options;
        tasks = [];

        for(var decoratorRefName in options) {
            tasks.push(makeDecorator(decoratorRefName, options[decoratorRefName], wire));
        }

		resolver.resolve(sequence(tasks, target));
    }

	//
	// Simple advice
	//

	function addSingleAdvice(addAdviceFunc, proxy, advice, options, wire, advices) {

		function handleAopConnection(srcProxy, srcMethod, adviceHandler) {
			checkAdvisable(srcProxy.target, srcMethod);
			advices.push(addAdviceFunc(srcProxy, srcMethod, adviceHandler));
		}

		return connection.parse(proxy, advice, options, wire, handleAopConnection);
	}

	function checkAdvisable(source, method) {
		if (!(typeof method == &#039;function&#039; || typeof source[method] == &#039;function&#039;)) {
			throw new TypeError(&#039;Cannot add advice to non-method: &#039; + method);
		}
	}

	function makeSingleAdviceAdd(adviceType) {
		return function (srcProxy, sourceMethod, advice) {
			var aspect = {};
			aspect[adviceType] = advice;
			return srcProxy.advise(sourceMethod, aspect);
		};
	}

	function addAfterFulfillingAdvice(srcProxy, sourceMethod, advice) {
		return srcProxy.advise(sourceMethod, {
			afterReturning: function(promise) {
				return when(promise, advice);
			}
		});
	}

	function addAfterRejectingAdvice(srcProxy, sourceMethod, advice) {
		return srcProxy.advise(sourceMethod, {
			afterReturning: function(promise) {
				return when(promise, null, advice);
			}
		});
	}

	function addAfterPromiseAdvice(srcProxy, sourceMethod, advice) {
		return srcProxy.advise(sourceMethod, {
			after: function(promise) {
				return when(promise, advice, advice);
			}
		});
	}

	function makeAdviceFacet(advices, addAdviceFunc) {
		return function(resolver, facet, wire) {
			var advice, target, advicesToAdd, promises;

			target = facet;
			advicesToAdd = facet.options;
			promises = [];

			for(advice in advicesToAdd) {
				promises.push(addSingleAdvice(addAdviceFunc,
					target, advice, advicesToAdd[advice], wire, advices));
			}

			resolver.resolve(when.all(promises));
		};
	}

    //
    // Aspect Weaving
    //

    function applyAspectCombined(targetProxy, aspect, wire, aspects) {
        return when(wire.resolveRef(aspect), function (aspect) {
            var pointcut = aspect.pointcut;

            if (pointcut) {
                aspects.push(targetProxy.advise(pointcut, aspect));
            }

            return targetProxy;
        });
    }

    function applyAspectSeparate(targetProxy, aspect, wire, aspects) {
        var pointcut, advice;

        pointcut = aspect.pointcut;
        advice = aspect.advice;

        function applyAdvice(pointcut) {
            return when(wire.resolveRef(advice), function (aspect) {
                aspects.push(targetProxy.advise(pointcut, aspect));
                return targetProxy;
            });
        }

        return typeof pointcut === &#039;string&#039;
            ? when(wire.resolveRef(pointcut, applyAdvice))
            : applyAdvice(pointcut);
    }

    function weave(proxy, wire, options, wovenAspects) {
		// TODO: Refactor weaving to use proxy.invoke

        var target, path, aspects, applyAdvice;

        aspects = options.aspects;
        path = proxy.path;

        if (path === undef) {
            return;
        }

        target = proxy.target;
        applyAdvice = applyAspectCombined;

        // Reduce will preserve order of aspects being applied
        return when.reduce(aspects, function(proxy, aspect) {
            var aspectPath;

            if (aspect.advice) {
                aspectPath = aspect.advice;
                applyAdvice = applyAspectSeparate;
            } else {
                aspectPath = aspect;
            }

            return typeof aspectPath === &#039;string&#039; &amp;&amp; aspectPath !== path
                ? applyAdvice(proxy, aspect, wire, wovenAspects)
                : proxy;

        }, proxy);
    }

	/**
	 * Creates wire/aop plugin instances.
	 *
	 * @param options {Object} options passed to the plugin
	 */
    return function(options) {

		var plugin, aspects, makeAdvice;

		aspects = [];
		makeAdvice = makeAdviceFacet.bind(null, aspects);

		plugin = {
			context: {
				destroy: function(resolver) {
					connection.removeAll(aspects);
					resolver.resolve();
				}
			},
			facets: {
				decorate:       makeFacet(&#039;configure:after&#039;, decorateFacet),
				afterFulfilling: makeFacet(adviceStep, makeAdvice(addAfterFulfillingAdvice)),
				afterRejecting:  makeFacet(adviceStep, makeAdvice(addAfterRejectingAdvice)),
				after: makeFacet(adviceStep, makeAdvice(addAfterPromiseAdvice))
			}
		};

		if(options.aspects) {
			plugin.create = function(resolver, proxy, wire) {
				var woven = weave(proxy, wire, options, aspects);
				resolver.resolve(woven);
			};
		}

		// Add all regular single advice facets
		adviceTypes.forEach(function(adviceType) {
			plugin.facets[adviceType] = makeFacet(adviceStep,
				makeAdvice(makeSingleAdviceAdd(adviceType)));
		});

		return plugin;

		function makeFacet(step, callback) {
			var facet = {};

			facet[step] = function(resolver, proxy, wire) {
				callback(resolver, proxy, wire);
			};

			return facet;
		}

	};
});
}(typeof define == &#039;function&#039; &amp;&amp; define.amd ? define : function(factory) { module.exports = factory(require); }));</textarea>
  </div>
</div>

<footer class="footer">
  <div class="container">
    <p>.</p>
  </div>
</footer>

<script type="text/html" id="complexity-popover-template">
  <div class="complexity-notice">
    Complexity : {{ complexity.cyclomatic }} <br>
    Length : {{ complexity.halstead.length }} <br>
    Difficulty : {{ complexity.halstead.difficulty.toFixed(2) }} <br>
    Est # bugs : {{ complexity.halstead.bugs.toFixed(2) }}<br>
  </div>
</script>

<script type="text/javascript" src="../../assets/scripts/bundles/core-bundle.js"></script>
<script type="text/javascript" src="../../assets/scripts/bundles/codemirror.js"></script>
<script type="text/javascript" src="../../assets/scripts/codemirror.markpopovertext.js"></script>
<script type="text/javascript" src="report.js"></script>
<script type="text/javascript" src="report.history.js"></script>
<script type="text/javascript" src="../../assets/scripts/plato-file.js"></script>
</body>
</html>
