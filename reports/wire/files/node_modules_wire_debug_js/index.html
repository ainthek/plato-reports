<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Plato - node_modules/wire/debug.js</title>

  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="">
  <meta name="author" content="">

  <!--[if lt IE 9]>
  <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->

  <link href="../../assets/css/vendor/morris.css" rel="stylesheet">
  <link href="../../assets/css/vendor/bootstrap.css" rel="stylesheet">
  <link href="../../assets/css/vendor/font-awesome.css" rel="stylesheet">
  <link href="../../assets/css/vendor/codemirror.css" rel="stylesheet">
  <link href="../../assets/css/plato.css" rel="stylesheet">
  <link href="../../assets/css/plato-file.css" rel="stylesheet">

</head>

<body>

<div class="navbar navbar-fixed-top">
  <div class="container">
    <a class="navbar-brand" href="http://github.com/es-analysis/plato">Plato on Github</a>
    <ul class="nav navbar-nav">
      <li>
        <a href="../../index.html">Report Home</a>
      </li>
    </ul>
  </div>
</div>

<div class="jumbotron">
  <div class="container">
    <h1>node_modules/wire/debug.js</h1>
  </div>
</div>

<div class="container aggregate-stats">
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Maintainability <a href="http://blogs.msdn.com/b/codeanalysis/archive/2007/11/20/maintainability-index-range-and-meaning.aspx"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="A value between 0 and 100 that represents the relative ease of maintaining the code. A high value means better maintainability." data-original-title="Maintainability Index"  data-container="body"></i></a></h2>
      <p class="stat">66.75</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Lines of code <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h2>
      <p class="stat">482</p>
    </div>
  </div>
  <div class="row historical">
    <div class="col-md-6">
      <p id="chart_historical_maint" class="chart"></p>
    </div>
    <div class="col-md-6">
      <p id="chart_historical_sloc" class="chart"></p>
    </div>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Difficulty  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="The difficulty measure is related to the difficulty of the program to write or understand." data-original-title="Difficulty" data-container="body"></i></a></h2>
      <p class="stat">68.71</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Estimated Errors  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Halstead's delivered bugs is an estimate for the number of errors in the implementation." data-original-title="Delivered Bugs" data-container="body"></i></a></h2>
      <p class="stat">3.32</p>
    </div>
  </div>
</div>

<div class="container charts">
  <div class="row">
    <h2 class="header">Function weight</h2>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h3 class="chart-header">By Complexity <a href="http://en.wikipedia.org/wiki/Cyclomatic_complexity"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="This metric counts the number of distinct paths through a block of code. Lower values are better." data-original-title="Cyclomatic Complexity" data-container="body"></i></a></h3>
      <div id="fn-by-complexity" class="stat"></div>
    </div>
    <div class="col-md-6">
      <h3 class="chart-header">By SLOC  <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h3>
      <div id="fn-by-sloc" class="stat"></div>
    </div>
  </div>
</div>

<div class="container">
  <div class="row">
    <textarea id="file-source" class="col-md-12">/** @license MIT License (c) copyright B Cavalier &amp; J Hann */

/*jshint sub:true*/
/*global Node:true*/

/**
 * debug
 * wire plugin that logs timing and debug information about wiring context and object
 * lifecycle events (e.g. creation, properties set, initialized, etc.).
 *
 * wire is part of the cujo.js family of libraries (http://cujojs.com/)
 *
 * Licensed under the MIT License at:
 * http://www.opensource.org/licenses/mit-license.php
 *
 * Usage:
 * {
 *     module: &#039;wire/debug&#039;,
 *
 *     // verbose (Optional)
 *     // If set to true, even more (a LOT) info will be output.
 *     // Default is false if not specified.
 *     verbose: false,
 *
 *     // timeout (Optional)
 *     // Milliseconds to wait for wiring to finish before reporting
 *     // failed components.  There may be failures caused by 3rd party
 *     // wire plugins and components that wire.js cannot detect.  This
 *     // provides a last ditch way to try to report those failures.
 *     // Default is 5000ms (5 seconds)
 *     timeout: 5000,
 *
 *     // filter (Optional)
 *     // String or RegExp to match against a component&#039;s name.  Only
 *     // components whose path matches will be reported in the debug
 *     // diagnostic output.
 *     // All components will still be tracked for failures.
 *     // This can be useful in reducing the amount of diagnostic output and
 *     // focusing it on specific components.
 *     // Defaults to matching all components
 *     // Examples:
 *     //   filter: &quot;.*View&quot;
 *     //   filter: /.*View/
 *     //   filter: &quot;[fF]oo[bB]ar&quot;
 *     filter: &quot;.*&quot;
 *
 *     // trace (Optional)
 *     // Enables application component tracing that will log information about component
 *     // method calls while your application runs.  This provides a powerful way to watch
 *     // and debug your application as it runs.
 *     // To enable full tracing, which is a LOT of information:
 *     trace: true
 *     // Or, specify options to enable more focused tracing:
 *     trace: {
 *          // filter (Optional)
 *          // Similar to above, can be string pattern or RegExp
 *          // If not specified, the general debug filter is used (see above)
 *          filter: &quot;.*View&quot;,
 *
 *          // pointcut (Optional)
 *          // Matches *method names*.  Can be used with or without specifying filter
 *          // When filter is not specified, this will match methods across all components.
 *          // For example, if all your components name their event emitters &quot;on&lt;Event&gt;&quot;, e.g. &quot;onClick&quot;
 *          // you could trace all your event emitters:
 *          // Default: &quot;^[^_]&quot; (all methods not starting with &#039;_&#039;)
 *          pointcut: &quot;on.*&quot;,
 *
 *          // step (Optional)
 *          // At what step in the wiring process should tracing start.  This can be helpful
 *          // if you need to trace a component during wiring.
 *          // Values: &#039;create&#039;, &#039;configure&#039;, &#039;initialize&#039;, &#039;ready&#039;, &#039;destroy&#039;
 *          // NOTE: This defines when tracing *begins*.  For example, if this is set to
 *          // &#039;configure&#039; (the default), anything that happens to components during and
 *          // after the configure step, until that component is destroyed, will be traced.
 *          // Default: &#039;configure&#039;
 *          step: &#039;configure&#039;
 *     }
 * }
 */
(function(global, define) {
define(function(require) {
	var meld, timer, defaultTimeout, logger, createTracer, ownProp;

	meld = require(&#039;meld&#039;);

	function noop() {}

	ownProp = Object.prototype.hasOwnProperty.call.bind(Object.prototype.hasOwnProperty);

	// Setup console for node, sane browsers, or IE
	logger = typeof console != &#039;undefined&#039;
		? console
		: global[&#039;console&#039;] || { log:noop, error:noop };

	// TODO: Consider using stacktrace.js
	// https://github.com/eriwen/javascript-stacktrace
	// For now, quick and dirty, based on how stacktrace.js chooses the appropriate field
	// and log using console.error
	function logStack(e) {
		var stack = e.stack || e.stacktrace;
		if(!stack) {
			// If e.sourceURL and e.line are available, this is probably Safari, so
			// we can build a clickable source:line
			// Fallback to message if available
			// If all else fails, just use e itself
			stack = e.sourceURL &amp;&amp; e.line
				? e.sourceURL + &#039;:&#039; + e.line
				: e.message || e;
		}

		logger.error(stack);
	}

	timer = createTimer();

	// If we don&#039;t see any wiring progress in this amount of time
	// since the last time we saw something happen, then we&#039;ll log
	// an error.
	defaultTimeout = 5000;

	/**
	 * Builds a string with timing info and a message for debug output
	 *
	 * @param text {String} message
	 * @param contextTimer per-context timer information
	 *
	 * @returns A formatted string for output
	 */
	function time(text, contextTimer) {
		var all, timing;

		all = timer();
		timing = &quot;(total: &quot; +
				 (contextTimer
					 ? all.total + &quot;ms, context: &quot; + contextTimer()
					 : all)
			+ &quot;): &quot;;

		return &quot;DEBUG &quot; + timing + text;
	}

	/**
	 * Creates a timer function that, when called, returns an object containing
	 * the total elapsed time since the timer was created, and the split time
	 * since the last time the timer was called.  All times in milliseconds
	 *
	 * @returns timer
	 */
	function createTimer() {
		var start, split;

		start = new Date().getTime();
		split = start;

		/**
		 * Returns the total elapsed time since this timer was created, and the
		 * split time since this getTime was last called.
		 *
		 * @returns Object containing total and split times in milliseconds, plus a
		 * toString() function that is useful in logging the time.
		 */
		return function getTime() {
			var now, total, splitTime;

			now = new Date().getTime();
			total = now - start;
			splitTime = now - split;
			split = now;

			return {
				total:total,
				split:splitTime,
				toString:function () {
					return &#039;&#039; + splitTime + &#039;ms / &#039; + total + &#039;ms&#039;;
				}
			};
		};
	}

	function defaultFilter(path) {
		return !!path;
	}

	function createPathFilter(filter) {
		if (!filter) {
			return defaultFilter;
		}

		var rx = filter.test ? filter : new RegExp(filter);

		return function (path) {
			return rx.test(path);
		};

	}

	/**
	 * Returns true if it is a Node
	 * Adapted from: http://stackoverflow.com/questions/384286/javascript-isdom-how-do-you-check-if-a-javascript-object-is-a-dom-object
	 * @param it anything
	 * @return true iff it is a Node
	 */
	function isNode(it) {
		return typeof Node === &quot;object&quot;
			? it instanceof Node
			: it &amp;&amp; typeof it === &quot;object&quot; &amp;&amp; typeof it.nodeType === &quot;number&quot; &amp;&amp; typeof it.nodeName===&quot;string&quot;;
	}

	function isObject(it) {
		// In IE7 tos.call(null) is &#039;[object Object]&#039;
		// so we need to check to see if &#039;it&#039; is
		// even set
		return it &amp;&amp; Object.prototype.toString.call(it) == &#039;[object Object]&#039;;
	}

	/**
	 * Function that applies tracing AOP to components being wired
	 * @function
	 * @param options {Object} tracing options
	 * @param plugin {Object} debug plugin instance to which to add tracing functionality
	 */
	createTracer = (function() {
		var depth, padding, defaultStep, defaultPointcut;

		/** Current trace depth */
		depth = 0;

		/** Padding character for indenting traces */
		padding =  &#039;.&#039;;

		/** 2^8 padding = 128 */
		for(var i=0; i&lt;8; i++) {
			padding += padding;
		}

		/** Default lifecycle step at which to begin tracing */
		defaultStep = &#039;configure&#039;;

		/** Default pointcut query to match methods that will be traced */
		defaultPointcut = /^[^_]/;

		function logAfter(context, tag, start, val) {
			console.log(context + tag + (new Date().getTime() - start.getTime()) + &#039;ms): &#039;, val);
		}

		/**
		 * Creates an aspect to be applied to components that are being traced
		 * @param path {String} component path
		 */
		function createTraceAspect(path) {
			return {
				around:function (joinpoint) {
					var val, context, start, indent;

					// Setup current indent level
					indent = padding.substr(0, depth);
					// Form full path to invoked method
					context = indent + &#039;DEBUG: &#039; + path + &#039;.&#039; + joinpoint.method;

					// Increase the depth before proceeding so that nested traces will be indented
					++depth;

					logger.log(context, joinpoint.args);

					try {
						start = new Date();
						val = joinpoint.proceed();

						logAfter(context, &#039; RETURN (&#039;, start, val);

						// return result
						return val;

					} catch (e) {

						// rethrow
						logAfter(context, &#039; THROW (&#039;, start, e ? e.toString() : e);

						throw e;

					} finally {
						// And now decrease the depth after
						--depth;
					}
				}
			};
		}

		/**
		 * Implementation of createTracer
		 */
		return function(options, plugin, filter) {
			var trace, untrace, traceStep, traceFilter, tracePointcut, traceAspects;

			traceFilter = options.trace.filter ? createPathFilter(options.trace.filter) : filter;
			tracePointcut = options.trace.pointcut || defaultPointcut;
			traceStep = options.trace.step || defaultStep;

			function isTraceable(target, prop) {
				return isObject(target) &amp;&amp; typeof target[prop] === &#039;function&#039;
					&amp;&amp; prop !== &#039;wire$plugin&#039;
					&amp;&amp; tracePointcut.test(prop);
			}

			/**
			 * Trace pointcut query function that filters out wire plugins
			 * @param target {Object} target object to query for methods to advise
			 */
			function pointcut(target) {
				var matches = [];

				if(isNode(target)) {
					return matches;
				}

				for (var p in target) {
					// Only match functions, exclude wire plugins, and then apply
					// the supplied tracePointcut regexp
					if (isTraceable(target, p)) {
						matches.push(p);
					}
				}

				return matches;
			}

			traceAspects = [];
			trace = function (path, target) {
				if (traceFilter(path)) {
					// Create the aspect, if the path matched
					traceAspects.push(meld.add(target, pointcut, createTraceAspect(path)));
				}
				// trace intentionally does not resolve the promise
				// trace relies on the existing plugin method to resolve it
			};

			untrace = function () {
				for (var i = traceAspects.length-1; i &gt;= 0; --i) {
					traceAspects[i].remove();
				}
			};

			// Defend against changes to the plugin in future revs
			var orig = plugin[traceStep] || function (promise) { promise.resolve(); };

			// Replace the plugin listener method with one that will call trace()
			// and add traceAspect
			plugin[traceStep] = function (promise, proxy, wire) {
				trace(proxy.path, proxy.target);
				orig(promise, proxy, wire);
			};

			return { trace: trace, untrace: untrace };
		};

	})();

	function logSeparator() {
		logger.log(&#039;---------------------------------------------------&#039;);
	}

	return function wireDebug(options) {

		var contextTimer, timeout, paths, count, tag,
			logCreated, logDestroyed, checkPathsTimeout,
			verbose, filter, plugin, context, tracer;

		verbose = options.verbose;
		contextTimer = createTimer();

		count = 0;
		tag = &quot;WIRING&quot;;

		tracer = { trace: noop, untrace: noop };

		filter = createPathFilter(options.filter);

		function contextTime(msg) {
			return time(msg, contextTimer);
		}

		logger.log(contextTime(&quot;Context debug&quot;));

		context = {
			initialize: function(resolver) {
				logger.log(contextTime(&quot;Context init&quot;));
				resolver.resolve();
			},
			ready: function(resolver) {
				cancelPathsTimeout();
				logger.log(contextTime(&quot;Context ready&quot;));
				resolver.resolve();
			},
			destroy: function(resolver) {
				tracer.untrace();
				logger.log(contextTime(&quot;Context destroyed&quot;));
				resolver.resolve();
			},
			error: function(resolver, api, err) {
				cancelPathsTimeout();
				console.error(contextTime(&quot;Context ERROR: &quot;) + err, err);
				logStack(err);
				resolver.reject(err);
			}
		};

		function makeListener(step, verbose) {
			return function (promise, proxy /*, wire */) {
				cancelPathsTimeout();

				var path = proxy.path;

				if (paths[path]) {
					paths[path].status = step;
				}

				if (verbose &amp;&amp; filter(path)) {
					var message = time(step + &#039; &#039; + (path || proxy.id || &#039;&#039;), contextTimer);
					if (proxy.target) {
						logger.log(message, proxy.target, proxy.metadata);
					} else {
						logger.log(message, proxy);
					}
				}

				if(count) {
					checkPathsTimeout = setTimeout(checkPaths, timeout);
				}

				promise.resolve();
			};
		}

		paths = {};
		timeout = options.timeout || defaultTimeout;
		logCreated = makeListener(&#039;created&#039;, verbose);
		logDestroyed = makeListener(&#039;destroyed&#039;, true);

		function cancelPathsTimeout() {
			clearTimeout(checkPathsTimeout);
			checkPathsTimeout = null;
		}

		function checkPaths() {
			if (!checkPathsTimeout) {
				return;
			}

			var p, component, msg, ready, notReady;

			logSeparator();
			if(count) {
				ready = [];
				notReady = [];
				logger.error(tag + &#039;: No progress in &#039; + timeout + &#039;ms, status:&#039;);

				for (p in paths) {
					component = paths[p];
					msg = p + &#039;: &#039; + component.status;

					(component.status == &#039;ready&#039; ? ready : notReady).push(
						{ msg: msg, metadata: component.metadata }
					);
				}

				if(notReady.length &gt; 0) {
					logSeparator();
					logger.log(&#039;Components that DID NOT finish wiring&#039;);
					for(p = notReady.length-1; p &gt;= 0; --p) {
						component = notReady[p];
						logger.error(component.msg, component.metadata);
					}
				}

				if(ready.length &gt; 0) {
					logSeparator();
					logger.log(&#039;Components that finished wiring&#039;);
					for(p = ready.length-1; p &gt;= 0; --p) {
						component = ready[p];
						logger.log(component.msg, component.metadata);
					}
				}
			} else {
				logger.error(tag + &#039;: No components created after &#039; + timeout + &#039;ms&#039;);
			}

			logSeparator();
		}

		/**
		 * Adds a named constructor function property to the supplied component
		 * so that the name shows up in debug inspectors.  Squelches all errors.
		 */
		function makeConstructor(name, component) {
			/*jshint evil:true*/
			var ctor;
			try {
				// Generate a named function to use as the constructor
				name = name.replace(/^[^a-zA-Z$_]|[^a-zA-Z0-9$_]+/g, &#039;_&#039;);
				eval(&#039;ctor = function &#039; + name + &#039; () {}&#039;);

				// Be friendly and make configurable and writable just in case
				// some other library or application code tries to set constructor.
				Object.defineProperty(component, &#039;constructor&#039;, {
					configurable: true,
					writable: true,
					value: ctor
				});

			} catch(e) {
				// Oh well, ignore.
			}
		}

		plugin = {
			context: context,
			create:function (promise, proxy) {
				var path, component;

				path = proxy.path;
				component = proxy.target;

				count++;
				paths[path || (&#039;(unnamed-&#039; + count + &#039;)&#039;)] = {
					metadata: proxy.metadata
				};

				if(component &amp;&amp; typeof component == &#039;object&#039;
					&amp;&amp; !ownProp(component, &#039;constructor&#039;)) {
					makeConstructor(proxy.id, component);
				}

				logCreated(promise, proxy);
			},
			configure:  makeListener(&#039;configured&#039;, verbose),
			initialize: makeListener(&#039;initialized&#039;, verbose),
			ready:      makeListener(&#039;ready&#039;, true),
			destroy:    function(promise, proxy) {
				// stop tracking destroyed components, since we don&#039;t
				// care anymore
				delete paths[proxy.path];
				count--;
				tag = &quot;DESTROY&quot;;

				logDestroyed(promise, proxy);
			}
		};

		if (options.trace) {
			tracer = createTracer(options, plugin, filter);
		}

		checkPathsTimeout = setTimeout(checkPaths, timeout);

		return plugin;
	};

});
})(this, typeof define == &#039;function&#039; &amp;&amp; define.amd
	? define : function(factory) { module.exports = factory(require); }
);</textarea>
  </div>
</div>

<footer class="footer">
  <div class="container">
    <p>.</p>
  </div>
</footer>

<script type="text/html" id="complexity-popover-template">
  <div class="complexity-notice">
    Complexity : {{ complexity.cyclomatic }} <br>
    Length : {{ complexity.halstead.length }} <br>
    Difficulty : {{ complexity.halstead.difficulty.toFixed(2) }} <br>
    Est # bugs : {{ complexity.halstead.bugs.toFixed(2) }}<br>
  </div>
</script>

<script type="text/javascript" src="../../assets/scripts/bundles/core-bundle.js"></script>
<script type="text/javascript" src="../../assets/scripts/bundles/codemirror.js"></script>
<script type="text/javascript" src="../../assets/scripts/codemirror.markpopovertext.js"></script>
<script type="text/javascript" src="report.js"></script>
<script type="text/javascript" src="report.history.js"></script>
<script type="text/javascript" src="../../assets/scripts/plato-file.js"></script>
</body>
</html>
