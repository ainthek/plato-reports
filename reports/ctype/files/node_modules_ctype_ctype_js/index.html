<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Plato - node_modules/ctype/ctype.js</title>

  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="">
  <meta name="author" content="">

  <!--[if lt IE 9]>
  <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->

  <link href="../../assets/css/vendor/morris.css" rel="stylesheet">
  <link href="../../assets/css/vendor/bootstrap.css" rel="stylesheet">
  <link href="../../assets/css/vendor/font-awesome.css" rel="stylesheet">
  <link href="../../assets/css/vendor/codemirror.css" rel="stylesheet">
  <link href="../../assets/css/plato.css" rel="stylesheet">
  <link href="../../assets/css/plato-file.css" rel="stylesheet">

</head>

<body>

<div class="navbar navbar-fixed-top">
  <div class="container">
    <a class="navbar-brand" href="http://github.com/es-analysis/plato">Plato on Github</a>
    <ul class="nav navbar-nav">
      <li>
        <a href="../../index.html">Report Home</a>
      </li>
    </ul>
  </div>
</div>

<div class="jumbotron">
  <div class="container">
    <h1>node_modules/ctype/ctype.js</h1>
  </div>
</div>

<div class="container aggregate-stats">
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Maintainability <a href="http://blogs.msdn.com/b/codeanalysis/archive/2007/11/20/maintainability-index-range-and-meaning.aspx"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="A value between 0 and 100 that represents the relative ease of maintaining the code. A high value means better maintainability." data-original-title="Maintainability Index"  data-container="body"></i></a></h2>
      <p class="stat">63.72</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Lines of code <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h2>
      <p class="stat">907</p>
    </div>
  </div>
  <div class="row historical">
    <div class="col-md-6">
      <p id="chart_historical_maint" class="chart"></p>
    </div>
    <div class="col-md-6">
      <p id="chart_historical_sloc" class="chart"></p>
    </div>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Difficulty  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="The difficulty measure is related to the difficulty of the program to write or understand." data-original-title="Difficulty" data-container="body"></i></a></h2>
      <p class="stat">120.93</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Estimated Errors  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Halstead's delivered bugs is an estimate for the number of errors in the implementation." data-original-title="Delivered Bugs" data-container="body"></i></a></h2>
      <p class="stat">7.13</p>
    </div>
  </div>
</div>

<div class="container charts">
  <div class="row">
    <h2 class="header">Function weight</h2>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h3 class="chart-header">By Complexity <a href="http://en.wikipedia.org/wiki/Cyclomatic_complexity"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="This metric counts the number of distinct paths through a block of code. Lower values are better." data-original-title="Cyclomatic Complexity" data-container="body"></i></a></h3>
      <div id="fn-by-complexity" class="stat"></div>
    </div>
    <div class="col-md-6">
      <h3 class="chart-header">By SLOC  <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h3>
      <div id="fn-by-sloc" class="stat"></div>
    </div>
  </div>
</div>

<div class="container">
  <div class="row">
    <textarea id="file-source" class="col-md-12">/*
 * rm - Feb 2011
 * ctype.js
 *
 * This module provides a simple abstraction towards reading and writing
 * different types of binary data. It is designed to use ctio.js and provide a
 * richer and more expressive API on top of it.
 *
 * By default we support the following as built in basic types:
 *	int8_t
 *	int16_t
 *	int32_t
 *	uint8_t
 *	uint16_t
 *	uint32_t
 *	uint64_t
 *	float
 *	double
 *	char
 *	char[]
 *
 * Each type is returned as a Number, with the exception of char and char[]
 * which are returned as Node Buffers. A char is considered a uint8_t.
 *
 * Requests to read and write data are specified as an array of JSON objects.
 * This is also the same way that one declares structs. Even if just a single
 * value is requested, it must be done as a struct. The array order determines
 * the order that we try and read values. Each entry has the following format
 * with values marked with a * being optional.
 *
 * { key: { type: /type/, value*: /value/, offset*: /offset/ }
 *
 * If offset is defined, we lseek(offset, SEEK_SET) before reading the next
 * value. Value is defined when we&#039;re writing out data, otherwise it&#039;s ignored.
 *
 */

var mod_ctf = require(&#039;./ctf.js&#039;);
var mod_ctio = require(&#039;./ctio.js&#039;);
var mod_assert = require(&#039;assert&#039;);

/*
 * This is the set of basic types that we support.
 *
 *	read		The function to call to read in a value from a buffer
 *
 *	write		The function to call to write a value to a buffer
 *
 */
var deftypes = {
    &#039;uint8_t&#039;:  { read: ctReadUint8, write: ctWriteUint8 },
    &#039;uint16_t&#039;: { read: ctReadUint16, write: ctWriteUint16 },
    &#039;uint32_t&#039;: { read: ctReadUint32, write: ctWriteUint32 },
    &#039;uint64_t&#039;: { read: ctReadUint64, write: ctWriteUint64 },
    &#039;int8_t&#039;: { read: ctReadSint8, write: ctWriteSint8 },
    &#039;int16_t&#039;: { read: ctReadSint16, write: ctWriteSint16 },
    &#039;int32_t&#039;: { read: ctReadSint32, write: ctWriteSint32 },
    &#039;int64_t&#039;: { read: ctReadSint64, write: ctWriteSint64 },
    &#039;float&#039;: { read: ctReadFloat, write: ctWriteFloat },
    &#039;double&#039;: { read: ctReadDouble, write: ctWriteDouble },
    &#039;char&#039;: { read: ctReadChar, write: ctWriteChar },
    &#039;char[]&#039;: { read: ctReadCharArray, write: ctWriteCharArray }
};

/*
 * The following are wrappers around the CType IO low level API. They encode
 * knowledge about the size and return something in the expected format.
 */
function ctReadUint8(endian, buffer, offset)
{
	var val = mod_ctio.ruint8(buffer, endian, offset);
	return ({ value: val, size: 1 });
}

function ctReadUint16(endian, buffer, offset)
{
	var val = mod_ctio.ruint16(buffer, endian, offset);
	return ({ value: val, size: 2 });
}

function ctReadUint32(endian, buffer, offset)
{
	var val = mod_ctio.ruint32(buffer, endian, offset);
	return ({ value: val, size: 4 });
}

function ctReadUint64(endian, buffer, offset)
{
	var val = mod_ctio.ruint64(buffer, endian, offset);
	return ({ value: val, size: 8 });
}

function ctReadSint8(endian, buffer, offset)
{
	var val = mod_ctio.rsint8(buffer, endian, offset);
	return ({ value: val, size: 1 });
}

function ctReadSint16(endian, buffer, offset)
{
	var val = mod_ctio.rsint16(buffer, endian, offset);
	return ({ value: val, size: 2 });
}

function ctReadSint32(endian, buffer, offset)
{
	var val = mod_ctio.rsint32(buffer, endian, offset);
	return ({ value: val, size: 4 });
}

function ctReadSint64(endian, buffer, offset)
{
	var val = mod_ctio.rsint64(buffer, endian, offset);
	return ({ value: val, size: 8 });
}

function ctReadFloat(endian, buffer, offset)
{
	var val = mod_ctio.rfloat(buffer, endian, offset);
	return ({ value: val, size: 4 });
}

function ctReadDouble(endian, buffer, offset)
{
	var val = mod_ctio.rdouble(buffer, endian, offset);
	return ({ value: val, size: 8 });
}

/*
 * Reads a single character into a node buffer
 */
function ctReadChar(endian, buffer, offset)
{
	var res = new Buffer(1);
	res[0] = mod_ctio.ruint8(buffer, endian, offset);
	return ({ value: res, size: 1 });
}

function ctReadCharArray(length, endian, buffer, offset)
{
	var ii;
	var res = new Buffer(length);

	for (ii = 0; ii &lt; length; ii++)
		res[ii] = mod_ctio.ruint8(buffer, endian, offset + ii);

	return ({ value: res, size: length });
}

function ctWriteUint8(value, endian, buffer, offset)
{
	mod_ctio.wuint8(value, endian, buffer, offset);
	return (1);
}

function ctWriteUint16(value, endian, buffer, offset)
{
	mod_ctio.wuint16(value, endian, buffer, offset);
	return (2);
}

function ctWriteUint32(value, endian, buffer, offset)
{
	mod_ctio.wuint32(value, endian, buffer, offset);
	return (4);
}

function ctWriteUint64(value, endian, buffer, offset)
{
	mod_ctio.wuint64(value, endian, buffer, offset);
	return (8);
}

function ctWriteSint8(value, endian, buffer, offset)
{
	mod_ctio.wsint8(value, endian, buffer, offset);
	return (1);
}

function ctWriteSint16(value, endian, buffer, offset)
{
	mod_ctio.wsint16(value, endian, buffer, offset);
	return (2);
}

function ctWriteSint32(value, endian, buffer, offset)
{
	mod_ctio.wsint32(value, endian, buffer, offset);
	return (4);
}

function ctWriteSint64(value, endian, buffer, offset)
{
	mod_ctio.wsint64(value, endian, buffer, offset);
	return (8);
}

function ctWriteFloat(value, endian, buffer, offset)
{
	mod_ctio.wfloat(value, endian, buffer, offset);
	return (4);
}

function ctWriteDouble(value, endian, buffer, offset)
{
	mod_ctio.wdouble(value, endian, buffer, offset);
	return (8);
}

/*
 * Writes a single character into a node buffer
 */
function ctWriteChar(value, endian, buffer, offset)
{
	if (!(value instanceof Buffer))
		throw (new Error(&#039;Input must be a buffer&#039;));

	mod_ctio.ruint8(value[0], endian, buffer, offset);
	return (1);
}

/*
 * We&#039;re going to write 0s into the buffer if the string is shorter than the
 * length of the array.
 */
function ctWriteCharArray(value, length, endian, buffer, offset)
{
	var ii;

	if (!(value instanceof Buffer))
		throw (new Error(&#039;Input must be a buffer&#039;));

	if (value.length &gt; length)
		throw (new Error(&#039;value length greater than array length&#039;));

	for (ii = 0; ii &lt; value.length &amp;&amp; ii &lt; length; ii++)
		mod_ctio.wuint8(value[ii], endian, buffer, offset + ii);

	for (; ii &lt; length; ii++)
		mod_ctio.wuint8(0, endian, offset + ii);


	return (length);
}

/*
 * Each parser has their own set of types. We want to make sure that they each
 * get their own copy as they may need to modify it.
 */
function ctGetBasicTypes()
{
	var ret = {};
	var key;
	for (key in deftypes)
		ret[key] = deftypes[key];

	return (ret);
}

/*
 * Given a string in the form of type[length] we want to split this into an
 * object that extracts that information. We want to note that we could possibly
 * have nested arrays so this should only check the furthest one. It may also be
 * the case that we have no [] pieces, in which case we just return the current
 * type.
 */
function ctParseType(str)
{
	var begInd, endInd;
	var type, len;
	if (typeof (str) != &#039;string&#039;)
		throw (new Error(&#039;type must be a Javascript string&#039;));

	endInd = str.lastIndexOf(&#039;]&#039;);
	if (endInd == -1) {
		if (str.lastIndexOf(&#039;[&#039;) != -1)
			throw (new Error(&#039;found invalid type with \&#039;[\&#039; but &#039; +
			    &#039;no corresponding \&#039;]\&#039;&#039;));

		return ({ type: str });
	}

	begInd = str.lastIndexOf(&#039;[&#039;);
	if (begInd == -1)
		throw (new Error(&#039;found invalid type with \&#039;]\&#039; but &#039; +
		    &#039;no corresponding \&#039;[\&#039;&#039;));

	if (begInd &gt;= endInd)
		throw (new Error(&#039;malformed type, \&#039;]\&#039; appears before \&#039;[\&#039;&#039;));

	type = str.substring(0, begInd);
	len = str.substring(begInd + 1, endInd);

	return ({ type: type, len: len });
}

/*
 * Given a request validate that all of the fields for it are valid and make
 * sense. This includes verifying the following notions:
 *  - Each type requested is present in types
 *  - Only allow a name for a field to be specified once
 *  - If an array is specified, validate that the requested field exists and
 *    comes before it.
 *  - If fields is defined, check that each entry has the occurrence of field
 */
function ctCheckReq(def, types, fields)
{
	var ii, jj;
	var req, keys, key;
	var found = {};

	if (!(def instanceof Array))
		throw (new Error(&#039;definition is not an array&#039;));

	if (def.length === 0)
		throw (new Error(&#039;definition must have at least one element&#039;));

	for (ii = 0; ii &lt; def.length; ii++) {
		req = def[ii];
		if (!(req instanceof Object))
			throw (new Error(&#039;definition must be an array of&#039; +
			    &#039;objects&#039;));

		keys = Object.keys(req);
		if (keys.length != 1)
			throw (new Error(&#039;definition entry must only have &#039; +
			    &#039;one key&#039;));

		if (keys[0] in found)
			throw (new Error(&#039;Specified name already &#039; +
			    &#039;specified: &#039; + keys[0]));

		if (!(&#039;type&#039; in req[keys[0]]))
			throw (new Error(&#039;missing required type definition&#039;));

		key = ctParseType(req[keys[0]][&#039;type&#039;]);

		/*
		 * We may have nested arrays, we need to check the validity of
		 * the types until the len field is undefined in key. However,
		 * each time len is defined we need to verify it is either an
		 * integer or corresponds to an already seen key.
		 */
		while (key[&#039;len&#039;] !== undefined) {
			if (isNaN(parseInt(key[&#039;len&#039;], 10))) {
				if (!(key[&#039;len&#039;] in found))
					throw (new Error(&#039;Given an array &#039; +
					    &#039;length without a matching type&#039;));

			}

			key = ctParseType(key[&#039;type&#039;]);
		}

		/* Now we can validate if the type is valid */
		if (!(key[&#039;type&#039;] in types))
			throw (new Error(&#039;type not found or typdefed: &#039; +
			    key[&#039;type&#039;]));

		/* Check for any required fields */
		if (fields !== undefined) {
			for (jj = 0; jj &lt; fields.length; jj++) {
				if (!(fields[jj] in req[keys[0]]))
					throw (new Error(&#039;Missing required &#039; +
					    &#039;field: &#039; + fields[jj]));
			}
		}

		found[keys[0]] = true;
	}
}


/*
 * Create a new instance of the parser. Each parser has its own store of
 * typedefs and endianness. Conf is an object with the following required
 * values:
 *
 *	endian		Either &#039;big&#039; or &#039;little&#039; do determine the endianness we
 *			want to read from or write to.
 *
 * And the following optional values:
 *
 * 	char-type	Valid options here are uint8 and int8. If uint8 is
 * 			specified this changes the default behavior of a single
 * 			char from being a buffer of a single character to being
 * 			a uint8_t. If int8, it becomes an int8_t instead.
 */
function CTypeParser(conf)
{
	if (!conf) throw (new Error(&#039;missing required argument&#039;));

	if (!(&#039;endian&#039; in conf))
		throw (new Error(&#039;missing required endian value&#039;));

	if (conf[&#039;endian&#039;] != &#039;big&#039; &amp;&amp; conf[&#039;endian&#039;] != &#039;little&#039;)
		throw (new Error(&#039;Invalid endian type&#039;));

	if (&#039;char-type&#039; in conf &amp;&amp; (conf[&#039;char-type&#039;] != &#039;uint8&#039; &amp;&amp;
	    conf[&#039;char-type&#039;] != &#039;int8&#039;))
		throw (new Error(&#039;invalid option for char-type: &#039; +
		    conf[&#039;char-type&#039;]));

	this.endian = conf[&#039;endian&#039;];
	this.types = ctGetBasicTypes();

	/*
	 * There may be a more graceful way to do this, but this will have to
	 * serve.
	 */
	if (&#039;char-type&#039; in conf &amp;&amp; conf[&#039;char-type&#039;] == &#039;uint8&#039;)
		this.types[&#039;char&#039;] = this.types[&#039;uint8_t&#039;];

	if (&#039;char-type&#039; in conf &amp;&amp; conf[&#039;char-type&#039;] == &#039;int8&#039;)
		this.types[&#039;char&#039;] = this.types[&#039;int8_t&#039;];
}

/*
 * Sets the current endian value for the Parser. If the value is not valid,
 * throws an Error.
 *
 *	endian		Either &#039;big&#039; or &#039;little&#039; do determine the endianness we
 *			want to read from or write to.
 *
 */
CTypeParser.prototype.setEndian = function (endian)
{
	if (endian != &#039;big&#039; &amp;&amp; endian != &#039;little&#039;)
		throw (new Error(&#039;invalid endian type, must be big or &#039; +
		    &#039;little&#039;));

	this.endian = endian;
};

/*
 * Returns the current value of the endian value for the parser.
 */
CTypeParser.prototype.getEndian = function ()
{
	return (this.endian);
};

/*
 * A user has requested to add a type, let us honor their request. Yet, if their
 * request doth spurn us, send them unto the Hells which Dante describes.
 *
 * 	name		The string for the type definition we&#039;re adding
 *
 *	value		Either a string that is a type/array name or an object
 *			that describes a struct.
 */
CTypeParser.prototype.typedef = function (name, value)
{
	var type;

	if (name === undefined)
		throw (new (Error(&#039;missing required typedef argument: name&#039;)));

	if (value === undefined)
		throw (new (Error(&#039;missing required typedef argument: value&#039;)));

	if (typeof (name) != &#039;string&#039;)
		throw (new (Error(&#039;the name of a type must be a string&#039;)));

	type = ctParseType(name);

	if (type[&#039;len&#039;] !== undefined)
		throw (new Error(&#039;Cannot have an array in the typedef name&#039;));

	if (name in this.types)
		throw (new Error(&#039;typedef name already present: &#039; + name));

	if (typeof (value) != &#039;string&#039; &amp;&amp; !(value instanceof Array))
		throw (new Error(&#039;typedef value must either be a string or &#039; +
		    &#039;struct&#039;));

	if (typeof (value) == &#039;string&#039;) {
		type = ctParseType(value);
		if (type[&#039;len&#039;] !== undefined) {
			if (isNaN(parseInt(type[&#039;len&#039;], 10)))
				throw (new (Error(&#039;typedef value must use &#039; +
				    &#039;fixed size array when outside of a &#039; +
				    &#039;struct&#039;)));
		}

		this.types[name] = value;
	} else {
		/* We have a struct, validate it */
		ctCheckReq(value, this.types);
		this.types[name] = value;
	}
};

/*
 * Include all of the typedefs, but none of the built in types. This should be
 * treated as read-only.
 */
CTypeParser.prototype.lstypes = function ()
{
	var key;
	var ret = {};

	for (key in this.types) {
		if (key in deftypes)
			continue;
		ret[key] = this.types[key];
	}

	return (ret);
};

/*
 * Given a type string that may have array types that aren&#039;t numbers, try and
 * fill them in from the values object. The object should be of the format where
 * indexing into it should return a number for that type.
 *
 *	str		The type string
 *
 *	values		An object that can be used to fulfill type information
 */
function ctResolveArray(str, values)
{
	var ret = &#039;&#039;;
	var type = ctParseType(str);

	while (type[&#039;len&#039;] !== undefined) {
		if (isNaN(parseInt(type[&#039;len&#039;], 10))) {
			if (typeof (values[type[&#039;len&#039;]]) != &#039;number&#039;)
				throw (new Error(&#039;cannot sawp in non-number &#039; +
				    &#039;for array value&#039;));
			ret = &#039;[&#039; + values[type[&#039;len&#039;]] + &#039;]&#039; + ret;
		} else {
			ret = &#039;[&#039; + type[&#039;len&#039;] + &#039;]&#039; + ret;
		}
		type = ctParseType(type[&#039;type&#039;]);
	}

	ret = type[&#039;type&#039;] + ret;

	return (ret);
}

/*
 * [private] Either the typedef resolves to another type string or to a struct.
 * If it resolves to a struct, we just pass it off to read struct. If not, we
 * can just pass it off to read entry.
 */
CTypeParser.prototype.resolveTypedef = function (type, dispatch, buffer,
    offset, value)
{
	var pt;

	mod_assert.ok(type in this.types);
	if (typeof (this.types[type]) == &#039;string&#039;) {
		pt = ctParseType(this.types[type]);
		if (dispatch == &#039;read&#039;)
			return (this.readEntry(pt, buffer, offset));
		else if (dispatch == &#039;write&#039;)
			return (this.writeEntry(value, pt, buffer, offset));
		else
			throw (new Error(&#039;invalid dispatch type to &#039; +
			    &#039;resolveTypedef&#039;));
	} else {
		if (dispatch == &#039;read&#039;)
			return (this.readStruct(this.types[type], buffer,
			    offset));
		else if (dispatch == &#039;write&#039;)
			return (this.writeStruct(value, this.types[type],
			    buffer, offset));
		else
			throw (new Error(&#039;invalid dispatch type to &#039; +
			    &#039;resolveTypedef&#039;));
	}

};

/*
 * [private] Try and read in the specific entry.
 */
CTypeParser.prototype.readEntry = function (type, buffer, offset)
{
	var parse, len;

	/*
	 * Because we want to special case char[]s this is unfortunately
	 * a bit uglier than it really should be. We want to special
	 * case char[]s so that we return a node buffer, thus they are a
	 * first class type where as all other arrays just call into a
	 * generic array routine which calls their data-specific routine
	 * the specified number of times.
	 *
	 * The valid dispatch options we have are:
	 *  - Array and char =&gt; char[] handler
	 *  - Generic array handler
	 *  - Generic typedef handler
	 *  - Basic type handler
	 */
	if (type[&#039;len&#039;] !== undefined) {
		len = parseInt(type[&#039;len&#039;], 10);
		if (isNaN(len))
			throw (new Error(&#039;somehow got a non-numeric length&#039;));

		if (type[&#039;type&#039;] == &#039;char&#039;)
			parse = this.types[&#039;char[]&#039;][&#039;read&#039;](len,
			    this.endian, buffer, offset);
		else
			parse = this.readArray(type[&#039;type&#039;],
			    len, buffer, offset);
	} else {
		if (type[&#039;type&#039;] in deftypes)
			parse = this.types[type[&#039;type&#039;]][&#039;read&#039;](this.endian,
			    buffer, offset);
		else
			parse = this.resolveTypedef(type[&#039;type&#039;], &#039;read&#039;,
			    buffer, offset);
	}

	return (parse);
};

/*
 * [private] Read an array of data
 */
CTypeParser.prototype.readArray = function (type, length, buffer, offset)
{
	var ii, ent, pt;
	var baseOffset = offset;
	var ret = new Array(length);
	pt = ctParseType(type);

	for (ii = 0; ii &lt; length; ii++) {
		ent = this.readEntry(pt, buffer, offset);
		offset += ent[&#039;size&#039;];
		ret[ii] = ent[&#039;value&#039;];
	}

	return ({ value: ret, size: offset - baseOffset });
};

/*
 * [private] Read a single struct in.
 */
CTypeParser.prototype.readStruct = function (def, buffer, offset)
{
	var parse, ii, type, entry, key;
	var baseOffset = offset;
	var ret = {};

	/* Walk it and handle doing what&#039;s necessary */
	for (ii = 0; ii &lt; def.length; ii++) {
		key = Object.keys(def[ii])[0];
		entry = def[ii][key];

		/* Resolve all array values */
		type = ctParseType(ctResolveArray(entry[&#039;type&#039;], ret));

		if (&#039;offset&#039; in entry)
			offset = baseOffset + entry[&#039;offset&#039;];

		parse = this.readEntry(type, buffer, offset);

		offset += parse[&#039;size&#039;];
		ret[key] = parse[&#039;value&#039;];
	}

	return ({ value: ret, size: (offset-baseOffset)});
};

/*
 * This is what we were born to do. We read the data from a buffer and return it
 * in an object whose keys match the values from the object.
 *
 *	def		The array definition of the data to read in
 *
 *	buffer		The buffer to read data from
 *
 *	offset		The offset to start writing to
 *
 * Returns an object where each key corresponds to an entry in def and the value
 * is the read value.
 */
CTypeParser.prototype.readData = function (def, buffer, offset)
{
	/* Sanity check for arguments */
	if (def === undefined)
		throw (new Error(&#039;missing definition for what we should be&#039; +
		    &#039;parsing&#039;));

	if (buffer === undefined)
		throw (new Error(&#039;missing buffer for what we should be &#039; +
		    &#039;parsing&#039;));

	if (offset === undefined)
		throw (new Error(&#039;missing offset for what we should be &#039; +
		    &#039;parsing&#039;));

	/* Sanity check the object definition */
	ctCheckReq(def, this.types);

	return (this.readStruct(def, buffer, offset)[&#039;value&#039;]);
};

/*
 * [private] Write out an array of data
 */
CTypeParser.prototype.writeArray = function (value, type, length, buffer,
    offset)
{
	var ii, pt;
	var baseOffset = offset;
	if (!(value instanceof Array))
		throw (new Error(&#039;asked to write an array, but value is not &#039; +
		    &#039;an array&#039;));

	if (value.length != length)
		throw (new Error(&#039;asked to write array of length &#039; + length +
		    &#039; but that does not match value length: &#039; + value.length));

	pt = ctParseType(type);
	for (ii = 0; ii &lt; length; ii++)
		offset += this.writeEntry(value[ii], pt, buffer, offset);

	return (offset - baseOffset);
};

/*
 * [private] Write the specific entry
 */
CTypeParser.prototype.writeEntry = function (value, type, buffer, offset)
{
	var len, ret;

	if (type[&#039;len&#039;] !== undefined) {
		len = parseInt(type[&#039;len&#039;], 10);
		if (isNaN(len))
			throw (new Error(&#039;somehow got a non-numeric length&#039;));

		if (type[&#039;type&#039;] == &#039;char&#039;)
			ret = this.types[&#039;char[]&#039;][&#039;write&#039;](value, len,
			    this.endian, buffer, offset);
		else
			ret = this.writeArray(value, type[&#039;type&#039;],
			    len, buffer, offset);
	} else {
		if (type[&#039;type&#039;] in deftypes)
			ret = this.types[type[&#039;type&#039;]][&#039;write&#039;](value,
			    this.endian, buffer, offset);
		else
			ret = this.resolveTypedef(type[&#039;type&#039;], &#039;write&#039;,
			    buffer, offset, value);
	}

	return (ret);
};

/*
 * [private] Write a single struct out.
 */
CTypeParser.prototype.writeStruct = function (value, def, buffer, offset)
{
	var ii, entry, type, key;
	var baseOffset = offset;
	var vals = {};

	for (ii = 0; ii &lt; def.length; ii++) {
		key = Object.keys(def[ii])[0];
		entry = def[ii][key];

		type = ctParseType(ctResolveArray(entry[&#039;type&#039;], vals));

		if (&#039;offset&#039; in entry)
			offset = baseOffset + entry[&#039;offset&#039;];

		offset += this.writeEntry(value[ii], type, buffer, offset);
		/* Now that we&#039;ve written it out, we can use it for arrays */
		vals[key] = value[ii];
	}

	return (offset);
};

/*
 * Unfortunately, we&#039;re stuck with the sins of an initial poor design. Because
 * of that, we are going to have to support the old way of writing data via
 * writeData. There we insert the values that you want to write into the
 * definition. A little baroque. Internally, we use the new model. So we need to
 * just get those values out of there. But to maintain the principle of least
 * surprise, we&#039;re not going to modify the input data.
 */
function getValues(def)
{
	var ii, out, key;
	out = [];
	for (ii = 0; ii &lt; def.length; ii++) {
		key = Object.keys(def[ii])[0];
		mod_assert.ok(&#039;value&#039; in def[ii][key]);
		out.push(def[ii][key][&#039;value&#039;]);
	}

	return (out);
}

/*
 * This is the second half of what we were born to do, write out the data
 * itself. Historically this function required you to put your values in the
 * definition section. This was not the smartest thing to do and a bit of an
 * oversight to be honest. As such, this function now takes a values argument.
 * If values is non-null and non-undefined, it will be used to determine the
 * values. This means that the old method is still supported, but is no longer
 * acceptable.
 *
 *	def		The array definition of the data to write out with
 *			values
 *
 *	buffer		The buffer to write to
 *
 *	offset		The offset in the buffer to write to
 *
 *	values		An array of values to write.
 */
CTypeParser.prototype.writeData = function (def, buffer, offset, values)
{
	var hv;

	if (def === undefined)
		throw (new Error(&#039;missing definition for what we should be&#039; +
		    &#039;parsing&#039;));

	if (buffer === undefined)
		throw (new Error(&#039;missing buffer for what we should be &#039; +
		    &#039;parsing&#039;));

	if (offset === undefined)
		throw (new Error(&#039;missing offset for what we should be &#039; +
		    &#039;parsing&#039;));

	hv = (values != null &amp;&amp; values != undefined);
	if (hv) {
		if (!Array.isArray(values))
			throw (new Error(&#039;missing values for writing&#039;));
		ctCheckReq(def, this.types);
	} else {
		ctCheckReq(def, this.types, [ &#039;value&#039; ]);
	}

	this.writeStruct(hv ? values : getValues(def), def, buffer, offset);
};

/*
 * Functions to go to and from 64 bit numbers in a way that is compatible with
 * Javascript limitations. There are two sets. One where the user is okay with
 * an approximation and one where they are definitely not okay with an
 * approximation.
 */

/*
 * Attempts to convert an array of two integers returned from rsint64 / ruint64
 * into an absolute 64 bit number. If however the value would exceed 2^52 this
 * will instead throw an error. The mantissa in a double is a 52 bit number and
 * rather than potentially give you a value that is an approximation this will
 * error. If you would rather an approximation, please see toApprox64.
 *
 *	val		An array of two 32-bit integers
 */
function toAbs64(val)
{
	if (val === undefined)
		throw (new Error(&#039;missing required arg: value&#039;));

	if (!Array.isArray(val))
		throw (new Error(&#039;value must be an array&#039;));

	if (val.length != 2)
		throw (new Error(&#039;value must be an array of length 2&#039;));

	/* We have 20 bits worth of precision in this range */
	if (val[0] &gt;= 0x100000)
		throw (new Error(&#039;value would become approximated&#039;));

	return (val[0] * Math.pow(2, 32) + val[1]);
}

/*
 * Will return the 64 bit value as returned in an array from rsint64 / ruint64
 * to a value as close as it can. Note that Javascript stores all numbers as a
 * double and the mantissa only has 52 bits. Thus this version may approximate
 * the value.
 *
 *	val		An array of two 32-bit integers
 */
function toApprox64(val)
{
	if (val === undefined)
		throw (new Error(&#039;missing required arg: value&#039;));

	if (!Array.isArray(val))
		throw (new Error(&#039;value must be an array&#039;));

	if (val.length != 2)
		throw (new Error(&#039;value must be an array of length 2&#039;));

	return (Math.pow(2, 32) * val[0] + val[1]);
}

function parseCTF(json, conf)
{
	var ctype = new CTypeParser(conf);
	mod_ctf.ctfParseJson(json, ctype);

	return (ctype);
}

/*
 * Export the few things we actually want to. Currently this is just the CType
 * Parser and ctio.
 */
exports.Parser = CTypeParser;
exports.toAbs64 = toAbs64;
exports.toApprox64 = toApprox64;

exports.parseCTF = parseCTF;

exports.ruint8 = mod_ctio.ruint8;
exports.ruint16 = mod_ctio.ruint16;
exports.ruint32 = mod_ctio.ruint32;
exports.ruint64 = mod_ctio.ruint64;
exports.wuint8 = mod_ctio.wuint8;
exports.wuint16 = mod_ctio.wuint16;
exports.wuint32 = mod_ctio.wuint32;
exports.wuint64 = mod_ctio.wuint64;

exports.rsint8 = mod_ctio.rsint8;
exports.rsint16 = mod_ctio.rsint16;
exports.rsint32 = mod_ctio.rsint32;
exports.rsint64 = mod_ctio.rsint64;
exports.wsint8 = mod_ctio.wsint8;
exports.wsint16 = mod_ctio.wsint16;
exports.wsint32 = mod_ctio.wsint32;
exports.wsint64 = mod_ctio.wsint64;

exports.rfloat = mod_ctio.rfloat;
exports.rdouble = mod_ctio.rdouble;
exports.wfloat = mod_ctio.wfloat;
exports.wdouble = mod_ctio.wdouble;</textarea>
  </div>
</div>

<footer class="footer">
  <div class="container">
    <p>.</p>
  </div>
</footer>

<script type="text/html" id="complexity-popover-template">
  <div class="complexity-notice">
    Complexity : {{ complexity.cyclomatic }} <br>
    Length : {{ complexity.halstead.length }} <br>
    Difficulty : {{ complexity.halstead.difficulty.toFixed(2) }} <br>
    Est # bugs : {{ complexity.halstead.bugs.toFixed(2) }}<br>
  </div>
</script>

<script type="text/javascript" src="../../assets/scripts/bundles/core-bundle.js"></script>
<script type="text/javascript" src="../../assets/scripts/bundles/codemirror.js"></script>
<script type="text/javascript" src="../../assets/scripts/codemirror.markpopovertext.js"></script>
<script type="text/javascript" src="report.js"></script>
<script type="text/javascript" src="report.history.js"></script>
<script type="text/javascript" src="../../assets/scripts/plato-file.js"></script>
</body>
</html>
