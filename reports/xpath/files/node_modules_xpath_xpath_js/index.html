<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Plato - node_modules/xpath/xpath.js</title>

  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="">
  <meta name="author" content="">

  <!--[if lt IE 9]>
  <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->

  <link href="../../assets/css/vendor/morris.css" rel="stylesheet">
  <link href="../../assets/css/vendor/bootstrap.css" rel="stylesheet">
  <link href="../../assets/css/vendor/font-awesome.css" rel="stylesheet">
  <link href="../../assets/css/vendor/codemirror.css" rel="stylesheet">
  <link href="../../assets/css/plato.css" rel="stylesheet">
  <link href="../../assets/css/plato-file.css" rel="stylesheet">

</head>

<body>

<div class="navbar navbar-fixed-top">
  <div class="container">
    <a class="navbar-brand" href="http://github.com/es-analysis/plato">Plato on Github</a>
    <ul class="nav navbar-nav">
      <li>
        <a href="../../index.html">Report Home</a>
      </li>
    </ul>
  </div>
</div>

<div class="jumbotron">
  <div class="container">
    <h1>node_modules/xpath/xpath.js</h1>
  </div>
</div>

<div class="container aggregate-stats">
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Maintainability <a href="http://blogs.msdn.com/b/codeanalysis/archive/2007/11/20/maintainability-index-range-and-meaning.aspx"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="A value between 0 and 100 that represents the relative ease of maintaining the code. A high value means better maintainability." data-original-title="Maintainability Index"  data-container="body"></i></a></h2>
      <p class="stat">62.38</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Lines of code <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h2>
      <p class="stat">4235</p>
    </div>
  </div>
  <div class="row historical">
    <div class="col-md-6">
      <p id="chart_historical_maint" class="chart"></p>
    </div>
    <div class="col-md-6">
      <p id="chart_historical_sloc" class="chart"></p>
    </div>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Difficulty  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="The difficulty measure is related to the difficulty of the program to write or understand." data-original-title="Difficulty" data-container="body"></i></a></h2>
      <p class="stat">166.49</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Estimated Errors  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Halstead's delivered bugs is an estimate for the number of errors in the implementation." data-original-title="Delivered Bugs" data-container="body"></i></a></h2>
      <p class="stat">65.34</p>
    </div>
  </div>
</div>

<div class="container charts">
  <div class="row">
    <h2 class="header">Function weight</h2>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h3 class="chart-header">By Complexity <a href="http://en.wikipedia.org/wiki/Cyclomatic_complexity"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="This metric counts the number of distinct paths through a block of code. Lower values are better." data-original-title="Cyclomatic Complexity" data-container="body"></i></a></h3>
      <div id="fn-by-complexity" class="stat"></div>
    </div>
    <div class="col-md-6">
      <h3 class="chart-header">By SLOC  <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h3>
      <div id="fn-by-sloc" class="stat"></div>
    </div>
  </div>
</div>

<div class="container">
  <div class="row">
    <textarea id="file-source" class="col-md-12">/*
 * xpath.js
 *
 * An XPath 1.0 library for JavaScript.
 *
 * Cameron McCormack &lt;cam (at) mcc.id.au&gt;
 *
 * This work is licensed under the Creative Commons Attribution-ShareAlike
 * License. To view a copy of this license, visit
 *
 *   http://creativecommons.org/licenses/by-sa/2.0/
 *
 * or send a letter to Creative Commons, 559 Nathan Abbott Way, Stanford,
 * California 94305, USA.
 *
 * Revision 20: April 26, 2011
 *   Fixed a typo resulting in FIRST_ORDERED_NODE_TYPE results being wrong,
 *   thanks to &lt;shi_a009 (at) hotmail.com&gt;.
 *
 * Revision 19: November 29, 2005
 *   Nodesets now store their nodes in a height balanced tree, increasing
 *   performance for the common case of selecting nodes in document order,
 *   thanks to S閎astien Cramatte &lt;contact (at) zeninteractif.com&gt;.
 *   AVL tree code adapted from Raimund Neumann &lt;rnova (at) gmx.net&gt;.
 *
 * Revision 18: October 27, 2005
 *   DOM 3 XPath support.  Caveats:
 *     - namespace prefixes aren&#039;t resolved in XPathEvaluator.createExpression,
 *       but in XPathExpression.evaluate.
 *     - XPathResult.invalidIteratorState is not implemented.
 *
 * Revision 17: October 25, 2005
 *   Some core XPath function fixes and a patch to avoid crashing certain
 *   versions of MSXML in PathExpr.prototype.getOwnerElement, thanks to
 *   S閎astien Cramatte &lt;contact (at) zeninteractif.com&gt;.
 *
 * Revision 16: September 22, 2005
 *   Workarounds for some IE 5.5 deficiencies.
 *   Fixed problem with prefix node tests on attribute nodes.
 *
 * Revision 15: May 21, 2005
 *   Fixed problem with QName node tests on elements with an xmlns=&quot;...&quot;.
 *
 * Revision 14: May 19, 2005
 *   Fixed QName node tests on attribute node regression.
 *
 * Revision 13: May 3, 2005
 *   Node tests are case insensitive now if working in an HTML DOM.
 *
 * Revision 12: April 26, 2005
 *   Updated licence.  Slight code changes to enable use of Dean
 *   Edwards&#039; script compression, http://dean.edwards.name/packer/ .
 *
 * Revision 11: April 23, 2005
 *   Fixed bug with &#039;and&#039; and &#039;or&#039; operators, fix thanks to
 *   Sandy McArthur &lt;sandy (at) mcarthur.org&gt;.
 *
 * Revision 10: April 15, 2005
 *   Added support for a virtual root node, supposedly helpful for
 *   implementing XForms.  Fixed problem with QName node tests and
 *   the parent axis.
 *
 * Revision 9: March 17, 2005
 *   Namespace resolver tweaked so using the document node as the context
 *   for namespace lookups is equivalent to using the document element.
 *
 * Revision 8: February 13, 2005
 *   Handle implicit declaration of &#039;xmlns&#039; namespace prefix.
 *   Fixed bug when comparing nodesets.
 *   Instance data can now be associated with a FunctionResolver, and
 *     workaround for MSXML not supporting &#039;localName&#039; and &#039;getElementById&#039;,
 *     thanks to Grant Gongaware.
 *   Fix a few problems when the context node is the root node.
 *
 * Revision 7: February 11, 2005
 *   Default namespace resolver fix from Grant Gongaware
 *   &lt;grant (at) gongaware.com&gt;.
 *
 * Revision 6: February 10, 2005
 *   Fixed bug in &#039;number&#039; function.
 *
 * Revision 5: February 9, 2005
 *   Fixed bug where text nodes not getting converted to string values.
 *
 * Revision 4: January 21, 2005
 *   Bug in &#039;name&#039; function, fix thanks to Bill Edney.
 *   Fixed incorrect processing of namespace nodes.
 *   Fixed NamespaceResolver to resolve &#039;xml&#039; namespace.
 *   Implemented union &#039;|&#039; operator.
 *
 * Revision 3: January 14, 2005
 *   Fixed bug with nodeset comparisons, bug lexing &lt; and &gt;.
 *
 * Revision 2: October 26, 2004
 *   QName node test namespace handling fixed.  Few other bug fixes.
 *
 * Revision 1: August 13, 2004
 *   Bug fixes from William J. Edney &lt;bedney (at) technicalpursuit.com&gt;.
 *   Added minimal licence.
 *
 * Initial version: June 14, 2004
 */

// non-node wrapper
if(typeof exports === &#039;undefined&#039; ) {
	xpath = {};
}
(function(exports) {
	
// XPathParser ///////////////////////////////////////////////////////////////

XPathParser.prototype = new Object();
XPathParser.prototype.constructor = XPathParser;
XPathParser.superclass = Object.prototype;

function XPathParser() {
	this.init();
}

XPathParser.prototype.init = function() {
	this.reduceActions = [];

	this.reduceActions[3] = function(rhs) {
		return new OrOperation(rhs[0], rhs[2]);
	};
	this.reduceActions[5] = function(rhs) {
		return new AndOperation(rhs[0], rhs[2]);
	};
	this.reduceActions[7] = function(rhs) {
		return new EqualsOperation(rhs[0], rhs[2]);
	};
	this.reduceActions[8] = function(rhs) {
		return new NotEqualOperation(rhs[0], rhs[2]);
	};
	this.reduceActions[10] = function(rhs) {
		return new LessThanOperation(rhs[0], rhs[2]);
	};
	this.reduceActions[11] = function(rhs) {
		return new GreaterThanOperation(rhs[0], rhs[2]);
	};
	this.reduceActions[12] = function(rhs) {
		return new LessThanOrEqualOperation(rhs[0], rhs[2]);
	};
	this.reduceActions[13] = function(rhs) {
		return new GreaterThanOrEqualOperation(rhs[0], rhs[2]);
	};
	this.reduceActions[15] = function(rhs) {
		return new PlusOperation(rhs[0], rhs[2]);
	};
	this.reduceActions[16] = function(rhs) {
		return new MinusOperation(rhs[0], rhs[2]);
	};
	this.reduceActions[18] = function(rhs) {
		return new MultiplyOperation(rhs[0], rhs[2]);
	};
	this.reduceActions[19] = function(rhs) {
		return new DivOperation(rhs[0], rhs[2]);
	};
	this.reduceActions[20] = function(rhs) {
		return new ModOperation(rhs[0], rhs[2]);
	};
	this.reduceActions[22] = function(rhs) {
		return new UnaryMinusOperation(rhs[1]);
	};
	this.reduceActions[24] = function(rhs) {
		return new BarOperation(rhs[0], rhs[2]);
	};
	this.reduceActions[25] = function(rhs) {
		return new PathExpr(undefined, undefined, rhs[0]);
	};
	this.reduceActions[27] = function(rhs) {
		rhs[0].locationPath = rhs[2];
		return rhs[0];
	};
	this.reduceActions[28] = function(rhs) {
		rhs[0].locationPath = rhs[2];
		rhs[0].locationPath.steps.unshift(new Step(Step.DESCENDANTORSELF, new NodeTest(NodeTest.NODE, undefined), []));
		return rhs[0];
	};
	this.reduceActions[29] = function(rhs) {
		return new PathExpr(rhs[0], [], undefined);
	};
	this.reduceActions[30] = function(rhs) {
		if (Utilities.instance_of(rhs[0], PathExpr)) {
			if (rhs[0].filterPredicates == undefined) {
				rhs[0].filterPredicates = [];
			}
			rhs[0].filterPredicates.push(rhs[1]);
			return rhs[0];
		} else {
			return new PathExpr(rhs[0], [rhs[1]], undefined);
		}
	};
	this.reduceActions[32] = function(rhs) {
		return rhs[1];
	};
	this.reduceActions[33] = function(rhs) {
		return new XString(rhs[0]);
	};
	this.reduceActions[34] = function(rhs) {
		return new XNumber(rhs[0]);
	};
	this.reduceActions[36] = function(rhs) {
		return new FunctionCall(rhs[0], []);
	};
	this.reduceActions[37] = function(rhs) {
		return new FunctionCall(rhs[0], rhs[2]);
	};
	this.reduceActions[38] = function(rhs) {
		return [ rhs[0] ];
	};
	this.reduceActions[39] = function(rhs) {
		rhs[2].unshift(rhs[0]);
		return rhs[2];
	};
	this.reduceActions[43] = function(rhs) {
		return new LocationPath(true, []);
	};
	this.reduceActions[44] = function(rhs) {
		rhs[1].absolute = true;
		return rhs[1];
	};
	this.reduceActions[46] = function(rhs) {
		return new LocationPath(false, [ rhs[0] ]);
	};
	this.reduceActions[47] = function(rhs) {
		rhs[0].steps.push(rhs[2]);
		return rhs[0];
	};
	this.reduceActions[49] = function(rhs) {
		return new Step(rhs[0], rhs[1], []);
	};
	this.reduceActions[50] = function(rhs) {
		return new Step(Step.CHILD, rhs[0], []);
	};
	this.reduceActions[51] = function(rhs) {
		return new Step(rhs[0], rhs[1], rhs[2]);
	};
	this.reduceActions[52] = function(rhs) {
		return new Step(Step.CHILD, rhs[0], rhs[1]);
	};
	this.reduceActions[54] = function(rhs) {
		return [ rhs[0] ];
	};
	this.reduceActions[55] = function(rhs) {
		rhs[1].unshift(rhs[0]);
		return rhs[1];
	};
	this.reduceActions[56] = function(rhs) {
		if (rhs[0] == &quot;ancestor&quot;) {
			return Step.ANCESTOR;
		} else if (rhs[0] == &quot;ancestor-or-self&quot;) {
			return Step.ANCESTORORSELF;
		} else if (rhs[0] == &quot;attribute&quot;) {
			return Step.ATTRIBUTE;
		} else if (rhs[0] == &quot;child&quot;) {
			return Step.CHILD;
		} else if (rhs[0] == &quot;descendant&quot;) {
			return Step.DESCENDANT;
		} else if (rhs[0] == &quot;descendant-or-self&quot;) {
			return Step.DESCENDANTORSELF;
		} else if (rhs[0] == &quot;following&quot;) {
			return Step.FOLLOWING;
		} else if (rhs[0] == &quot;following-sibling&quot;) {
			return Step.FOLLOWINGSIBLING;
		} else if (rhs[0] == &quot;namespace&quot;) {
			return Step.NAMESPACE;
		} else if (rhs[0] == &quot;parent&quot;) {
			return Step.PARENT;
		} else if (rhs[0] == &quot;preceding&quot;) {
			return Step.PRECEDING;
		} else if (rhs[0] == &quot;preceding-sibling&quot;) {
			return Step.PRECEDINGSIBLING;
		} else if (rhs[0] == &quot;self&quot;) {
			return Step.SELF;
		}
		return -1;
	};
	this.reduceActions[57] = function(rhs) {
		return Step.ATTRIBUTE;
	};
	this.reduceActions[59] = function(rhs) {
		if (rhs[0] == &quot;comment&quot;) {
			return new NodeTest(NodeTest.COMMENT, undefined);
		} else if (rhs[0] == &quot;text&quot;) {
			return new NodeTest(NodeTest.TEXT, undefined);
		} else if (rhs[0] == &quot;processing-instruction&quot;) {
			return new NodeTest(NodeTest.PI, undefined);
		} else if (rhs[0] == &quot;node&quot;) {
			return new NodeTest(NodeTest.NODE, undefined);
		}
		return new NodeTest(-1, undefined);
	};
	this.reduceActions[60] = function(rhs) {
		return new NodeTest(NodeTest.PI, rhs[2]);
	};
	this.reduceActions[61] = function(rhs) {
		return rhs[1];
	};
	this.reduceActions[63] = function(rhs) {
		rhs[1].absolute = true;
		rhs[1].steps.unshift(new Step(Step.DESCENDANTORSELF, new NodeTest(NodeTest.NODE, undefined), []));
		return rhs[1];
	};
	this.reduceActions[64] = function(rhs) {
		rhs[0].steps.push(new Step(Step.DESCENDANTORSELF, new NodeTest(NodeTest.NODE, undefined), []));
		rhs[0].steps.push(rhs[2]);
		return rhs[0];
	};
	this.reduceActions[65] = function(rhs) {
		return new Step(Step.SELF, new NodeTest(NodeTest.NODE, undefined), []);
	};
	this.reduceActions[66] = function(rhs) {
		return new Step(Step.PARENT, new NodeTest(NodeTest.NODE, undefined), []);
	};
	this.reduceActions[67] = function(rhs) {
		return new VariableReference(rhs[1]);
	};
	this.reduceActions[68] = function(rhs) {
		return new NodeTest(NodeTest.NAMETESTANY, undefined);
	};
	this.reduceActions[69] = function(rhs) {
		var prefix = rhs[0].substring(0, rhs[0].indexOf(&quot;:&quot;));
		return new NodeTest(NodeTest.NAMETESTPREFIXANY, prefix);
	};
	this.reduceActions[70] = function(rhs) {
		return new NodeTest(NodeTest.NAMETESTQNAME, rhs[0]);
	};
};

XPathParser.actionTable = [
	&quot; s s        sssssssss    s ss  s  ss&quot;,
	&quot;                 s                  &quot;,
	&quot;r  rrrrrrrrr         rrrrrrr rr  r  &quot;,
	&quot;                rrrrr               &quot;,
	&quot; s s        sssssssss    s ss  s  ss&quot;,
	&quot;rs  rrrrrrrr s  sssssrrrrrr  rrs rs &quot;,
	&quot; s s        sssssssss    s ss  s  ss&quot;,
	&quot;                            s       &quot;,
	&quot;                            s       &quot;,
	&quot;r  rrrrrrrrr         rrrrrrr rr rr  &quot;,
	&quot;r  rrrrrrrrr         rrrrrrr rr rr  &quot;,
	&quot;r  rrrrrrrrr         rrrrrrr rr rr  &quot;,
	&quot;r  rrrrrrrrr         rrrrrrr rr rr  &quot;,
	&quot;r  rrrrrrrrr         rrrrrrr rr rr  &quot;,
	&quot;  s                                 &quot;,
	&quot;                            s       &quot;,
	&quot; s           s  sssss          s  s &quot;,
	&quot;r  rrrrrrrrr         rrrrrrr rr  r  &quot;,
	&quot;a                                   &quot;,
	&quot;r       s                    rr  r  &quot;,
	&quot;r      sr                    rr  r  &quot;,
	&quot;r   s  rr            s       rr  r  &quot;,
	&quot;r   rssrr            rss     rr  r  &quot;,
	&quot;r   rrrrr            rrrss   rr  r  &quot;,
	&quot;r   rrrrrsss         rrrrr   rr  r  &quot;,
	&quot;r   rrrrrrrr         rrrrr   rr  r  &quot;,
	&quot;r   rrrrrrrr         rrrrrs  rr  r  &quot;,
	&quot;r   rrrrrrrr         rrrrrr  rr  r  &quot;,
	&quot;r   rrrrrrrr         rrrrrr  rr  r  &quot;,
	&quot;r  srrrrrrrr         rrrrrrs rr sr  &quot;,
	&quot;r  srrrrrrrr         rrrrrrs rr  r  &quot;,
	&quot;r  rrrrrrrrr         rrrrrrr rr rr  &quot;,
	&quot;r  rrrrrrrrr         rrrrrrr rr rr  &quot;,
	&quot;r  rrrrrrrrr         rrrrrrr rr rr  &quot;,
	&quot;r   rrrrrrrr         rrrrrr  rr  r  &quot;,
	&quot;r   rrrrrrrr         rrrrrr  rr  r  &quot;,
	&quot;r  rrrrrrrrr         rrrrrrr rr  r  &quot;,
	&quot;r  rrrrrrrrr         rrrrrrr rr  r  &quot;,
	&quot;                sssss               &quot;,
	&quot;r  rrrrrrrrr         rrrrrrr rr sr  &quot;,
	&quot;r  rrrrrrrrr         rrrrrrr rr  r  &quot;,
	&quot;r  rrrrrrrrr         rrrrrrr rr rr  &quot;,
	&quot;r  rrrrrrrrr         rrrrrrr rr rr  &quot;,
	&quot;                             s      &quot;,
	&quot;r  srrrrrrrr         rrrrrrs rr  r  &quot;,
	&quot;r   rrrrrrrr         rrrrr   rr  r  &quot;,
	&quot;              s                     &quot;,
	&quot;                             s      &quot;,
	&quot;                rrrrr               &quot;,
	&quot; s s        sssssssss    s sss s  ss&quot;,
	&quot;r  srrrrrrrr         rrrrrrs rr  r  &quot;,
	&quot; s s        sssssssss    s ss  s  ss&quot;,
	&quot; s s        sssssssss    s ss  s  ss&quot;,
	&quot; s s        sssssssss    s ss  s  ss&quot;,
	&quot; s s        sssssssss    s ss  s  ss&quot;,
	&quot; s s        sssssssss    s ss  s  ss&quot;,
	&quot; s s        sssssssss    s ss  s  ss&quot;,
	&quot; s s        sssssssss    s ss  s  ss&quot;,
	&quot; s s        sssssssss    s ss  s  ss&quot;,
	&quot; s s        sssssssss    s ss  s  ss&quot;,
	&quot; s s        sssssssss    s ss  s  ss&quot;,
	&quot; s s        sssssssss    s ss  s  ss&quot;,
	&quot; s s        sssssssss    s ss  s  ss&quot;,
	&quot; s s        sssssssss    s ss  s  ss&quot;,
	&quot; s s        sssssssss      ss  s  ss&quot;,
	&quot; s s        sssssssss    s ss  s  ss&quot;,
	&quot; s           s  sssss          s  s &quot;,
	&quot; s           s  sssss          s  s &quot;,
	&quot;r  rrrrrrrrr         rrrrrrr rr rr  &quot;,
	&quot; s           s  sssss          s  s &quot;,
	&quot; s           s  sssss          s  s &quot;,
	&quot;r  rrrrrrrrr         rrrrrrr rr sr  &quot;,
	&quot;r  rrrrrrrrr         rrrrrrr rr sr  &quot;,
	&quot;r  rrrrrrrrr         rrrrrrr rr  r  &quot;,
	&quot;r  rrrrrrrrr         rrrrrrr rr rr  &quot;,
	&quot;                             s      &quot;,
	&quot;r  rrrrrrrrr         rrrrrrr rr rr  &quot;,
	&quot;r  rrrrrrrrr         rrrrrrr rr rr  &quot;,
	&quot;                             rr     &quot;,
	&quot;                             s      &quot;,
	&quot;                             rs     &quot;,
	&quot;r      sr                    rr  r  &quot;,
	&quot;r   s  rr            s       rr  r  &quot;,
	&quot;r   rssrr            rss     rr  r  &quot;,
	&quot;r   rssrr            rss     rr  r  &quot;,
	&quot;r   rrrrr            rrrss   rr  r  &quot;,
	&quot;r   rrrrr            rrrss   rr  r  &quot;,
	&quot;r   rrrrr            rrrss   rr  r  &quot;,
	&quot;r   rrrrr            rrrss   rr  r  &quot;,
	&quot;r   rrrrrsss         rrrrr   rr  r  &quot;,
	&quot;r   rrrrrsss         rrrrr   rr  r  &quot;,
	&quot;r   rrrrrrrr         rrrrr   rr  r  &quot;,
	&quot;r   rrrrrrrr         rrrrr   rr  r  &quot;,
	&quot;r   rrrrrrrr         rrrrr   rr  r  &quot;,
	&quot;r   rrrrrrrr         rrrrrr  rr  r  &quot;,
	&quot;                                 r  &quot;,
	&quot;                                 s  &quot;,
	&quot;r  srrrrrrrr         rrrrrrs rr  r  &quot;,
	&quot;r  srrrrrrrr         rrrrrrs rr  r  &quot;,
	&quot;r  rrrrrrrrr         rrrrrrr rr  r  &quot;,
	&quot;r  rrrrrrrrr         rrrrrrr rr  r  &quot;,
	&quot;r  rrrrrrrrr         rrrrrrr rr  r  &quot;,
	&quot;r  rrrrrrrrr         rrrrrrr rr  r  &quot;,
	&quot;r  rrrrrrrrr         rrrrrrr rr rr  &quot;,
	&quot;r  rrrrrrrrr         rrrrrrr rr rr  &quot;,
	&quot; s s        sssssssss    s ss  s  ss&quot;,
	&quot;r  rrrrrrrrr         rrrrrrr rr rr  &quot;,
	&quot;                             r      &quot;
];

XPathParser.actionTableNumber = [
	&quot; 1 0        /.-,+*)(&#039;    &amp; %$  #  \&quot;!&quot;,
	&quot;                 J                  &quot;,
	&quot;a  aaaaaaaaa         aaaaaaa aa  a  &quot;,
	&quot;                YYYYY               &quot;,
	&quot; 1 0        /.-,+*)(&#039;    &amp; %$  #  \&quot;!&quot;,
	&quot;K1  KKKKKKKK .  +*)(&#039;KKKKKK  KK# K\&quot; &quot;,
	&quot; 1 0        /.-,+*)(&#039;    &amp; %$  #  \&quot;!&quot;,
	&quot;                            N       &quot;,
	&quot;                            O       &quot;,
	&quot;e  eeeeeeeee         eeeeeee ee ee  &quot;,
	&quot;f  fffffffff         fffffff ff ff  &quot;,
	&quot;d  ddddddddd         ddddddd dd dd  &quot;,
	&quot;B  BBBBBBBBB         BBBBBBB BB BB  &quot;,
	&quot;A  AAAAAAAAA         AAAAAAA AA AA  &quot;,
	&quot;  P                                 &quot;,
	&quot;                            Q       &quot;,
	&quot; 1           .  +*)(&#039;          #  \&quot; &quot;,
	&quot;b  bbbbbbbbb         bbbbbbb bb  b  &quot;,
	&quot;                                    &quot;,
	&quot;!       S                    !!  !  &quot;,
	&quot;\&quot;      T\&quot;                    \&quot;\&quot;  \&quot;  &quot;,
	&quot;$   V  $$            U       $$  $  &quot;,
	&quot;&amp;   &amp;ZY&amp;&amp;            &amp;XW     &amp;&amp;  &amp;  &quot;,
	&quot;)   )))))            )))\\[   ))  )  &quot;,
	&quot;.   ....._^]         .....   ..  .  &quot;,
	&quot;1   11111111         11111   11  1  &quot;,
	&quot;5   55555555         55555`  55  5  &quot;,
	&quot;7   77777777         777777  77  7  &quot;,
	&quot;9   99999999         999999  99  9  &quot;,
	&quot;:  c::::::::         ::::::b :: a:  &quot;,
	&quot;I  fIIIIIIII         IIIIIIe II  I  &quot;,
	&quot;=  =========         ======= == ==  &quot;,
	&quot;?  ?????????         ??????? ?? ??  &quot;,
	&quot;C  CCCCCCCCC         CCCCCCC CC CC  &quot;,
	&quot;J   JJJJJJJJ         JJJJJJ  JJ  J  &quot;,
	&quot;M   MMMMMMMM         MMMMMM  MM  M  &quot;,
	&quot;N  NNNNNNNNN         NNNNNNN NN  N  &quot;,
	&quot;P  PPPPPPPPP         PPPPPPP PP  P  &quot;,
	&quot;                +*)(&#039;               &quot;,
	&quot;R  RRRRRRRRR         RRRRRRR RR aR  &quot;,
	&quot;U  UUUUUUUUU         UUUUUUU UU  U  &quot;,
	&quot;Z  ZZZZZZZZZ         ZZZZZZZ ZZ ZZ  &quot;,
	&quot;c  ccccccccc         ccccccc cc cc  &quot;,
	&quot;                             j      &quot;,
	&quot;L  fLLLLLLLL         LLLLLLe LL  L  &quot;,
	&quot;6   66666666         66666   66  6  &quot;,
	&quot;              k                     &quot;,
	&quot;                             l      &quot;,
	&quot;                XXXXX               &quot;,
	&quot; 1 0        /.-,+*)(&#039;    &amp; %$m #  \&quot;!&quot;,
	&quot;_  f________         ______e __  _  &quot;,
	&quot; 1 0        /.-,+*)(&#039;    &amp; %$  #  \&quot;!&quot;,
	&quot; 1 0        /.-,+*)(&#039;    &amp; %$  #  \&quot;!&quot;,
	&quot; 1 0        /.-,+*)(&#039;    &amp; %$  #  \&quot;!&quot;,
	&quot; 1 0        /.-,+*)(&#039;    &amp; %$  #  \&quot;!&quot;,
	&quot; 1 0        /.-,+*)(&#039;    &amp; %$  #  \&quot;!&quot;,
	&quot; 1 0        /.-,+*)(&#039;    &amp; %$  #  \&quot;!&quot;,
	&quot; 1 0        /.-,+*)(&#039;    &amp; %$  #  \&quot;!&quot;,
	&quot; 1 0        /.-,+*)(&#039;    &amp; %$  #  \&quot;!&quot;,
	&quot; 1 0        /.-,+*)(&#039;    &amp; %$  #  \&quot;!&quot;,
	&quot; 1 0        /.-,+*)(&#039;    &amp; %$  #  \&quot;!&quot;,
	&quot; 1 0        /.-,+*)(&#039;    &amp; %$  #  \&quot;!&quot;,
	&quot; 1 0        /.-,+*)(&#039;    &amp; %$  #  \&quot;!&quot;,
	&quot; 1 0        /.-,+*)(&#039;    &amp; %$  #  \&quot;!&quot;,
	&quot; 1 0        /.-,+*)(&#039;      %$  #  \&quot;!&quot;,
	&quot; 1 0        /.-,+*)(&#039;    &amp; %$  #  \&quot;!&quot;,
	&quot; 1           .  +*)(&#039;          #  \&quot; &quot;,
	&quot; 1           .  +*)(&#039;          #  \&quot; &quot;,
	&quot;&gt;  &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;         &gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; &gt;&gt;  &quot;,
	&quot; 1           .  +*)(&#039;          #  \&quot; &quot;,
	&quot; 1           .  +*)(&#039;          #  \&quot; &quot;,
	&quot;Q  QQQQQQQQQ         QQQQQQQ QQ aQ  &quot;,
	&quot;V  VVVVVVVVV         VVVVVVV VV aV  &quot;,
	&quot;T  TTTTTTTTT         TTTTTTT TT  T  &quot;,
	&quot;@  @@@@@@@@@         @@@@@@@ @@ @@  &quot;,
	&quot;                             \x87      &quot;,
	&quot;[  [[[[[[[[[         [[[[[[[ [[ [[  &quot;,
	&quot;D  DDDDDDDDD         DDDDDDD DD DD  &quot;,
	&quot;                             HH     &quot;,
	&quot;                             \x88      &quot;,
	&quot;                             F\x89     &quot;,
	&quot;#      T#                    ##  #  &quot;,
	&quot;%   V  %%            U       %%  %  &quot;,
	&quot;&#039;   &#039;ZY&#039;&#039;            &#039;XW     &#039;&#039;  &#039;  &quot;,
	&quot;(   (ZY((            (XW     ((  (  &quot;,
	&quot;+   +++++            +++\\[   ++  +  &quot;,
	&quot;*   *****            ***\\[   **  *  &quot;,
	&quot;-   -----            ---\\[   --  -  &quot;,
	&quot;,   ,,,,,            ,,,\\[   ,,  ,  &quot;,
	&quot;0   00000_^]         00000   00  0  &quot;,
	&quot;/   /////_^]         /////   //  /  &quot;,
	&quot;2   22222222         22222   22  2  &quot;,
	&quot;3   33333333         33333   33  3  &quot;,
	&quot;4   44444444         44444   44  4  &quot;,
	&quot;8   88888888         888888  88  8  &quot;,
	&quot;                                 ^  &quot;,
	&quot;                                 \x8a  &quot;,
	&quot;;  f;;;;;;;;         ;;;;;;e ;;  ;  &quot;,
	&quot;&lt;  f&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;         &lt;&lt;&lt;&lt;&lt;&lt;e &lt;&lt;  &lt;  &quot;,
	&quot;O  OOOOOOOOO         OOOOOOO OO  O  &quot;,
	&quot;`  `````````         ``````` ``  `  &quot;,
	&quot;S  SSSSSSSSS         SSSSSSS SS  S  &quot;,
	&quot;W  WWWWWWWWW         WWWWWWW WW  W  &quot;,
	&quot;\\  \\\\\\\\\\\\\\\\\\         \\\\\\\\\\\\\\ \\\\ \\\\  &quot;,
	&quot;E  EEEEEEEEE         EEEEEEE EE EE  &quot;,
	&quot; 1 0        /.-,+*)(&#039;    &amp; %$  #  \&quot;!&quot;,
	&quot;]  ]]]]]]]]]         ]]]]]]] ]] ]]  &quot;,
	&quot;                             G      &quot;
];

XPathParser.gotoTable = [
	&quot;3456789:;&lt;=&gt;?@ AB  CDEFGH IJ &quot;,
	&quot;                             &quot;,
	&quot;                             &quot;,
	&quot;                             &quot;,
	&quot;L456789:;&lt;=&gt;?@ AB  CDEFGH IJ &quot;,
	&quot;            M        EFGH IJ &quot;,
	&quot;       N;&lt;=&gt;?@ AB  CDEFGH IJ &quot;,
	&quot;                             &quot;,
	&quot;                             &quot;,
	&quot;                             &quot;,
	&quot;                             &quot;,
	&quot;                             &quot;,
	&quot;                             &quot;,
	&quot;                             &quot;,
	&quot;                             &quot;,
	&quot;                             &quot;,
	&quot;            S        EFGH IJ &quot;,
	&quot;                             &quot;,
	&quot;                             &quot;,
	&quot;                             &quot;,
	&quot;                             &quot;,
	&quot;                             &quot;,
	&quot;                             &quot;,
	&quot;                             &quot;,
	&quot;                             &quot;,
	&quot;                             &quot;,
	&quot;                             &quot;,
	&quot;                             &quot;,
	&quot;                             &quot;,
	&quot;              e              &quot;,
	&quot;                             &quot;,
	&quot;                             &quot;,
	&quot;                             &quot;,
	&quot;                             &quot;,
	&quot;                             &quot;,
	&quot;                             &quot;,
	&quot;                             &quot;,
	&quot;                             &quot;,
	&quot;                        h  J &quot;,
	&quot;              i          j   &quot;,
	&quot;                             &quot;,
	&quot;                             &quot;,
	&quot;                             &quot;,
	&quot;                             &quot;,
	&quot;                             &quot;,
	&quot;                             &quot;,
	&quot;                             &quot;,
	&quot;                             &quot;,
	&quot;                             &quot;,
	&quot;o456789:;&lt;=&gt;?@ ABpqCDEFGH IJ &quot;,
	&quot;                             &quot;,
	&quot;  r6789:;&lt;=&gt;?@ AB  CDEFGH IJ &quot;,
	&quot;   s789:;&lt;=&gt;?@ AB  CDEFGH IJ &quot;,
	&quot;    t89:;&lt;=&gt;?@ AB  CDEFGH IJ &quot;,
	&quot;    u89:;&lt;=&gt;?@ AB  CDEFGH IJ &quot;,
	&quot;     v9:;&lt;=&gt;?@ AB  CDEFGH IJ &quot;,
	&quot;     w9:;&lt;=&gt;?@ AB  CDEFGH IJ &quot;,
	&quot;     x9:;&lt;=&gt;?@ AB  CDEFGH IJ &quot;,
	&quot;     y9:;&lt;=&gt;?@ AB  CDEFGH IJ &quot;,
	&quot;      z:;&lt;=&gt;?@ AB  CDEFGH IJ &quot;,
	&quot;      {:;&lt;=&gt;?@ AB  CDEFGH IJ &quot;,
	&quot;       |;&lt;=&gt;?@ AB  CDEFGH IJ &quot;,
	&quot;       };&lt;=&gt;?@ AB  CDEFGH IJ &quot;,
	&quot;       ~;&lt;=&gt;?@ AB  CDEFGH IJ &quot;,
	&quot;         \x7f=&gt;?@ AB  CDEFGH IJ &quot;,
	&quot;\x80456789:;&lt;=&gt;?@ AB  CDEFGH IJ\x81&quot;,
	&quot;            \x82        EFGH IJ &quot;,
	&quot;            \x83        EFGH IJ &quot;,
	&quot;                             &quot;,
	&quot;                     \x84 GH IJ &quot;,
	&quot;                     \x85 GH IJ &quot;,
	&quot;              i          \x86   &quot;,
	&quot;              i          \x87   &quot;,
	&quot;                             &quot;,
	&quot;                             &quot;,
	&quot;                             &quot;,
	&quot;                             &quot;,
	&quot;                             &quot;,
	&quot;                             &quot;,
	&quot;                             &quot;,
	&quot;                             &quot;,
	&quot;                             &quot;,
	&quot;                             &quot;,
	&quot;                             &quot;,
	&quot;                             &quot;,
	&quot;                             &quot;,
	&quot;                             &quot;,
	&quot;                             &quot;,
	&quot;                             &quot;,
	&quot;                             &quot;,
	&quot;                             &quot;,
	&quot;                             &quot;,
	&quot;                             &quot;,
	&quot;                             &quot;,
	&quot;                             &quot;,
	&quot;                             &quot;,
	&quot;                             &quot;,
	&quot;                             &quot;,
	&quot;                             &quot;,
	&quot;                             &quot;,
	&quot;                             &quot;,
	&quot;                             &quot;,
	&quot;                             &quot;,
	&quot;                             &quot;,
	&quot;                             &quot;,
	&quot;o456789:;&lt;=&gt;?@ AB\x8cqCDEFGH IJ &quot;,
	&quot;                             &quot;,
	&quot;                             &quot;
];

XPathParser.productions = [
	[1, 1, 2],
	[2, 1, 3],
	[3, 1, 4],
	[3, 3, 3, -9, 4],
	[4, 1, 5],
	[4, 3, 4, -8, 5],
	[5, 1, 6],
	[5, 3, 5, -22, 6],
	[5, 3, 5, -5, 6],
	[6, 1, 7],
	[6, 3, 6, -23, 7],
	[6, 3, 6, -24, 7],
	[6, 3, 6, -6, 7],
	[6, 3, 6, -7, 7],
	[7, 1, 8],
	[7, 3, 7, -25, 8],
	[7, 3, 7, -26, 8],
	[8, 1, 9],
	[8, 3, 8, -12, 9],
	[8, 3, 8, -11, 9],
	[8, 3, 8, -10, 9],
	[9, 1, 10],
	[9, 2, -26, 9],
	[10, 1, 11],
	[10, 3, 10, -27, 11],
	[11, 1, 12],
	[11, 1, 13],
	[11, 3, 13, -28, 14],
	[11, 3, 13, -4, 14],
	[13, 1, 15],
	[13, 2, 13, 16],
	[15, 1, 17],
	[15, 3, -29, 2, -30],
	[15, 1, -15],
	[15, 1, -16],
	[15, 1, 18],
	[18, 3, -13, -29, -30],
	[18, 4, -13, -29, 19, -30],
	[19, 1, 20],
	[19, 3, 20, -31, 19],
	[20, 1, 2],
	[12, 1, 14],
	[12, 1, 21],
	[21, 1, -28],
	[21, 2, -28, 14],
	[21, 1, 22],
	[14, 1, 23],
	[14, 3, 14, -28, 23],
	[14, 1, 24],
	[23, 2, 25, 26],
	[23, 1, 26],
	[23, 3, 25, 26, 27],
	[23, 2, 26, 27],
	[23, 1, 28],
	[27, 1, 16],
	[27, 2, 16, 27],
	[25, 2, -14, -3],
	[25, 1, -32],
	[26, 1, 29],
	[26, 3, -20, -29, -30],
	[26, 4, -21, -29, -15, -30],
	[16, 3, -33, 30, -34],
	[30, 1, 2],
	[22, 2, -4, 14],
	[24, 3, 14, -4, 23],
	[28, 1, -35],
	[28, 1, -2],
	[17, 2, -36, -18],
	[29, 1, -17],
	[29, 1, -19],
	[29, 1, -18]
];

XPathParser.DOUBLEDOT = 2;
XPathParser.DOUBLECOLON = 3;
XPathParser.DOUBLESLASH = 4;
XPathParser.NOTEQUAL = 5;
XPathParser.LESSTHANOREQUAL = 6;
XPathParser.GREATERTHANOREQUAL = 7;
XPathParser.AND = 8;
XPathParser.OR = 9;
XPathParser.MOD = 10;
XPathParser.DIV = 11;
XPathParser.MULTIPLYOPERATOR = 12;
XPathParser.FUNCTIONNAME = 13;
XPathParser.AXISNAME = 14;
XPathParser.LITERAL = 15;
XPathParser.NUMBER = 16;
XPathParser.ASTERISKNAMETEST = 17;
XPathParser.QNAME = 18;
XPathParser.NCNAMECOLONASTERISK = 19;
XPathParser.NODETYPE = 20;
XPathParser.PROCESSINGINSTRUCTIONWITHLITERAL = 21;
XPathParser.EQUALS = 22;
XPathParser.LESSTHAN = 23;
XPathParser.GREATERTHAN = 24;
XPathParser.PLUS = 25;
XPathParser.MINUS = 26;
XPathParser.BAR = 27;
XPathParser.SLASH = 28;
XPathParser.LEFTPARENTHESIS = 29;
XPathParser.RIGHTPARENTHESIS = 30;
XPathParser.COMMA = 31;
XPathParser.AT = 32;
XPathParser.LEFTBRACKET = 33;
XPathParser.RIGHTBRACKET = 34;
XPathParser.DOT = 35;
XPathParser.DOLLAR = 36;

XPathParser.prototype.tokenize = function(s1) {
	var types = [];
	var values = [];
	var s = s1 + &#039;\0&#039;;

	var pos = 0;
	var c = s.charAt(pos++);
	while (1) {
		while (c == &#039; &#039; || c == &#039;\t&#039; || c == &#039;\r&#039; || c == &#039;\n&#039;) {
			c = s.charAt(pos++);
		}
		if (c == &#039;\0&#039; || pos &gt;= s.length) {
			break;
		}

		if (c == &#039;(&#039;) {
			types.push(XPathParser.LEFTPARENTHESIS);
			values.push(c);
			c = s.charAt(pos++);
			continue;
		}
		if (c == &#039;)&#039;) {
			types.push(XPathParser.RIGHTPARENTHESIS);
			values.push(c);
			c = s.charAt(pos++);
			continue;
		}
		if (c == &#039;[&#039;) {
			types.push(XPathParser.LEFTBRACKET);
			values.push(c);
			c = s.charAt(pos++);
			continue;
		}
		if (c == &#039;]&#039;) {
			types.push(XPathParser.RIGHTBRACKET);
			values.push(c);
			c = s.charAt(pos++);
			continue;
		}
		if (c == &#039;@&#039;) {
			types.push(XPathParser.AT);
			values.push(c);
			c = s.charAt(pos++);
			continue;
		}
		if (c == &#039;,&#039;) {
			types.push(XPathParser.COMMA);
			values.push(c);
			c = s.charAt(pos++);
			continue;
		}
		if (c == &#039;|&#039;) {
			types.push(XPathParser.BAR);
			values.push(c);
			c = s.charAt(pos++);
			continue;
		}
		if (c == &#039;+&#039;) {
			types.push(XPathParser.PLUS);
			values.push(c);
			c = s.charAt(pos++);
			continue;
		}
		if (c == &#039;-&#039;) {
			types.push(XPathParser.MINUS);
			values.push(c);
			c = s.charAt(pos++);
			continue;
		}
		if (c == &#039;=&#039;) {
			types.push(XPathParser.EQUALS);
			values.push(c);
			c = s.charAt(pos++);
			continue;
		}
		if (c == &#039;$&#039;) {
			types.push(XPathParser.DOLLAR);
			values.push(c);
			c = s.charAt(pos++);
			continue;
		}

		if (c == &#039;.&#039;) {
			c = s.charAt(pos++);
			if (c == &#039;.&#039;) {
				types.push(XPathParser.DOUBLEDOT);
				values.push(&quot;..&quot;);
				c = s.charAt(pos++);
				continue;
			}
			if (c &gt;= &#039;0&#039; &amp;&amp; c &lt;= &#039;9&#039;) {
				var number = &quot;.&quot; + c;
				c = s.charAt(pos++);
				while (c &gt;= &#039;0&#039; &amp;&amp; c &lt;= &#039;9&#039;) {
					number += c;
					c = s.charAt(pos++);
				}
				types.push(XPathParser.NUMBER);
				values.push(number);
				continue;
			}
			types.push(XPathParser.DOT);
			values.push(&#039;.&#039;);
			continue;
		}

		if (c == &#039;\&#039;&#039; || c == &#039;&quot;&#039;) {
			var delimiter = c;
			var literal = &quot;&quot;;
			while ((c = s.charAt(pos++)) != delimiter) {
				literal += c;
			}
			types.push(XPathParser.LITERAL);
			values.push(literal);
			c = s.charAt(pos++);
			continue;
		}

		if (c &gt;= &#039;0&#039; &amp;&amp; c &lt;= &#039;9&#039;) {
			var number = c;
			c = s.charAt(pos++);
			while (c &gt;= &#039;0&#039; &amp;&amp; c &lt;= &#039;9&#039;) {
				number += c;
				c = s.charAt(pos++);
			}
			if (c == &#039;.&#039;) {
				if (s.charAt(pos) &gt;= &#039;0&#039; &amp;&amp; s.charAt(pos) &lt;= &#039;9&#039;) {
					number += c;
					number += s.charAt(pos++);
					c = s.charAt(pos++);
					while (c &gt;= &#039;0&#039; &amp;&amp; c &lt;= &#039;9&#039;) {
						number += c;
						c = s.charAt(pos++);
					}
				}
			}
			types.push(XPathParser.NUMBER);
			values.push(number);
			continue;
		}

		if (c == &#039;*&#039;) {
			if (types.length &gt; 0) {
				var last = types[types.length - 1];
				if (last != XPathParser.AT
						&amp;&amp; last != XPathParser.DOUBLECOLON
						&amp;&amp; last != XPathParser.LEFTPARENTHESIS
						&amp;&amp; last != XPathParser.LEFTBRACKET
						&amp;&amp; last != XPathParser.AND
						&amp;&amp; last != XPathParser.OR
						&amp;&amp; last != XPathParser.MOD
						&amp;&amp; last != XPathParser.DIV
						&amp;&amp; last != XPathParser.MULTIPLYOPERATOR
						&amp;&amp; last != XPathParser.SLASH
						&amp;&amp; last != XPathParser.DOUBLESLASH
						&amp;&amp; last != XPathParser.BAR
						&amp;&amp; last != XPathParser.PLUS
						&amp;&amp; last != XPathParser.MINUS
						&amp;&amp; last != XPathParser.EQUALS
						&amp;&amp; last != XPathParser.NOTEQUAL
						&amp;&amp; last != XPathParser.LESSTHAN
						&amp;&amp; last != XPathParser.LESSTHANOREQUAL
						&amp;&amp; last != XPathParser.GREATERTHAN
						&amp;&amp; last != XPathParser.GREATERTHANOREQUAL) {
					types.push(XPathParser.MULTIPLYOPERATOR);
					values.push(c);
					c = s.charAt(pos++);
					continue;
				}
			}
			types.push(XPathParser.ASTERISKNAMETEST);
			values.push(c);
			c = s.charAt(pos++);
			continue;
		}

		if (c == &#039;:&#039;) {
			if (s.charAt(pos) == &#039;:&#039;) {
				types.push(XPathParser.DOUBLECOLON);
				values.push(&quot;::&quot;);
				pos++;
				c = s.charAt(pos++);
				continue;
			}
		}

		if (c == &#039;/&#039;) {
			c = s.charAt(pos++);
			if (c == &#039;/&#039;) {
				types.push(XPathParser.DOUBLESLASH);
				values.push(&quot;//&quot;);
				c = s.charAt(pos++);
				continue;
			}
			types.push(XPathParser.SLASH);
			values.push(&#039;/&#039;);
			continue;
		}

		if (c == &#039;!&#039;) {
			if (s.charAt(pos) == &#039;=&#039;) {
				types.push(XPathParser.NOTEQUAL);
				values.push(&quot;!=&quot;);
				pos++;
				c = s.charAt(pos++);
				continue;
			}
		}

		if (c == &#039;&lt;&#039;) {
			if (s.charAt(pos) == &#039;=&#039;) {
				types.push(XPathParser.LESSTHANOREQUAL);
				values.push(&quot;&lt;=&quot;);
				pos++;
				c = s.charAt(pos++);
				continue;
			}
			types.push(XPathParser.LESSTHAN);
			values.push(&#039;&lt;&#039;);
			c = s.charAt(pos++);
			continue;
		}

		if (c == &#039;&gt;&#039;) {
			if (s.charAt(pos) == &#039;=&#039;) {
				types.push(XPathParser.GREATERTHANOREQUAL);
				values.push(&quot;&gt;=&quot;);
				pos++;
				c = s.charAt(pos++);
				continue;
			}
			types.push(XPathParser.GREATERTHAN);
			values.push(&#039;&gt;&#039;);
			c = s.charAt(pos++);
			continue;
		}

		if (c == &#039;_&#039; || Utilities.isLetter(c.charCodeAt(0))) {
			var name = c;
			c = s.charAt(pos++);
			while (Utilities.isNCNameChar(c.charCodeAt(0))) {
				name += c;
				c = s.charAt(pos++);
			}
			if (types.length &gt; 0) {
				var last = types[types.length - 1];
				if (last != XPathParser.AT
						&amp;&amp; last != XPathParser.DOUBLECOLON
						&amp;&amp; last != XPathParser.LEFTPARENTHESIS
						&amp;&amp; last != XPathParser.LEFTBRACKET
						&amp;&amp; last != XPathParser.AND
						&amp;&amp; last != XPathParser.OR
						&amp;&amp; last != XPathParser.MOD
						&amp;&amp; last != XPathParser.DIV
						&amp;&amp; last != XPathParser.MULTIPLYOPERATOR
						&amp;&amp; last != XPathParser.SLASH
						&amp;&amp; last != XPathParser.DOUBLESLASH
						&amp;&amp; last != XPathParser.BAR
						&amp;&amp; last != XPathParser.PLUS
						&amp;&amp; last != XPathParser.MINUS
						&amp;&amp; last != XPathParser.EQUALS
						&amp;&amp; last != XPathParser.NOTEQUAL
						&amp;&amp; last != XPathParser.LESSTHAN
						&amp;&amp; last != XPathParser.LESSTHANOREQUAL
						&amp;&amp; last != XPathParser.GREATERTHAN
						&amp;&amp; last != XPathParser.GREATERTHANOREQUAL) {
					if (name == &quot;and&quot;) {
						types.push(XPathParser.AND);
						values.push(name);
						continue;
					}
					if (name == &quot;or&quot;) {
						types.push(XPathParser.OR);
						values.push(name);
						continue;
					}
					if (name == &quot;mod&quot;) {
						types.push(XPathParser.MOD);
						values.push(name);
						continue;
					}
					if (name == &quot;div&quot;) {
						types.push(XPathParser.DIV);
						values.push(name);
						continue;
					}
				}
			}
			if (c == &#039;:&#039;) {
				if (s.charAt(pos) == &#039;*&#039;) {
					types.push(XPathParser.NCNAMECOLONASTERISK);
					values.push(name + &quot;:*&quot;);
					pos++;
					c = s.charAt(pos++);
					continue;
				}
				if (s.charAt(pos) == &#039;_&#039; || Utilities.isLetter(s.charCodeAt(pos))) {
					name += &#039;:&#039;;
					c = s.charAt(pos++);
					while (Utilities.isNCNameChar(c.charCodeAt(0))) {
						name += c;
						c = s.charAt(pos++);
					}
					if (c == &#039;(&#039;) {
						types.push(XPathParser.FUNCTIONNAME);
						values.push(name);
						continue;
					}
					types.push(XPathParser.QNAME);
					values.push(name);
					continue;
				}
				if (s.charAt(pos) == &#039;:&#039;) {
					types.push(XPathParser.AXISNAME);
					values.push(name);
					continue;
				}
			}
			if (c == &#039;(&#039;) {
				if (name == &quot;comment&quot; || name == &quot;text&quot; || name == &quot;node&quot;) {
					types.push(XPathParser.NODETYPE);
					values.push(name);
					continue;
				}
				if (name == &quot;processing-instruction&quot;) {
					if (s.charAt(pos) == &#039;)&#039;) {
						types.push(XPathParser.NODETYPE);
					} else {
						types.push(XPathParser.PROCESSINGINSTRUCTIONWITHLITERAL);
					}
					values.push(name);
					continue;
				}
				types.push(XPathParser.FUNCTIONNAME);
				values.push(name);
				continue;
			}
			types.push(XPathParser.QNAME);
			values.push(name);
			continue;
		}

		throw new Error(&quot;Unexpected character &quot; + c);
	}
	types.push(1);
	values.push(&quot;[EOF]&quot;);
	return [types, values];
};

XPathParser.SHIFT = &#039;s&#039;;
XPathParser.REDUCE = &#039;r&#039;;
XPathParser.ACCEPT = &#039;a&#039;;

XPathParser.prototype.parse = function(s) {
	var types;
	var values;
	var res = this.tokenize(s);
	if (res == undefined) {
		return undefined;
	}
	types = res[0];
	values = res[1];
	var tokenPos = 0;
	var state = [];
	var tokenType = [];
	var tokenValue = [];
	var s;
	var a;
	var t;

	state.push(0);
	tokenType.push(1);
	tokenValue.push(&quot;_S&quot;);

	a = types[tokenPos];
	t = values[tokenPos++];
	while (1) {
		s = state[state.length - 1];
		switch (XPathParser.actionTable[s].charAt(a - 1)) {
			case XPathParser.SHIFT:
				tokenType.push(-a);
				tokenValue.push(t);
				state.push(XPathParser.actionTableNumber[s].charCodeAt(a - 1) - 32);
				a = types[tokenPos];
				t = values[tokenPos++];
				break;
			case XPathParser.REDUCE:
				var num = XPathParser.productions[XPathParser.actionTableNumber[s].charCodeAt(a - 1) - 32][1];
				var rhs = [];
				for (var i = 0; i &lt; num; i++) {
					tokenType.pop();
					rhs.unshift(tokenValue.pop());
					state.pop();
				}
				var s_ = state[state.length - 1];
				tokenType.push(XPathParser.productions[XPathParser.actionTableNumber[s].charCodeAt(a - 1) - 32][0]);
				if (this.reduceActions[XPathParser.actionTableNumber[s].charCodeAt(a - 1) - 32] == undefined) {
					tokenValue.push(rhs[0]);
				} else {
					tokenValue.push(this.reduceActions[XPathParser.actionTableNumber[s].charCodeAt(a - 1) - 32](rhs));
				}
				state.push(XPathParser.gotoTable[s_].charCodeAt(XPathParser.productions[XPathParser.actionTableNumber[s].charCodeAt(a - 1) - 32][0] - 2) - 33);
				break;
			case XPathParser.ACCEPT:
				return new XPath(tokenValue.pop());
			default:
				throw new Error(&quot;XPath parse error&quot;);
		}
	}
};

// XPath /////////////////////////////////////////////////////////////////////

XPath.prototype = new Object();
XPath.prototype.constructor = XPath;
XPath.superclass = Object.prototype;

function XPath(e) {
	this.expression = e;
}

XPath.prototype.toString = function() {
	return this.expression.toString();
};

XPath.prototype.evaluate = function(c) {
	c.contextNode = c.expressionContextNode;
	c.contextSize = 1;
	c.contextPosition = 1;
	c.caseInsensitive = false;
	if (c.contextNode != null) {
		var doc = c.contextNode;
		if (doc.nodeType != 9 /*Node.DOCUMENT_NODE*/) {
			doc = doc.ownerDocument;
		}
		try {
			c.caseInsensitive = doc.implementation.hasFeature(&quot;HTML&quot;, &quot;2.0&quot;);
		} catch (e) {
			c.caseInsensitive = true;
		}
	}
	return this.expression.evaluate(c);
};

XPath.XML_NAMESPACE_URI = &quot;http://www.w3.org/XML/1998/namespace&quot;;
XPath.XMLNS_NAMESPACE_URI = &quot;http://www.w3.org/2000/xmlns/&quot;;

// Expression ////////////////////////////////////////////////////////////////

Expression.prototype = new Object();
Expression.prototype.constructor = Expression;
Expression.superclass = Object.prototype;

function Expression() {
}

Expression.prototype.init = function() {
};

Expression.prototype.toString = function() {
	return &quot;&lt;Expression&gt;&quot;;
};

Expression.prototype.evaluate = function(c) {
	throw new Error(&quot;Could not evaluate expression.&quot;);
};

// UnaryOperation ////////////////////////////////////////////////////////////

UnaryOperation.prototype = new Expression();
UnaryOperation.prototype.constructor = UnaryOperation;
UnaryOperation.superclass = Expression.prototype;

function UnaryOperation(rhs) {
	if (arguments.length &gt; 0) {
		this.init(rhs);
	}
}

UnaryOperation.prototype.init = function(rhs) {
	this.rhs = rhs;
};

// UnaryMinusOperation ///////////////////////////////////////////////////////

UnaryMinusOperation.prototype = new UnaryOperation();
UnaryMinusOperation.prototype.constructor = UnaryMinusOperation;
UnaryMinusOperation.superclass = UnaryOperation.prototype;

function UnaryMinusOperation(rhs) {
	if (arguments.length &gt; 0) {
		this.init(rhs);
	}
}

UnaryMinusOperation.prototype.init = function(rhs) {
	UnaryMinusOperation.superclass.init.call(this, rhs);
};

UnaryMinusOperation.prototype.evaluate = function(c) {
	return this.rhs.evaluate(c).number().negate();
};

UnaryMinusOperation.prototype.toString = function() {
	return &quot;-&quot; + this.rhs.toString();
};

// BinaryOperation ///////////////////////////////////////////////////////////

BinaryOperation.prototype = new Expression();
BinaryOperation.prototype.constructor = BinaryOperation;
BinaryOperation.superclass = Expression.prototype;

function BinaryOperation(lhs, rhs) {
	if (arguments.length &gt; 0) {
		this.init(lhs, rhs);
	}
}

BinaryOperation.prototype.init = function(lhs, rhs) {
	this.lhs = lhs;
	this.rhs = rhs;
};

// OrOperation ///////////////////////////////////////////////////////////////

OrOperation.prototype = new BinaryOperation();
OrOperation.prototype.constructor = OrOperation;
OrOperation.superclass = BinaryOperation.prototype;

function OrOperation(lhs, rhs) {
	if (arguments.length &gt; 0) {
		this.init(lhs, rhs);
	}
}

OrOperation.prototype.init = function(lhs, rhs) {
	OrOperation.superclass.init.call(this, lhs, rhs);
};

OrOperation.prototype.toString = function() {
	return &quot;(&quot; + this.lhs.toString() + &quot; or &quot; + this.rhs.toString() + &quot;)&quot;;
};

OrOperation.prototype.evaluate = function(c) {
	var b = this.lhs.evaluate(c).bool();
	if (b.booleanValue()) {
		return b;
	}
	return this.rhs.evaluate(c).bool();
};

// AndOperation //////////////////////////////////////////////////////////////

AndOperation.prototype = new BinaryOperation();
AndOperation.prototype.constructor = AndOperation;
AndOperation.superclass = BinaryOperation.prototype;

function AndOperation(lhs, rhs) {
	if (arguments.length &gt; 0) {
		this.init(lhs, rhs);
	}
}

AndOperation.prototype.init = function(lhs, rhs) {
	AndOperation.superclass.init.call(this, lhs, rhs);
};

AndOperation.prototype.toString = function() {
	return &quot;(&quot; + this.lhs.toString() + &quot; and &quot; + this.rhs.toString() + &quot;)&quot;;
};

AndOperation.prototype.evaluate = function(c) {
	var b = this.lhs.evaluate(c).bool();
	if (!b.booleanValue()) {
		return b;
	}
	return this.rhs.evaluate(c).bool();
};

// EqualsOperation ///////////////////////////////////////////////////////////

EqualsOperation.prototype = new BinaryOperation();
EqualsOperation.prototype.constructor = EqualsOperation;
EqualsOperation.superclass = BinaryOperation.prototype;

function EqualsOperation(lhs, rhs) {
	if (arguments.length &gt; 0) {
		this.init(lhs, rhs);
	}
}

EqualsOperation.prototype.init = function(lhs, rhs) {
	EqualsOperation.superclass.init.call(this, lhs, rhs);
};

EqualsOperation.prototype.toString = function() {
	return &quot;(&quot; + this.lhs.toString() + &quot; = &quot; + this.rhs.toString() + &quot;)&quot;;
};

EqualsOperation.prototype.evaluate = function(c) {
	return this.lhs.evaluate(c).equals(this.rhs.evaluate(c));
};

// NotEqualOperation /////////////////////////////////////////////////////////

NotEqualOperation.prototype = new BinaryOperation();
NotEqualOperation.prototype.constructor = NotEqualOperation;
NotEqualOperation.superclass = BinaryOperation.prototype;

function NotEqualOperation(lhs, rhs) {
	if (arguments.length &gt; 0) {
		this.init(lhs, rhs);
	}
}

NotEqualOperation.prototype.init = function(lhs, rhs) {
	NotEqualOperation.superclass.init.call(this, lhs, rhs);
};

NotEqualOperation.prototype.toString = function() {
	return &quot;(&quot; + this.lhs.toString() + &quot; != &quot; + this.rhs.toString() + &quot;)&quot;;
};

NotEqualOperation.prototype.evaluate = function(c) {
	return this.lhs.evaluate(c).notequal(this.rhs.evaluate(c));
};

// LessThanOperation /////////////////////////////////////////////////////////

LessThanOperation.prototype = new BinaryOperation();
LessThanOperation.prototype.constructor = LessThanOperation;
LessThanOperation.superclass = BinaryOperation.prototype;

function LessThanOperation(lhs, rhs) {
	if (arguments.length &gt; 0) {
		this.init(lhs, rhs);
	}
}

LessThanOperation.prototype.init = function(lhs, rhs) {
	LessThanOperation.superclass.init.call(this, lhs, rhs);
};

LessThanOperation.prototype.evaluate = function(c) {
	return this.lhs.evaluate(c).lessthan(this.rhs.evaluate(c));
};

LessThanOperation.prototype.toString = function() {
	return &quot;(&quot; + this.lhs.toString() + &quot; &lt; &quot; + this.rhs.toString() + &quot;)&quot;;
};

// GreaterThanOperation //////////////////////////////////////////////////////

GreaterThanOperation.prototype = new BinaryOperation();
GreaterThanOperation.prototype.constructor = GreaterThanOperation;
GreaterThanOperation.superclass = BinaryOperation.prototype;

function GreaterThanOperation(lhs, rhs) {
	if (arguments.length &gt; 0) {
		this.init(lhs, rhs);
	}
}

GreaterThanOperation.prototype.init = function(lhs, rhs) {
	GreaterThanOperation.superclass.init.call(this, lhs, rhs);
};

GreaterThanOperation.prototype.evaluate = function(c) {
	return this.lhs.evaluate(c).greaterthan(this.rhs.evaluate(c));
};

GreaterThanOperation.prototype.toString = function() {
	return &quot;(&quot; + this.lhs.toString() + &quot; &gt; &quot; + this.rhs.toString() + &quot;)&quot;;
};

// LessThanOrEqualOperation //////////////////////////////////////////////////

LessThanOrEqualOperation.prototype = new BinaryOperation();
LessThanOrEqualOperation.prototype.constructor = LessThanOrEqualOperation;
LessThanOrEqualOperation.superclass = BinaryOperation.prototype;

function LessThanOrEqualOperation(lhs, rhs) {
	if (arguments.length &gt; 0) {
		this.init(lhs, rhs);
	}
}

LessThanOrEqualOperation.prototype.init = function(lhs, rhs) {
	LessThanOrEqualOperation.superclass.init.call(this, lhs, rhs);
};

LessThanOrEqualOperation.prototype.evaluate = function(c) {
	return this.lhs.evaluate(c).lessthanorequal(this.rhs.evaluate(c));
};

LessThanOrEqualOperation.prototype.toString = function() {
	return &quot;(&quot; + this.lhs.toString() + &quot; &lt;= &quot; + this.rhs.toString() + &quot;)&quot;;
};

// GreaterThanOrEqualOperation ///////////////////////////////////////////////

GreaterThanOrEqualOperation.prototype = new BinaryOperation();
GreaterThanOrEqualOperation.prototype.constructor = GreaterThanOrEqualOperation;
GreaterThanOrEqualOperation.superclass = BinaryOperation.prototype;

function GreaterThanOrEqualOperation(lhs, rhs) {
	if (arguments.length &gt; 0) {
		this.init(lhs, rhs);
	}
}

GreaterThanOrEqualOperation.prototype.init = function(lhs, rhs) {
	GreaterThanOrEqualOperation.superclass.init.call(this, lhs, rhs);
};

GreaterThanOrEqualOperation.prototype.evaluate = function(c) {
	return this.lhs.evaluate(c).greaterthanorequal(this.rhs.evaluate(c));
};

GreaterThanOrEqualOperation.prototype.toString = function() {
	return &quot;(&quot; + this.lhs.toString() + &quot; &gt;= &quot; + this.rhs.toString() + &quot;)&quot;;
};

// PlusOperation /////////////////////////////////////////////////////////////

PlusOperation.prototype = new BinaryOperation();
PlusOperation.prototype.constructor = PlusOperation;
PlusOperation.superclass = BinaryOperation.prototype;

function PlusOperation(lhs, rhs) {
	if (arguments.length &gt; 0) {
		this.init(lhs, rhs);
	}
}

PlusOperation.prototype.init = function(lhs, rhs) {
	PlusOperation.superclass.init.call(this, lhs, rhs);
};

PlusOperation.prototype.evaluate = function(c) {
	return this.lhs.evaluate(c).number().plus(this.rhs.evaluate(c).number());
};

PlusOperation.prototype.toString = function() {
	return &quot;(&quot; + this.lhs.toString() + &quot; + &quot; + this.rhs.toString() + &quot;)&quot;;
};

// MinusOperation ////////////////////////////////////////////////////////////

MinusOperation.prototype = new BinaryOperation();
MinusOperation.prototype.constructor = MinusOperation;
MinusOperation.superclass = BinaryOperation.prototype;

function MinusOperation(lhs, rhs) {
	if (arguments.length &gt; 0) {
		this.init(lhs, rhs);
	}
}

MinusOperation.prototype.init = function(lhs, rhs) {
	MinusOperation.superclass.init.call(this, lhs, rhs);
};

MinusOperation.prototype.evaluate = function(c) {
	return this.lhs.evaluate(c).number().minus(this.rhs.evaluate(c).number());
};

MinusOperation.prototype.toString = function() {
	return &quot;(&quot; + this.lhs.toString() + &quot; - &quot; + this.rhs.toString() + &quot;)&quot;;
};

// MultiplyOperation /////////////////////////////////////////////////////////

MultiplyOperation.prototype = new BinaryOperation();
MultiplyOperation.prototype.constructor = MultiplyOperation;
MultiplyOperation.superclass = BinaryOperation.prototype;

function MultiplyOperation(lhs, rhs) {
	if (arguments.length &gt; 0) {
		this.init(lhs, rhs);
	}
}

MultiplyOperation.prototype.init = function(lhs, rhs) {
	MultiplyOperation.superclass.init.call(this, lhs, rhs);
};

MultiplyOperation.prototype.evaluate = function(c) {
	return this.lhs.evaluate(c).number().multiply(this.rhs.evaluate(c).number());
};

MultiplyOperation.prototype.toString = function() {
	return &quot;(&quot; + this.lhs.toString() + &quot; * &quot; + this.rhs.toString() + &quot;)&quot;;
};

// DivOperation //////////////////////////////////////////////////////////////

DivOperation.prototype = new BinaryOperation();
DivOperation.prototype.constructor = DivOperation;
DivOperation.superclass = BinaryOperation.prototype;

function DivOperation(lhs, rhs) {
	if (arguments.length &gt; 0) {
		this.init(lhs, rhs);
	}
}

DivOperation.prototype.init = function(lhs, rhs) {
	DivOperation.superclass.init.call(this, lhs, rhs);
};

DivOperation.prototype.evaluate = function(c) {
	return this.lhs.evaluate(c).number().div(this.rhs.evaluate(c).number());
};

DivOperation.prototype.toString = function() {
	return &quot;(&quot; + this.lhs.toString() + &quot; div &quot; + this.rhs.toString() + &quot;)&quot;;
};

// ModOperation //////////////////////////////////////////////////////////////

ModOperation.prototype = new BinaryOperation();
ModOperation.prototype.constructor = ModOperation;
ModOperation.superclass = BinaryOperation.prototype;

function ModOperation(lhs, rhs) {
	if (arguments.length &gt; 0) {
		this.init(lhs, rhs);
	}
}

ModOperation.prototype.init = function(lhs, rhs) {
	ModOperation.superclass.init.call(this, lhs, rhs);
};

ModOperation.prototype.evaluate = function(c) {
	return this.lhs.evaluate(c).number().mod(this.rhs.evaluate(c).number());
};

ModOperation.prototype.toString = function() {
	return &quot;(&quot; + this.lhs.toString() + &quot; mod &quot; + this.rhs.toString() + &quot;)&quot;;
};

// BarOperation //////////////////////////////////////////////////////////////

BarOperation.prototype = new BinaryOperation();
BarOperation.prototype.constructor = BarOperation;
BarOperation.superclass = BinaryOperation.prototype;

function BarOperation(lhs, rhs) {
	if (arguments.length &gt; 0) {
		this.init(lhs, rhs);
	}
}

BarOperation.prototype.init = function(lhs, rhs) {
	BarOperation.superclass.init.call(this, lhs, rhs);
};

BarOperation.prototype.evaluate = function(c) {
	return this.lhs.evaluate(c).nodeset().union(this.rhs.evaluate(c).nodeset());
};

BarOperation.prototype.toString = function() {
	return this.lhs.toString() + &quot; | &quot; + this.rhs.toString();
};

// PathExpr //////////////////////////////////////////////////////////////////

PathExpr.prototype = new Expression();
PathExpr.prototype.constructor = PathExpr;
PathExpr.superclass = Expression.prototype;

function PathExpr(filter, filterPreds, locpath) {
	if (arguments.length &gt; 0) {
		this.init(filter, filterPreds, locpath);
	}
}

PathExpr.prototype.init = function(filter, filterPreds, locpath) {
	PathExpr.superclass.init.call(this);
	this.filter = filter;
	this.filterPredicates = filterPreds;
	this.locationPath = locpath;
};

PathExpr.prototype.evaluate = function(c) {
	var nodes;
	var xpc = new XPathContext();
	xpc.variableResolver = c.variableResolver;
	xpc.functionResolver = c.functionResolver;
	xpc.namespaceResolver = c.namespaceResolver;
	xpc.expressionContextNode = c.expressionContextNode;
	xpc.virtualRoot = c.virtualRoot;
	xpc.caseInsensitive = c.caseInsensitive;
	if (this.filter == null) {
		nodes = [ c.contextNode ];
	} else {
		var ns = this.filter.evaluate(c);
		if (!Utilities.instance_of(ns, XNodeSet)) {
			if (this.filterPredicates != null &amp;&amp; this.filterPredicates.length &gt; 0 || this.locationPath != null) {
				throw new Error(&quot;Path expression filter must evaluate to a nodset if predicates or location path are used&quot;);
			}
			return ns;
		}
		nodes = ns.toArray();
		if (this.filterPredicates != null) {
			// apply each of the predicates in turn
			for (var j = 0; j &lt; this.filterPredicates.length; j++) {
				var pred = this.filterPredicates[j];
				var newNodes = [];
				xpc.contextSize = nodes.length;
				for (xpc.contextPosition = 1; xpc.contextPosition &lt;= xpc.contextSize; xpc.contextPosition++) {
					xpc.contextNode = nodes[xpc.contextPosition - 1];
					if (this.predicateMatches(pred, xpc)) {
						newNodes.push(xpc.contextNode);
					}
				}
				nodes = newNodes;
			}
		}
	}
	if (this.locationPath != null) {
		if (this.locationPath.absolute) {
			if (nodes[0].nodeType != 9 /*Node.DOCUMENT_NODE*/) {
				if (xpc.virtualRoot != null) {
					nodes = [ xpc.virtualRoot ];
				} else {
					if (nodes[0].ownerDocument == null) {
						// IE 5.5 doesn&#039;t have ownerDocument?
						var n = nodes[0];
						while (n.parentNode != null) {
							n = n.parentNode;
						}
						nodes = [ n ];
					} else {
						nodes = [ nodes[0].ownerDocument ];
					}
				}
			} else {
				nodes = [ nodes[0] ];
			}
		}
		for (var i = 0; i &lt; this.locationPath.steps.length; i++) {
			var step = this.locationPath.steps[i];
			var newNodes = [];
			for (var j = 0; j &lt; nodes.length; j++) {
				xpc.contextNode = nodes[j];
				switch (step.axis) {
					case Step.ANCESTOR:
						// look at all the ancestor nodes
						if (xpc.contextNode === xpc.virtualRoot) {
							break;
						}
						var m;
						if (xpc.contextNode.nodeType == 2 /*Node.ATTRIBUTE_NODE*/) {
							m = this.getOwnerElement(xpc.contextNode);
						} else {
							m = xpc.contextNode.parentNode;
						}
						while (m != null) {
							if (step.nodeTest.matches(m, xpc)) {
								newNodes.push(m);
							}
							if (m === xpc.virtualRoot) {
								break;
							}
							m = m.parentNode;
						}
						break;

					case Step.ANCESTORORSELF:
						// look at all the ancestor nodes and the current node
						for (var m = xpc.contextNode; m != null; m = m.nodeType == 2 /*Node.ATTRIBUTE_NODE*/ ? this.getOwnerElement(m) : m.parentNode) {
							if (step.nodeTest.matches(m, xpc)) {
								newNodes.push(m);
							}
							if (m === xpc.virtualRoot) {
								break;
							}
						}
						break;

					case Step.ATTRIBUTE:
						// look at the attributes
						var nnm = xpc.contextNode.attributes;
						if (nnm != null) {
							for (var k = 0; k &lt; nnm.length; k++) {
								var m = nnm.item(k);
								if (step.nodeTest.matches(m, xpc)) {
									newNodes.push(m);
								}
							}
						}
						break;

					case Step.CHILD:
						// look at all child elements
						for (var m = xpc.contextNode.firstChild; m != null; m = m.nextSibling) {
							if (step.nodeTest.matches(m, xpc)) {
								newNodes.push(m);
							}
						}
						break;

					case Step.DESCENDANT:
						// look at all descendant nodes
						var st = [ xpc.contextNode.firstChild ];
						while (st.length &gt; 0) {
							for (var m = st.pop(); m != null; ) {
								if (step.nodeTest.matches(m, xpc)) {
									newNodes.push(m);
								}
								if (m.firstChild != null) {
									st.push(m.nextSibling);
									m = m.firstChild;
								} else {
									m = m.nextSibling;
								}
							}
						}
						break;

					case Step.DESCENDANTORSELF:
						// look at self
						if (step.nodeTest.matches(xpc.contextNode, xpc)) {
							newNodes.push(xpc.contextNode);
						}
						// look at all descendant nodes
						var st = [ xpc.contextNode.firstChild ];
						while (st.length &gt; 0) {
							for (var m = st.pop(); m != null; ) {
								if (step.nodeTest.matches(m, xpc)) {
									newNodes.push(m);
								}
								if (m.firstChild != null) {
									st.push(m.nextSibling);
									m = m.firstChild;
								} else {
									m = m.nextSibling;
								}
							}
						}
						break;

					case Step.FOLLOWING:
						if (xpc.contextNode === xpc.virtualRoot) {
							break;
						}
						var st = [];
						if (xpc.contextNode.firstChild != null) {
							st.unshift(xpc.contextNode.firstChild);
						} else {
							st.unshift(xpc.contextNode.nextSibling);
						}
						for (var m = xpc.contextNode.parentNode; m != null &amp;&amp; m.nodeType != 9 /*Node.DOCUMENT_NODE*/ &amp;&amp; m !== xpc.virtualRoot; m = m.parentNode) {
							st.unshift(m.nextSibling);
						}
						do {
							for (var m = st.pop(); m != null; ) {
								if (step.nodeTest.matches(m, xpc)) {
									newNodes.push(m);
								}
								if (m.firstChild != null) {
									st.push(m.nextSibling);
									m = m.firstChild;
								} else {
									m = m.nextSibling;
								}
							}
						} while (st.length &gt; 0);
						break;

					case Step.FOLLOWINGSIBLING:
						if (xpc.contextNode === xpc.virtualRoot) {
							break;
						}
						for (var m = xpc.contextNode.nextSibling; m != null; m = m.nextSibling) {
							if (step.nodeTest.matches(m, xpc)) {
								newNodes.push(m);
							}
						}
						break;

					case Step.NAMESPACE:
						var n = {};
						if (xpc.contextNode.nodeType == 1 /*Node.ELEMENT_NODE*/) {
							n[&quot;xml&quot;] = XPath.XML_NAMESPACE_URI;
							n[&quot;xmlns&quot;] = XPath.XMLNS_NAMESPACE_URI;
							for (var m = xpc.contextNode; m != null &amp;&amp; m.nodeType == 1 /*Node.ELEMENT_NODE*/; m = m.parentNode) {
								for (var k = 0; k &lt; m.attributes.length; k++) {
									var attr = m.attributes.item(k);
									var nm = String(attr.name);
									if (nm == &quot;xmlns&quot;) {
										if (n[&quot;&quot;] == undefined) {
											n[&quot;&quot;] = attr.value;
										}
									} else if (nm.length &gt; 6 &amp;&amp; nm.substring(0, 6) == &quot;xmlns:&quot;) {
										var pre = nm.substring(6, nm.length);
										if (n[pre] == undefined) {
											n[pre] = attr.value;
										}
									}
								}
							}
							for (var pre in n) {
								var nsn = new NamespaceNode(pre, n[pre], xpc.contextNode);
								if (step.nodeTest.matches(nsn, xpc)) {
									newNodes.push(nsn);
								}
							}
						}
						break;

					case Step.PARENT:
						m = null;
						if (xpc.contextNode !== xpc.virtualRoot) {
							if (xpc.contextNode.nodeType == 2 /*Node.ATTRIBUTE_NODE*/) {
								m = this.getOwnerElement(xpc.contextNode);
							} else {
								m = xpc.contextNode.parentNode;
							}
						}
						if (m != null &amp;&amp; step.nodeTest.matches(m, xpc)) {
							newNodes.push(m);
						}
						break;

					case Step.PRECEDING:
						var st;
						if (xpc.virtualRoot != null) {
							st = [ xpc.virtualRoot ];
						} else {
							st = xpc.contextNode.nodeType == 9 /*Node.DOCUMENT_NODE*/
								? [ xpc.contextNode ]
								: [ xpc.contextNode.ownerDocument ];
						}
						outer: while (st.length &gt; 0) {
							for (var m = st.pop(); m != null; ) {
								if (m == xpc.contextNode) {
									break outer;
								}
								if (step.nodeTest.matches(m, xpc)) {
									newNodes.unshift(m);
								}
								if (m.firstChild != null) {
									st.push(m.nextSibling);
									m = m.firstChild;
								} else {
									m = m.nextSibling;
								}
							}
						}
						break;

					case Step.PRECEDINGSIBLING:
						if (xpc.contextNode === xpc.virtualRoot) {
							break;
						}
						for (var m = xpc.contextNode.previousSibling; m != null; m = m.previousSibling) {
							if (step.nodeTest.matches(m, xpc)) {
								newNodes.push(m);
							}
						}
						break;

					case Step.SELF:
						if (step.nodeTest.matches(xpc.contextNode, xpc)) {
							newNodes.push(xpc.contextNode);
						}
						break;

					default:
				}
			}
			nodes = newNodes;
			// apply each of the predicates in turn
			for (var j = 0; j &lt; step.predicates.length; j++) {
				var pred = step.predicates[j];
				var newNodes = [];
				xpc.contextSize = nodes.length;
				for (xpc.contextPosition = 1; xpc.contextPosition &lt;= xpc.contextSize; xpc.contextPosition++) {
					xpc.contextNode = nodes[xpc.contextPosition - 1];
					if (this.predicateMatches(pred, xpc)) {
						newNodes.push(xpc.contextNode);
					} else {
					}
				}
				nodes = newNodes;
			}
		}
	}
	var ns = new XNodeSet();
	ns.addArray(nodes);
	return ns;
};

PathExpr.prototype.predicateMatches = function(pred, c) {
	var res = pred.evaluate(c);
	if (Utilities.instance_of(res, XNumber)) {
		return c.contextPosition == res.numberValue();
	}
	return res.booleanValue();
};

PathExpr.prototype.toString = function() {
	if (this.filter != undefined) {
		var s = this.filter.toString();
		if (Utilities.instance_of(this.filter, XString)) {
			s = &quot;&#039;&quot; + s + &quot;&#039;&quot;;
		}
		if (this.filterPredicates != undefined) {
			for (var i = 0; i &lt; this.filterPredicates.length; i++) {
				s = s + &quot;[&quot; + this.filterPredicates[i].toString() + &quot;]&quot;;
			}
		}
		if (this.locationPath != undefined) {
			if (!this.locationPath.absolute) {
				s += &quot;/&quot;;
			}
			s += this.locationPath.toString();
		}
		return s;
	}
	return this.locationPath.toString();
};

PathExpr.prototype.getOwnerElement = function(n) {
	// DOM 2 has ownerElement
	if (n.ownerElement) {
		return n.ownerElement;
	}
	// DOM 1 Internet Explorer can use selectSingleNode (ironically)
	try {
		if (n.selectSingleNode) {
			return n.selectSingleNode(&quot;..&quot;);
		}
	} catch (e) {
	}
	// Other DOM 1 implementations must use this egregious search
	var doc = n.nodeType == 9 /*Node.DOCUMENT_NODE*/
			? n
			: n.ownerDocument;
	var elts = doc.getElementsByTagName(&quot;*&quot;);
	for (var i = 0; i &lt; elts.length; i++) {
		var elt = elts.item(i);
		var nnm = elt.attributes;
		for (var j = 0; j &lt; nnm.length; j++) {
			var an = nnm.item(j);
			if (an === n) {
				return elt;
			}
		}
	}
	return null;
};

// LocationPath //////////////////////////////////////////////////////////////

LocationPath.prototype = new Object();
LocationPath.prototype.constructor = LocationPath;
LocationPath.superclass = Object.prototype;

function LocationPath(abs, steps) {
	if (arguments.length &gt; 0) {
		this.init(abs, steps);
	}
}

LocationPath.prototype.init = function(abs, steps) {
	this.absolute = abs;
	this.steps = steps;
};

LocationPath.prototype.toString = function() {
	var s;
	if (this.absolute) {
		s = &quot;/&quot;;
	} else {
		s = &quot;&quot;;
	}
	for (var i = 0; i &lt; this.steps.length; i++) {
		if (i != 0) {
			s += &quot;/&quot;;
		}
		s += this.steps[i].toString();
	}
	return s;
};

// Step //////////////////////////////////////////////////////////////////////

Step.prototype = new Object();
Step.prototype.constructor = Step;
Step.superclass = Object.prototype;

function Step(axis, nodetest, preds) {
	if (arguments.length &gt; 0) {
		this.init(axis, nodetest, preds);
	}
}

Step.prototype.init = function(axis, nodetest, preds) {
	this.axis = axis;
	this.nodeTest = nodetest;
	this.predicates = preds;
};

Step.prototype.toString = function() {
	var s;
	switch (this.axis) {
		case Step.ANCESTOR:
			s = &quot;ancestor&quot;;
			break;
		case Step.ANCESTORORSELF:
			s = &quot;ancestor-or-self&quot;;
			break;
		case Step.ATTRIBUTE:
			s = &quot;attribute&quot;;
			break;
		case Step.CHILD:
			s = &quot;child&quot;;
			break;
		case Step.DESCENDANT:
			s = &quot;descendant&quot;;
			break;
		case Step.DESCENDANTORSELF:
			s = &quot;descendant-or-self&quot;;
			break;
		case Step.FOLLOWING:
			s = &quot;following&quot;;
			break;
		case Step.FOLLOWINGSIBLING:
			s = &quot;following-sibling&quot;;
			break;
		case Step.NAMESPACE:
			s = &quot;namespace&quot;;
			break;
		case Step.PARENT:
			s = &quot;parent&quot;;
			break;
		case Step.PRECEDING:
			s = &quot;preceding&quot;;
			break;
		case Step.PRECEDINGSIBLING:
			s = &quot;preceding-sibling&quot;;
			break;
		case Step.SELF:
			s = &quot;self&quot;;
			break;
	}
	s += &quot;::&quot;;
	s += this.nodeTest.toString();
	for (var i = 0; i &lt; this.predicates.length; i++) {
		s += &quot;[&quot; + this.predicates[i].toString() + &quot;]&quot;;
	}
	return s;
};

Step.ANCESTOR = 0;
Step.ANCESTORORSELF = 1;
Step.ATTRIBUTE = 2;
Step.CHILD = 3;
Step.DESCENDANT = 4;
Step.DESCENDANTORSELF = 5;
Step.FOLLOWING = 6;
Step.FOLLOWINGSIBLING = 7;
Step.NAMESPACE = 8;
Step.PARENT = 9;
Step.PRECEDING = 10;
Step.PRECEDINGSIBLING = 11;
Step.SELF = 12;

// NodeTest //////////////////////////////////////////////////////////////////

NodeTest.prototype = new Object();
NodeTest.prototype.constructor = NodeTest;
NodeTest.superclass = Object.prototype;

function NodeTest(type, value) {
	if (arguments.length &gt; 0) {
		this.init(type, value);
	}
}

NodeTest.prototype.init = function(type, value) {
	this.type = type;
	this.value = value;
};

NodeTest.prototype.toString = function() {
	switch (this.type) {
		case NodeTest.NAMETESTANY:
			return &quot;*&quot;;
		case NodeTest.NAMETESTPREFIXANY:
			return this.value + &quot;:*&quot;;
		case NodeTest.NAMETESTRESOLVEDANY:
			return &quot;{&quot; + this.value + &quot;}*&quot;;
		case NodeTest.NAMETESTQNAME:
			return this.value;
		case NodeTest.NAMETESTRESOLVEDNAME:
			return &quot;{&quot; + this.namespaceURI + &quot;}&quot; + this.value;
		case NodeTest.COMMENT:
			return &quot;comment()&quot;;
		case NodeTest.TEXT:
			return &quot;text()&quot;;
		case NodeTest.PI:
			if (this.value != undefined) {
				return &quot;processing-instruction(\&quot;&quot; + this.value + &quot;\&quot;)&quot;;
			}
			return &quot;processing-instruction()&quot;;
		case NodeTest.NODE:
			return &quot;node()&quot;;
	}
	return &quot;&lt;unknown nodetest type&gt;&quot;;
};

NodeTest.prototype.matches = function(n, xpc) {
	switch (this.type) {
		case NodeTest.NAMETESTANY:
			if (n.nodeType == 2 /*Node.ATTRIBUTE_NODE*/
					|| n.nodeType == 1 /*Node.ELEMENT_NODE*/
					|| n.nodeType == XPathNamespace.XPATH_NAMESPACE_NODE) {
				return true;
			}
			return false;
		case NodeTest.NAMETESTPREFIXANY:
			if ((n.nodeType == 2 /*Node.ATTRIBUTE_NODE*/ || n.nodeType == 1 /*Node.ELEMENT_NODE*/)) {
				var ns = xpc.namespaceResolver.getNamespace(this.value, xpc.expressionContextNode);
				if (ns == null) {
					throw new Error(&quot;Cannot resolve QName &quot; + this.value);
				}
				return ns == (n.namespaceURI || &#039;&#039;);
			}
			return false;
		case NodeTest.NAMETESTQNAME:
			if (n.nodeType == 2 /*Node.ATTRIBUTE_NODE*/
					|| n.nodeType == 1 /*Node.ELEMENT_NODE*/
					|| n.nodeType == XPathNamespace.XPATH_NAMESPACE_NODE) {
				var test = Utilities.resolveQName(this.value, xpc.namespaceResolver, xpc.expressionContextNode, false);
				if (test[0] == null) {
					throw new Error(&quot;Cannot resolve QName &quot; + this.value);
				}
				test[0] = String(test[0]);
				test[1] = String(test[1]);
				if (test[0] == &quot;&quot;) {
					test[0] = null;
				}
				var node = [n.namespaceURI || &#039;&#039;, n.localName];
				node[0] = String(node[0]);
				node[1] = String(node[1]);
				if (node[0] == &quot;&quot;) {
					node[0] = null;
				}
				if (xpc.caseInsensitive) {
					return test[0] == node[0] &amp;&amp; String(test[1]).toLowerCase() == String(node[1]).toLowerCase();
				}
				return test[0] == node[0] &amp;&amp; test[1] == node[1];
			}
			return false;
		case NodeTest.COMMENT:
			return n.nodeType == 8 /*Node.COMMENT_NODE*/;
		case NodeTest.TEXT:
			return n.nodeType == 3 /*Node.TEXT_NODE*/ || n.nodeType == 4 /*Node.CDATA_SECTION_NODE*/;
		case NodeTest.PI:
			return n.nodeType == 7 /*Node.PROCESSING_INSTRUCTION_NODE*/
				&amp;&amp; (this.value == null || n.nodeName == this.value);
		case NodeTest.NODE:
			return n.nodeType == 9 /*Node.DOCUMENT_NODE*/
				|| n.nodeType == 1 /*Node.ELEMENT_NODE*/
				|| n.nodeType == 2 /*Node.ATTRIBUTE_NODE*/
				|| n.nodeType == 3 /*Node.TEXT_NODE*/
				|| n.nodeType == 4 /*Node.CDATA_SECTION_NODE*/
				|| n.nodeType == 8 /*Node.COMMENT_NODE*/
				|| n.nodeType == 7 /*Node.PROCESSING_INSTRUCTION_NODE*/;
	}
	return false;
};

NodeTest.NAMETESTANY = 0;
NodeTest.NAMETESTPREFIXANY = 1;
NodeTest.NAMETESTQNAME = 2;
NodeTest.COMMENT = 3;
NodeTest.TEXT = 4;
NodeTest.PI = 5;
NodeTest.NODE = 6;

// VariableReference /////////////////////////////////////////////////////////

VariableReference.prototype = new Expression();
VariableReference.prototype.constructor = VariableReference;
VariableReference.superclass = Expression.prototype;

function VariableReference(v) {
	if (arguments.length &gt; 0) {
		this.init(v);
	}
}

VariableReference.prototype.init = function(v) {
	this.variable = v;
};

VariableReference.prototype.toString = function() {
	return &quot;$&quot; + this.variable;
};

VariableReference.prototype.evaluate = function(c) {
	return c.variableResolver.getVariable(this.variable, c);
};

// FunctionCall //////////////////////////////////////////////////////////////

FunctionCall.prototype = new Expression();
FunctionCall.prototype.constructor = FunctionCall;
FunctionCall.superclass = Expression.prototype;

function FunctionCall(fn, args) {
	if (arguments.length &gt; 0) {
		this.init(fn, args);
	}
}

FunctionCall.prototype.init = function(fn, args) {
	this.functionName = fn;
	this.arguments = args;
};

FunctionCall.prototype.toString = function() {
	var s = this.functionName + &quot;(&quot;;
	for (var i = 0; i &lt; this.arguments.length; i++) {
		if (i &gt; 0) {
			s += &quot;, &quot;;
		}
		s += this.arguments[i].toString();
	}
	return s + &quot;)&quot;;
};

FunctionCall.prototype.evaluate = function(c) {
	var f = c.functionResolver.getFunction(this.functionName, c);
	if (f == undefined) {
		throw new Error(&quot;Unknown function &quot; + this.functionName);
	}
	var a = [c].concat(this.arguments);
	return f.apply(c.functionResolver.thisArg, a);
};

// XString ///////////////////////////////////////////////////////////////////

XString.prototype = new Expression();
XString.prototype.constructor = XString;
XString.superclass = Expression.prototype;

function XString(s) {
	if (arguments.length &gt; 0) {
		this.init(s);
	}
}

XString.prototype.init = function(s) {
	this.str = s;
};

XString.prototype.toString = function() {
	return this.str;
};

XString.prototype.evaluate = function(c) {
	return this;
};

XString.prototype.string = function() {
	return this;
};

XString.prototype.number = function() {
	return new XNumber(this.str);
};

XString.prototype.bool = function() {
	return new XBoolean(this.str);
};

XString.prototype.nodeset = function() {
	throw new Error(&quot;Cannot convert string to nodeset&quot;);
};

XString.prototype.stringValue = function() {
	return this.str;
};

XString.prototype.numberValue = function() {
	return this.number().numberValue();
};

XString.prototype.booleanValue = function() {
	return this.bool().booleanValue();
};

XString.prototype.equals = function(r) {
	if (Utilities.instance_of(r, XBoolean)) {
		return this.bool().equals(r);
	}
	if (Utilities.instance_of(r, XNumber)) {
		return this.number().equals(r);
	}
	if (Utilities.instance_of(r, XNodeSet)) {
		return r.compareWithString(this, Operators.equals);
	}
	return new XBoolean(this.str == r.str);
};

XString.prototype.notequal = function(r) {
	if (Utilities.instance_of(r, XBoolean)) {
		return this.bool().notequal(r);
	}
	if (Utilities.instance_of(r, XNumber)) {
		return this.number().notequal(r);
	}
	if (Utilities.instance_of(r, XNodeSet)) {
		return r.compareWithString(this, Operators.notequal);
	}
	return new XBoolean(this.str != r.str);
};

XString.prototype.lessthan = function(r) {
	if (Utilities.instance_of(r, XNodeSet)) {
		return r.compareWithNumber(this.number(), Operators.greaterthanorequal);
	}
	return this.number().lessthan(r.number());
};

XString.prototype.greaterthan = function(r) {
	if (Utilities.instance_of(r, XNodeSet)) {
		return r.compareWithNumber(this.number(), Operators.lessthanorequal);
	}
	return this.number().greaterthan(r.number());
};

XString.prototype.lessthanorequal = function(r) {
	if (Utilities.instance_of(r, XNodeSet)) {
		return r.compareWithNumber(this.number(), Operators.greaterthan);
	}
	return this.number().lessthanorequal(r.number());
};

XString.prototype.greaterthanorequal = function(r) {
	if (Utilities.instance_of(r, XNodeSet)) {
		return r.compareWithNumber(this.number(), Operators.lessthan);
	}
	return this.number().greaterthanorequal(r.number());
};

// XNumber ///////////////////////////////////////////////////////////////////

XNumber.prototype = new Expression();
XNumber.prototype.constructor = XNumber;
XNumber.superclass = Expression.prototype;

function XNumber(n) {
	if (arguments.length &gt; 0) {
		this.init(n);
	}
}

XNumber.prototype.init = function(n) {
	this.num = Number(n);
};

XNumber.prototype.toString = function() {
	return this.num;
};

XNumber.prototype.evaluate = function(c) {
	return this;
};

XNumber.prototype.string = function() {
	return new XString(this.num);
};

XNumber.prototype.number = function() {
	return this;
};

XNumber.prototype.bool = function() {
	return new XBoolean(this.num);
};

XNumber.prototype.nodeset = function() {
	throw new Error(&quot;Cannot convert number to nodeset&quot;);
};

XNumber.prototype.stringValue = function() {
	return this.string().stringValue();
};

XNumber.prototype.numberValue = function() {
	return this.num;
};

XNumber.prototype.booleanValue = function() {
	return this.bool().booleanValue();
};

XNumber.prototype.negate = function() {
	return new XNumber(-this.num);
};

XNumber.prototype.equals = function(r) {
	if (Utilities.instance_of(r, XBoolean)) {
		return this.bool().equals(r);
	}
	if (Utilities.instance_of(r, XString)) {
		return this.equals(r.number());
	}
	if (Utilities.instance_of(r, XNodeSet)) {
		return r.compareWithNumber(this, Operators.equals);
	}
	return new XBoolean(this.num == r.num);
};

XNumber.prototype.notequal = function(r) {
	if (Utilities.instance_of(r, XBoolean)) {
		return this.bool().notequal(r);
	}
	if (Utilities.instance_of(r, XString)) {
		return this.notequal(r.number());
	}
	if (Utilities.instance_of(r, XNodeSet)) {
		return r.compareWithNumber(this, Operators.notequal);
	}
	return new XBoolean(this.num != r.num);
};

XNumber.prototype.lessthan = function(r) {
	if (Utilities.instance_of(r, XNodeSet)) {
		return r.compareWithNumber(this, Operators.greaterthanorequal);
	}
	if (Utilities.instance_of(r, XBoolean) || Utilities.instance_of(r, XString)) {
		return this.lessthan(r.number());
	}
	return new XBoolean(this.num &lt; r.num);
};

XNumber.prototype.greaterthan = function(r) {
	if (Utilities.instance_of(r, XNodeSet)) {
		return r.compareWithNumber(this, Operators.lessthanorequal);
	}
	if (Utilities.instance_of(r, XBoolean) || Utilities.instance_of(r, XString)) {
		return this.greaterthan(r.number());
	}
	return new XBoolean(this.num &gt; r.num);
};

XNumber.prototype.lessthanorequal = function(r) {
	if (Utilities.instance_of(r, XNodeSet)) {
		return r.compareWithNumber(this, Operators.greaterthan);
	}
	if (Utilities.instance_of(r, XBoolean) || Utilities.instance_of(r, XString)) {
		return this.lessthanorequal(r.number());
	}
	return new XBoolean(this.num &lt;= r.num);
};

XNumber.prototype.greaterthanorequal = function(r) {
	if (Utilities.instance_of(r, XNodeSet)) {
		return r.compareWithNumber(this, Operators.lessthan);
	}
	if (Utilities.instance_of(r, XBoolean) || Utilities.instance_of(r, XString)) {
		return this.greaterthanorequal(r.number());
	}
	return new XBoolean(this.num &gt;= r.num);
};

XNumber.prototype.plus = function(r) {
	return new XNumber(this.num + r.num);
};

XNumber.prototype.minus = function(r) {
	return new XNumber(this.num - r.num);
};

XNumber.prototype.multiply = function(r) {
	return new XNumber(this.num * r.num);
};

XNumber.prototype.div = function(r) {
	return new XNumber(this.num / r.num);
};

XNumber.prototype.mod = function(r) {
	return new XNumber(this.num % r.num);
};

// XBoolean //////////////////////////////////////////////////////////////////

XBoolean.prototype = new Expression();
XBoolean.prototype.constructor = XBoolean;
XBoolean.superclass = Expression.prototype;

function XBoolean(b) {
	if (arguments.length &gt; 0) {
		this.init(b);
	}
}

XBoolean.prototype.init = function(b) {
	this.b = Boolean(b);
};

XBoolean.prototype.toString = function() {
	return this.b.toString();
};

XBoolean.prototype.evaluate = function(c) {
	return this;
};

XBoolean.prototype.string = function() {
	return new XString(this.b);
};

XBoolean.prototype.number = function() {
	return new XNumber(this.b);
};

XBoolean.prototype.bool = function() {
	return this;
};

XBoolean.prototype.nodeset = function() {
	throw new Error(&quot;Cannot convert boolean to nodeset&quot;);
};

XBoolean.prototype.stringValue = function() {
	return this.string().stringValue();
};

XBoolean.prototype.numberValue = function() {
	return this.num().numberValue();
};

XBoolean.prototype.booleanValue = function() {
	return this.b;
};

XBoolean.prototype.not = function() {
	return new XBoolean(!this.b);
};

XBoolean.prototype.equals = function(r) {
	if (Utilities.instance_of(r, XString) || Utilities.instance_of(r, XNumber)) {
		return this.equals(r.bool());
	}
	if (Utilities.instance_of(r, XNodeSet)) {
		return r.compareWithBoolean(this, Operators.equals);
	}
	return new XBoolean(this.b == r.b);
};

XBoolean.prototype.notequal = function(r) {
	if (Utilities.instance_of(r, XString) || Utilities.instance_of(r, XNumber)) {
		return this.notequal(r.bool());
	}
	if (Utilities.instance_of(r, XNodeSet)) {
		return r.compareWithBoolean(this, Operators.notequal);
	}
	return new XBoolean(this.b != r.b);
};

XBoolean.prototype.lessthan = function(r) {
	if (Utilities.instance_of(r, XNodeSet)) {
		return r.compareWithNumber(this.number(), Operators.greaterthanorequal);
	}
	return this.number().lessthan(r.number());
};

XBoolean.prototype.greaterthan = function(r) {
	if (Utilities.instance_of(r, XNodeSet)) {
		return r.compareWithNumber(this.number(), Operators.lessthanorequal);
	}
	return this.number().greaterthan(r.number());
};

XBoolean.prototype.lessthanorequal = function(r) {
	if (Utilities.instance_of(r, XNodeSet)) {
		return r.compareWithNumber(this.number(), Operators.greaterthan);
	}
	return this.number().lessthanorequal(r.number());
};

XBoolean.prototype.greaterthanorequal = function(r) {
	if (Utilities.instance_of(r, XNodeSet)) {
		return r.compareWithNumber(this.number(), Operators.lessthan);
	}
	return this.number().greaterthanorequal(r.number());
};

// AVLTree ///////////////////////////////////////////////////////////////////

AVLTree.prototype = new Object();
AVLTree.prototype.constructor = AVLTree;
AVLTree.superclass = Object.prototype;

function AVLTree(n) {
	this.init(n);
}

AVLTree.prototype.init = function(n) {
	this.left = null;
    this.right = null;
	this.node = n;
	this.depth = 1;
};

AVLTree.prototype.balance = function() {
    var ldepth = this.left  == null ? 0 : this.left.depth;
    var rdepth = this.right == null ? 0 : this.right.depth;

	if (ldepth &gt; rdepth + 1) {
        // LR or LL rotation
        var lldepth = this.left.left  == null ? 0 : this.left.left.depth;
        var lrdepth = this.left.right == null ? 0 : this.left.right.depth;

        if (lldepth &lt; lrdepth) {
            // LR rotation consists of a RR rotation of the left child
            this.left.rotateRR();
            // plus a LL rotation of this node, which happens anyway
        }
        this.rotateLL();
    } else if (ldepth + 1 &lt; rdepth) {
        // RR or RL rorarion
		var rrdepth = this.right.right == null ? 0 : this.right.right.depth;
		var rldepth = this.right.left  == null ? 0 : this.right.left.depth;

        if (rldepth &gt; rrdepth) {
            // RR rotation consists of a LL rotation of the right child
            this.right.rotateLL();
            // plus a RR rotation of this node, which happens anyway
        }
        this.rotateRR();
    }
};

AVLTree.prototype.rotateLL = function() {
    // the left side is too long =&gt; rotate from the left (_not_ leftwards)
    var nodeBefore = this.node;
    var rightBefore = this.right;
    this.node = this.left.node;
    this.right = this.left;
    this.left = this.left.left;
    this.right.left = this.right.right;
    this.right.right = rightBefore;
    this.right.node = nodeBefore;
    this.right.updateInNewLocation();
    this.updateInNewLocation();
};

AVLTree.prototype.rotateRR = function() {
    // the right side is too long =&gt; rotate from the right (_not_ rightwards)
    var nodeBefore = this.node;
    var leftBefore = this.left;
    this.node = this.right.node;
    this.left = this.right;
    this.right = this.right.right;
    this.left.right = this.left.left;
    this.left.left = leftBefore;
    this.left.node = nodeBefore;
    this.left.updateInNewLocation();
    this.updateInNewLocation();
};

AVLTree.prototype.updateInNewLocation = function() {
    this.getDepthFromChildren();
};

AVLTree.prototype.getDepthFromChildren = function() {
    this.depth = this.node == null ? 0 : 1;
    if (this.left != null) {
        this.depth = this.left.depth + 1;
    }
    if (this.right != null &amp;&amp; this.depth &lt;= this.right.depth) {
        this.depth = this.right.depth + 1;
    }
};

AVLTree.prototype.order = function(n1, n2) {
	if (n1 === n2) {
		return 0;
	}
	var d1 = 0;
	var d2 = 0;
	for (var m1 = n1; m1 != null; m1 = m1.parentNode) {
		d1++;
	}
	for (var m2 = n2; m2 != null; m2 = m2.parentNode) {
		d2++;
	}
	if (d1 &gt; d2) {
		while (d1 &gt; d2) {
			n1 = n1.parentNode;
			d1--;
		}
		if (n1 == n2) {
			return 1;
		}
	} else if (d2 &gt; d1) {
		while (d2 &gt; d1) {
			n2 = n2.parentNode;
			d2--;
		}
		if (n1 == n2) {
			return -1;
		}
	}
	while (n1.parentNode != n2.parentNode) {
		n1 = n1.parentNode;
		n2 = n2.parentNode;
	}
	while (n1.previousSibling != null &amp;&amp; n2.previousSibling != null) {
		n1 = n1.previousSibling;
		n2 = n2.previousSibling;
	}
	if (n1.previousSibling == null) {
		return -1;
	}
	return 1;
};

AVLTree.prototype.add = function(n)  {
	if (n === this.node) {
        return false;
    }

	var o = this.order(n, this.node);

    var ret = false;
    if (o == -1) {
        if (this.left == null) {
            this.left = new AVLTree(n);
            ret = true;
        } else {
            ret = this.left.add(n);
            if (ret) {
                this.balance();
            }
        }
    } else if (o == 1) {
        if (this.right == null) {
            this.right = new AVLTree(n);
            ret = true;
        } else {
            ret = this.right.add(n);
            if (ret) {
                this.balance();
            }
        }
    }

    if (ret) {
        this.getDepthFromChildren();
    }
    return ret;
};

// XNodeSet //////////////////////////////////////////////////////////////////

XNodeSet.prototype = new Expression();
XNodeSet.prototype.constructor = XNodeSet;
XNodeSet.superclass = Expression.prototype;

function XNodeSet() {
	this.init();
}

XNodeSet.prototype.init = function() {
	this.tree = null;
	this.size = 0;
};

XNodeSet.prototype.toString = function() {
	var p = this.first();
	if (p == null) {
		return &quot;&quot;;
	}
	return this.stringForNode(p);
};

XNodeSet.prototype.evaluate = function(c) {
	return this;
};

XNodeSet.prototype.string = function() {
	return new XString(this.toString());
};

XNodeSet.prototype.stringValue = function() {
	return this.toString();
};

XNodeSet.prototype.number = function() {
	return new XNumber(this.string());
};

XNodeSet.prototype.numberValue = function() {
	return Number(this.string());
};

XNodeSet.prototype.bool = function() {
	return new XBoolean(this.tree != null);
};

XNodeSet.prototype.booleanValue = function() {
	return this.tree != null;
};

XNodeSet.prototype.nodeset = function() {
	return this;
};

XNodeSet.prototype.stringForNode = function(n) {
	if (n.nodeType == 9 /*Node.DOCUMENT_NODE*/) {
		n = n.documentElement;
	}
	if (n.nodeType == 1 /*Node.ELEMENT_NODE*/) {
		return this.stringForNodeRec(n);
	}
	if (n.isNamespaceNode) {
		return n.namespace;
	}
	return n.nodeValue;
};

XNodeSet.prototype.stringForNodeRec = function(n) {
	var s = &quot;&quot;;
	for (var n2 = n.firstChild; n2 != null; n2 = n2.nextSibling) {
		if (n2.nodeType == 3 /*Node.TEXT_NODE*/) {
			s += n2.nodeValue;
		} else if (n2.nodeType == 1 /*Node.ELEMENT_NODE*/) {
			s += this.stringForNodeRec(n2);
		}
	}
	return s;
};

XNodeSet.prototype.first = function() {
	var p = this.tree;
	if (p == null) {
		return null;
	}
	while (p.left != null) {
		p = p.left;
	}
	return p.node;
};

XNodeSet.prototype.add = function(n) {
    var added;
    if (this.tree == null) {
        this.tree = new AVLTree(n);
        added = true;
    } else {
        added = this.tree.add(n);
    }
    if (added) {
        this.size++;
    }
};

XNodeSet.prototype.addArray = function(ns) {
	for (var i = 0; i &lt; ns.length; i++) {
		this.add(ns[i]);
	}
};

XNodeSet.prototype.toArray = function() {
	var a = [];
	this.toArrayRec(this.tree, a);
	return a;
};

XNodeSet.prototype.toArrayRec = function(t, a) {
	if (t != null) {
		this.toArrayRec(t.left, a);
		a.push(t.node);
		this.toArrayRec(t.right, a);
	}
};

XNodeSet.prototype.compareWithString = function(r, o) {
	var a = this.toArray();
	for (var i = 0; i &lt; a.length; i++) {
		var n = a[i];
		var l = new XString(this.stringForNode(n));
		var res = o(l, r);
		if (res.booleanValue()) {
			return res;
		}
	}
	return new XBoolean(false);
};

XNodeSet.prototype.compareWithNumber = function(r, o) {
	var a = this.toArray();
	for (var i = 0; i &lt; a.length; i++) {
		var n = a[i];
		var l = new XNumber(this.stringForNode(n));
		var res = o(l, r);
		if (res.booleanValue()) {
			return res;
		}
	}
	return new XBoolean(false);
};

XNodeSet.prototype.compareWithBoolean = function(r, o) {
	return o(this.bool(), r);
};

XNodeSet.prototype.compareWithNodeSet = function(r, o) {
	var a = this.toArray();
	for (var i = 0; i &lt; a.length; i++) {
		var n = a[i];
		var l = new XString(this.stringForNode(n));
		var b = r.toArray();
		for (var j = 0; j &lt; b.length; j++) {
			var n2 = b[j];
			var r = new XString(this.stringForNode(n2));
			var res = o(l, r);
			if (res.booleanValue()) {
				return res;
			}
		}
	}
	return new XBoolean(false);
};

XNodeSet.prototype.equals = function(r) {
	if (Utilities.instance_of(r, XString)) {
		return this.compareWithString(r, Operators.equals);
	}
	if (Utilities.instance_of(r, XNumber)) {
		return this.compareWithNumber(r, Operators.equals);
	}
	if (Utilities.instance_of(r, XBoolean)) {
		return this.compareWithBoolean(r, Operators.equals);
	}
	return this.compareWithNodeSet(r, Operators.equals);
};

XNodeSet.prototype.notequal = function(r) {
	if (Utilities.instance_of(r, XString)) {
		return this.compareWithString(r, Operators.notequal);
	}
	if (Utilities.instance_of(r, XNumber)) {
		return this.compareWithNumber(r, Operators.notequal);
	}
	if (Utilities.instance_of(r, XBoolean)) {
		return this.compareWithBoolean(r, Operators.notequal);
	}
	return this.compareWithNodeSet(r, Operators.notequal);
};

XNodeSet.prototype.lessthan = function(r) {
	if (Utilities.instance_of(r, XString)) {
		return this.compareWithNumber(r.number(), Operators.lessthan);
	}
	if (Utilities.instance_of(r, XNumber)) {
		return this.compareWithNumber(r, Operators.lessthan);
	}
	if (Utilities.instance_of(r, XBoolean)) {
		return this.compareWithBoolean(r, Operators.lessthan);
	}
	return this.compareWithNodeSet(r, Operators.lessthan);
};

XNodeSet.prototype.greaterthan = function(r) {
	if (Utilities.instance_of(r, XString)) {
		return this.compareWithNumber(r.number(), Operators.greaterthan);
	}
	if (Utilities.instance_of(r, XNumber)) {
		return this.compareWithNumber(r, Operators.greaterthan);
	}
	if (Utilities.instance_of(r, XBoolean)) {
		return this.compareWithBoolean(r, Operators.greaterthan);
	}
	return this.compareWithNodeSet(r, Operators.greaterthan);
};

XNodeSet.prototype.lessthanorequal = function(r) {
	if (Utilities.instance_of(r, XString)) {
		return this.compareWithNumber(r.number(), Operators.lessthanorequal);
	}
	if (Utilities.instance_of(r, XNumber)) {
		return this.compareWithNumber(r, Operators.lessthanorequal);
	}
	if (Utilities.instance_of(r, XBoolean)) {
		return this.compareWithBoolean(r, Operators.lessthanorequal);
	}
	return this.compareWithNodeSet(r, Operators.lessthanorequal);
};

XNodeSet.prototype.greaterthanorequal = function(r) {
	if (Utilities.instance_of(r, XString)) {
		return this.compareWithNumber(r.number(), Operators.greaterthanorequal);
	}
	if (Utilities.instance_of(r, XNumber)) {
		return this.compareWithNumber(r, Operators.greaterthanorequal);
	}
	if (Utilities.instance_of(r, XBoolean)) {
		return this.compareWithBoolean(r, Operators.greaterthanorequal);
	}
	return this.compareWithNodeSet(r, Operators.greaterthanorequal);
};

XNodeSet.prototype.union = function(r) {
	var ns = new XNodeSet();
	ns.tree = this.tree;
	ns.size = this.size;
	ns.addArray(r.toArray());
	return ns;
};

// XPathNamespace ////////////////////////////////////////////////////////////

XPathNamespace.prototype = new Object();
XPathNamespace.prototype.constructor = XPathNamespace;
XPathNamespace.superclass = Object.prototype;

function XPathNamespace(pre, ns, p) {
	this.isXPathNamespace = true;
	this.ownerDocument = p.ownerDocument;
	this.nodeName = &quot;#namespace&quot;;
	this.prefix = pre;
	this.localName = pre;
	this.namespaceURI = ns;
	this.nodeValue = ns;
	this.ownerElement = p;
	this.nodeType = XPathNamespace.XPATH_NAMESPACE_NODE;
}

XPathNamespace.prototype.toString = function() {
	return &quot;{ \&quot;&quot; + this.prefix + &quot;\&quot;, \&quot;&quot; + this.namespaceURI + &quot;\&quot; }&quot;;
};

// Operators /////////////////////////////////////////////////////////////////

var Operators = new Object();

Operators.equals = function(l, r) {
	return l.equals(r);
};

Operators.notequal = function(l, r) {
	return l.notequal(r);
};

Operators.lessthan = function(l, r) {
	return l.lessthan(r);
};

Operators.greaterthan = function(l, r) {
	return l.greaterthan(r);
};

Operators.lessthanorequal = function(l, r) {
	return l.lessthanorequal(r);
};

Operators.greaterthanorequal = function(l, r) {
	return l.greaterthanorequal(r);
};

// XPathContext //////////////////////////////////////////////////////////////

XPathContext.prototype = new Object();
XPathContext.prototype.constructor = XPathContext;
XPathContext.superclass = Object.prototype;

function XPathContext(vr, nr, fr) {
	this.variableResolver = vr != null ? vr : new VariableResolver();
	this.namespaceResolver = nr != null ? nr : new NamespaceResolver();
	this.functionResolver = fr != null ? fr : new FunctionResolver();
}

// VariableResolver //////////////////////////////////////////////////////////

VariableResolver.prototype = new Object();
VariableResolver.prototype.constructor = VariableResolver;
VariableResolver.superclass = Object.prototype;

function VariableResolver() {
}

VariableResolver.prototype.getVariable = function(vn, c) {
	var parts = Utilities.splitQName(vn);
	if (parts[0] != null) {
		parts[0] = c.namespaceResolver.getNamespace(parts[0], c.expressionContextNode);
        if (parts[0] == null) {
            throw new Error(&quot;Cannot resolve QName &quot; + fn);
        }
	}
	return this.getVariableWithName(parts[0], parts[1], c.expressionContextNode);
};

VariableResolver.prototype.getVariableWithName = function(ns, ln, c) {
	return null;
};

// FunctionResolver //////////////////////////////////////////////////////////

FunctionResolver.prototype = new Object();
FunctionResolver.prototype.constructor = FunctionResolver;
FunctionResolver.superclass = Object.prototype;

function FunctionResolver(thisArg) {
	this.thisArg = thisArg != null ? thisArg : Functions;
	this.functions = new Object();
	this.addStandardFunctions();
}

FunctionResolver.prototype.addStandardFunctions = function() {
	this.functions[&quot;{}last&quot;] = Functions.last;
	this.functions[&quot;{}position&quot;] = Functions.position;
	this.functions[&quot;{}count&quot;] = Functions.count;
	this.functions[&quot;{}id&quot;] = Functions.id;
	this.functions[&quot;{}local-name&quot;] = Functions.localName;
	this.functions[&quot;{}namespace-uri&quot;] = Functions.namespaceURI;
	this.functions[&quot;{}name&quot;] = Functions.name;
	this.functions[&quot;{}string&quot;] = Functions.string;
	this.functions[&quot;{}concat&quot;] = Functions.concat;
	this.functions[&quot;{}starts-with&quot;] = Functions.startsWith;
	this.functions[&quot;{}contains&quot;] = Functions.contains;
	this.functions[&quot;{}substring-before&quot;] = Functions.substringBefore;
	this.functions[&quot;{}substring-after&quot;] = Functions.substringAfter;
	this.functions[&quot;{}substring&quot;] = Functions.substring;
	this.functions[&quot;{}string-length&quot;] = Functions.stringLength;
	this.functions[&quot;{}normalize-space&quot;] = Functions.normalizeSpace;
	this.functions[&quot;{}translate&quot;] = Functions.translate;
	this.functions[&quot;{}boolean&quot;] = Functions.boolean_;
	this.functions[&quot;{}not&quot;] = Functions.not;
	this.functions[&quot;{}true&quot;] = Functions.true_;
	this.functions[&quot;{}false&quot;] = Functions.false_;
	this.functions[&quot;{}lang&quot;] = Functions.lang;
	this.functions[&quot;{}number&quot;] = Functions.number;
	this.functions[&quot;{}sum&quot;] = Functions.sum;
	this.functions[&quot;{}floor&quot;] = Functions.floor;
	this.functions[&quot;{}ceiling&quot;] = Functions.ceiling;
	this.functions[&quot;{}round&quot;] = Functions.round;
};

FunctionResolver.prototype.addFunction = function(ns, ln, f) {
	this.functions[&quot;{&quot; + ns + &quot;}&quot; + ln] = f;
};

FunctionResolver.prototype.getFunction = function(fn, c) {
	var parts = Utilities.resolveQName(fn, c.namespaceResolver, c.contextNode, false);
    if (parts[0] == null) {
        throw new Error(&quot;Cannot resolve QName &quot; + fn);
    }
	return this.getFunctionWithName(parts[0], parts[1], c.contextNode);
};

FunctionResolver.prototype.getFunctionWithName = function(ns, ln, c) {
	return this.functions[&quot;{&quot; + ns + &quot;}&quot; + ln];
};

// NamespaceResolver /////////////////////////////////////////////////////////

NamespaceResolver.prototype = new Object();
NamespaceResolver.prototype.constructor = NamespaceResolver;
NamespaceResolver.superclass = Object.prototype;

function NamespaceResolver() {
}

NamespaceResolver.prototype.getNamespace = function(prefix, n) {
	if (prefix == &quot;xml&quot;) {
		return XPath.XML_NAMESPACE_URI;
	} else if (prefix == &quot;xmlns&quot;) {
		return XPath.XMLNS_NAMESPACE_URI;
	}
	if (n.nodeType == 9 /*Node.DOCUMENT_NODE*/) {
		n = n.documentElement;
	} else if (n.nodeType == 2 /*Node.ATTRIBUTE_NODE*/) {
		n = PathExpr.prototype.getOwnerElement(n);
	} else if (n.nodeType != 1 /*Node.ELEMENT_NODE*/) {
		n = n.parentNode;
	}
	while (n != null &amp;&amp; n.nodeType == 1 /*Node.ELEMENT_NODE*/) {
		var nnm = n.attributes;
		for (var i = 0; i &lt; nnm.length; i++) {
			var a = nnm.item(i);
			var aname = a.nodeName;
			if (aname == &quot;xmlns&quot; &amp;&amp; prefix == &quot;&quot;
					|| aname == &quot;xmlns:&quot; + prefix) {
				return String(a.nodeValue);
			}
		}
		n = n.parentNode;
	}
	return null;
};

// Functions /////////////////////////////////////////////////////////////////

Functions = new Object();

Functions.last = function() {
	var c = arguments[0];
	if (arguments.length != 1) {
		throw new Error(&quot;Function last expects ()&quot;);
	}
	return new XNumber(c.contextSize);
};

Functions.position = function() {
	var c = arguments[0];
	if (arguments.length != 1) {
		throw new Error(&quot;Function position expects ()&quot;);
	}
	return new XNumber(c.contextPosition);
};

Functions.count = function() {
	var c = arguments[0];
	var ns;
	if (arguments.length != 2 || !Utilities.instance_of(ns = arguments[1].evaluate(c), XNodeSet)) {
		throw new Error(&quot;Function count expects (node-set)&quot;);
	}
	return new XNumber(ns.size);
};

Functions.id = function() {
	var c = arguments[0];
	var id;
	if (arguments.length != 2) {
		throw new Error(&quot;Function id expects (object)&quot;);
	}
	id = arguments[1].evaluate(c);
	if (Utilities.instance_of(id, XNodeSet)) {
		id = id.toArray().join(&quot; &quot;);
	} else {
		id = id.stringValue();
	}
	var ids = id.split(/[\x0d\x0a\x09\x20]+/);
	var count = 0;
	var ns = new XNodeSet();
	var doc = c.contextNode.nodeType == 9 /*Node.DOCUMENT_NODE*/
			? c.contextNode
			: c.contextNode.ownerDocument;
	for (var i = 0; i &lt; ids.length; i++) {
		var n;
		if (doc.getElementById) {
			n = doc.getElementById(ids[i]);
		} else {
			n = Utilities.getElementById(doc, ids[i]);
		}
		if (n != null) {
			ns.add(n);
			count++;
		}
	}
	return ns;
};

Functions.localName = function() {
	var c = arguments[0];
	var n;
	if (arguments.length == 1) {
		n = c.contextNode;
	} else if (arguments.length == 2) {
		n = arguments[1].evaluate(c).first();
	} else {
		throw new Error(&quot;Function local-name expects (node-set?)&quot;);
	}
	if (n == null) {
		return new XString(&quot;&quot;);
	}
	return new XString(n.localName ? n.localName : n.baseName);
};

Functions.namespaceURI = function() {
	var c = arguments[0];
	var n;
	if (arguments.length == 1) {
		n = c.contextNode;
	} else if (arguments.length == 2) {
		n = arguments[1].evaluate(c).first();
	} else {
		throw new Error(&quot;Function namespace-uri expects (node-set?)&quot;);
	}
	if (n == null) {
		return new XString(&quot;&quot;);
	}
	return new XString(n.namespaceURI);
};

Functions.name = function() {
	var c = arguments[0];
	var n;
	if (arguments.length == 1) {
		n = c.contextNode;
	} else if (arguments.length == 2) {
		n = arguments[1].evaluate(c).first();
	} else {
		throw new Error(&quot;Function name expects (node-set?)&quot;);
	}
	if (n == null) {
		return new XString(&quot;&quot;);
	}
	if (n.nodeType == 1 /*Node.ELEMENT_NODE*/ || n.nodeType == 2 /*Node.ATTRIBUTE_NODE*/) {
		return new XString(n.nodeName);
	} else if (n.localName == null) {
		return new XString(&quot;&quot;);
	} else {
		return new XString(n.localName);
	}
};

Functions.string = function() {
	var c = arguments[0];
	if (arguments.length == 1) {
		return XNodeSet.prototype.stringForNode(c.contextNode);
	} else if (arguments.length == 2) {
		return arguments[1].evaluate(c).string();
	}
	throw new Error(&quot;Function string expects (object?)&quot;);
};

Functions.concat = function() {
	var c = arguments[0];
	if (arguments.length &lt; 3) {
		throw new Error(&quot;Function concat expects (string, string, string*)&quot;);
	}
	var s = &quot;&quot;;
	for (var i = 1; i &lt; arguments.length; i++) {
		s += arguments[i].evaluate(c).stringValue();
	}
	return new XString(s);
};

Functions.startsWith = function() {
	var c = arguments[0];
	if (arguments.length != 3) {
		throw new Error(&quot;Function startsWith expects (string, string)&quot;);
	}
	var s1 = arguments[1].evaluate(c).stringValue();
	var s2 = arguments[2].evaluate(c).stringValue();
	return new XBoolean(s1.substring(0, s2.length) == s2);
};

Functions.contains = function() {
	var c = arguments[0];
	if (arguments.length != 3) {
		throw new Error(&quot;Function contains expects (string, string)&quot;);
	}
	var s1 = arguments[1].evaluate(c).stringValue();
	var s2 = arguments[2].evaluate(c).stringValue();
	return new XBoolean(s1.indexOf(s2) != -1);
};

Functions.substringBefore = function() {
	var c = arguments[0];
	if (arguments.length != 3) {
		throw new Error(&quot;Function substring-before expects (string, string)&quot;);
	}
	var s1 = arguments[1].evaluate(c).stringValue();
	var s2 = arguments[2].evaluate(c).stringValue();
	return new XString(s1.substring(0, s1.indexOf(s2)));
};

Functions.substringAfter = function() {
	var c = arguments[0];
	if (arguments.length != 3) {
		throw new Error(&quot;Function substring-after expects (string, string)&quot;);
	}
	var s1 = arguments[1].evaluate(c).stringValue();
	var s2 = arguments[2].evaluate(c).stringValue();
	if (s2.length == 0) {
		return new XString(s1);
	}
	var i = s1.indexOf(s2);
	if (i == -1) {
		return new XString(&quot;&quot;);
	}
	return new XString(s1.substring(s1.indexOf(s2) + 1));
};

Functions.substring = function() {
	var c = arguments[0];
	if (!(arguments.length == 3 || arguments.length == 4)) {
		throw new Error(&quot;Function substring expects (string, number, number?)&quot;);
	}
	var s = arguments[1].evaluate(c).stringValue();
	var n1 = Math.round(arguments[2].evaluate(c).numberValue()) - 1;
	var n2 = arguments.length == 4 ? n1 + Math.round(arguments[3].evaluate(c).numberValue()) : undefined;
	return new XString(s.substring(n1, n2));
};

Functions.stringLength = function() {
	var c = arguments[0];
	var s;
	if (arguments.length == 1) {
		s = XNodeSet.prototype.stringForNode(c.contextNode);
	} else if (arguments.length == 2) {
		s = arguments[1].evaluate(c).stringValue();
	} else {
		throw new Error(&quot;Function string-length expects (string?)&quot;);
	}
	return new XNumber(s.length);
};

Functions.normalizeSpace = function() {
	var c = arguments[0];
	var s;
	if (arguments.length == 1) {
		s = XNodeSet.prototype.stringForNode(c.contextNode);
	} else if (arguments.length == 2) {
		s = arguments[1].evaluate(c).stringValue();
	} else {
		throw new Error(&quot;Function normalize-space expects (string?)&quot;);
	}
	var i = 0;
	var j = s.length - 1;
	while (Utilities.isSpace(s.charCodeAt(j))) {
		j--;
	}
	var t = &quot;&quot;;
	while (i &lt;= j &amp;&amp; Utilities.isSpace(s.charCodeAt(i))) {
		i++;
	}
	while (i &lt;= j) {
		if (Utilities.isSpace(s.charCodeAt(i))) {
			t += &quot; &quot;;
			while (i &lt;= j &amp;&amp; Utilities.isSpace(s.charCodeAt(i))) {
				i++;
			}
		} else {
			t += s.charAt(i);
			i++;
		}
	}
	return new XString(t);
};

Functions.translate = function() {
	var c = arguments[0];
	if (arguments.length != 4) {
		throw new Error(&quot;Function translate expects (string, string, string)&quot;);
	}
	var s1 = arguments[1].evaluate(c).stringValue();
	var s2 = arguments[2].evaluate(c).stringValue();
	var s3 = arguments[3].evaluate(c).stringValue();
	var map = [];
	for (var i = 0; i &lt; s2.length; i++) {
		var j = s2.charCodeAt(i);
		if (map[j] == undefined) {
			var k = i &gt; s3.length ? &quot;&quot; : s3.charAt(i);
			map[j] = k;
		}
	}
	var t = &quot;&quot;;
	for (var i = 0; i &lt; s1.length; i++) {
		var c = s1.charCodeAt(i);
		var r = map[c];
		if (r == undefined) {
			t += s1.charAt(i);
		} else {
			t += r;
		}
	}
	return new XString(t);
};

Functions.boolean_ = function() {
	var c = arguments[0];
	if (arguments.length != 2) {
		throw new Error(&quot;Function boolean expects (object)&quot;);
	}
	return arguments[1].evaluate(c).bool();
};

Functions.not = function() {
	var c = arguments[0];
	if (arguments.length != 2) {
		throw new Error(&quot;Function not expects (object)&quot;);
	}
	return arguments[1].evaluate(c).bool().not();
};

Functions.true_ = function() {
	if (arguments.length != 1) {
		throw new Error(&quot;Function true expects ()&quot;);
	}
	return new XBoolean(true);
};

Functions.false_ = function() {
	if (arguments.length != 1) {
		throw new Error(&quot;Function false expects ()&quot;);
	}
	return new XBoolean(false);
};

Functions.lang = function() {
	var c = arguments[0];
	if (arguments.length != 2) {
		throw new Error(&quot;Function lang expects (string)&quot;);
	}
	var lang;
	for (var n = c.contextNode; n != null &amp;&amp; n.nodeType != 9 /*Node.DOCUMENT_NODE*/; n = n.parentNode) {
		var a = n.getAttributeNS(XPath.XML_NAMESPACE_URI, &quot;lang&quot;);
		if (a != null) {
			lang = String(a);
			break;
		}
	}
	if (lang == null) {
		return new XBoolean(false);
	}
	var s = arguments[1].evaluate(c).stringValue();
	return new XBoolean(lang.substring(0, s.length) == s
				&amp;&amp; (lang.length == s.length || lang.charAt(s.length) == &#039;-&#039;));
};

Functions.number = function() {
	var c = arguments[0];
	if (!(arguments.length == 1 || arguments.length == 2)) {
		throw new Error(&quot;Function number expects (object?)&quot;);
	}
	if (arguments.length == 1) {
		return new XNumber(XNodeSet.prototype.stringForNode(c.contextNode));
	}
	return arguments[1].evaluate(c).number();
};

Functions.sum = function() {
	var c = arguments[0];
	var ns;
	if (arguments.length != 2 || !Utilities.instance_of((ns = arguments[1].evaluate(c)), XNodeSet)) {
		throw new Error(&quot;Function sum expects (node-set)&quot;);
	}
	ns = ns.toArray();
	var n = 0;
	for (var i = 0; i &lt; ns.length; i++) {
		n += new XNumber(XNodeSet.prototype.stringForNode(ns[i])).numberValue();
	}
	return new XNumber(n);
};

Functions.floor = function() {
	var c = arguments[0];
	if (arguments.length != 2) {
		throw new Error(&quot;Function floor expects (number)&quot;);
	}
	return new XNumber(Math.floor(arguments[1].evaluate(c).numberValue()));
};

Functions.ceiling = function() {
	var c = arguments[0];
	if (arguments.length != 2) {
		throw new Error(&quot;Function ceiling expects (number)&quot;);
	}
	return new XNumber(Math.ceil(arguments[1].evaluate(c).numberValue()));
};

Functions.round = function() {
	var c = arguments[0];
	if (arguments.length != 2) {
		throw new Error(&quot;Function round expects (number)&quot;);
	}
	return new XNumber(Math.round(arguments[1].evaluate(c).numberValue()));
};

// Utilities /////////////////////////////////////////////////////////////////

Utilities = new Object();

Utilities.splitQName = function(qn) {
	var i = qn.indexOf(&quot;:&quot;);
	if (i == -1) {
		return [ null, qn ];
	}
	return [ qn.substring(0, i), qn.substring(i + 1) ];
};

Utilities.resolveQName = function(qn, nr, n, useDefault) {
	var parts = Utilities.splitQName(qn);
	if (parts[0] != null) {
		parts[0] = nr.getNamespace(parts[0], n);
	} else {
		if (useDefault) {
			parts[0] = nr.getNamespace(&quot;&quot;, n);
			if (parts[0] == null) {
				parts[0] = &quot;&quot;;
			}
		} else {
			parts[0] = &quot;&quot;;
		}
	}
	return parts;
};

Utilities.isSpace = function(c) {
	return c == 0x9 || c == 0xd || c == 0xa || c == 0x20;
};

Utilities.isLetter = function(c) {
	return c &gt;= 0x0041 &amp;&amp; c &lt;= 0x005A ||
		c &gt;= 0x0061 &amp;&amp; c &lt;= 0x007A ||
		c &gt;= 0x00C0 &amp;&amp; c &lt;= 0x00D6 ||
		c &gt;= 0x00D8 &amp;&amp; c &lt;= 0x00F6 ||
		c &gt;= 0x00F8 &amp;&amp; c &lt;= 0x00FF ||
		c &gt;= 0x0100 &amp;&amp; c &lt;= 0x0131 ||
		c &gt;= 0x0134 &amp;&amp; c &lt;= 0x013E ||
		c &gt;= 0x0141 &amp;&amp; c &lt;= 0x0148 ||
		c &gt;= 0x014A &amp;&amp; c &lt;= 0x017E ||
		c &gt;= 0x0180 &amp;&amp; c &lt;= 0x01C3 ||
		c &gt;= 0x01CD &amp;&amp; c &lt;= 0x01F0 ||
		c &gt;= 0x01F4 &amp;&amp; c &lt;= 0x01F5 ||
		c &gt;= 0x01FA &amp;&amp; c &lt;= 0x0217 ||
		c &gt;= 0x0250 &amp;&amp; c &lt;= 0x02A8 ||
		c &gt;= 0x02BB &amp;&amp; c &lt;= 0x02C1 ||
		c == 0x0386 ||
		c &gt;= 0x0388 &amp;&amp; c &lt;= 0x038A ||
		c == 0x038C ||
		c &gt;= 0x038E &amp;&amp; c &lt;= 0x03A1 ||
		c &gt;= 0x03A3 &amp;&amp; c &lt;= 0x03CE ||
		c &gt;= 0x03D0 &amp;&amp; c &lt;= 0x03D6 ||
		c == 0x03DA ||
		c == 0x03DC ||
		c == 0x03DE ||
		c == 0x03E0 ||
		c &gt;= 0x03E2 &amp;&amp; c &lt;= 0x03F3 ||
		c &gt;= 0x0401 &amp;&amp; c &lt;= 0x040C ||
		c &gt;= 0x040E &amp;&amp; c &lt;= 0x044F ||
		c &gt;= 0x0451 &amp;&amp; c &lt;= 0x045C ||
		c &gt;= 0x045E &amp;&amp; c &lt;= 0x0481 ||
		c &gt;= 0x0490 &amp;&amp; c &lt;= 0x04C4 ||
		c &gt;= 0x04C7 &amp;&amp; c &lt;= 0x04C8 ||
		c &gt;= 0x04CB &amp;&amp; c &lt;= 0x04CC ||
		c &gt;= 0x04D0 &amp;&amp; c &lt;= 0x04EB ||
		c &gt;= 0x04EE &amp;&amp; c &lt;= 0x04F5 ||
		c &gt;= 0x04F8 &amp;&amp; c &lt;= 0x04F9 ||
		c &gt;= 0x0531 &amp;&amp; c &lt;= 0x0556 ||
		c == 0x0559 ||
		c &gt;= 0x0561 &amp;&amp; c &lt;= 0x0586 ||
		c &gt;= 0x05D0 &amp;&amp; c &lt;= 0x05EA ||
		c &gt;= 0x05F0 &amp;&amp; c &lt;= 0x05F2 ||
		c &gt;= 0x0621 &amp;&amp; c &lt;= 0x063A ||
		c &gt;= 0x0641 &amp;&amp; c &lt;= 0x064A ||
		c &gt;= 0x0671 &amp;&amp; c &lt;= 0x06B7 ||
		c &gt;= 0x06BA &amp;&amp; c &lt;= 0x06BE ||
		c &gt;= 0x06C0 &amp;&amp; c &lt;= 0x06CE ||
		c &gt;= 0x06D0 &amp;&amp; c &lt;= 0x06D3 ||
		c == 0x06D5 ||
		c &gt;= 0x06E5 &amp;&amp; c &lt;= 0x06E6 ||
		c &gt;= 0x0905 &amp;&amp; c &lt;= 0x0939 ||
		c == 0x093D ||
		c &gt;= 0x0958 &amp;&amp; c &lt;= 0x0961 ||
		c &gt;= 0x0985 &amp;&amp; c &lt;= 0x098C ||
		c &gt;= 0x098F &amp;&amp; c &lt;= 0x0990 ||
		c &gt;= 0x0993 &amp;&amp; c &lt;= 0x09A8 ||
		c &gt;= 0x09AA &amp;&amp; c &lt;= 0x09B0 ||
		c == 0x09B2 ||
		c &gt;= 0x09B6 &amp;&amp; c &lt;= 0x09B9 ||
		c &gt;= 0x09DC &amp;&amp; c &lt;= 0x09DD ||
		c &gt;= 0x09DF &amp;&amp; c &lt;= 0x09E1 ||
		c &gt;= 0x09F0 &amp;&amp; c &lt;= 0x09F1 ||
		c &gt;= 0x0A05 &amp;&amp; c &lt;= 0x0A0A ||
		c &gt;= 0x0A0F &amp;&amp; c &lt;= 0x0A10 ||
		c &gt;= 0x0A13 &amp;&amp; c &lt;= 0x0A28 ||
		c &gt;= 0x0A2A &amp;&amp; c &lt;= 0x0A30 ||
		c &gt;= 0x0A32 &amp;&amp; c &lt;= 0x0A33 ||
		c &gt;= 0x0A35 &amp;&amp; c &lt;= 0x0A36 ||
		c &gt;= 0x0A38 &amp;&amp; c &lt;= 0x0A39 ||
		c &gt;= 0x0A59 &amp;&amp; c &lt;= 0x0A5C ||
		c == 0x0A5E ||
		c &gt;= 0x0A72 &amp;&amp; c &lt;= 0x0A74 ||
		c &gt;= 0x0A85 &amp;&amp; c &lt;= 0x0A8B ||
		c == 0x0A8D ||
		c &gt;= 0x0A8F &amp;&amp; c &lt;= 0x0A91 ||
		c &gt;= 0x0A93 &amp;&amp; c &lt;= 0x0AA8 ||
		c &gt;= 0x0AAA &amp;&amp; c &lt;= 0x0AB0 ||
		c &gt;= 0x0AB2 &amp;&amp; c &lt;= 0x0AB3 ||
		c &gt;= 0x0AB5 &amp;&amp; c &lt;= 0x0AB9 ||
		c == 0x0ABD ||
		c == 0x0AE0 ||
		c &gt;= 0x0B05 &amp;&amp; c &lt;= 0x0B0C ||
		c &gt;= 0x0B0F &amp;&amp; c &lt;= 0x0B10 ||
		c &gt;= 0x0B13 &amp;&amp; c &lt;= 0x0B28 ||
		c &gt;= 0x0B2A &amp;&amp; c &lt;= 0x0B30 ||
		c &gt;= 0x0B32 &amp;&amp; c &lt;= 0x0B33 ||
		c &gt;= 0x0B36 &amp;&amp; c &lt;= 0x0B39 ||
		c == 0x0B3D ||
		c &gt;= 0x0B5C &amp;&amp; c &lt;= 0x0B5D ||
		c &gt;= 0x0B5F &amp;&amp; c &lt;= 0x0B61 ||
		c &gt;= 0x0B85 &amp;&amp; c &lt;= 0x0B8A ||
		c &gt;= 0x0B8E &amp;&amp; c &lt;= 0x0B90 ||
		c &gt;= 0x0B92 &amp;&amp; c &lt;= 0x0B95 ||
		c &gt;= 0x0B99 &amp;&amp; c &lt;= 0x0B9A ||
		c == 0x0B9C ||
		c &gt;= 0x0B9E &amp;&amp; c &lt;= 0x0B9F ||
		c &gt;= 0x0BA3 &amp;&amp; c &lt;= 0x0BA4 ||
		c &gt;= 0x0BA8 &amp;&amp; c &lt;= 0x0BAA ||
		c &gt;= 0x0BAE &amp;&amp; c &lt;= 0x0BB5 ||
		c &gt;= 0x0BB7 &amp;&amp; c &lt;= 0x0BB9 ||
		c &gt;= 0x0C05 &amp;&amp; c &lt;= 0x0C0C ||
		c &gt;= 0x0C0E &amp;&amp; c &lt;= 0x0C10 ||
		c &gt;= 0x0C12 &amp;&amp; c &lt;= 0x0C28 ||
		c &gt;= 0x0C2A &amp;&amp; c &lt;= 0x0C33 ||
		c &gt;= 0x0C35 &amp;&amp; c &lt;= 0x0C39 ||
		c &gt;= 0x0C60 &amp;&amp; c &lt;= 0x0C61 ||
		c &gt;= 0x0C85 &amp;&amp; c &lt;= 0x0C8C ||
		c &gt;= 0x0C8E &amp;&amp; c &lt;= 0x0C90 ||
		c &gt;= 0x0C92 &amp;&amp; c &lt;= 0x0CA8 ||
		c &gt;= 0x0CAA &amp;&amp; c &lt;= 0x0CB3 ||
		c &gt;= 0x0CB5 &amp;&amp; c &lt;= 0x0CB9 ||
		c == 0x0CDE ||
		c &gt;= 0x0CE0 &amp;&amp; c &lt;= 0x0CE1 ||
		c &gt;= 0x0D05 &amp;&amp; c &lt;= 0x0D0C ||
		c &gt;= 0x0D0E &amp;&amp; c &lt;= 0x0D10 ||
		c &gt;= 0x0D12 &amp;&amp; c &lt;= 0x0D28 ||
		c &gt;= 0x0D2A &amp;&amp; c &lt;= 0x0D39 ||
		c &gt;= 0x0D60 &amp;&amp; c &lt;= 0x0D61 ||
		c &gt;= 0x0E01 &amp;&amp; c &lt;= 0x0E2E ||
		c == 0x0E30 ||
		c &gt;= 0x0E32 &amp;&amp; c &lt;= 0x0E33 ||
		c &gt;= 0x0E40 &amp;&amp; c &lt;= 0x0E45 ||
		c &gt;= 0x0E81 &amp;&amp; c &lt;= 0x0E82 ||
		c == 0x0E84 ||
		c &gt;= 0x0E87 &amp;&amp; c &lt;= 0x0E88 ||
		c == 0x0E8A ||
		c == 0x0E8D ||
		c &gt;= 0x0E94 &amp;&amp; c &lt;= 0x0E97 ||
		c &gt;= 0x0E99 &amp;&amp; c &lt;= 0x0E9F ||
		c &gt;= 0x0EA1 &amp;&amp; c &lt;= 0x0EA3 ||
		c == 0x0EA5 ||
		c == 0x0EA7 ||
		c &gt;= 0x0EAA &amp;&amp; c &lt;= 0x0EAB ||
		c &gt;= 0x0EAD &amp;&amp; c &lt;= 0x0EAE ||
		c == 0x0EB0 ||
		c &gt;= 0x0EB2 &amp;&amp; c &lt;= 0x0EB3 ||
		c == 0x0EBD ||
		c &gt;= 0x0EC0 &amp;&amp; c &lt;= 0x0EC4 ||
		c &gt;= 0x0F40 &amp;&amp; c &lt;= 0x0F47 ||
		c &gt;= 0x0F49 &amp;&amp; c &lt;= 0x0F69 ||
		c &gt;= 0x10A0 &amp;&amp; c &lt;= 0x10C5 ||
		c &gt;= 0x10D0 &amp;&amp; c &lt;= 0x10F6 ||
		c == 0x1100 ||
		c &gt;= 0x1102 &amp;&amp; c &lt;= 0x1103 ||
		c &gt;= 0x1105 &amp;&amp; c &lt;= 0x1107 ||
		c == 0x1109 ||
		c &gt;= 0x110B &amp;&amp; c &lt;= 0x110C ||
		c &gt;= 0x110E &amp;&amp; c &lt;= 0x1112 ||
		c == 0x113C ||
		c == 0x113E ||
		c == 0x1140 ||
		c == 0x114C ||
		c == 0x114E ||
		c == 0x1150 ||
		c &gt;= 0x1154 &amp;&amp; c &lt;= 0x1155 ||
		c == 0x1159 ||
		c &gt;= 0x115F &amp;&amp; c &lt;= 0x1161 ||
		c == 0x1163 ||
		c == 0x1165 ||
		c == 0x1167 ||
		c == 0x1169 ||
		c &gt;= 0x116D &amp;&amp; c &lt;= 0x116E ||
		c &gt;= 0x1172 &amp;&amp; c &lt;= 0x1173 ||
		c == 0x1175 ||
		c == 0x119E ||
		c == 0x11A8 ||
		c == 0x11AB ||
		c &gt;= 0x11AE &amp;&amp; c &lt;= 0x11AF ||
		c &gt;= 0x11B7 &amp;&amp; c &lt;= 0x11B8 ||
		c == 0x11BA ||
		c &gt;= 0x11BC &amp;&amp; c &lt;= 0x11C2 ||
		c == 0x11EB ||
		c == 0x11F0 ||
		c == 0x11F9 ||
		c &gt;= 0x1E00 &amp;&amp; c &lt;= 0x1E9B ||
		c &gt;= 0x1EA0 &amp;&amp; c &lt;= 0x1EF9 ||
		c &gt;= 0x1F00 &amp;&amp; c &lt;= 0x1F15 ||
		c &gt;= 0x1F18 &amp;&amp; c &lt;= 0x1F1D ||
		c &gt;= 0x1F20 &amp;&amp; c &lt;= 0x1F45 ||
		c &gt;= 0x1F48 &amp;&amp; c &lt;= 0x1F4D ||
		c &gt;= 0x1F50 &amp;&amp; c &lt;= 0x1F57 ||
		c == 0x1F59 ||
		c == 0x1F5B ||
		c == 0x1F5D ||
		c &gt;= 0x1F5F &amp;&amp; c &lt;= 0x1F7D ||
		c &gt;= 0x1F80 &amp;&amp; c &lt;= 0x1FB4 ||
		c &gt;= 0x1FB6 &amp;&amp; c &lt;= 0x1FBC ||
		c == 0x1FBE ||
		c &gt;= 0x1FC2 &amp;&amp; c &lt;= 0x1FC4 ||
		c &gt;= 0x1FC6 &amp;&amp; c &lt;= 0x1FCC ||
		c &gt;= 0x1FD0 &amp;&amp; c &lt;= 0x1FD3 ||
		c &gt;= 0x1FD6 &amp;&amp; c &lt;= 0x1FDB ||
		c &gt;= 0x1FE0 &amp;&amp; c &lt;= 0x1FEC ||
		c &gt;= 0x1FF2 &amp;&amp; c &lt;= 0x1FF4 ||
		c &gt;= 0x1FF6 &amp;&amp; c &lt;= 0x1FFC ||
		c == 0x2126 ||
		c &gt;= 0x212A &amp;&amp; c &lt;= 0x212B ||
		c == 0x212E ||
		c &gt;= 0x2180 &amp;&amp; c &lt;= 0x2182 ||
		c &gt;= 0x3041 &amp;&amp; c &lt;= 0x3094 ||
		c &gt;= 0x30A1 &amp;&amp; c &lt;= 0x30FA ||
		c &gt;= 0x3105 &amp;&amp; c &lt;= 0x312C ||
		c &gt;= 0xAC00 &amp;&amp; c &lt;= 0xD7A3 ||
		c &gt;= 0x4E00 &amp;&amp; c &lt;= 0x9FA5 ||
		c == 0x3007 ||
		c &gt;= 0x3021 &amp;&amp; c &lt;= 0x3029;
};

Utilities.isNCNameChar = function(c) {
	return c &gt;= 0x0030 &amp;&amp; c &lt;= 0x0039
		|| c &gt;= 0x0660 &amp;&amp; c &lt;= 0x0669
		|| c &gt;= 0x06F0 &amp;&amp; c &lt;= 0x06F9
		|| c &gt;= 0x0966 &amp;&amp; c &lt;= 0x096F
		|| c &gt;= 0x09E6 &amp;&amp; c &lt;= 0x09EF
		|| c &gt;= 0x0A66 &amp;&amp; c &lt;= 0x0A6F
		|| c &gt;= 0x0AE6 &amp;&amp; c &lt;= 0x0AEF
		|| c &gt;= 0x0B66 &amp;&amp; c &lt;= 0x0B6F
		|| c &gt;= 0x0BE7 &amp;&amp; c &lt;= 0x0BEF
		|| c &gt;= 0x0C66 &amp;&amp; c &lt;= 0x0C6F
		|| c &gt;= 0x0CE6 &amp;&amp; c &lt;= 0x0CEF
		|| c &gt;= 0x0D66 &amp;&amp; c &lt;= 0x0D6F
		|| c &gt;= 0x0E50 &amp;&amp; c &lt;= 0x0E59
		|| c &gt;= 0x0ED0 &amp;&amp; c &lt;= 0x0ED9
		|| c &gt;= 0x0F20 &amp;&amp; c &lt;= 0x0F29
		|| c == 0x002E
		|| c == 0x002D
		|| c == 0x005F
		|| Utilities.isLetter(c)
		|| c &gt;= 0x0300 &amp;&amp; c &lt;= 0x0345
		|| c &gt;= 0x0360 &amp;&amp; c &lt;= 0x0361
		|| c &gt;= 0x0483 &amp;&amp; c &lt;= 0x0486
		|| c &gt;= 0x0591 &amp;&amp; c &lt;= 0x05A1
		|| c &gt;= 0x05A3 &amp;&amp; c &lt;= 0x05B9
		|| c &gt;= 0x05BB &amp;&amp; c &lt;= 0x05BD
		|| c == 0x05BF
		|| c &gt;= 0x05C1 &amp;&amp; c &lt;= 0x05C2
		|| c == 0x05C4
		|| c &gt;= 0x064B &amp;&amp; c &lt;= 0x0652
		|| c == 0x0670
		|| c &gt;= 0x06D6 &amp;&amp; c &lt;= 0x06DC
		|| c &gt;= 0x06DD &amp;&amp; c &lt;= 0x06DF
		|| c &gt;= 0x06E0 &amp;&amp; c &lt;= 0x06E4
		|| c &gt;= 0x06E7 &amp;&amp; c &lt;= 0x06E8
		|| c &gt;= 0x06EA &amp;&amp; c &lt;= 0x06ED
		|| c &gt;= 0x0901 &amp;&amp; c &lt;= 0x0903
		|| c == 0x093C
		|| c &gt;= 0x093E &amp;&amp; c &lt;= 0x094C
		|| c == 0x094D
		|| c &gt;= 0x0951 &amp;&amp; c &lt;= 0x0954
		|| c &gt;= 0x0962 &amp;&amp; c &lt;= 0x0963
		|| c &gt;= 0x0981 &amp;&amp; c &lt;= 0x0983
		|| c == 0x09BC
		|| c == 0x09BE
		|| c == 0x09BF
		|| c &gt;= 0x09C0 &amp;&amp; c &lt;= 0x09C4
		|| c &gt;= 0x09C7 &amp;&amp; c &lt;= 0x09C8
		|| c &gt;= 0x09CB &amp;&amp; c &lt;= 0x09CD
		|| c == 0x09D7
		|| c &gt;= 0x09E2 &amp;&amp; c &lt;= 0x09E3
		|| c == 0x0A02
		|| c == 0x0A3C
		|| c == 0x0A3E
		|| c == 0x0A3F
		|| c &gt;= 0x0A40 &amp;&amp; c &lt;= 0x0A42
		|| c &gt;= 0x0A47 &amp;&amp; c &lt;= 0x0A48
		|| c &gt;= 0x0A4B &amp;&amp; c &lt;= 0x0A4D
		|| c &gt;= 0x0A70 &amp;&amp; c &lt;= 0x0A71
		|| c &gt;= 0x0A81 &amp;&amp; c &lt;= 0x0A83
		|| c == 0x0ABC
		|| c &gt;= 0x0ABE &amp;&amp; c &lt;= 0x0AC5
		|| c &gt;= 0x0AC7 &amp;&amp; c &lt;= 0x0AC9
		|| c &gt;= 0x0ACB &amp;&amp; c &lt;= 0x0ACD
		|| c &gt;= 0x0B01 &amp;&amp; c &lt;= 0x0B03
		|| c == 0x0B3C
		|| c &gt;= 0x0B3E &amp;&amp; c &lt;= 0x0B43
		|| c &gt;= 0x0B47 &amp;&amp; c &lt;= 0x0B48
		|| c &gt;= 0x0B4B &amp;&amp; c &lt;= 0x0B4D
		|| c &gt;= 0x0B56 &amp;&amp; c &lt;= 0x0B57
		|| c &gt;= 0x0B82 &amp;&amp; c &lt;= 0x0B83
		|| c &gt;= 0x0BBE &amp;&amp; c &lt;= 0x0BC2
		|| c &gt;= 0x0BC6 &amp;&amp; c &lt;= 0x0BC8
		|| c &gt;= 0x0BCA &amp;&amp; c &lt;= 0x0BCD
		|| c == 0x0BD7
		|| c &gt;= 0x0C01 &amp;&amp; c &lt;= 0x0C03
		|| c &gt;= 0x0C3E &amp;&amp; c &lt;= 0x0C44
		|| c &gt;= 0x0C46 &amp;&amp; c &lt;= 0x0C48
		|| c &gt;= 0x0C4A &amp;&amp; c &lt;= 0x0C4D
		|| c &gt;= 0x0C55 &amp;&amp; c &lt;= 0x0C56
		|| c &gt;= 0x0C82 &amp;&amp; c &lt;= 0x0C83
		|| c &gt;= 0x0CBE &amp;&amp; c &lt;= 0x0CC4
		|| c &gt;= 0x0CC6 &amp;&amp; c &lt;= 0x0CC8
		|| c &gt;= 0x0CCA &amp;&amp; c &lt;= 0x0CCD
		|| c &gt;= 0x0CD5 &amp;&amp; c &lt;= 0x0CD6
		|| c &gt;= 0x0D02 &amp;&amp; c &lt;= 0x0D03
		|| c &gt;= 0x0D3E &amp;&amp; c &lt;= 0x0D43
		|| c &gt;= 0x0D46 &amp;&amp; c &lt;= 0x0D48
		|| c &gt;= 0x0D4A &amp;&amp; c &lt;= 0x0D4D
		|| c == 0x0D57
		|| c == 0x0E31
		|| c &gt;= 0x0E34 &amp;&amp; c &lt;= 0x0E3A
		|| c &gt;= 0x0E47 &amp;&amp; c &lt;= 0x0E4E
		|| c == 0x0EB1
		|| c &gt;= 0x0EB4 &amp;&amp; c &lt;= 0x0EB9
		|| c &gt;= 0x0EBB &amp;&amp; c &lt;= 0x0EBC
		|| c &gt;= 0x0EC8 &amp;&amp; c &lt;= 0x0ECD
		|| c &gt;= 0x0F18 &amp;&amp; c &lt;= 0x0F19
		|| c == 0x0F35
		|| c == 0x0F37
		|| c == 0x0F39
		|| c == 0x0F3E
		|| c == 0x0F3F
		|| c &gt;= 0x0F71 &amp;&amp; c &lt;= 0x0F84
		|| c &gt;= 0x0F86 &amp;&amp; c &lt;= 0x0F8B
		|| c &gt;= 0x0F90 &amp;&amp; c &lt;= 0x0F95
		|| c == 0x0F97
		|| c &gt;= 0x0F99 &amp;&amp; c &lt;= 0x0FAD
		|| c &gt;= 0x0FB1 &amp;&amp; c &lt;= 0x0FB7
		|| c == 0x0FB9
		|| c &gt;= 0x20D0 &amp;&amp; c &lt;= 0x20DC
		|| c == 0x20E1
		|| c &gt;= 0x302A &amp;&amp; c &lt;= 0x302F
		|| c == 0x3099
		|| c == 0x309A
		|| c == 0x00B7
		|| c == 0x02D0
		|| c == 0x02D1
		|| c == 0x0387
		|| c == 0x0640
		|| c == 0x0E46
		|| c == 0x0EC6
		|| c == 0x3005
		|| c &gt;= 0x3031 &amp;&amp; c &lt;= 0x3035
		|| c &gt;= 0x309D &amp;&amp; c &lt;= 0x309E
		|| c &gt;= 0x30FC &amp;&amp; c &lt;= 0x30FE;
};

Utilities.coalesceText = function(n) {
	for (var m = n.firstChild; m != null; m = m.nextSibling) {
		if (m.nodeType == 3 /*Node.TEXT_NODE*/ || m.nodeType == 4 /*Node.CDATA_SECTION_NODE*/) {
			var s = m.nodeValue;
			var first = m;
			m = m.nextSibling;
			while (m != null &amp;&amp; (m.nodeType == 3 /*Node.TEXT_NODE*/ || m.nodeType == 4 /*Node.CDATA_SECTION_NODE*/)) {
				s += m.nodeValue;
				var del = m;
				m = m.nextSibling;
				del.parentNode.removeChild(del);
			}
			if (first.nodeType == 4 /*Node.CDATA_SECTION_NODE*/) {
				var p = first.parentNode;
				if (first.nextSibling == null) {
					p.removeChild(first);
					p.appendChild(p.ownerDocument.createTextNode(s));
				} else {
					var next = first.nextSibling;
					p.removeChild(first);
					p.insertBefore(p.ownerDocument.createTextNode(s), next);
				}
			} else {
				first.nodeValue = s;
			}
			if (m == null) {
				break;
			}
		} else if (m.nodeType == 1 /*Node.ELEMENT_NODE*/) {
			Utilities.coalesceText(m);
		}
	}
};

Utilities.instance_of = function(o, c) {
	while (o != null) {
		if (o.constructor === c) {
			return true;
		}
		if (o === Object) {
			return false;
		}
		o = o.constructor.superclass;
	}
	return false;
};

Utilities.getElementById = function(n, id) {
	// Note that this does not check the DTD to check for actual
	// attributes of type ID, so this may be a bit wrong.
	if (n.nodeType == 1 /*Node.ELEMENT_NODE*/) {
		if (n.getAttribute(&quot;id&quot;) == id
				|| n.getAttributeNS(null, &quot;id&quot;) == id) {
			return n;
		}
	}
	for (var m = n.firstChild; m != null; m = m.nextSibling) {
		var res = Utilities.getElementById(m, id);
		if (res != null) {
			return res;
		}
	}
	return null;
};

// XPathException ////////////////////////////////////////////////////////////

XPathException.prototype = {};
XPathException.prototype.constructor = XPathException;
XPathException.superclass = Object.prototype;

function XPathException(c, e) {
	this.code = c;
	this.exception = e;
}

XPathException.prototype.toString = function() {
	var msg = this.exception ? &quot;: &quot; + this.exception.toString() : &quot;&quot;;
	switch (this.code) {
		case XPathException.INVALID_EXPRESSION_ERR:
			return &quot;Invalid expression&quot; + msg;
		case XPathException.TYPE_ERR:
			return &quot;Type error&quot; + msg;
	}
};

XPathException.INVALID_EXPRESSION_ERR = 51;
XPathException.TYPE_ERR = 52;

// XPathExpression ///////////////////////////////////////////////////////////

XPathExpression.prototype = {};
XPathExpression.prototype.constructor = XPathExpression;
XPathExpression.superclass = Object.prototype;

function XPathExpression(e, r, p) {
	this.xpath = p.parse(e);
	this.context = new XPathContext();
	this.context.namespaceResolver = new XPathNSResolverWrapper(r);
}

XPathExpression.prototype.evaluate = function(n, t, res) {
	this.context.expressionContextNode = n;
	var result = this.xpath.evaluate(this.context);
	return new XPathResult(result, t);
}

// XPathNSResolverWrapper ////////////////////////////////////////////////////

XPathNSResolverWrapper.prototype = {};
XPathNSResolverWrapper.prototype.constructor = XPathNSResolverWrapper;
XPathNSResolverWrapper.superclass = Object.prototype;

function XPathNSResolverWrapper(r) {
	this.xpathNSResolver = r;
}

XPathNSResolverWrapper.prototype.getNamespace = function(prefix, n) {
    if (this.xpathNSResolver == null) {
        return null;
    }
	return this.xpathNSResolver.lookupNamespaceURI(prefix);
};

// NodeXPathNSResolver ///////////////////////////////////////////////////////

NodeXPathNSResolver.prototype = {};
NodeXPathNSResolver.prototype.constructor = NodeXPathNSResolver;
NodeXPathNSResolver.superclass = Object.prototype;

function NodeXPathNSResolver(n) {
	this.node = n;
	this.namespaceResolver = new NamespaceResolver();
}

NodeXPathNSResolver.prototype.lookupNamespaceURI = function(prefix) {
	return this.namespaceResolver.getNamespace(prefix, this.node);
};

// XPathResult ///////////////////////////////////////////////////////////////

XPathResult.prototype = {};
XPathResult.prototype.constructor = XPathResult;
XPathResult.superclass = Object.prototype;

function XPathResult(v, t) {
	if (t == XPathResult.ANY_TYPE) {
		if (v.constructor === XString) {
			t = XPathResult.STRING_TYPE;
		} else if (v.constructor === XNumber) {
			t = XPathResult.NUMBER_TYPE;
		} else if (v.constructor === XBoolean) {
			t = XPathResult.BOOLEAN_TYPE;
		} else if (v.constructor === XNodeSet) {
			t = XPathResult.UNORDERED_NODE_ITERATOR_TYPE;
		}
	}
	this.resultType = t;
	switch (t) {
		case XPathResult.NUMBER_TYPE:
			this.numberValue = v.numberValue();
			return;
		case XPathResult.STRING_TYPE:
			this.stringValue = v.stringValue();
			return;
		case XPathResult.BOOLEAN_TYPE:
			this.booleanValue = v.booleanValue();
			return;
		case XPathResult.ANY_UNORDERED_NODE_TYPE:
		case XPathResult.FIRST_ORDERED_NODE_TYPE:
			if (v.constructor === XNodeSet) {
				this.singleNodeValue = v.first();
				return;
			}
			break;
		case XPathResult.UNORDERED_NODE_ITERATOR_TYPE:
		case XPathResult.ORDERED_NODE_ITERATOR_TYPE:
			if (v.constructor === XNodeSet) {
				this.invalidIteratorState = false;
				this.nodes = v.toArray();
				this.iteratorIndex = 0;
				return;
			}
			break;
		case XPathResult.UNORDERED_NODE_SNAPSHOT_TYPE:
		case XPathResult.ORDERED_NODE_SNAPSHOT_TYPE:
			if (v.constructor === XNodeSet) {
				this.nodes = v.toArray();
				this.snapshotLength = this.nodes.length;
				return;
			}
			break;
	}
	throw new XPathException(XPathException.TYPE_ERR);
};

XPathResult.prototype.iterateNext = function() {
	if (this.resultType != XPathResult.UNORDERED_NODE_ITERATOR_TYPE
			&amp;&amp; this.resultType != XPathResult.ORDERED_NODE_ITERATOR_TYPE) {
		throw new XPathException(XPathException.TYPE_ERR);
	}
	return this.nodes[this.iteratorIndex++];
};

XPathResult.prototype.snapshotItem = function(i) {
	if (this.resultType != XPathResult.UNORDERED_NODE_SNAPSHOT_TYPE
			&amp;&amp; this.resultType != XPathResult.ORDERED_NODE_SNAPSHOT_TYPE) {
		throw new XPathException(XPathException.TYPE_ERR);
	}
	return this.nodes[i];
};

XPathResult.ANY_TYPE = 0;
XPathResult.NUMBER_TYPE = 1;
XPathResult.STRING_TYPE = 2;
XPathResult.BOOLEAN_TYPE = 3;
XPathResult.UNORDERED_NODE_ITERATOR_TYPE = 4;
XPathResult.ORDERED_NODE_ITERATOR_TYPE = 5;
XPathResult.UNORDERED_NODE_SNAPSHOT_TYPE = 6;
XPathResult.ORDERED_NODE_SNAPSHOT_TYPE = 7;
XPathResult.ANY_UNORDERED_NODE_TYPE = 8;
XPathResult.FIRST_ORDERED_NODE_TYPE = 9;

// DOM 3 XPath support ///////////////////////////////////////////////////////

function installDOM3XPathSupport(doc, p) {
	doc.createExpression = function(e, r) {
		try {
			return new XPathExpression(e, r, p);
		} catch (e) {
			throw new XPathException(XPathException.INVALID_EXPRESSION_ERR, e);
		}
	};
	doc.createNSResolver = function(n) {
		return new NodeXPathNSResolver(n);
	};
	doc.evaluate = function(e, cn, r, t, res) {
		if (t &lt; 0 || t &gt; 9) {
			throw { code: 0, toString: function() { return &quot;Request type not supported&quot;; } };
		}
        return doc.createExpression(e, r, p).evaluate(cn, t, res);
	};
};

// ---------------------------------------------------------------------------

// Install DOM 3 XPath support for the current document.
try {
	var shouldInstall = true;
	try {
		if (document.implementation
				&amp;&amp; document.implementation.hasFeature
				&amp;&amp; document.implementation.hasFeature(&quot;XPath&quot;, null)) {
			shouldInstall = false;
		}
	} catch (e) {
	}
	if (shouldInstall) {
		installDOM3XPathSupport(document, new XPathParser());
	}
} catch (e) {
}

// ---------------------------------------------------------------------------
// exports for node.js

installDOM3XPathSupport(exports, new XPathParser());

exports.XPathResult = XPathResult;

// helper
exports.select = function(e, doc, single) {
	return exports.selectWithResolver(e, doc, null, single);
};

exports.useNamespaces = function(mappings) {
	var resolver = {
		mappings: mappings || {},
		lookupNamespaceURI: function(prefix) {
			return this.mappings[prefix];
		}
	};

	return function(e, doc, single) {
		return exports.selectWithResolver(e, doc, resolver, single);
	};
};

exports.selectWithResolver = function(e, doc, resolver, single) {
	var expression = new XPathExpression(e, resolver, new XPathParser());
	var type = XPathResult.ANY_TYPE;

	var result = expression.evaluate(doc, type, null);

	if (result.resultType == XPathResult.STRING_TYPE) {
		result = result.stringValue;
	}
	else if (result.resultType == XPathResult.NUMBER_TYPE) {
		result = result.numberValue;
	}
	else if (result.resultType == XPathResult.BOOLEAN_TYPE) {
		result = result.booleanValue;
	}
	else {
		result = result.nodes;
		if (single) {
			result = result[0];
		}
	}

	return result;
};

exports.select1 = function(e, doc) {
	return exports.select(e, doc, true);
};

// end non-node wrapper
})(typeof exports !== &#039;undefined&#039; ? exports : xpath);</textarea>
  </div>
</div>

<footer class="footer">
  <div class="container">
    <p>.</p>
  </div>
</footer>

<script type="text/html" id="complexity-popover-template">
  <div class="complexity-notice">
    Complexity : {{ complexity.cyclomatic }} <br>
    Length : {{ complexity.halstead.length }} <br>
    Difficulty : {{ complexity.halstead.difficulty.toFixed(2) }} <br>
    Est # bugs : {{ complexity.halstead.bugs.toFixed(2) }}<br>
  </div>
</script>

<script type="text/javascript" src="../../assets/scripts/bundles/core-bundle.js"></script>
<script type="text/javascript" src="../../assets/scripts/bundles/codemirror.js"></script>
<script type="text/javascript" src="../../assets/scripts/codemirror.markpopovertext.js"></script>
<script type="text/javascript" src="report.js"></script>
<script type="text/javascript" src="report.history.js"></script>
<script type="text/javascript" src="../../assets/scripts/plato-file.js"></script>
</body>
</html>
