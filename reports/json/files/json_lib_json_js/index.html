<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Plato - json/lib/json.js</title>

  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="">
  <meta name="author" content="">

  <!--[if lt IE 9]>
  <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->

  <link href="../../assets/css/vendor/morris.css" rel="stylesheet">
  <link href="../../assets/css/vendor/bootstrap.css" rel="stylesheet">
  <link href="../../assets/css/vendor/font-awesome.css" rel="stylesheet">
  <link href="../../assets/css/vendor/codemirror.css" rel="stylesheet">
  <link href="../../assets/css/plato.css" rel="stylesheet">
  <link href="../../assets/css/plato-file.css" rel="stylesheet">

</head>

<body>

<div class="navbar navbar-fixed-top">
  <div class="container">
    <a class="navbar-brand" href="http://github.com/es-analysis/plato">Plato on Github</a>
    <ul class="nav navbar-nav">
      <li>
        <a href="../../index.html">Report Home</a>
      </li>
    </ul>
  </div>
</div>

<div class="jumbotron">
  <div class="container">
    <h1>json/lib/json.js</h1>
  </div>
</div>

<div class="container aggregate-stats">
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Maintainability <a href="http://blogs.msdn.com/b/codeanalysis/archive/2007/11/20/maintainability-index-range-and-meaning.aspx"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="A value between 0 and 100 that represents the relative ease of maintaining the code. A high value means better maintainability." data-original-title="Maintainability Index"  data-container="body"></i></a></h2>
      <p class="stat">52.32</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Lines of code <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h2>
      <p class="stat">1666</p>
    </div>
  </div>
  <div class="row historical">
    <div class="col-md-6">
      <p id="chart_historical_maint" class="chart"></p>
    </div>
    <div class="col-md-6">
      <p id="chart_historical_sloc" class="chart"></p>
    </div>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Difficulty  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="The difficulty measure is related to the difficulty of the program to write or understand." data-original-title="Difficulty" data-container="body"></i></a></h2>
      <p class="stat">121.95</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Estimated Errors  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Halstead's delivered bugs is an estimate for the number of errors in the implementation." data-original-title="Delivered Bugs" data-container="body"></i></a></h2>
      <p class="stat">17.91</p>
    </div>
  </div>
</div>

<div class="container charts">
  <div class="row">
    <h2 class="header">Function weight</h2>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h3 class="chart-header">By Complexity <a href="http://en.wikipedia.org/wiki/Cyclomatic_complexity"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="This metric counts the number of distinct paths through a block of code. Lower values are better." data-original-title="Cyclomatic Complexity" data-container="body"></i></a></h3>
      <div id="fn-by-complexity" class="stat"></div>
    </div>
    <div class="col-md-6">
      <h3 class="chart-header">By SLOC  <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h3>
      <div id="fn-by-sloc" class="stat"></div>
    </div>
  </div>
</div>

<div class="container">
  <div class="row">
    <textarea id="file-source" class="col-md-12">//#!/usr/bin/env node
/**
 * Copyright (c) 2014 Trent Mick. All rights reserved.
 * Copyright (c) 2014 Joyent Inc. All rights reserved.
 *
 * json -- JSON love for your command line.
 *
 * See &lt;https://github.com/trentm/json&gt; and &lt;https://trentm.com/json/&gt;
 */

var VERSION = &#039;9.0.3&#039;;

var p = console.warn;
var util = require(&#039;util&#039;);
var assert = require(&#039;assert&#039;);
var path = require(&#039;path&#039;);
var vm = require(&#039;vm&#039;);
var fs = require(&#039;fs&#039;);
var warn = console.warn;
var EventEmitter = require(&#039;events&#039;).EventEmitter;



//--- exports for module usage

exports.main = main;
exports.getVersion = getVersion;
exports.parseLookup = parseLookup;

// As an exported API, these are still experimental:
exports.lookupDatum = lookupDatum;
exports.printDatum = printDatum; // DEPRECATED



//---- globals and constants

// Output modes.
var OM_JSONY = 1;
var OM_JSON = 2;
var OM_INSPECT = 3;
var OM_COMPACT = 4;
var OM_FROM_NAME = {
    &#039;jsony&#039;: OM_JSONY,
    &#039;json&#039;: OM_JSON,
    &#039;inspect&#039;: OM_INSPECT,
    &#039;compact&#039;: OM_COMPACT
};



//---- support functions

function getVersion() {
    return VERSION;
}

/**
 * Return a *shallow* copy of the given object.
 *
 * Only support objects that you get out of JSON, i.e. no functions.
 */
function objCopy(obj) {
    var copy;
    if (Array.isArray(obj)) {
        copy = obj.slice();
    } else if (typeof (obj) === &#039;object&#039;) {
        copy = {};
        Object.keys(obj).forEach(function (k) {
            copy[k] = obj[k];
        });
    } else {
        copy = obj; // immutable type
    }
    return copy;
}

if (util.format) {
    format = util.format;
} else {
    // From &lt;https://github.com/joyent/node/blob/master/lib/util.js#L22&gt;:
    var formatRegExp = /%[sdj%]/g;

    function format(f) {
        var i;
        if (typeof (f) !== &#039;string&#039;) {
            var objects = [];
            for (i = 0; i &lt; arguments.length; i++) {
                objects.push(util.inspect(arguments[i]));
            }
            return objects.join(&#039; &#039;);
        }
        i = 1;
        var args = arguments;
        var len = args.length;
        var str = String(f).replace(formatRegExp, function (x) {
            if (i &gt;= len)
              return x;
            switch (x) {
            case &#039;%s&#039;:
                return String(args[i++]);
            case &#039;%d&#039;:
                return Number(args[i++]);
            case &#039;%j&#039;:
                return JSON.stringify(args[i++]);
            case &#039;%%&#039;:
                return &#039;%&#039;;
            default:
                return x;
            }
        });
        for (var x = args[i]; i &lt; len; x = args[++i]) {
            if (x === null || typeof (x) !== &#039;object&#039;) {
                str += &#039; &#039; + x;
            } else {
                str += &#039; &#039; + util.inspect(x);
            }
        }
        return str;
    }
}

/**
 * Parse the given string into a JS string. Basically: handle escapes.
 */
function _parseString(s) {
    /* JSSTYLED */
    var quoted = &#039;&quot;&#039; + s.replace(/\\&quot;/, &#039;&quot;&#039;).replace(&#039;&quot;&#039;, &#039;\\&quot;&#039;) + &#039;&quot;&#039;;
    return eval(quoted);
}

// json_parse.js (&lt;https://github.com/douglascrockford/JSON-js&gt;)
/* BEGIN JSSTYLED */
// START json_parse
var json_parse=function(){&quot;use strict&quot;;var a,b,c={&#039;&quot;&#039;:&#039;&quot;&#039;,&quot;\\&quot;:&quot;\\&quot;,&quot;/&quot;:&quot;/&quot;,b:&quot;\b&quot;,f:&quot;\f&quot;,n:&quot;\n&quot;,r:&quot;\r&quot;,t:&quot;\t&quot;},d,e=function(b){throw{name:&quot;SyntaxError&quot;,message:b,at:a,text:d}},f=function(c){return c&amp;&amp;c!==b&amp;&amp;e(&quot;Expected &#039;&quot;+c+&quot;&#039; instead of &#039;&quot;+b+&quot;&#039;&quot;),b=d.charAt(a),a+=1,b},g=function(){var a,c=&quot;&quot;;b===&quot;-&quot;&amp;&amp;(c=&quot;-&quot;,f(&quot;-&quot;));while(b&gt;=&quot;0&quot;&amp;&amp;b&lt;=&quot;9&quot;)c+=b,f();if(b===&quot;.&quot;){c+=&quot;.&quot;;while(f()&amp;&amp;b&gt;=&quot;0&quot;&amp;&amp;b&lt;=&quot;9&quot;)c+=b}if(b===&quot;e&quot;||b===&quot;E&quot;){c+=b,f();if(b===&quot;-&quot;||b===&quot;+&quot;)c+=b,f();while(b&gt;=&quot;0&quot;&amp;&amp;b&lt;=&quot;9&quot;)c+=b,f()}a=+c;if(!isFinite(a))e(&quot;Bad number&quot;);else return a},h=function(){var a,d,g=&quot;&quot;,h;if(b===&#039;&quot;&#039;)while(f()){if(b===&#039;&quot;&#039;)return f(),g;if(b===&quot;\\&quot;){f();if(b===&quot;u&quot;){h=0;for(d=0;d&lt;4;d+=1){a=parseInt(f(),16);if(!isFinite(a))break;h=h*16+a}g+=String.fromCharCode(h)}else if(typeof c[b]==&quot;string&quot;)g+=c[b];else break}else g+=b}e(&quot;Bad string&quot;)},i=function(){while(b&amp;&amp;b&lt;=&quot; &quot;)f()},j=function(){switch(b){case&quot;t&quot;:return f(&quot;t&quot;),f(&quot;r&quot;),f(&quot;u&quot;),f(&quot;e&quot;),!0;case&quot;f&quot;:return f(&quot;f&quot;),f(&quot;a&quot;),f(&quot;l&quot;),f(&quot;s&quot;),f(&quot;e&quot;),!1;case&quot;n&quot;:return f(&quot;n&quot;),f(&quot;u&quot;),f(&quot;l&quot;),f(&quot;l&quot;),null}e(&quot;Unexpected &#039;&quot;+b+&quot;&#039;&quot;)},k,l=function(){var a=[];if(b===&quot;[&quot;){f(&quot;[&quot;),i();if(b===&quot;]&quot;)return f(&quot;]&quot;),a;while(b){a.push(k()),i();if(b===&quot;]&quot;)return f(&quot;]&quot;),a;f(&quot;,&quot;),i()}}e(&quot;Bad array&quot;)},m=function(){var a,c={};if(b===&quot;{&quot;){f(&quot;{&quot;),i();if(b===&quot;}&quot;)return f(&quot;}&quot;),c;while(b){a=h(),i(),f(&quot;:&quot;),Object.hasOwnProperty.call(c,a)&amp;&amp;e(&#039;Duplicate key &quot;&#039;+a+&#039;&quot;&#039;),c[a]=k(),i();if(b===&quot;}&quot;)return f(&quot;}&quot;),c;f(&quot;,&quot;),i()}}e(&quot;Bad object&quot;)};return k=function(){i();switch(b){case&quot;{&quot;:return m();case&quot;[&quot;:return l();case&#039;&quot;&#039;:return h();case&quot;-&quot;:return g();default:return b&gt;=&quot;0&quot;&amp;&amp;b&lt;=&quot;9&quot;?g():j()}},function(c,f){var g;return d=c,a=0,b=&quot; &quot;,g=k(),i(),b&amp;&amp;e(&quot;Syntax error&quot;),typeof f==&quot;function&quot;?function h(a,b){var c,d,e=a[b];if(e&amp;&amp;typeof e==&quot;object&quot;)for(c in e)Object.prototype.hasOwnProperty.call(e,c)&amp;&amp;(d=h(e,c),d!==undefined?e[c]=d:delete e[c]);return f.call(a,b,e)}({&quot;&quot;:g},&quot;&quot;):g}}();
// END json_parse
/* END JSSTYLED */

function printHelp() {
    /* BEGIN JSSTYLED */
    var w = console.log;
    w(&#039;Usage:&#039;);
    w(&#039;  &lt;something generating JSON on stdout&gt; | json [OPTIONS] [LOOKUPS...]&#039;);
    w(&#039;  json -f FILE [OPTIONS] [LOOKUPS...]&#039;);
    w(&#039;&#039;);
    w(&#039;Pipe in your JSON for pretty-printing, JSON validation, filtering, &#039;);
    w(&#039;and modification. Supply one or more `LOOKUPS` to extract a &#039;);
    w(&#039;subset of the JSON. HTTP header blocks are skipped by default.&#039;);
    w(&#039;Roughly in order of processing, features are:&#039;);
    w(&#039;&#039;);
    w(&#039;Grouping:&#039;);
    w(&#039;  Use &quot;-g&quot; or &quot;--group&quot; to group adjacent objects, separated by&#039;);
    w(&#039;  by no space or a by a newline, or adjacent arrays, separate by&#039;);
    w(&#039;  by a newline. This can be helpful for, e.g.: &#039;);
    w(&#039;     $ cat *.json | json -g ... &#039;);
    w(&#039;  and similar.&#039;);
    w(&#039;&#039;);
    w(&#039;Execution:&#039;);
    w(&#039;  Use the &quot;-e CODE&quot; option to execute JavaScript code on the input JSON.&#039;);
    w(&#039;     $ echo \&#039;{&quot;name&quot;:&quot;trent&quot;,&quot;age&quot;:38}\&#039; | json -e \&#039;this.age++\&#039;&#039;);
    w(&#039;     {&#039;);
    w(&#039;       &quot;name&quot;: &quot;trent&quot;,&#039;);
    w(&#039;       &quot;age&quot;: 39&#039;);
    w(&#039;     }&#039;);
    w(&#039;  If input is an array, this will automatically process each&#039;);
    w(&#039;  item separately.&#039;);
    w(&#039;&#039;);
    w(&#039;Conditional filtering:&#039;);
    w(&#039;  Use the &quot;-c CODE&quot; option to filter the input JSON.&#039;);
    w(&#039;     $ echo \&#039;[{&quot;age&quot;:38},{&quot;age&quot;:4}]\&#039; | json -c \&#039;this.age&gt;21\&#039;&#039;);
    w(&#039;     [{\&#039;age\&#039;:38}]&#039;);
    w(&#039;  If input is an array, this will automatically process each&#039;);
    w(&#039;  item separately. Note: &quot;CODE&quot; is JavaScript code.&#039;);
    w(&#039;&#039;);
    w(&#039;Lookups:&#039;);
    w(&#039;  Use lookup arguments to extract particular values:&#039;);
    w(&#039;     $ echo \&#039;{&quot;name&quot;:&quot;trent&quot;,&quot;age&quot;:38}\&#039; | json name&#039;);
    w(&#039;     trent&#039;);
    w(&#039;&#039;);
    w(&#039;  Use &quot;-a&quot; for *array processing* of lookups and *tabular output*:&#039;);
    w(&#039;     $ echo \&#039;{&quot;name&quot;:&quot;trent&quot;,&quot;age&quot;:38}\&#039; | json name age&#039;);
    w(&#039;     trent&#039;);
    w(&#039;     38&#039;);
    w(&#039;     $ echo \&#039;[{&quot;name&quot;:&quot;trent&quot;,&quot;age&quot;:38},&#039;);
    w(&#039;               {&quot;name&quot;:&quot;ewan&quot;,&quot;age&quot;:4}]\&#039; | json -a name age&#039;);
    w(&#039;     trent 38&#039;);
    w(&#039;     ewan 4&#039;);
    w(&#039;&#039;);
    w(&#039;In-place editing:&#039;);
    w(&#039;  Use &quot;-I, --in-place&quot; to edit a file in place:&#039;);
    w(&#039;     $ json -I -f config.json  # reformat&#039;);
    w(&#039;     $ json -I -f config.json -c \&#039;this.logLevel=&quot;debug&quot;\&#039; # add field&#039;);
    w(&#039;&#039;);
    w(&#039;Pretty-printing:&#039;);
    w(&#039;  Output is &quot;jsony&quot; by default: 2-space indented JSON, except a&#039;);
    w(&#039;  single string value is printed without quotes.&#039;);
    w(&#039;     $ echo \&#039;{&quot;name&quot;: &quot;trent&quot;, &quot;age&quot;: 38}\&#039; | json&#039;);
    w(&#039;     {&#039;);
    w(&#039;       &quot;name&quot;: &quot;trent&quot;,&#039;);
    w(&#039;       &quot;age&quot;: 38&#039;);
    w(&#039;     }&#039;);
    w(&#039;     $ echo \&#039;{&quot;name&quot;: &quot;trent&quot;, &quot;age&quot;: 38}\&#039; | json name&#039;);
    w(&#039;     trent&#039;);
    w(&#039;&#039;);
    w(&quot;  Use &#039;-j&#039; or &#039;-o json&#039; for explicit JSON, &#039;-o json-N&#039; for N-space indent:&quot;);
    w(&#039;     $ echo \&#039;{&quot;name&quot;: &quot;trent&quot;, &quot;age&quot;: 38}\&#039; | json -o json-0&#039;);
    w(&#039;     {&quot;name&quot;:&quot;trent&quot;,&quot;age&quot;:38}&#039;);
    w(&#039;&#039;);
    w(&#039;Options:&#039;);
    w(&#039;  -h, --help    Print this help info and exit.&#039;);
    w(&#039;  --version     Print version of this command and exit.&#039;);
    w(&#039;  -q, --quiet   Don\&#039;t warn if input isn\&#039;t valid JSON.&#039;);
    w(&#039;&#039;);
    w(&#039;  -f FILE       Path to a file to process. If not given, then&#039;);
    w(&#039;                stdin is used.&#039;);
    w(&#039;  -I, --in-place  In-place edit of the file given with &quot;-f&quot;.&#039;);
    w(&#039;                Lookups are not allow with in-place editing&#039;);
    w(&#039;                because it makes it too easy to lose content.&#039;);
    w(&#039;&#039;);
    w(&#039;  -H            Drop any HTTP header block (as from `curl -i ...`).&#039;);
    w(&#039;  -g, --group   Group adjacent objects or arrays into an array.&#039;);
    w(&#039;  --merge       Merge adjacent objects into one. Keys in last &#039;);
    w(&#039;                object win.&#039;);
    w(&#039;  --deep-merge  Same as &quot;--merge&quot;, but will recurse into objects &#039;);
    w(&#039;                under the same key in both.&#039;)
    w(&#039;  -a, --array   Process input as an array of separate inputs&#039;);
    w(&#039;                and output in tabular form.&#039;);
    w(&#039;  -A            Process input as a single object, i.e. stop&#039;);
    w(&#039;                &quot;-e&quot; and &quot;-c&quot; automatically processing each&#039;);
    w(&#039;                item of an input array.&#039;);
    w(&#039;  -d DELIM      Delimiter char for tabular output (default is &quot; &quot;).&#039;);
    w(&#039;  -D DELIM      Delimiter char between lookups (default is &quot;.&quot;). E.g.:&#039;);
    w(&#039;                    $ echo \&#039;{&quot;a.b&quot;: {&quot;b&quot;: 1}}\&#039; | json -D / a.b/b&#039;);
    w(&#039;&#039;);
    w(&#039;  -M, --items   Itemize an object into an array of &#039;);
    w(&#039;                    {&quot;key&quot;: &lt;key&gt;, &quot;value&quot;: &lt;value&gt;}&#039;);
    w(&#039;                objects for easier processing.&#039;);
    w(&#039;&#039;);
    w(&#039;  -e CODE       Execute the given JavaScript code on the input. If input&#039;);
    w(&#039;                is an array, then each item of the array is processed&#039;);
    w(&#039;                separately (use &quot;-A&quot; to override).&#039;);
    w(&#039;  -c CODE       Filter the input with JavaScript `CODE`. If `CODE`&#039;);
    w(&#039;                returns false-y, then the item is filtered out. If&#039;);
    w(&#039;                input is an array, then each item of the array is &#039;);
    w(&#039;                processed separately (use &quot;-A&quot; to override).&#039;);
    w(&#039;&#039;);
    w(&#039;  -k, --keys    Output the input object\&#039;s keys.&#039;);
    w(&#039;  -n, --validate  Just validate the input (no processing or output).&#039;);
    w(&#039;                Use with &quot;-q&quot; for silent validation (exit status).&#039;);
    w(&#039;&#039;);
    w(&#039;  -o, --output MODE&#039;);
    w(&#039;                Specify an output mode. One of:&#039;);
    w(&#039;                    jsony (default): JSON with string quotes elided&#039;);
    w(&#039;                    json: JSON output, 2-space indent&#039;);
    w(&#039;                    json-N: JSON output, N-space indent, e.g. &quot;json-4&quot;&#039;);
    w(&#039;                    inspect: node.js `util.inspect` output&#039;);
    w(&#039;  -i            Shortcut for `-o inspect`&#039;);
    w(&#039;  -j            Shortcut for `-o json`&#039;);
    w(&#039;  -0, -2, -4    Set indentation to the given value w/o setting MODE.&#039;);
    w(&#039;                    -0   =&gt;  -o jsony-0&#039;);
    w(&#039;                    -4   =&gt;  -o jsony-4&#039;);
    w(&#039;                    -j0  =&gt;  -o json-0&#039;);
    w(&#039;&#039;);
    w(&#039;See &lt;http://trentm.com/json&gt; for more docs and &#039;);
    w(&#039;&lt;https://github.com/trentm/json&gt; for project details.&#039;);
    /* END JSSTYLED */
}


/**
 * Parse the command-line options and arguments into an object.
 *
 *    {
 *      &#039;args&#039;: [...]       // arguments
 *      &#039;help&#039;: true,       // true if &#039;-h&#039; option given
 *       // etc.
 *    }
 *
 * @return {Object} The parsed options. `.args` is the argument list.
 * @throws {Error} If there is an error parsing argv.
 */
function parseArgv(argv) {
    var parsed = {
        args: [],
        help: false,
        quiet: false,
        dropHeaders: false,
        exeSnippets: [],
        condSnippets: [],
        outputMode: OM_JSONY,
        jsonIndent: 2,
        array: null,
        delim: &#039; &#039;,
        lookupDelim: &#039;.&#039;,
        items: false,
        outputKeys: false,
        group: false,
        merge: null, // --merge -&gt; &#039;shallow&#039;, --deep-merge -&gt; &#039;deep&#039;
        inputFiles: [],
        validate: false,
        inPlace: false
    };

    // Turn &#039;-iH&#039; into &#039;-i -H&#039;, except for argument-accepting options.
    var args = argv.slice(2); // drop [&#039;node&#039;, &#039;scriptname&#039;]
    var newArgs = [];
    var optTakesArg = {
        &#039;d&#039;: true,
        &#039;o&#039;: true,
        &#039;D&#039;: true
    };
    for (var i = 0; i &lt; args.length; i++) {
        if (args[i] === &#039;--&#039;) {
            newArgs = newArgs.concat(args.slice(i));
            break;
        }
        if (args[i].charAt(0) === &#039;-&#039; &amp;&amp; args[i].charAt(1) !== &#039;-&#039; &amp;&amp;
            args[i].length &gt; 2)
        {
            var splitOpts = args[i].slice(1).split(&#039;&#039;);
            for (var j = 0; j &lt; splitOpts.length; j++) {
                newArgs.push(&#039;-&#039; + splitOpts[j])
                if (optTakesArg[splitOpts[j]]) {
                    var optArg = splitOpts.slice(j + 1).join(&#039;&#039;);
                    if (optArg.length) {
                        newArgs.push(optArg);
                    }
                    break;
                }
            }
        } else {
            newArgs.push(args[i]);
        }
    }
    args = newArgs;

    endOfOptions = false;
    while (args.length &gt; 0) {
        var arg = args.shift();
        if (endOfOptions) {
            parsed.args.push(arg);
            break;
        }
        switch (arg) {
        case &#039;--&#039;:
            endOfOptions = true;
            break;
        case &#039;-h&#039;: // display help and exit
        case &#039;--help&#039;:
            parsed.help = true;
            break;
        case &#039;--version&#039;:
            parsed.version = true;
            break;
        case &#039;-q&#039;:
        case &#039;--quiet&#039;:
            parsed.quiet = true;
            break;
        case &#039;-H&#039;: // drop any headers
            parsed.dropHeaders = true;
            break;
        case &#039;-o&#039;:
        case &#039;--output&#039;:
            var name = args.shift();
            if (!name) {
                throw new Error(&#039;no argument given for &quot;-o|--output&quot; option&#039;);
            }
            var idx = name.lastIndexOf(&#039;-&#039;);
            if (idx !== -1) {
                var indent = name.slice(idx + 1);
                if (/^\d+$/.test(indent)) {
                    parsed.jsonIndent = Number(indent);
                    name = name.slice(0, idx);
                } else if (indent === &#039;tab&#039;) {
                    parsed.jsonIndent = &#039;\t&#039;;
                    name = name.slice(0, idx);
                }
            }
            parsed.outputMode = OM_FROM_NAME[name];
            if (parsed.outputMode === undefined) {
                throw new Error(&#039;unknown output mode: &quot;&#039; + name + &#039;&quot;&#039;);
            }
            break;
        case &#039;-0&#039;:
            parsed.jsonIndent = 0;
            break;
        case &#039;-2&#039;:
            parsed.jsonIndent = 2;
            break;
        case &#039;-4&#039;:
            parsed.jsonIndent = 4;
            break;
        case &#039;-I&#039;:
        case &#039;--in-place&#039;:
            parsed.inPlace = true;
            break;
        case &#039;-i&#039;: // output with util.inspect
            parsed.outputMode = OM_INSPECT;
            break;
        case &#039;-j&#039;: // output with JSON.stringify
            parsed.outputMode = OM_JSON;
            break;
        case &#039;-a&#039;:
        case &#039;--array&#039;:
            parsed.array = true;
            break;
        case &#039;-A&#039;:
            parsed.array = false;
            break;
        case &#039;-d&#039;:
            parsed.delim = _parseString(args.shift());
            break;
        case &#039;-D&#039;:
            parsed.lookupDelim = args.shift();
            if (parsed.lookupDelim.length !== 1) {
                throw new Error(format(
                    &#039;invalid lookup delim &quot;%s&quot; (must be a single char)&#039;,
                    parsed.lookupDelim));
            }
            break;
        case &#039;-e&#039;:
        case &#039;-E&#039;:  // DEPRECATED in v9
            parsed.exeSnippets.push(args.shift());
            break;
        case &#039;-c&#039;:
        case &#039;-C&#039;:  // DEPRECATED in v9
            parsed.condSnippets.push(args.shift());
            break;
        case &#039;-M&#039;:
        case &#039;--items&#039;:
            parsed.items = true;
            break;
        case &#039;-k&#039;:
        case &#039;--keys&#039;:
            parsed.outputKeys = true;
            break;
        case &#039;-g&#039;:
        case &#039;--group&#039;:
            parsed.group = true;
            break;
        case &#039;--merge&#039;:
            parsed.merge = &#039;shallow&#039;;
            break;
        case &#039;--deep-merge&#039;:
            parsed.merge = &#039;deep&#039;;
            break;
        case &#039;-f&#039;:
            parsed.inputFiles.push(args.shift());
            break;
        case &#039;-n&#039;:
        case &#039;--validate&#039;:
            parsed.validate = true;
            break;
        default: // arguments
            if (!endOfOptions &amp;&amp; arg.length &gt; 0 &amp;&amp; arg[0] === &#039;-&#039;) {
                throw new Error(&#039;unknown option &quot;&#039; + arg + &#039;&quot;&#039;);
            }
            parsed.args.push(arg);
            break;
        }
    }

    if (parsed.group &amp;&amp; parsed.merge) {
        throw new Error(&#039;cannot use -g|--group and --merge options together&#039;);
    }
    if (parsed.outputKeys &amp;&amp; parsed.args.length &gt; 0) {
        throw new Error(
            &#039;cannot use -k|--keys option and lookup arguments together&#039;);
    }
    if (parsed.inPlace &amp;&amp; parsed.inputFiles.length !== 1) {
        throw new Error(&#039;must specify exactly one file with &quot;-f FILE&quot; to &#039; +
            &#039;use -I/--in-place&#039;);
    }
    if (parsed.inPlace &amp;&amp; parsed.args.length &gt; 0) {
        throw new Error(&#039;lookups cannot be specified with in-place editing &#039; +
            &#039;(-I/--in-place), too easy to lose content&#039;);
    }

    return parsed;
}



/**
 * Streams chunks from given file paths or stdin.
 *
 * @param opts {Object} Parsed options.
 * @returns {Object} An emitter that emits &#039;chunk&#039;, &#039;error&#039;, and &#039;end&#039;.
 *    - `emit(&#039;chunk&#039;, chunk, [obj])` where chunk is a complete block of JSON
 *       ready to parse. If `obj` is provided, it is the already parsed
 *       JSON.
 *    - `emit(&#039;error&#039;, error)` when an underlying stream emits an error
 *    - `emit(&#039;end&#039;)` when all streams are done
 */
function chunkEmitter(opts) {
    var emitter = new EventEmitter();
    var streaming = true;
    var chunks = [];
    var leftover = &#039;&#039;;
    var finishedHeaders = false;

    function stripHeaders(s) {
        // Take off a leading HTTP header if any and pass it through.
        while (true) {
            if (s.slice(0, 5) === &#039;HTTP/&#039;) {
                var index = s.indexOf(&#039;\r\n\r\n&#039;);
                var sepLen = 4;
                if (index == -1) {
                    index = s.indexOf(&#039;\n\n&#039;);
                    sepLen = 2;
                }
                if (index != -1) {
                    if (!opts.dropHeaders) {
                        emit(s.slice(0, index + sepLen));
                    }
                    var is100Continue = (
                        s.slice(0, 21) === &#039;HTTP/1.1 100 Continue&#039;);
                    s = s.slice(index + sepLen);
                    if (is100Continue) {
                        continue;
                    }
                    finishedHeaders = true;
                }
            } else {
                finishedHeaders = true;
            }
            break;
        }
        //console.warn(&#039;stripHeaders done, finishedHeaders=%s&#039;, finishedHeaders)
        return s;
    }

    function emitChunks(block, emitter) {
        //console.warn(&#039;emitChunks start: block=&quot;%s&quot;&#039;, block)
        /* JSSTYLED */
        var splitter = /(})(\s*\n\s*)?({\s*&quot;)/;
        var leftTrimmedBlock = block.trimLeft();
        if (leftTrimmedBlock &amp;&amp; leftTrimmedBlock[0] !== &#039;{&#039;) {
            // Currently only support streaming consecutive *objects*.
            streaming = false;
            chunks.push(block);
            return &#039;&#039;;
        }
        /**
         * Example:
         * &gt; &#039;{&quot;a&quot;:&quot;b&quot;}\n{&quot;a&quot;:&quot;b&quot;}\n{&quot;a&quot;:&quot;b&quot;}&#039;.split(/(})(\s*\n\s*)?({\s*&quot;)/)
         * [ &#039;{&quot;a&quot;:&quot;b&quot;&#039;,
         *   &#039;}&#039;,
         *   &#039;\n&#039;,
         *   &#039;{&quot;&#039;,
         *   &#039;a&quot;:&quot;b&quot;&#039;,
         *   &#039;}&#039;,
         *   &#039;\n&#039;,
         *   &#039;{&quot;&#039;,
         *   &#039;a&quot;:&quot;b&quot;}&#039; ]
         */
        var bits = block.split(splitter);
        //console.warn(&#039;emitChunks: bits (length %d): %j&#039;, bits.length, bits);
        if (bits.length === 1) {
            /*
             * An unwanted side-effect of using a regex to find
             * newline-separated objects *with a regex*, is that we are looking
             * for the end of one object leading into the start of a another.
             * That means that we can end up buffering a complete object until
             * a subsequent one comes in. If the input stream has large delays
             * between objects, then this is unwanted buffering.
             *
             * One solution would be full stream parsing of objects a la
             * &lt;https://github.com/creationix/jsonparse&gt;. This would nicely
             * also remove the artibrary requirement that the input stream be
             * newline separated. jsonparse apparently has some issues tho, so
             * I don&#039;t want to use it right now. It also isn&#039;t *small* so not
             * sure I want to inline it (`json` doesn&#039;t have external deps).
             *
             * An alternative: The block we have so far one of:
             * 1. some JSON that we don&#039;t support grouping (e.g. a stream of
             *    non-objects),
             * 2. a JSON object fragment, or
             * 3. a complete JSON object (with a possible trailing &#039;{&#039;)
             *
             * If #3, then we can just emit this as a chunk right now.
             *
             * TODO(PERF): Try out avoiding the first more complete regex split
             * for a presumed common case of single-line newline-separated JSON
             * objects (e.g. a bunyan log).
             */
            // An object must end with &#039;}&#039;. This is an early out to avoid
            // `JSON.parse` which I&#039;m *presuming* is slower.
            var trimmed = block.split(/\s*\r?\n/)[0];
            if (trimmed[trimmed.length - 1] === &#039;}&#039;) {
                var obj;
                try {
                    obj = JSON.parse(block);
                } catch (e) {
                    /* pass through */
                }
                if (obj !== undefined) {
                    // Emit the parsed `obj` to avoid re-parsing it later.
                    emitter.emit(&#039;chunk&#039;, block, obj);
                    block = &#039;&#039;;
                }
            }
            return block;
        } else {
            var n = bits.length - 2;
            var s;
            s = bits[0] + bits[1];
            emitter.emit(&#039;chunk&#039;, s, JSON.parse(s));
            for (var i = 3; i &lt; n; i += 4) {
                s = bits[i] + bits[i + 1] + bits[i + 2];
                emitter.emit(&#039;chunk&#039;, s, JSON.parse(s));
            }
            return bits[n] + bits[n + 1];
        }
    }

    function addDataListener(stream) {
        stream.on(&#039;data&#039;, function (chunk) {
            var s = leftover + chunk;
            if (!finishedHeaders) {
                s = stripHeaders(s);
            }
            if (!finishedHeaders) {
                leftover = s;
            } else {
                if (!streaming) {
                    chunks.push(chunk);
                    return;
                }
                leftover = emitChunks(s, emitter);
            }
        });
    }

    if (opts.inputFiles.length &gt; 0) {
        // Stream each file in order.
        var i = 0;

        function addErrorListener(file) {
            file.on(&#039;error&#039;, function (err) {
                emitter.emit(
                    &#039;error&#039;,
                    format(&#039;could not read &quot;%s&quot;: %s&#039;, opts.inputFiles[i], e)
                );
            });
        }

        function addEndListener(file) {
            file.on(&#039;end&#039;, function () {
                if (i &lt; opts.inputFiles.length) {
                    var next = opts.inputFiles[i++];
                    var nextFile = fs.createReadStream(next,
                        {encoding: &#039;utf8&#039;});
                    addErrorListener(nextFile);
                    addEndListener(nextFile);
                    addDataListener(nextFile);
                } else {
                    if (!streaming) {
                        emitter.emit(&#039;chunk&#039;, chunks.join(&#039;&#039;));
                    } else if (leftover) {
                        leftover = emitChunks(leftover, emitter);
                        emitter.emit(&#039;chunk&#039;, leftover);
                    }
                    emitter.emit(&#039;end&#039;);
                }
            });
        }
        var first = fs.createReadStream(opts.inputFiles[i++],
            {encoding: &#039;utf8&#039;});
        addErrorListener(first);
        addEndListener(first);
        addDataListener(first);
    } else {
        // Streaming from stdin.
        var stdin = process.openStdin();
        stdin.setEncoding(&#039;utf8&#039;);
        addDataListener(stdin);
        stdin.on(&#039;end&#039;, function () {
            if (!streaming) {
                emitter.emit(&#039;chunk&#039;, chunks.join(&#039;&#039;));
            } else if (leftover) {
                leftover = emitChunks(leftover, emitter);
                emitter.emit(&#039;chunk&#039;, leftover);
            }
            emitter.emit(&#039;end&#039;);
        });
    }
    return emitter;
}

/**
 * Get input from either given file paths or stdin. If `opts.inPlace` then
 * this calls the callback once for each `opts.inputFiles`.
 *
 * @param opts {Object} Parsed options.
 * @param callback {Function} `function (err, content, filename)` where err
 *    is an error string if there was a problem, `content` is the read
 *    content and `filename` is the associated file name from which content
 *    was loaded if applicable.
 */
function getInput(opts, callback) {
    if (opts.inputFiles.length === 0) {
        // Read from stdin.
        var chunks = [];

        var stdin = process.openStdin();
        stdin.setEncoding(&#039;utf8&#039;);
        stdin.on(&#039;data&#039;, function (chunk) {
            chunks.push(chunk);
        });

        stdin.on(&#039;end&#039;, function () {
            callback(null, chunks.join(&#039;&#039;));
        });
    } else if (opts.inPlace) {
        for (var i = 0; i &lt; opts.inputFiles.length; i++) {
            var file = opts.inputFiles[i];
            var content;
            try {
                content = fs.readFileSync(file, &#039;utf8&#039;);
            } catch (e) {
                callback(e, null, file);
            }
            if (content) {
                callback(null, content, file);
            }
        }
    } else {
        // Read input files.
        var i = 0;
        var chunks = [];
        try {
            for (; i &lt; opts.inputFiles.length; i++) {
                chunks.push(fs.readFileSync(opts.inputFiles[i], &#039;utf8&#039;));
            }
        } catch (e) {
            return callback(
                format(&#039;could not read &quot;%s&quot;: %s&#039;, opts.inputFiles[i], e));
        }
        callback(null, chunks.join(&#039;&#039;),
            (opts.inputFiles.length === 1 ? opts.inputFiles[0] : undefined));
    }
}


function isInteger(s) {
    return (s.search(/^-?[0-9]+$/) == 0);
}


/**
 * Parse a lookup string into a list of lookup bits. E.g.:
 *
 *    &#039;a.b.c&#039; -&gt; [&quot;a&quot;,&quot;b&quot;,&quot;c&quot;]
 *    &#039;b[&quot;a&quot;]&#039; -&gt; [&quot;b&quot;,&quot;a&quot;]
 *    &#039;b[&quot;a&quot; + &quot;c&quot;]&#039; -&gt; [&quot;b&quot;,&quot;ac&quot;]
 *
 * Optionally receives an alternative lookup delimiter (other than &#039;.&#039;)
 */
function parseLookup(lookup, lookupDelim) {
    var debug = function () {};
    //var debug = console.warn;

    var bits = [];
    debug(&#039;\n*** &#039; + lookup + &#039; ***&#039;);

    bits = [];
    lookupDelim = lookupDelim || &#039;.&#039;;
    var bit = &#039;&#039;;
    var states = [null];
    var escaped = false;
    var ch = null;
    for (var i = 0; i &lt; lookup.length; ++i) {
        var escaped = (!escaped &amp;&amp; ch === &#039;\\&#039;);
        var ch = lookup[i];
        debug(&#039;-- i=&#039; + i + &#039;, ch=&#039; + JSON.stringify(ch) + &#039; escaped=&#039; +
            JSON.stringify(escaped));
        debug(&#039;states: &#039; + JSON.stringify(states));

        if (escaped) {
            bit += ch;
            continue;
        }

        switch (states[states.length - 1]) {
        case null:
            switch (ch) {
            case &#039;&quot;&#039;:
            case &#039;\&#039;&#039;:
                states.push(ch);
                bit += ch;
                break;
            case &#039;[&#039;:
                states.push(ch);
                if (bit !== &#039;&#039;) {
                    bits.push(bit);
                    bit = &#039;&#039;
                }
                bit += ch;
                break;
            case lookupDelim:
                if (bit !== &#039;&#039;) {
                    bits.push(bit);
                    bit = &#039;&#039;
                }
                break;
            default:
                bit += ch;
                break;
            }
            break;

        case &#039;[&#039;:
            bit += ch;
            switch (ch) {
            case &#039;&quot;&#039;:
            case &#039;\&#039;&#039;:
            case &#039;[&#039;:
                states.push(ch);
                break;
            case &#039;]&#039;:
                states.pop();
                if (states[states.length - 1] === null) {
                    var evaled = vm.runInNewContext(
                        &#039;(&#039; + bit.slice(1, -1) + &#039;)&#039;, {}, &#039;&lt;lookup&gt;&#039;);
                    bits.push(evaled);
                    bit = &#039;&#039;
                }
                break;
            }
            break;

        case &#039;&quot;&#039;:
            bit += ch;
            switch (ch) {
            case &#039;&quot;&#039;:
                states.pop();
                if (states[states.length - 1] === null) {
                    bits.push(bit);
                    bit = &#039;&#039;
                }
                break;
            }
            break;

        case &#039;\&#039;&#039;:
            bit += ch;
            switch (ch) {
            case &#039;\&#039;&#039;:
                states.pop();
                if (states[states.length - 1] === null) {
                    bits.push(bit);
                    bit = &#039;&#039;
                }
                break;
            }
            break;
        }
        debug(&#039;bit: &#039; + JSON.stringify(bit));
        debug(&#039;bits: &#039; + JSON.stringify(bits));
    }

    if (bit !== &#039;&#039;) {
        bits.push(bit);
        bit = &#039;&#039;
    }

    // Negative-intify: strings that are negative ints we change to a Number for
    // special handling in `lookupDatum`: Python-style negative array indexing.
    var negIntPat = /^-\d+$/;
    for (var i = 0; i &lt; bits.length; i++) {
        if (negIntPat.test(bits[i])) {
            bits[i] = Number(bits[i]);
        }
    }

    debug(JSON.stringify(lookup) + &#039; -&gt; &#039; + JSON.stringify(bits));
    return bits
}


/**
 * Parse the given stdin input into:
 *  {
 *    &#039;error&#039;: ... error object if there was an error ...,
 *    &#039;datum&#039;: ... parsed object if content was JSON ...
 *   }
 *
 * @param buffer {String} The text to parse as JSON.
 * @param obj {Object} Optional. Set when in streaming mode to avoid
 *    re-interpretation of `group`. Also avoids reparsing.
 * @param group {Boolean} Default false. If true, then non-JSON input
 *    will be attempted to be &#039;arrayified&#039; (see inline comment).
 * @param merge {Boolean} Default null. Can be &#039;shallow&#039; or &#039;deep&#039;. An
 *    attempt will be made to interpret the input as adjacent objects to
 *    be merged, last key wins. See inline comment for limitations.
 */
function parseInput(buffer, obj, group, merge) {
    if (obj) {
        return {
            datum: obj
        };
    } else if (group) {
        /**
         * Special case: Grouping (previously called auto-arrayification)
         * of unjoined list of objects:
         *    {&quot;one&quot;: 1}{&quot;two&quot;: 2}
         * and auto-concatenation of unjoined list of arrays:
         *    [&quot;a&quot;, &quot;b&quot;][&quot;c&quot;, &quot;d&quot;]
         *
         * This can be nice to process a stream of JSON objects generated from
         * multiple calls to another tool or `cat *.json | json`.
         *
         * Rules:
         * - Only JS objects and arrays. Don&#039;t see strong need for basic
         *   JS types right now and this limitation simplifies.
         * - The break between JS objects has to include a newline:
         *      {&quot;one&quot;: 1}
         *      {&quot;two&quot;: 2}
         *   or no spaces at all:
         *      {&quot;one&quot;: 1}{&quot;two&quot;: 2}
         *   I.e., not this:
         *      {&quot;one&quot;: 1}  {&quot;two&quot;: 2}
         *   This condition should be fine for typical use cases and ensures
         *   no false matches inside JS strings.
         * - The break between JS *arrays* has to include a newline:
         *      [&quot;one&quot;, &quot;two&quot;]
         *      [&quot;three&quot;]
         *   The &#039;no spaces&#039; case is NOT supported for JS arrays as of v6.0.0
         *   because &lt;https://github.com/trentm/json/issues/55&gt; shows that that
         *   is not safe.
         */
        var newBuffer = buffer;
        /* JSSTYLED */
        [/(})\s*\n\s*({)/g, /(})({&quot;)/g].forEach(function (pat) {
            newBuffer = newBuffer.replace(pat, &#039;$1,\n$2&#039;);
        });
        [/(\])\s*\n\s*(\[)/g].forEach(function (pat) {
            newBuffer = newBuffer.replace(pat, &#039;,\n&#039;);
        });
        newBuffer = newBuffer.trim();
        if (newBuffer[0] !== &#039;[&#039;) {
            newBuffer = &#039;[\n&#039; + newBuffer;
        }
        if (newBuffer.slice(-1) !== &#039;]&#039;) {
            newBuffer = newBuffer + &#039;\n]\n&#039;;
        }
        try {
            return {
                datum: JSON.parse(newBuffer)
            };
        } catch (e2) {
            return {
                error: e2
            };
        }
    } else if (merge) {
        // See the &#039;Rules&#039; above for limitations on boundaries for &#039;adjacent&#039;
        // objects: KISS.
        var newBuffer = buffer;
        /* JSSTYLED */
        [/(})\s*\n\s*({)/g, /(})({&quot;)/g].forEach(function (pat) {
            newBuffer = newBuffer.replace(pat, &#039;$1,\n$2&#039;);
        });
        newBuffer = &#039;[\n&#039; + newBuffer + &#039;\n]\n&#039;;
        var objs;
        try {
            objs = JSON.parse(newBuffer);
        } catch (e) {
            return {
                error: e
            };
        }
        var merged = objs[0];
        if (merge === &#039;shallow&#039;) {
            for (var i = 1; i &lt; objs.length; i++) {
                var obj = objs[i];
                Object.keys(obj).forEach(function (k) {
                    merged[k] = obj[k];
                });
            }
        } else if (merge === &#039;deep&#039;) {
            function deepExtend(a, b) {
                Object.keys(b).forEach(function (k) {
                    if (a[k] &amp;&amp; b[k] &amp;&amp;
                        toString.call(a[k]) === &#039;[object Object]&#039; &amp;&amp;
                        toString.call(b[k]) === &#039;[object Object]&#039;)
                    {
                        deepExtend(a[k], b[k])
                    } else {
                        a[k] = b[k];
                    }
                });
            }
            for (var i = 1; i &lt; objs.length; i++) {
                deepExtend(merged, objs[i]);
            }
        } else {
            throw new Error(format(&#039;unknown value for &quot;merge&quot;: &quot;%s&quot;&#039;, merge));
        }
        return {
            datum: merged
        };
    } else {
        try {
            return {
                datum: JSON.parse(buffer)
            };
        } catch (e) {
            return {
                error: e
            };
        }
    }
}


/**
 * Apply a lookup to the given datum.
 *
 * @argument datum {Object}
 * @argument lookup {Array} The parsed lookup (from
 *    `parseLookup(&lt;string&gt;, &lt;string&gt;)`). Might be empty.
 * @returns {Object} The result of the lookup.
 */
function lookupDatum(datum, lookup) {
    var d = datum;
    for (var i = 0; i &lt; lookup.length; i++) {
        var bit = lookup[i];
        if (typeof (bit) === &#039;number&#039; &amp;&amp; bit &lt; 0) {
            d = d[d.length + bit];
        } else {
            d = d[bit];
        }
        if (d === undefined) {
            return undefined;
        }
    }
    return d;
}


/**
 * Output the given datasets.
 *
 * @param datasets {Array} Array of data sets to print, in the form:
 *    `[ [&lt;datum&gt;, &lt;sep&gt;, &lt;alwaysPrintSep&gt;], ... ]`
 * @param filename {String} The filename to which to write the output. If
 *    not set, then emit to stdout.
 * @param headers {String} The HTTP header block string, if any, to emit
 *    first.
 * @param opts {Object} Parsed tool options.
 */
function printDatasets(datasets, filename, headers, opts) {
    var isTTY = (filename ? false : process.stdout.isTTY)
    var write = emit;
    if (filename) {
        var tmpPath = path.resolve(path.dirname(filename),
            format(&#039;.%s-json-%s-%s.tmp&#039;, path.basename(filename), process.pid,
                Date.now()));
        var stats = fs.statSync(filename);
        var f = fs.createWriteStream(tmpPath,
            {encoding: &#039;utf8&#039;, mode: stats.mode});
        write = f.write.bind(f);
    }
    if (headers &amp;&amp; headers.length &gt; 0) {
        write(headers)
    }
    for (var i = 0; i &lt; datasets.length; i++) {
        var dataset = datasets[i];
        var output = stringifyDatum(dataset[0], opts, isTTY);
        var sep = dataset[1];
        if (output &amp;&amp; output.length) {
            write(output);
            write(sep);
        } else if (dataset[2]) {
            write(sep);
        }
    }
    if (filename) {
        f.end();
        fs.renameSync(tmpPath, filename);
        if (!opts.quiet) {
            warn(&#039;json: updated &quot;%s&quot; in-place&#039;, filename);
        }
    }
}


/**
 * Stringify the given datum according to the given output options.
 */
function stringifyDatum(datum, opts, isTTY) {
    var output = null;
    switch (opts.outputMode) {
    case OM_INSPECT:
        output = util.inspect(datum, false, Infinity, isTTY);
        break;
    case OM_JSON:
        if (typeof (datum) !== &#039;undefined&#039;) {
            output = JSON.stringify(datum, null, opts.jsonIndent);
        }
        break;
    case OM_COMPACT:
        // Dev Note: A still relatively experimental attempt at a more
        // compact ouput somewhat a la Python&#039;s repr of a dict. I.e. try to
        // fit elements on one line as much as reasonable.
        if (datum === undefined) {
            // pass
        } else if (Array.isArray(datum)) {
            var bits = [&#039;[\n&#039;];
            datum.forEach(function (d) {
                bits.push(&#039;  &#039;)
                bits.push(JSON.stringify(d, null, 0).replace(
                    /* JSSTYLED */
                    /,&quot;(?![,:])/g, &#039;, &quot;&#039;));
                bits.push(&#039;,\n&#039;);
            });
            bits.push(bits.pop().slice(0, -2) + &#039;\n&#039;) // drop last comma
            bits.push(&#039;]&#039;);
            output = bits.join(&#039;&#039;);
        } else {
            output = JSON.stringify(datum, null, 0);
        }
        break;
    case OM_JSONY:
        if (typeof (datum) === &#039;string&#039;) {
            output = datum;
        } else if (typeof (datum) !== &#039;undefined&#039;) {
            output = JSON.stringify(datum, null, opts.jsonIndent);
        }
        break;
    default:
        throw new Error(&#039;unknown output mode: &#039; + opts.outputMode);
    }
    return output;
}


/**
 * Print out a single result, considering input options.
 *
 * @deprecated
 */
function printDatum(datum, opts, sep, alwaysPrintSep) {
    var output = stringifyDatum(datum, opts);
    if (output &amp;&amp; output.length) {
        emit(output);
        emit(sep);
    } else if (alwaysPrintSep) {
        emit(sep);
    }
}


var stdoutFlushed = true;
function emit(s) {
    // TODO:PERF If this is try/catch is too slow (too granular): move up to
    //    mainline and be sure to only catch this particular error.
    if (drainingStdout) {
        return;
    }
    try {
        stdoutFlushed = process.stdout.write(s);
    } catch (e) {
        // Handle any exceptions in stdout writing in the &#039;error&#039; event above.
    }
}

process.stdout.on(&#039;error&#039;, function (err) {
    if (err.code === &#039;EPIPE&#039;) {
        // See &lt;https://github.com/trentm/json/issues/9&gt;.
        drainStdoutAndExit(0);
    } else {
        warn(err)
        drainStdoutAndExit(1);
    }
});


/**
 * A hacked up version of &#039;process.exit&#039; that will first drain stdout
 * before exiting. *WARNING: This doesn&#039;t stop event processing.* IOW,
 * callers have to be careful that code following this call isn&#039;t
 * accidentally executed.
 *
 * In node v0.6 &quot;process.stdout and process.stderr are blocking when they
 * refer to regular files or TTY file descriptors.&quot; However, this hack might
 * still be necessary in a shell pipeline.
 */
var drainingStdout = false;
function drainStdoutAndExit(code) {
    if (drainingStdout) {
        return;
    }
    drainingStdout = true;
    process.stdout.on(&#039;drain&#039;, function () {
        process.exit(code);
    });
    process.stdout.on(&#039;close&#039;, function () {
        process.exit(code);
    });
    if (stdoutFlushed) {
        process.exit(code);
    }
}


/**
 * Return a function for the given JS code that returns.
 *
 * If no &#039;return&#039; in the given javascript snippet, then assume we are a single
 * statement and wrap in &#039;return (...)&#039;. This is for convenience for short
 * &#039;-c ...&#039; snippets.
 */
function funcWithReturnFromSnippet(js) {
    // auto-&quot;return&quot;
    if (js.indexOf(&#039;return&#039;) === -1) {
        if (js.substring(js.length - 1) === &#039;;&#039;) {
            js = js.substring(0, js.length - 1);
        }
        js = &#039;return (&#039; + js + &#039;)&#039;;
    }
    return (new Function(js));
}



//---- mainline

function main(argv) {
    var opts;
    try {
        opts = parseArgv(argv);
    } catch (e) {
        warn(&#039;json: error: %s&#039;, e.message)
        return drainStdoutAndExit(1);
    }
    //warn(opts);
    if (opts.help) {
        printHelp();
        return;
    }
    if (opts.version) {
        if (opts.outputMode === OM_JSON) {
            var v = {
                version: getVersion(),
                author: &#039;Trent Mick&#039;,
                project: &#039;https://github.com/trentm/json&#039;
            };
            console.log(JSON.stringify(v, null, opts.jsonIndent));
        } else {
            console.log(&#039;json &#039; + getVersion());
            console.log(&#039;written by Trent Mick&#039;);
            console.log(&#039;https://github.com/trentm/json&#039;);
        }
        return;
    }
    var lookupStrs = opts.args;

    // Prepare condition and execution funcs (and vm scripts) for -c/-e.
    var execVm = Boolean(process.env.JSON_EXEC &amp;&amp;
        process.env.JSON_EXEC === &#039;vm&#039;);
    var i;
    var condFuncs = [];
    if (!execVm) {
        for (i = 0; i &lt; opts.condSnippets.length; i++) {
            condFuncs[i] = funcWithReturnFromSnippet(opts.condSnippets[i]);
        }
    }
    var condScripts = [];
    if (execVm) {
        for (i = 0; i &lt; opts.condSnippets.length; i++) {
            condScripts[i] = vm.createScript(opts.condSnippets[i]);
        }
    }
    var cond = Boolean(condFuncs.length + condScripts.length);
    var exeFuncs = [];
    if (!execVm) {
        for (i = 0; i &lt; opts.exeSnippets.length; i++) {
            exeFuncs[i] = new Function(opts.exeSnippets[i]);
        }
    }
    var exeScripts = [];
    if (execVm) {
        for (i = 0; i &lt; opts.exeSnippets.length; i++) {
            exeScripts[i] = vm.createScript(opts.exeSnippets[i]);
        }
    }
    var exe = Boolean(exeFuncs.length + exeScripts.length);

    var lookups = lookupStrs.map(function (lookup) {
        return parseLookup(lookup, opts.lookupDelim);
    });

    if (opts.group &amp;&amp; opts.array &amp;&amp; opts.outputMode !== OM_JSON) {
        // streaming
        var chunker = chunkEmitter(opts);
        chunker.on(&#039;error&#039;, function (error) {
            warn(&#039;json: error: %s&#039;, err);
            return drainStdoutAndExit(1);
        });
        chunker.on(&#039;chunk&#039;, parseChunk);
    } else if (opts.inPlace) {
        assert.equal(opts.inputFiles.length, 1,
            &#039;cannot handle more than one file with -I&#039;);
        getInput(opts, function (err, content, filename) {
            if (err) {
                warn(&#039;json: error: %s&#039;, err)
                return drainStdoutAndExit(1);
            }

            // Take off a leading HTTP header if any and pass it through.
            var headers = [];
            while (true) {
                if (content.slice(0, 5) === &#039;HTTP/&#039;) {
                    var index = content.indexOf(&#039;\r\n\r\n&#039;);
                    var sepLen = 4;
                    if (index == -1) {
                        index = content.indexOf(&#039;\n\n&#039;);
                        sepLen = 2;
                    }
                    if (index != -1) {
                        if (!opts.dropHeaders) {
                            headers.push(content.slice(0, index + sepLen));
                        }
                        var is100Continue = (
                            content.slice(0, 21) === &#039;HTTP/1.1 100 Continue&#039;);
                        content = content.slice(index + sepLen);
                        if (is100Continue) {
                            continue;
                        }
                    }
                }
                break;
            }
            parseChunk(content, undefined, filename, true, headers.join(&#039;&#039;));
        });
    } else {
        // not streaming
        getInput(opts, function (err, buffer, filename) {
            if (err) {
                warn(&#039;json: error: %s&#039;, err)
                return drainStdoutAndExit(1);
            }
            // Take off a leading HTTP header if any and pass it through.
            while (true) {
                if (buffer.slice(0, 5) === &#039;HTTP/&#039;) {
                    var index = buffer.indexOf(&#039;\r\n\r\n&#039;);
                    var sepLen = 4;
                    if (index == -1) {
                        index = buffer.indexOf(&#039;\n\n&#039;);
                        sepLen = 2;
                    }
                    if (index != -1) {
                        if (!opts.dropHeaders) {
                            emit(buffer.slice(0, index + sepLen));
                        }
                        var is100Continue = (
                            buffer.slice(0, 21) === &#039;HTTP/1.1 100 Continue&#039;);
                        buffer = buffer.slice(index + sepLen);
                        if (is100Continue) {
                            continue;
                        }
                    }
                }
                break;
            }
            parseChunk(buffer, null, filename, false);
        });
    }

    /**
     * Parse a single chunk of JSON. This may be called more than once
     * (when streaming or when operating on multiple files).
     *
     * @param chunk {String} The JSON-encoded string.
     * @param obj {Object} Optional. For some code paths while streaming `obj`
     *    will be provided. This is an already parsed JSON object.
     * @param filename {String} Optional. The filename from which this content
     *    came, if relevant.
     * @param inPlace {Boolean} Optional. If true, then output will be written
     *    to `filename`.
     * @param headers {String} Optional. Leading HTTP headers, if any to emit.
     */
    function parseChunk(chunk, obj, filename, inPlace, headers) {
        // Expect the chunk to be JSON.
        if (!chunk.length) {
            return;
        }
        // parseInput() -&gt; {datum: &lt;input object&gt;, error: &lt;error object&gt;}
        var input = parseInput(chunk, obj, opts.group, opts.merge);
        if (input.error) {
            // Doesn&#039;t look like JSON. Just print it out and move on.
            if (!opts.quiet) {
                // Use JSON-js&#039; &quot;json_parse&quot; parser to get more detail on the
                // syntax error.
                var details = &#039;&#039;;
                var normBuffer = chunk.replace(/\r\n|\n|\r/, &#039;\n&#039;);
                try {
                    json_parse(normBuffer);
                    details = input.error;
                } catch (err) {
                    // err.at has the position. Get line/column from that.
                    var at = err.at - 1; // `err.at` looks to be 1-based.
                    var lines = chunk.split(&#039;\n&#039;);
                    var line, col, pos = 0;
                    for (line = 0; line &lt; lines.length; line++) {
                        pos += lines[line].length + 1;
                        if (pos &gt; at) {
                            col = at - (pos - lines[line].length - 1);
                            break;
                        }
                    }
                    var spaces = &#039;&#039;;
                    for (var i = 0; i &lt; col; i++) {
                        spaces += &#039;.&#039;;
                    }
                    details = err.message + &#039; at line &#039; + (line + 1) +
                        &#039;, column &#039; + (col + 1) + &#039;:\n        &#039; +
                        lines[line] + &#039;\n        &#039; + spaces + &#039;^&#039;;
                }
                warn(&#039;json: error: %s is not JSON: %s&#039;,
                    filename ? &#039;&quot;&#039; + filename + &#039;&quot;&#039; : &#039;input&#039;, details);
            }
            if (!opts.validate) {
                emit(chunk);
                if (chunk.length &amp;&amp; chunk[chunk.length - 1] !== &#039;\n&#039;) {
                    emit(&#039;\n&#039;);
                }
            }
            return drainStdoutAndExit(1);
        }
        if (opts.validate) {
            return drainStdoutAndExit(0);
        }
        var data = input.datum;

        // Process: items (-M, --items)
        if (opts.items) {
            if (!Array.isArray(data)) {
                var key;
                var array = [];
                for (key in data) {
                    if (data.hasOwnProperty(key)) {
                        array.push({
                          key: key,
                          value: data[key]
                        });
                    }
                }
                data = array;
            }
        }

        // Process: executions (-e, -E)
        var i, j;
        if (!exe) {
            /* pass */
        } else if (opts.array || (opts.array === null &amp;&amp; Array.isArray(data))) {
            var arrayified = false;
            if (!Array.isArray(data)) {
                arrayified = true;
                data = [data];
            }
            for (i = 0; i &lt; data.length; i++) {
                var datum = data[i];
                for (j = 0; j &lt; exeFuncs.length; j++) {
                    exeFuncs[j].call(datum);
                }
                for (j = 0; j &lt; exeScripts.length; j++) {
                    exeScripts[j].runInNewContext(datum);
                }
            }
            if (arrayified) {
                data = data[0];
            }
        } else {
            for (j = 0; j &lt; exeFuncs.length; j++) {
                exeFuncs[j].call(data);
            }
            for (j = 0; j &lt; exeScripts.length; j++) {
                exeScripts[j].runInNewContext(data);
            }
        }

        // Process: conditionals (-c)
        if (!cond) {
            /* pass */
        } else if (opts.array || (opts.array === null &amp;&amp; Array.isArray(data))) {
            var arrayified = false;
            if (!Array.isArray(data)) {
                arrayified = true;
                data = [data];
            }
            var filtered = [];
            for (i = 0; i &lt; data.length; i++) {
                var datum = data[i];
                var datumCopy = objCopy(datum);
                var keep = true;
                // TODO(perf): Perhaps drop the &#039;datumCopy&#039;? &quot;this is a gun&quot;
                for (j = 0; j &lt; condFuncs.length; j++) {
                    if (!condFuncs[j].call(datumCopy)) {
                        keep = false;
                        break;
                    }
                }
                if (keep) {
                    for (j = 0; j &lt; condScripts.length; j++) {
                        if (!condScripts[j].runInNewContext(datumCopy)) {
                            keep = false;
                            break;
                        }
                    }
                    if (keep) {
                        filtered.push(datum);
                    }
                }
            }
            if (arrayified) {
                data = (filtered.length ? filtered[0] : []);
            } else {
                data = filtered;
            }
        } else {
            var keep = true;
            var dataCopy = objCopy(data);
            for (j = 0; j &lt; condFuncs.length; j++) {
                // TODO(perf): Perhaps drop the &#039;dataCopy&#039;? &quot;this is a gun&quot;
                if (!condFuncs[j].call(dataCopy)) {
                    keep = false;
                    break;
                }
            }
            if (keep) {
                for (j = 0; j &lt; condScripts.length; j++) {
                    if (!condScripts[j].runInNewContext(dataCopy)) {
                        keep = false;
                        break;
                    }
                }
            }
            if (!keep) {
                data = undefined;
            }
        }

        // Process: lookups
        var lookupsAreIndeces = false;
        if (lookups.length) {
            if (opts.array) {
                if (!Array.isArray(data)) data = [data];
                var table = [];
                for (j = 0; j &lt; data.length; j++) {
                    var datum = data[j];
                    var row = {};
                    for (i = 0; i &lt; lookups.length; i++) {
                        var lookup = lookups[i];
                        var value = lookupDatum(datum, lookup);
                        if (value !== undefined) {
                            row[lookup.join(&#039;.&#039;)] = value;
                        }
                    }
                    table.push(row);
                }
                data = table;
            } else {
                // Special case handling: Note if the &#039;lookups&#039; are indeces into
                // an array. This may be used below to change the output
                // representation.
                if (Array.isArray(data)) {
                    lookupsAreIndeces = true;
                    for (i = 0; i &lt; lookups.length; i++) {
                        if (lookups[i].length !== 1 ||
                            isNaN(Number(lookups[i])))
                        {
                            lookupsAreIndeces = false;
                            break;
                        }
                    }
                }
                var row = {};
                for (i = 0; i &lt; lookups.length; i++) {
                    var lookup = lookups[i];
                    var value = lookupDatum(data, lookup);
                    if (value !== undefined) {
                        row[lookup.join(&#039;.&#039;)] = value;
                    }
                }
                data = row;
            }
        }

        // --keys
        if (opts.outputKeys) {
            var data = Object.keys(data);
        }

        // Output
        var datasets = [];
        if (opts.outputMode === OM_JSON) {
            if (lookups.length === 1 &amp;&amp; !opts.array) {
                /**
                 * Special case: For JSON output of a *single* lookup, *don&#039;t*
                 * use the full table structure, else there is no way to get
                 * string quoting for a single value:
                 *      $ echo &#039;{&quot;a&quot;: [], &quot;b&quot;: &quot;[]&quot;}&#039; | json -j a
                 *      []
                 *      $ echo &#039;{&quot;a&quot;: [], &quot;b&quot;: &quot;[]&quot;}&#039; | json -j b
                 *      &#039;[]&#039;
                 * See &lt;https://github.com/trentm/json/issues/35&gt; for why.
                 */
                data = data[lookups[0].join(&#039;.&#039;)];
            } else if (lookupsAreIndeces) {
                /**
                 * Special case: Lookups that are all indeces into an input
                 * array are more likely to be wanted as an array of selected
                 * items rather than a &#039;JSON table&#039; thing that we use otherwise.
                 */
                var flattened = [];
                for (i = 0; i &lt; lookups.length; i++) {
                    var lookupStr = lookups[i].join(&#039;.&#039;);
                    if (data.hasOwnProperty(lookupStr)) {
                        flattened.push(data[lookupStr])
                    }
                }
                data = flattened;
            }
            // If JSON output mode, then always just output full set of data to
            // ensure valid JSON output.
            datasets.push([data, &#039;\n&#039;, false]);
        } else if (lookups.length) {
            if (opts.array) {
                // Output `data` as a &#039;table&#039; of lookup results.
                for (j = 0; j &lt; data.length; j++) {
                    var row = data[j];
                    for (i = 0; i &lt; lookups.length - 1; i++) {
                        datasets.push([row[lookups[i].join(&#039;.&#039;)],
                            opts.delim, true]);
                    }
                    datasets.push([row[lookups[i].join(&#039;.&#039;)], &#039;\n&#039;, true]);
                }
            } else {
                for (i = 0; i &lt; lookups.length; i++) {
                    datasets.push([data[lookups[i].join(&#039;.&#039;)], &#039;\n&#039;, false]);
                }
            }
        } else if (opts.array) {
            if (!Array.isArray(data)) data = [data];
            for (j = 0; j &lt; data.length; j++) {
                datasets.push([data[j], &#039;\n&#039;, false]);
            }
        } else {
            // Output `data` as is.
            datasets.push([data, &#039;\n&#039;, false]);
        }
        printDatasets(datasets, inPlace ? filename : undefined, headers, opts);
    }
}

if (require.main === module) {
    // HACK guard for &lt;https://github.com/trentm/json/issues/24&gt;.
    // We override the `process.stdout.end` guard that core node.js puts in
    // place. The real fix is that `.end()` shouldn&#039;t be called on stdout
    // in node core. Hopefully node v0.6.9 will fix that. Only guard
    // for v0.6.0..v0.6.8.
    var nodeVer = process.versions.node.split(&#039;.&#039;).map(Number);
    if ([0, 6, 0] &lt;= nodeVer &amp;&amp; nodeVer &lt;= [0, 6, 8]) {
        var stdout = process.stdout;
        stdout.end = stdout.destroy = stdout.destroySoon = function () {
            /* pass */
        };
    }

    main(process.argv);
}</textarea>
  </div>
</div>

<footer class="footer">
  <div class="container">
    <p>.</p>
  </div>
</footer>

<script type="text/html" id="complexity-popover-template">
  <div class="complexity-notice">
    Complexity : {{ complexity.cyclomatic }} <br>
    Length : {{ complexity.halstead.length }} <br>
    Difficulty : {{ complexity.halstead.difficulty.toFixed(2) }} <br>
    Est # bugs : {{ complexity.halstead.bugs.toFixed(2) }}<br>
  </div>
</script>

<script type="text/javascript" src="../../assets/scripts/bundles/core-bundle.js"></script>
<script type="text/javascript" src="../../assets/scripts/bundles/codemirror.js"></script>
<script type="text/javascript" src="../../assets/scripts/codemirror.markpopovertext.js"></script>
<script type="text/javascript" src="report.js"></script>
<script type="text/javascript" src="report.history.js"></script>
<script type="text/javascript" src="../../assets/scripts/plato-file.js"></script>
</body>
</html>
