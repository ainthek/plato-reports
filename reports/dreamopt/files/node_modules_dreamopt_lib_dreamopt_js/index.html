<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Plato - node_modules/dreamopt/lib/dreamopt.js</title>

  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="">
  <meta name="author" content="">

  <!--[if lt IE 9]>
  <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->

  <link href="../../assets/css/vendor/morris.css" rel="stylesheet">
  <link href="../../assets/css/vendor/bootstrap.css" rel="stylesheet">
  <link href="../../assets/css/vendor/font-awesome.css" rel="stylesheet">
  <link href="../../assets/css/vendor/codemirror.css" rel="stylesheet">
  <link href="../../assets/css/plato.css" rel="stylesheet">
  <link href="../../assets/css/plato-file.css" rel="stylesheet">

</head>

<body>

<div class="navbar navbar-fixed-top">
  <div class="container">
    <a class="navbar-brand" href="http://github.com/es-analysis/plato">Plato on Github</a>
    <ul class="nav navbar-nav">
      <li>
        <a href="../../index.html">Report Home</a>
      </li>
    </ul>
  </div>
</div>

<div class="jumbotron">
  <div class="container">
    <h1>node_modules/dreamopt/lib/dreamopt.js</h1>
  </div>
</div>

<div class="container aggregate-stats">
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Maintainability <a href="http://blogs.msdn.com/b/codeanalysis/archive/2007/11/20/maintainability-index-range-and-meaning.aspx"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="A value between 0 and 100 that represents the relative ease of maintaining the code. A high value means better maintainability." data-original-title="Maintainability Index"  data-container="body"></i></a></h2>
      <p class="stat">57.56</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Lines of code <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h2>
      <p class="stat">890</p>
    </div>
  </div>
  <div class="row historical">
    <div class="col-md-6">
      <p id="chart_historical_maint" class="chart"></p>
    </div>
    <div class="col-md-6">
      <p id="chart_historical_sloc" class="chart"></p>
    </div>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Difficulty  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="The difficulty measure is related to the difficulty of the program to write or understand." data-original-title="Difficulty" data-container="body"></i></a></h2>
      <p class="stat">156.63</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Estimated Errors  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Halstead's delivered bugs is an estimate for the number of errors in the implementation." data-original-title="Delivered Bugs" data-container="body"></i></a></h2>
      <p class="stat">12.36</p>
    </div>
  </div>
</div>

<div class="container charts">
  <div class="row">
    <h2 class="header">Function weight</h2>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h3 class="chart-header">By Complexity <a href="http://en.wikipedia.org/wiki/Cyclomatic_complexity"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="This metric counts the number of distinct paths through a block of code. Lower values are better." data-original-title="Cyclomatic Complexity" data-container="body"></i></a></h3>
      <div id="fn-by-complexity" class="stat"></div>
    </div>
    <div class="col-md-6">
      <h3 class="chart-header">By SLOC  <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h3>
      <div id="fn-by-sloc" class="stat"></div>
    </div>
  </div>
</div>

<div class="container">
  <div class="row">
    <textarea id="file-source" class="col-md-12">// Generated by CoffeeScript 1.3.3
(function() {
  var ARGUMENT, COMMAND, Command, DUMMY, DefaultHandlers, HEADER, OPTION, OPTION_BOOL, OPTION_DESC, OPTION_DESC_DEFAULT, OPTION_DESC_TAG, OPTION_LONG, OPTION_METAVARS, OPTION_SHORT, Option, SUBSUBSUB, Syntax, TEXT, USAGE, Usage, UsageSection, alignment, cleanUpMetaVarName, cleanUpNameForUsingAsVarName, createError, formatMetaVar, formatUsageString, indent, parse, separator, width, wordwrap, wrapText,
    __slice = [].slice;

  wordwrap = require(&#039;wordwrap&#039;);

  USAGE = /^Usage:/;

  HEADER = /^[^-].*:$/;

  OPTION = /^\s+-/;

  COMMAND = /^\s+([\w.-]+)(?:\s{2,}(.*))?$/;

  TEXT = /^\S/;

  ARGUMENT = /^\s+(?:[A-Z._-][A-Z0-9._-]+|&lt;[^\s&gt;]+&gt;)(?:\s\s|$)/;

  OPTION_DESC = /^(.*?)\s{2,}(.*)$/;

  OPTION_METAVARS = /^([^\s,]+(?:,\s*\S+)?)((?:\s(?:[A-Z._-][A-Z0-9._-]+|&lt;[^\s&gt;]+&gt;))*)$/;

  OPTION_SHORT = /^(-\S)(?:,\s*(.*))?$/;

  OPTION_LONG = /^(--\S+)$/;

  OPTION_BOOL = /^--\[no-\](.*)$/;

  OPTION_DESC_TAG = /^(.*)\#(\w+)(?:\(([^()]*)\))?\s*$/;

  DUMMY = /\#/;

  OPTION_DESC_DEFAULT = /\((?:default:|default\s+is|defaults\s+to)\s+([^()]+)\)/i;

  SUBSUBSUB = [&#039;command&#039;, &#039;subcommand&#039;, &#039;subsubcommand&#039;, &#039;subsubsubcommand&#039;];

  createError = function(message) {
    var e;
    e = new Error(message);
    e.isCommandLineError = true;
    return e;
  };

  DefaultHandlers = {
    auto: function(value) {
      if (typeof value !== &#039;string&#039;) {
        return value;
      }
      if (!isNaN(Number(value))) {
        return Number(value);
      }
      return value;
    },
    string: function(value) {
      return value;
    },
    int: function(value) {
      if (typeof value !== &#039;string&#039;) {
        return value;
      }
      if (isNaN(parseInt(value, 10))) {
        throw createError(&quot;Integer value required: &quot; + value);
      }
      return parseInt(value, 10);
    },
    flag: function(value, options, optionName, tagValue) {
      var _ref, _ref1;
      if (!(value != null)) {
        return true;
      }
      if (typeof value !== &#039;string&#039;) {
        return value;
      }
      if ((_ref = value.toLowerCase()) === &#039;0&#039; || _ref === &#039;false&#039; || _ref === &#039;no&#039; || _ref === &#039;off&#039;) {
        return false;
      }
      if ((_ref1 = value.toLowerCase()) === &#039;&#039; || _ref1 === &#039;1&#039; || _ref1 === &#039;true&#039; || _ref1 === &#039;yes&#039; || _ref1 === &#039;on&#039;) {
        return true;
      }
      throw new Error(&quot;Invalid flag value &quot; + (JSON.stringify(value)) + &quot; for option &quot; + optionName);
    }
  };

  alignment = 24;

  indent = &quot;  &quot;;

  separator = &quot;  &quot;;

  width = 100;

  wrapText = require(&#039;wordwrap&#039;)(width);

  formatUsageString = function(left, right) {
    var actualAlignment, descriptionWidth, firstLine, otherLines, overhead, padding, wrappedLineIndent, _ref;
    overhead = indent.length + separator.length;
    if (left.length &lt; alignment - overhead) {
      padding = new Array(alignment - overhead - left.length + 1).join(&#039; &#039;);
    } else {
      padding = &#039;&#039;;
    }
    actualAlignment = overhead + left.length + padding.length;
    descriptionWidth = width - actualAlignment;
    wrappedLineIndent = new Array(actualAlignment + 1).join(&#039; &#039;);
    _ref = wordwrap(descriptionWidth)(right).trim().split(&#039;\n&#039;), firstLine = _ref[0], otherLines = 2 &lt;= _ref.length ? __slice.call(_ref, 1) : [];
    right = [firstLine].concat(otherLines.map(function(line) {
      return wrappedLineIndent + line;
    })).join(&quot;\n&quot;);
    if (otherLines.length) {
      right += &quot;\n&quot;;
    }
    return &quot;  &quot; + left + padding + &quot;  &quot; + right;
  };

  cleanUpMetaVarName = function(name) {
    var $;
    if ($ = name.match(/^&lt;(.*)&gt;$/)) {
      return $[1];
    } else {
      return name;
    }
  };

  formatMetaVar = function(metavar) {
    if (metavar === metavar.toUpperCase()) {
      return metavar;
    } else {
      return &quot;&lt;&quot; + metavar + &quot;&gt;&quot;;
    }
  };

  cleanUpNameForUsingAsVarName = function(name, isOption) {
    if (!isOption) {
      if (name === name.toUpperCase()) {
        name = name.toLowerCase();
      }
    }
    return name;
  };

  Option = (function() {

    function Option(shortOpt, longOpt, desc, tagPairs, metavars, defaultValue) {
      var $, name, tag, value, _i, _len, _ref;
      this.shortOpt = shortOpt;
      this.longOpt = longOpt;
      this.desc = desc;
      this.metavars = metavars;
      this.defaultValue = defaultValue;
      if (this.longOpt || this.shortOpt) {
        this.name = this.longOpt &amp;&amp; this.longOpt.slice(2) || this.shortOpt.slice(1);
      } else if (this.metavars.length) {
        this.name = this.metavars[0];
        if ($ = this.name.match(/^\[(.*)\]$/)) {
          this.name = $[1];
        }
        this.name = cleanUpMetaVarName(this.name);
      }
      this.metavars = (function() {
        var _i, _len, _ref, _results;
        _ref = this.metavars;
        _results = [];
        for (_i = 0, _len = _ref.length; _i &lt; _len; _i++) {
          name = _ref[_i];
          _results.push(cleanUpMetaVarName(name));
        }
        return _results;
      }).call(this);
      this[&quot;var&quot;] = cleanUpNameForUsingAsVarName(this.name, this.longOpt || this.shortOpt);
      this.tags = {};
      this.tagsOrder = [];
      for (_i = 0, _len = tagPairs.length; _i &lt; _len; _i++) {
        _ref = tagPairs[_i], tag = _ref[0], value = _ref[1];
        this.tags[tag] = value;
        this.tagsOrder.push(tag);
        switch (tag) {
          case &#039;default&#039;:
            this.defaultValue = value;
            break;
          case &#039;var&#039;:
            this[&quot;var&quot;] = value;
        }
      }
      this.func = null;
    }

    Option.prototype.leftUsageComponent = function() {
      var longOpt, mv, string;
      longOpt = this.longOpt;
      if (longOpt &amp;&amp; this.tags.acceptsno) {
        longOpt = &quot;--[no-]&quot; + longOpt.slice(2);
      }
      string = (function() {
        switch (false) {
          case !(this.shortOpt &amp;&amp; longOpt):
            return &quot;&quot; + this.shortOpt + &quot;, &quot; + longOpt;
          case !this.shortOpt:
            return this.shortOpt;
          case !this.longOpt:
            return &quot;    &quot; + longOpt;
          default:
            return &#039;&#039;;
        }
      }).call(this);
      if (this.metavars) {
        string = string + (string &amp;&amp; &#039; &#039; || &#039;&#039;) + ((function() {
          var _i, _len, _ref, _results;
          _ref = this.metavars;
          _results = [];
          for (_i = 0, _len = _ref.length; _i &lt; _len; _i++) {
            mv = _ref[_i];
            _results.push(formatMetaVar(mv));
          }
          return _results;
        }).call(this)).join(&#039; &#039;);
      }
      return string;
    };

    Option.prototype.toUsageString = function() {
      return formatUsageString(this.leftUsageComponent(), this.desc);
    };

    Option.prototype.coerce = function(value, options, syntax) {
      var any, handler, newValue, tag, _i, _len, _ref;
      any = false;
      _ref = this.tagsOrder;
      for (_i = 0, _len = _ref.length; _i &lt; _len; _i++) {
        tag = _ref[_i];
        if (handler = syntax.handlers[tag] || DefaultHandlers[tag]) {
          newValue = handler(value, options, this.leftUsageComponent(), this.tags[tag]);
          if (typeof newValue !== void 0) {
            value = newValue;
          }
          any = true;
        }
      }
      if (!any) {
        value = DefaultHandlers.auto(value, options, syntax, this.leftUsageComponent());
      }
      return value;
    };

    return Option;

  })();

  Command = (function() {

    function Command(name, desc, syntax) {
      this.name = name;
      this.desc = desc;
      this.syntax = syntax;
      this.func = null;
      this.desc || (this.desc = this.syntax.usage.firstPreambleLine());
    }

    Command.prototype.leftUsageComponent = function() {
      return this.name;
    };

    Command.prototype.toUsageString = function() {
      return formatUsageString(this.leftUsageComponent(), this.desc);
    };

    return Command;

  })();

  UsageSection = (function() {

    function UsageSection(type, header) {
      this.type = type;
      this.header = header;
      this.lines = [];
    }

    UsageSection.prototype.toUsageString = function() {
      var line;
      return (this.header ? &quot;&quot; + this.header + &quot;\n&quot; : &#039;&#039;) + ((function() {
        var _i, _len, _ref, _results;
        _ref = this.lines;
        _results = [];
        for (_i = 0, _len = _ref.length; _i &lt; _len; _i++) {
          line = _ref[_i];
          _results.push(&quot;&quot; + line + &quot;\n&quot;);
        }
        return _results;
      }).call(this)).join(&#039;&#039;);
    };

    return UsageSection;

  })();

  Usage = (function() {

    function Usage() {
      this.sections = [];
      this.lastSection = null;
      this.implicitHeaders = {
        preamble: &quot;&quot;,
        text: &quot;&quot;,
        options: &quot;Options:&quot;,
        &quot;arguments&quot;: &quot;Arguments:&quot;,
        commands: &quot;Commands:&quot;
      };
      this.startSectionType(&#039;preamble&#039;);
    }

    Usage.prototype.startSection = function(type, header) {
      this.lastSection = new UsageSection(type, header);
      return this.sections.push(this.lastSection);
    };

    Usage.prototype.endSection = function() {
      return this.lastSection = null;
    };

    Usage.prototype.startSectionType = function(type) {
      var _ref, _ref1;
      if (((_ref = this.lastSection) != null ? _ref.type : void 0) === type) {
        return;
      }
      if (this.lastSection &amp;&amp; (type === &#039;*&#039;)) {
        return;
      }
      if (((_ref1 = this.lastSection) != null ? _ref1.type : void 0) === &#039;*&#039;) {
        return this.lastSection.type = type;
      } else {
        return this.startSection(type, this.implicitHeaders[type]);
      }
    };

    Usage.prototype.add = function(sectionType, line) {
      if ((sectionType === &#039;text&#039;) &amp;&amp; (this.sections.length === 1) &amp;&amp; (this.sections[0].lines.length === 0)) {
        sectionType = &#039;preamble&#039;;
      }
      this.startSectionType(sectionType);
      return this.lastSection.lines.push(line);
    };

    Usage.prototype.filtered = function() {
      var result, section;
      result = new Usage();
      result.sections = (function() {
        var _i, _len, _ref, _ref1, _results;
        _ref = this.sections;
        _results = [];
        for (_i = 0, _len = _ref.length; _i &lt; _len; _i++) {
          section = _ref[_i];
          if (!((_ref1 = section.type) === &#039;preamble&#039; || _ref1 === &#039;commands&#039;)) {
            _results.push(section);
          }
        }
        return _results;
      }).call(this);
      return result;
    };

    Usage.prototype.firstPreambleLine = function() {
      return this.sections[0].lines[0] || &#039;&#039;;
    };

    Usage.prototype.toUsageString = function() {
      var s, section, usageStrings;
      usageStrings = (function() {
        var _i, _len, _ref, _results;
        _ref = this.sections;
        _results = [];
        for (_i = 0, _len = _ref.length; _i &lt; _len; _i++) {
          section = _ref[_i];
          _results.push(section.toUsageString());
        }
        return _results;
      }).call(this);
      return ((function() {
        var _i, _len, _results;
        _results = [];
        for (_i = 0, _len = usageStrings.length; _i &lt; _len; _i++) {
          s = usageStrings[_i];
          if (s) {
            _results.push(s);
          }
        }
        return _results;
      })()).join(&quot;\n&quot;);
    };

    Usage.toUsageString = function(usages) {
      var s, usage, usageStrings;
      usageStrings = (function() {
        var _i, _len, _results;
        _results = [];
        for (_i = 0, _len = usages.length; _i &lt; _len; _i++) {
          usage = usages[_i];
          _results.push(usage.toUsageString());
        }
        return _results;
      })();
      return ((function() {
        var _i, _len, _results;
        _results = [];
        for (_i = 0, _len = usageStrings.length; _i &lt; _len; _i++) {
          s = usageStrings[_i];
          if (s) {
            _results.push(s);
          }
        }
        return _results;
      })()).join(&quot;\n&quot;);
    };

    return Usage;

  })();

  Syntax = (function() {

    function Syntax(handlers, specs, parent, parentContext) {
      this.handlers = handlers;
      if (specs == null) {
        specs = [];
      }
      this.parent = parent != null ? parent : null;
      this.parentContext = parentContext != null ? parentContext : &#039;&#039;;
      this.usage = new Usage();
      this.options = [];
      this[&quot;arguments&quot;] = [];
      this.commands = {};
      this.commandsOrder = [];
      if (this.parent) {
        this.parentContexts = [this.parentContext].concat(this.parent.parentContexts);
      } else {
        this.parentContexts = [];
      }
      this.nestingLevel = (this.parent ? this.parent.nestingLevel + 1 : 0);
      this.shortOptions = {};
      this.longOptions = {};
      if (specs) {
        this.add(specs);
      }
    }

    Syntax.prototype.add = function(specs, options) {
      var $, command, desc, func, gotArray, gotFunction, name, option, spec, subspecs, subsyntax, _;
      if (options == null) {
        options = {};
      }
      if (typeof specs !== &#039;object&#039;) {
        specs = [specs];
      }
      specs = specs.slice(0);
      gotArray = function() {
        return (typeof specs[0] === &#039;object&#039;) &amp;&amp; (specs[0] instanceof Array);
      };
      gotFunction = function() {
        return typeof specs[0] === &#039;function&#039;;
      };
      while (spec = specs.shift()) {
        if (typeof spec !== &#039;string&#039;) {
          throw new Error(&quot;Expected string spec, found &quot; + (typeof spec));
        }
        if (spec.match(HEADER)) {
          this.usage.startSection(&#039;*&#039;, spec);
        } else if (spec.match(USAGE)) {
          this.usage.add(&#039;usage&#039;, &quot;&quot; + spec);
        } else if (spec.match(OPTION)) {
          this.options.push((option = Option.parse(spec.trim())));
          if (option.shortOpt) {
            this.shortOptions[option.shortOpt.slice(1)] = option;
          }
          if (option.longOpt) {
            this.longOptions[option.longOpt.slice(2)] = option;
          }
          if (gotFunction()) {
            option.func = specs.shift();
          }
          this.usage.add(&#039;options&#039;, option.toUsageString());
        } else if (!gotArray() &amp;&amp; spec.match(ARGUMENT)) {
          this[&quot;arguments&quot;].push((option = Option.parse(spec.trim())));
          if (gotFunction()) {
            option.func = specs.shift();
          }
          this.usage.add(&#039;arguments&#039;, option.toUsageString());
        } else if ($ = spec.match(COMMAND)) {
          _ = $[0], name = $[1], desc = $[2];
          desc = (desc || &#039;&#039;).trim();
          func = gotFunction() ? specs.shift() : null;
          if (gotArray()) {
            subspecs = specs.shift();
          } else if ((subspecs = typeof options.loadCommandSyntax === &quot;function&quot; ? options.loadCommandSyntax(this.parentContexts.concat([name]).join(&#039; &#039;)) : void 0)) {

          } else {
            throw new Error(&quot;Array must follow a command spec: &quot; + (JSON.stringify(spec)));
          }
          subsyntax = new Syntax(this.handlers, [], this, name);
          subsyntax.add(subspecs, options);
          command = new Command(name, desc, subsyntax);
          command.func = func;
          this.commands[name] = command;
          this.commandsOrder.push(name);
          this.usage.add(&#039;commands&#039;, command.toUsageString());
        } else if (spec.trim() === &#039;&#039;) {
          this.usage.endSection();
        } else if (spec.match(TEXT)) {
          this.usage.add(&#039;text&#039;, &quot;\n&quot; + wrapText(spec.trim()));
        } else {
          throw new Error(&quot;String spec invalid: &quot; + (JSON.stringify(spec)));
        }
      }
      return this;
    };

    Syntax.prototype.filteredUsages = function() {
      var _ref;
      return [this.usage.filtered()].concat(((_ref = this.parent) != null ? _ref.filteredUsages() : void 0) || []);
    };

    Syntax.prototype.toUsageString = function() {
      var _ref;
      return Usage.toUsageString([this.usage].concat(((_ref = this.parent) != null ? _ref.filteredUsages() : void 0) || []));
    };

    Syntax.prototype.parse = function(argv, options) {
      var $, allArguments, arg, assignValue, c, command, commands, executeHook, func, funcs, index, key, name, option, positional, processOption, remainder, result, subarg, syntax, value, _, _i, _j, _k, _l, _len, _len1, _len2, _len3, _len4, _m, _ref, _ref1,
        _this = this;
      argv = argv.slice(0);
      result = {};
      positional = [];
      funcs = [];
      commands = [];
      syntax = this;
      executeHook = function(option, value) {
        var newValue;
        if (option.func) {
          if (option.tags.delayfunc) {
            funcs.push([option.func, option, value]);
          } else {
            newValue = option.func(value, result, syntax, option);
            if (newValue != null) {
              value = newValue;
            }
          }
        }
        return value;
      };
      processOption = function(result, arg, option, value) {
        var index, metavar, subvalue, _i, _len, _ref;
        switch (option.metavars.length) {
          case 0:
            value = true;
            break;
          case 1:
            if (value == null) {
              value = argv.shift();
            }
            if (typeof value === &#039;undefined&#039;) {
              throw createError(&quot;Option &quot; + arg + &quot; requires an argument: &quot; + (option.leftUsageComponent()));
            }
            break;
          default:
            value = [];
            _ref = option.metavars;
            for (index = _i = 0, _len = _ref.length; _i &lt; _len; index = ++_i) {
              metavar = _ref[index];
              value.push((subvalue = argv.shift()));
              if (typeof subvalue === &#039;undefined&#039;) {
                throw createError(&quot;Option &quot; + arg + &quot; requires &quot; + option.metavars.length + &quot; arguments: &quot; + (option.leftUsageComponent()));
              }
            }
        }
        return option.coerce(value, result, syntax);
      };
      assignValue = function(result, option, value) {
        if (option.tags.list) {
          if (!result.hasOwnProperty(option[&quot;var&quot;])) {
            result[option[&quot;var&quot;]] = [];
          }
          if (value != null) {
            return result[option[&quot;var&quot;]].push(value);
          }
        } else {
          return result[option[&quot;var&quot;]] = value;
        }
      };
      while (arg = argv.shift()) {
        if (arg === &#039;--&#039;) {
          while (arg = argv.shift()) {
            positional.push(arg);
          }
        } else if (arg === &#039;-&#039;) {
          positional.push(arg);
        } else if (arg.match(/^--no-/) &amp;&amp; (option = syntax.lookupLongOption(arg.slice(5), result)) &amp;&amp; option.tags.flag) {
          assignValue(result, option, false);
        } else if ($ = arg.match(/^--([^=]+)(?:=(.*))?$/)) {
          _ = $[0], name = $[1], value = $[2];
          if (option = syntax.lookupLongOption(name, result)) {
            value = processOption(result, arg, option, value);
            value = executeHook(option, value);
            assignValue(result, option, value);
          } else {
            throw createError(&quot;Unknown long option: &quot; + arg);
          }
        } else if (arg.match(/^-/)) {
          remainder = arg.slice(1);
          while (remainder) {
            subarg = remainder[0];
            remainder = remainder.slice(1);
            if (option = syntax.lookupShortOption(subarg, result)) {
              if (remainder &amp;&amp; option.metavars.length &gt; 0) {
                value = remainder;
                remainder = &#039;&#039;;
              } else {
                value = void 0;
              }
              value = processOption(result, arg, option, value);
              value = executeHook(option, value);
              assignValue(result, option, value);
            } else {
              if (arg === (&quot;-&quot; + subarg)) {
                throw createError(&quot;Unknown short option &quot; + arg);
              } else {
                throw createError(&quot;Unknown short option -&quot; + subarg + &quot; in &quot; + arg);
              }
            }
          }
        } else if ((positional.length === 0) &amp;&amp; (command = syntax.lookupCommand(arg, result))) {
          commands.push(command);
          if (key = options.commandKeys[syntax.nestingLevel]) {
            result[key] = arg;
          }
          if (key = options.compoundCommandKey) {
            result[key] = ((function() {
              var _i, _len, _results;
              _results = [];
              for (_i = 0, _len = commands.length; _i &lt; _len; _i++) {
                c = commands[_i];
                _results.push(c.name);
              }
              return _results;
            })()).join(&#039; &#039;);
          }
          syntax = command.syntax;
        } else {
          positional.push(arg);
        }
      }
      if (syntax.commandsOrder.length &gt; 0) {
        if (positional.length === 0) {
          throw createError(&quot;No &quot; + SUBSUBSUB[syntax.nestingLevel] + &quot; specified&quot;);
        } else {
          throw createError(&quot;Unknown &quot; + SUBSUBSUB[syntax.nestingLevel] + &quot; &#039;&quot; + positional[0] + &quot;&#039;&quot;);
        }
      }
      _ref = syntax.allOptions();
      for (_i = 0, _len = _ref.length; _i &lt; _len; _i++) {
        option = _ref[_i];
        if (!result.hasOwnProperty(option[&quot;var&quot;])) {
          if (option.tags.required) {
            throw createError(&quot;Missing required option: &quot; + (option.leftUsageComponent()));
          }
          if ((option.defaultValue != null) || option.tags.fancydefault || option.tags.list) {
            if (option.defaultValue != null) {
              value = option.coerce(option.defaultValue, result, syntax);
            } else {
              value = null;
            }
            value = executeHook(option, value);
            assignValue(result, option, value);
          }
        }
      }
      allArguments = syntax.allArguments();
      for (index = _j = 0, _len1 = positional.length; _j &lt; _len1; index = ++_j) {
        arg = positional[index];
        if (option = allArguments[index]) {
          value = option.coerce(arg, result, syntax);
          value = executeHook(option, value);
          positional[index] = value;
          if (option[&quot;var&quot;]) {
            assignValue(result, option, value);
          }
        }
      }
      for (index = _k = 0, _len2 = allArguments.length; _k &lt; _len2; index = ++_k) {
        option = allArguments[index];
        if (index &gt;= positional.length) {
          if (option.tags.required) {
            throw createError(&quot;Missing required argument \#&quot; + (index + 1) + &quot;: &quot; + (option.leftUsageComponent()));
          }
          if ((option.defaultValue != null) || option.tags.fancydefault) {
            if (option.defaultValue != null) {
              value = option.coerce(option.defaultValue, result, syntax);
            } else {
              value = null;
            }
            value = executeHook(option, value);
            if (option[&quot;var&quot;]) {
              assignValue(result, option, value);
            }
            if (index === positional.length) {
              positional.push(value);
            } else if (!option[&quot;var&quot;] &amp;&amp; !option.func) {
              throw new Error(&quot;Cannot apply default value to argument \#&quot; + (index + 1) + &quot; (&quot; + (option.leftUsageComponent()) + &quot;) because no #var is specified, no func is provided and previous arguments don&#039;t have default values&quot;);
            }
          }
        }
      }
      result.argv = positional;
      for (_l = 0, _len3 = funcs.length; _l &lt; _len3; _l++) {
        _ref1 = funcs[_l], func = _ref1[0], option = _ref1[1], value = _ref1[2];
        func(value, result, syntax, option);
      }
      for (_m = 0, _len4 = commands.length; _m &lt; _len4; _m++) {
        command = commands[_m];
        if (typeof command.func === &quot;function&quot;) {
          command.func(result);
        }
      }
      return result;
    };

    Syntax.prototype.lookupLongOption = function(name, result) {
      var option, _base;
      if (!this.longOptions.hasOwnProperty(name)) {
        if (this.parent &amp;&amp; (option = this.parent.lookupLongOption(name, result))) {
          return option;
        }
        if (typeof (_base = this.handlers).resolveLongOption === &quot;function&quot;) {
          _base.resolveLongOption(name, result, this);
        }
      }
      if (this.longOptions.hasOwnProperty(name)) {
        return this.longOptions[name];
      } else {
        return null;
      }
    };

    Syntax.prototype.lookupShortOption = function(name, result) {
      var option, _base;
      if (!this.shortOptions.hasOwnProperty(name)) {
        if (this.parent &amp;&amp; (option = this.parent.lookupShortOption(name, result))) {
          return option;
        }
        if (typeof (_base = this.handlers).resolveShortOption === &quot;function&quot;) {
          _base.resolveShortOption(name, result, this);
        }
      }
      if (this.shortOptions.hasOwnProperty(name)) {
        return this.shortOptions[name];
      } else {
        return null;
      }
    };

    Syntax.prototype.lookupCommand = function(name, result) {
      var command, _base;
      if (!this.commands.hasOwnProperty(name)) {
        if (this.parent &amp;&amp; (command = this.parent.lookupCommand(name, result))) {
          return command;
        }
        if (typeof (_base = this.handlers).resolveCommand === &quot;function&quot;) {
          _base.resolveCommand(name, result, this);
        }
      }
      if (this.commands.hasOwnProperty(name)) {
        return this.commands[name];
      } else {
        return null;
      }
    };

    Syntax.prototype.allOptions = function() {
      var _ref;
      return (((_ref = this.parent) != null ? _ref.allOptions() : void 0) || []).concat(this.options);
    };

    Syntax.prototype.allArguments = function() {
      var _ref;
      return (((_ref = this.parent) != null ? _ref.allArguments() : void 0) || []).concat(this[&quot;arguments&quot;]);
    };

    Syntax.prototype.allCommands = function() {
      return this.commandsOrder;
    };

    return Syntax;

  })();

  Option.parse = function(spec) {
    var $, defaultValue, desc, isOption, longOpt, metavars, options, shortOpt, tag, tags, value, _, _ref, _ref1, _ref2, _ref3, _ref4;
    isOption = (&#039; &#039; + spec).match(OPTION);
    _ref = spec.match(OPTION_DESC) || [void 0, spec, &quot;&quot;], _ = _ref[0], options = _ref[1], desc = _ref[2];
    if (isOption) {
      _ref1 = options.match(OPTION_METAVARS) || [void 0, options, &quot;&quot;], _ = _ref1[0], options = _ref1[1], metavars = _ref1[2];
      _ref2 = options.match(OPTION_SHORT) || [void 0, &quot;&quot;, options], _ = _ref2[0], shortOpt = _ref2[1], options = _ref2[2];
      _ref3 = (options || &#039;&#039;).match(OPTION_LONG) || [void 0, &quot;&quot;, options], _ = _ref3[0], longOpt = _ref3[1], options = _ref3[2];
    } else {
      _ref4 = [options, &quot;&quot;], metavars = _ref4[0], options = _ref4[1];
    }
    metavars = metavars &amp;&amp; metavars.trim() &amp;&amp; metavars.trim().split(/\s+/) || [];
    tags = ((function() {
      var _results;
      _results = [];
      while ($ = desc.match(OPTION_DESC_TAG)) {
        _results.push(((_ = $[0], desc = $[1], tag = $[2], value = $[3], $), [tag, value != null ? value : true]));
      }
      return _results;
    })());
    tags.reverse();
    if (longOpt &amp;&amp; longOpt.match(OPTION_BOOL)) {
      tags.push([&#039;acceptsno&#039;, true]);
      longOpt = longOpt.replace(&#039;--[no-]&#039;, &#039;--&#039;);
    }
    if (isOption &amp;&amp; metavars.length === 0) {
      tags.push([&#039;flag&#039;, true]);
    }
    if ($ = desc.match(OPTION_DESC_DEFAULT)) {
      defaultValue = $[1];
      if (defaultValue.match(/\s/)) {
        defaultValue = void 0;
        tags.push([&#039;fancydefault&#039;, true]);
      }
    }
    if (options) {
      throw new Error(&quot;Invalid option spec format (cannot parse &quot; + (JSON.stringify(options)) + &quot;): &quot; + (JSON.stringify(spec)));
    }
    if (isOption &amp;&amp; !(shortOpt || longOpt)) {
      throw new Error(&quot;Invalid option spec format !(shortOpt || longOpt): &quot; + (JSON.stringify(spec)));
    }
    return new Option(shortOpt || null, longOpt || null, desc.trim(), tags, metavars, defaultValue);
  };

  parse = function(specs, options) {
    var syntax, _ref, _ref1, _ref2, _ref3, _ref4;
    if (options == null) {
      options = {};
    }
    if ((_ref = options.handlers) == null) {
      options.handlers = {};
    }
    if ((_ref1 = options.argv) == null) {
      options.argv = process.argv.slice(2);
    }
    if ((_ref2 = options.error) == null) {
      options.error = function(e) {
        process.stderr.write(&quot;&quot; + (e.message.trim()) + &quot;. Run with --help for help.\n&quot;);
        return process.exit(10);
      };
    }
    if ((_ref3 = options.help) == null) {
      options.help = function(text) {
        process.stdout.write(text.trim() + &quot;\n&quot;);
        return process.exit(0);
      };
    }
    if ((_ref4 = options.commandKeys) == null) {
      options.commandKeys = [&#039;command&#039;, &#039;subcommand&#039;, &#039;subsubcommand&#039;, &#039;subsubsubcommand&#039;];
    }
    options.compoundCommandKey = null;
    syntax = new Syntax(options.handlers);
    syntax.add(specs, options);
    if (!syntax.longOptions.help) {
      syntax.add([
        &quot;  -h, --help  Display this usage information&quot;, function(v, o, syntax) {
          return options.help(syntax.toUsageString());
        }
      ]);
    }
    try {
      return syntax.parse(options.argv, options);
    } catch (e) {
      if (e.isCommandLineError) {
        return options.error(e);
      } else {
        throw e;
      }
    }
  };

  module.exports = parse;

  module.exports.parseOptionSpec = Option.parse;

  module.exports.Syntax = Syntax;

}).call(this);</textarea>
  </div>
</div>

<footer class="footer">
  <div class="container">
    <p>.</p>
  </div>
</footer>

<script type="text/html" id="complexity-popover-template">
  <div class="complexity-notice">
    Complexity : {{ complexity.cyclomatic }} <br>
    Length : {{ complexity.halstead.length }} <br>
    Difficulty : {{ complexity.halstead.difficulty.toFixed(2) }} <br>
    Est # bugs : {{ complexity.halstead.bugs.toFixed(2) }}<br>
  </div>
</script>

<script type="text/javascript" src="../../assets/scripts/bundles/core-bundle.js"></script>
<script type="text/javascript" src="../../assets/scripts/bundles/codemirror.js"></script>
<script type="text/javascript" src="../../assets/scripts/codemirror.markpopovertext.js"></script>
<script type="text/javascript" src="report.js"></script>
<script type="text/javascript" src="report.history.js"></script>
<script type="text/javascript" src="../../assets/scripts/plato-file.js"></script>
</body>
</html>
