<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Plato - node_modules/ampersand-state/test/full.js</title>

  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="">
  <meta name="author" content="">

  <!--[if lt IE 9]>
  <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->

  <link href="../../assets/css/vendor/morris.css" rel="stylesheet">
  <link href="../../assets/css/vendor/bootstrap.css" rel="stylesheet">
  <link href="../../assets/css/vendor/font-awesome.css" rel="stylesheet">
  <link href="../../assets/css/vendor/codemirror.css" rel="stylesheet">
  <link href="../../assets/css/plato.css" rel="stylesheet">
  <link href="../../assets/css/plato-file.css" rel="stylesheet">

</head>

<body>

<div class="navbar navbar-fixed-top">
  <div class="container">
    <a class="navbar-brand" href="http://github.com/es-analysis/plato">Plato on Github</a>
    <ul class="nav navbar-nav">
      <li>
        <a href="../../index.html">Report Home</a>
      </li>
    </ul>
  </div>
</div>

<div class="jumbotron">
  <div class="container">
    <h1>node_modules/ampersand-state/test/full.js</h1>
  </div>
</div>

<div class="container aggregate-stats">
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Maintainability <a href="http://blogs.msdn.com/b/codeanalysis/archive/2007/11/20/maintainability-index-range-and-meaning.aspx"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="A value between 0 and 100 that represents the relative ease of maintaining the code. A high value means better maintainability." data-original-title="Maintainability Index"  data-container="body"></i></a></h2>
      <p class="stat">66.74</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Lines of code <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h2>
      <p class="stat">1495</p>
    </div>
  </div>
  <div class="row historical">
    <div class="col-md-6">
      <p id="chart_historical_maint" class="chart"></p>
    </div>
    <div class="col-md-6">
      <p id="chart_historical_sloc" class="chart"></p>
    </div>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Difficulty  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="The difficulty measure is related to the difficulty of the program to write or understand." data-original-title="Difficulty" data-container="body"></i></a></h2>
      <p class="stat">79.53</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Estimated Errors  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Halstead's delivered bugs is an estimate for the number of errors in the implementation." data-original-title="Delivered Bugs" data-container="body"></i></a></h2>
      <p class="stat">17.42</p>
    </div>
  </div>
</div>

<div class="container charts">
  <div class="row">
    <h2 class="header">Function weight</h2>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h3 class="chart-header">By Complexity <a href="http://en.wikipedia.org/wiki/Cyclomatic_complexity"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="This metric counts the number of distinct paths through a block of code. Lower values are better." data-original-title="Cyclomatic Complexity" data-container="body"></i></a></h3>
      <div id="fn-by-complexity" class="stat"></div>
    </div>
    <div class="col-md-6">
      <h3 class="chart-header">By SLOC  <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h3>
      <div id="fn-by-sloc" class="stat"></div>
    </div>
  </div>
</div>

<div class="container">
  <div class="row">
    <textarea id="file-source" class="col-md-12">var tape = require(&#039;tape&#039;);
var State = require(&#039;../ampersand-state&#039;);
var AmpersandRegistry = require(&#039;ampersand-registry&#039;);
var Collection = require(&#039;ampersand-collection&#039;);
var definition, Foo, registry;


// wrap test so we always run reset first
var test = function () {
    reset();
    tape.apply(tape, arguments);
};
test.only = function () {
    reset();
    tape.only.apply(tape, arguments);
};

function reset() {
    registry = new AmpersandRegistry();

    definition = {
        type: &#039;foo&#039;,
        props: {
            id: &#039;number&#039;,
            firstName: [&#039;string&#039;, true, &#039;defaults&#039;],
            lastName: [&#039;string&#039;, true],
            thing: {
                type: &#039;string&#039;,
                required: true,
                default: &#039;hi&#039;
            },
            num: [&#039;number&#039;, true],
            today: [&#039;date&#039;],
            hash: [&#039;object&#039;],
            list: [&#039;array&#039;],
            myBool: [&#039;boolean&#039;, true, false],
            someNumber: {type: &#039;number&#039;, allowNull: true},
            someNull: {type: &#039;object&#039;, default: null},
            good: {
                type: &#039;string&#039;,
                test: function (newVal) {
                    if (newVal !== &#039;good&#039;) {
                        return &quot;Value not good&quot;;
                    }
                }
            }
        },
        session: {
            active: [&#039;boolean&#039;, true, true]
        },
        derived: {
            name: {
                deps: [&#039;firstName&#039;, &#039;lastName&#039;],
                fn: function () {
                    return this.firstName + &#039; &#039; + this.lastName;
                }
            },
            initials: {
                deps: [&#039;firstName&#039;, &#039;lastName&#039;],
                cache: false,
                fn: function () {
                    // This currently breaks without both deps being set
                    if (this.firstName &amp;&amp; this.lastName) {
                        return (this.firstName.charAt(0) + this.lastName.charAt(0)).toUpperCase();
                    }
                    return &#039;&#039;;
                }
            },
            isCrazy: {
                deps: [&#039;crazyPerson&#039;],
                fn: function () {
                    return !!this.crazyPerson;
                }
            }
        },
        // add a reference to the registry
        registry: registry
    };

    Foo = State.extend(definition);
}

test(&#039;should get the derived value&#039;, function (t) {
    var foo = new Foo({
        firstName: &#039;jim&#039;,
        lastName: &#039;tom&#039;
    });
    foo.firstName = &#039;jim&#039;;
    foo.lastName = &#039;tom&#039;;

    t.strictEqual(foo.name, &#039;jim tom&#039;);
    t.strictEqual(foo.initials, &#039;JT&#039;);
    t.end();
});

test(&#039;should have default values for properties&#039;, function (t) {
    var foo = new Foo({
        firstName: &#039;jim&#039;,
        lastName: &#039;tom&#039;
    });
    t.strictEqual(foo.myBool, false);
    t.strictEqual(foo.someNull, null);
    t.end();
});

test(&#039;should have default array/object properties&#039;, function (t) {
    var Bar = State.extend({
        props: {
            list: [&#039;array&#039;, true],
            hash: [&#039;object&#039;, true]
        }
    });
    var bar = new Bar();
    var otherBar = new Bar();

    t.ok(bar.list !== undefined);
    t.ok(bar.hash !== undefined);

    //Should create unique instances of the defaults
    otherBar.list.push(&#039;foo&#039;);
    otherBar.hash.foo = &#039;bar&#039;;

    t.ok(bar.list.length === 0);
    t.ok(bar.hash.foo === undefined);

    t.end();
});

test(&#039;should throw a useful error setting a default value to an array&#039;, function (t) {
    t.plan(2);
    try {
        State.extend({
            props: { list: [&#039;array&#039;, true, []] }
        });
    } catch (err) {
        t.ok(err instanceof TypeError);
        t.ok(err.message.match(/value for list cannot be an object\/array/));
    }
});

test(&#039;should throw a useful error setting a default value to an object&#039;, function (t) {
    t.plan(2);
    try {
        State.extend({
            props: { list: [&#039;array&#039;, true, []] }
        });
    } catch (err) {
        t.ok(err instanceof TypeError);
        t.ok(err.message.match(/value for list cannot be an object\/array/));
    }
});

test(&#039;a default should be settable as a function which returns a value&#039;, function (t) {
    var Foo = State.extend({
        props: {
            anObject: [&#039;object&#039;, true, function () { return {foo: &#039;bar&#039;}; }]
        }
    });

    var foo = new Foo();

    t.deepEqual(foo.anObject, {foo: &#039;bar&#039;});
    t.end();
});

test(&#039;should throw an error setting a derived prop&#039;, function (t) {
    t.plan(1);
    var foo = new Foo();
    try { foo.name = &#039;bob&#039;; }
    catch (err) { t.ok(err instanceof TypeError); }
});

test(&#039;Error when setting derived property should be helpful&#039;, function (t) {
    var foo = new Foo();
    try { foo.name = &#039;bob&#039;; }
    catch (err) {
        t.equal(err.message, &quot;\&quot;name\&quot; is a derived property, it can&#039;t be set directly.&quot;);
    }
    t.end();
});

test(&#039;should get correct defaults&#039;, function (t) {
    var foo = new Foo({});
    t.strictEqual(foo.firstName, &#039;defaults&#039;);
    t.strictEqual(foo.thing, &#039;hi&#039;);
    t.end();
});

test(&#039;Setting other properties when `extraProperties: &quot;reject&quot;` throws error&#039;, function (t) {
    var Foo = State.extend({
        extraProperties: &#039;reject&#039;
    });
    var foo = new Foo();
    t.throws(function () {
        foo.set({
            craziness: &#039;new&#039;
        });
    }, Error, &#039;Throws exception if set to rejcet&#039;);
    t.end();
});

test(&#039;Setting other properties ignores them by default&#039;, function (t) {
    var foo = new Foo();
    foo.set({
        craziness: &#039;new&#039;
    });
    t.strictEqual(foo.craziness, undefined, &#039;property should be ignored&#039;);
    t.end();
});

test(&#039;Setting other properties is ok if extraProperties = &quot;allow&quot;&#039;, function (t) {
    var foo = new Foo();
    foo.extraProperties = &#039;allow&#039;;
    foo.set({
        craziness: &#039;new&#039;
    });
    t.equal(foo.get(&#039;craziness&#039;), &#039;new&#039;);
    t.end();
});

test(&#039;#11 - multiple instances of the same state class should be able to use extraProperties = &quot;allow&quot; as expected&#039;, function (t) {
    var Foo = State.extend({
        extraProperties: &#039;allow&#039;
    });

    var one = new Foo({ a: &#039;one.a&#039;, b: &#039;one.b&#039; });
    var two = new Foo({ a: &#039;two.a&#039;, b: &#039;two.b&#039;, c: &#039;two.c&#039; });

    t.equal(one.a, &#039;one.a&#039;);
    t.equal(one.b, &#039;one.b&#039;);

    t.equal(two.a, &#039;two.a&#039;);
    t.equal(two.b, &#039;two.b&#039;);
    t.equal(two.c, &#039;two.c&#039;);

    t.end();
});

test(&#039;extraProperties = &quot;allow&quot; properties should be defined entirely on the instance not the prototype&#039;, function (t) {
    var Foo = State.extend({
        extraProperties: &#039;allow&#039;
    });

    var one = new Foo({ a: &#039;one.a&#039;, b: &#039;one.b&#039; });
    var two = new Foo();

    t.deepEqual(two._definition, {});
    t.end();
});

test(&#039;should throw a type error for bad data types&#039;, function (t) {
    t.throws(function () {
        new Foo({firstName: 3});
    }, TypeError);
    t.throws(function () {
        new Foo({num: &#039;foo&#039;});
    }, TypeError);
    t.throws(function () {
        new Foo({hash: 10});
    }, TypeError);
    t.throws(function () {
        new Foo({today: &#039;asdfadsfa&#039;});
    }, TypeError);
    t.doesNotThrow(function () {
        new Foo({today: 1397631169892});
        new Foo({today: &#039;1397631169892&#039;});
        new Foo({today: &#039;2014-11-13&#039;});
        new Foo({today: &#039;2014-11-13T21:01Z&#039;});
        new Foo({today: &#039;2014-11-13T21:01:28.752Z&#039;});
    });
    t.throws(function () {
        new Foo({list: 10});
    }, TypeError);
    t.end();
});

test(&#039;should validate model&#039;, function (t) {
    var foo = new Foo();
    t.equal(foo._verifyRequired(), false);

    foo.firstName = &#039;a&#039;;
    foo.lastName = &#039;b&#039;;
    foo.thing = &#039;abc&#039;;
    foo.num = 12;
    t.ok(foo._verifyRequired());
    t.end();
});

test(&#039;should store previous attributes&#039;, function (t) {
    var foo = new Foo({
        firstName: &#039;beau&#039;
    });
    foo.firstName = &#039;john&#039;;
    t.strictEqual(foo.firstName, &#039;john&#039;);
    t.strictEqual(foo.previous(&#039;firstName&#039;), &#039;beau&#039;);
    foo.firstName = &#039;blah&#039;;
    t.strictEqual(foo.previous(&#039;firstName&#039;), &#039;john&#039;);
    t.end();
});

test(&#039;should have data serialization methods&#039;, function (t) {
    var foo = new Foo({
        firstName: &#039;bob&#039;,
        lastName: &#039;tom&#039;,
        thing: &#039;abc&#039;
    });

    t.deepEqual(foo.attributes, {
        firstName: &#039;bob&#039;,
        lastName: &#039;tom&#039;,
        thing: &#039;abc&#039;,
        myBool: false,
        active: true,
        someNull: null
    });
    t.deepEqual(foo.serialize(), {
        firstName: &#039;bob&#039;,
        lastName: &#039;tom&#039;,
        thing: &#039;abc&#039;,
        myBool: false,
        someNull: null
    });
    t.end();
});

test(&#039;serialize should not include session properties no matter how they\&#039;re defined.&#039;, function (t) {
    var Foo = State.extend({
        props: {
            name: &#039;string&#039;
        },
        session: {
            // simple definintion
            active: &#039;boolean&#039;
        }
    });

    var Bar = State.extend({
        props: {
            name: &#039;string&#039;
        },
        session: {
            // fuller definition
            active: [&#039;boolean&#039;, true, false]
        }
    });

    var foo = new Foo({name: &#039;hi&#039;, active: true});
    var bar = new Bar({name: &#039;hi&#039;, active: true});
    t.deepEqual(foo.serialize(), {name: &#039;hi&#039;});
    t.deepEqual(bar.serialize(), {name: &#039;hi&#039;});
    t.end();
});

test(&#039;should fire events normally for properties defined on the fly&#039;, function (t) {
    var foo = new Foo();
    foo.extraProperties = &#039;allow&#039;;
    foo.on(&#039;change:crazyPerson&#039;, function () {
        t.ok(true);
    });
    foo.set({
        crazyPerson: true
    });
    t.end();
});

test(&#039;should fire event on derived properties, even if dependent on ad hoc prop.&#039;, function (t) {
    var Foo = State.extend({
        extraProperties: &#039;allow&#039;,
        derived: {
            isCrazy: {
                deps: [&#039;crazyPerson&#039;],
                fn: function () {
                    return !!this.crazyPerson;
                }
            }
        }
    });
    var foo = new Foo();
    foo.on(&#039;change:isCrazy&#039;, function () {
        t.ok(true);
    });
    foo.set({
        crazyPerson: true
    });
    t.end();
});

test(&#039;throw error on invalid extraProperties&#039;, function (t) {
    var Foo = State.extend({
        extraProperties: &#039;qwijbo&#039;
    });
    var foo = new Foo();
    t.throws(function () {
        foo.set(&#039;a&#039;, &#039;b&#039;);
    }, TypeError, &#039;Throws TypeError on invalid extraProperties&#039;);
    t.end();
});

test(&#039;should fire general change event on single attribute&#039;, function (t) {
    var foo = new Foo({firstName: &#039;coffee&#039;});
    foo.on(&#039;change&#039;, function () {
        t.ok(true);
    });
    foo.firstName = &#039;bob&#039;;
    t.end();
});

test(&#039;should fire single change event for multiple attribute set&#039;, function (t) {
    var foo = new Foo({firstName: &#039;coffee&#039;});
    foo.on(&#039;change&#039;, function () {
        t.ok(true);
    });
    foo.set({
        firstName: &#039;roger&#039;,
        lastName: &#039;smells&#039;
    });
    t.end();
});

test(&#039;derived properties&#039;, function (t) {
    var ran = 0;
    var notCachedRan = 0;
    var Foo = State.extend({
        props: {
            name: [&#039;string&#039;, true]
        },
        derived: {
            greeting: {
                deps: [&#039;name&#039;],
                fn: function () {
                    ran++;
                    return &#039;hi, &#039; + this.name;
                }
            },
            notCached: {
                cache: false,
                deps: [&#039;name&#039;],
                fn: function () {
                    notCachedRan++;
                    return &#039;hi, &#039; + this.name;
                }
            }
        }
    });
    var foo = new Foo({name: &#039;henrik&#039;});
    t.strictEqual(ran, 0, &#039;derived function should not have run yet.&#039;);
    t.equal(foo.greeting, &#039;hi, henrik&#039;);
    t.equal(foo.greeting, &#039;hi, henrik&#039;);
    t.equal(ran, 1, &#039;cached derived should only run once&#039;);
    t.equal(notCachedRan, 0, &#039;shold not have been run yet&#039;);
    foo.name = &#039;someone&#039;;
    t.equal(foo.greeting, &#039;hi, someone&#039;);
    t.equal(foo.greeting, &#039;hi, someone&#039;);
    t.equal(ran, 2, &#039;cached derived should have been cleared and run once again&#039;);
    t.equal(notCachedRan, 1, &#039;shold have been run once because it was triggered&#039;);
    t.equal(foo.notCached, &#039;hi, someone&#039;);
    t.equal(notCachedRan, 2, &#039;incremented again&#039;);
    t.equal(foo.notCached, &#039;hi, someone&#039;);
    t.equal(notCachedRan, 3, &#039;incremented each time&#039;);
    t.end();
});

test(&#039;cached, derived properties should only fire change event if they\&#039;ve actually changed&#039;, function (t) {
    var changed = 0;
    var Foo = State.extend({
        props: {
            name: [&#039;string&#039;, true],
            other: &#039;string&#039;
        },
        derived: {
            greeting: {
                deps: [&#039;name&#039;, &#039;other&#039;],
                fn: function () {
                    return &#039;hi, &#039; + this.name;
                }
            }
        }
    });
    var foo = new Foo({name: &#039;henrik&#039;});
    foo.on(&#039;change:greeting&#039;, function () {
        changed++;
    });
    t.equal(changed, 0);
    foo.name = &#039;new&#039;;
    t.equal(changed, 1);
    foo.other = &#039;new&#039;;
    t.equal(changed, 1);
    t.end();
});

test(&#039;derived properties with derived dependencies&#039;, function (t) {
    var ran = 0;
    var Foo = State.extend({
        props: {
            name: [&#039;string&#039;, true]
        },
        derived: {
            greeting: {
                deps: [&#039;name&#039;],
                fn: function () {
                    return &#039;hi, &#039; + this.name;
                }
            },
            awesomeGreeting: {
                deps: [&#039;greeting&#039;],
                fn: function () {
                    return this.greeting + &#039;!&#039;;
                }
            }
        }
    });
    var foo = new Foo({name: &#039;henrik&#039;});
    foo.on(&#039;change:awesomeGreeting&#039;, function () {
        ran++;
        t.ok(true, &#039;should fire derived event&#039;);
    });
    foo.on(&#039;change:greeting&#039;, function () {
        ran++;
        t.ok(true, &#039;should fire derived event&#039;);
    });
    foo.on(&#039;change:name&#039;, function () {
        ran++;
        t.ok(true, &#039;should fire derived event&#039;);
    });
    foo.on(&#039;change&#039;, function () {
        ran++;
        t.ok(true, &#039;should file main event&#039;);
    });
    foo.name = &#039;something&#039;;
    t.equal(ran, 4);
    t.end();
});

test(&#039;derived properties triggered with multiple instances&#039;, function (t) {
    var foo = new Foo({firstName: &#039;Silly&#039;, lastName: &#039;Fool&#039;});
    var bar = new Foo({firstName: &#039;Bar&#039;, lastName: &#039;Man&#039;});

    foo.on(&#039;change:name&#039;, function () {
        t.ok(&#039;name changed&#039;);
    });
    foo.firstName = &#039;bob&#039;;
    bar.on(&#039;change:name&#039;, function () {
        t.ok(&#039;name changed&#039;);
    });
    bar.firstName = &#039;bob too&#039;;
    t.end();
});

test(&#039;Calling `previous` during change of derived cached property should work&#039;, function (t) {
    var foo = new Foo({firstName: &#039;Henrik&#039;, lastName: &#039;Joreteg&#039;});
    var ran = false;
    foo.on(&#039;change:name&#039;, function () {
        if (!ran) {
            t.equal(typeof foo.previous(&#039;name&#039;), &#039;undefined&#039;);
            ran = true;
        } else {
            t.equal(foo.previous(&#039;name&#039;), &#039;Crazy Joreteg&#039;);
        }
    });

    foo.firstName = &#039;Crazy&#039;;
    foo.firstName = &#039;Lance!&#039;;
    t.end();
});

test(&#039;Calling `previous` during change of derived property that is not cached, should be `undefined`&#039;, function (t) {
    var foo = new Foo({firstName: &#039;Henrik&#039;, lastName: &#039;Joreteg&#039;});

    // the initials property is explicitly not cached
    // so you should not be able to get a previous value
    // for it.
    foo.on(&#039;change:initials&#039;, function () {
        t.equal(typeof foo.previous(&#039;initials&#039;), &#039;undefined&#039;);
    });

    foo.firstName = &#039;Crazy&#039;;
    t.end();
});

test(&#039;Should be able to define and use custom data types&#039;, function (t) {
    var Foo = State.extend({
        props: {
            silliness: &#039;crazyType&#039;
        },
        dataTypes: {
            crazyType: {
                set: function (newVal) {
                    return {
                        val: newVal,
                        type: &#039;crazyType&#039;
                    };
                },
                get: function (val) {
                    return val + &#039;crazy!&#039;;
                }
            }
        }
    });

    var foo = new Foo({silliness: &#039;you &#039;});

    t.equal(foo.silliness, &#039;you crazy!&#039;);
    t.end();
});

test(&#039;Uses dataType compare&#039;, function (t) {
    var compareRun;

    var Foo = State.extend({
        props: {
            silliness: &#039;crazyType&#039;
        },
        dataTypes: {
            crazyType: {
                compare: function (oldVal, newVal) {
                    compareRun = true;
                    return false;
                },
                set: function (newVal) {
                    return {
                        val: newVal,
                        type: &#039;crazyType&#039;
                    };
                },
                get: function (val) {
                    return val + &#039;crazy!&#039;;
                }
            }
        }
    });

    compareRun = false;
    var foo = new Foo({ silliness: &#039;you&#039; });
    t.assert(compareRun);

    compareRun = false;
    foo.silliness = &#039;they&#039;;
    t.assert(compareRun);
    t.end();
});

test(&#039;Should only allow nulls where specified&#039;, function (t) {
    var foo = new Foo({
        firstName: &#039;bob&#039;,
        lastName: &#039;vila&#039;,
        someNumber: null
    });
    t.equal(foo.someNumber, null);
    t.throws(function () {
        foo.firstName = null;
    }, TypeError, &#039;Throws exception when setting unallowed null&#039;);
    t.end();
});

test(&#039;Attribute test function works&#039;, function (t) {
    var foo = new Foo({good: &#039;good&#039;});
    t.equal(foo.good, &#039;good&#039;);

    t.throws(function () {
        foo.good = &#039;bad&#039;;
    }, TypeError, &#039;Throws exception on invalid attribute value&#039;);
    t.end();
});

test(&#039;Values attribute basic functionality&#039;, function (t) {
    var Model = State.extend({
        props: {
            state: {
                values: [&#039;CA&#039;, &#039;WA&#039;, &#039;NV&#039;]
            }
        }
    });

    var m = new Model();

    t.throws(function () {
        m.state = &#039;PR&#039;;
    }, TypeError, &#039;Throws exception when setting something not in list&#039;);

    t.equal(m.state, undefined, &#039;Should be undefined if no default&#039;);

    m.state = &#039;CA&#039;;

    t.equal(m.state, &#039;CA&#039;, &#039;State should be set&#039;);
    t.end();
});

test(&#039;Values attribute default works&#039;, function (t) {
    var Model = State.extend({
        props: {
            state: {
                values: [&#039;CA&#039;, &#039;WA&#039;, &#039;NV&#039;],
                default: &#039;CA&#039;
            }
        }
    });

    var m = new Model();

    t.equal(m.state, &#039;CA&#039;, &#039;Should have applied the default&#039;);

    t.throws(function () {
        m.state = &#039;PR&#039;;
    }, TypeError, &#039;Throws exception when setting something not in list&#039;);
    t.end();
});

test(&#039;toggle() works on boolean and values properties.&#039;, function (t) {
    var Model = State.extend({
        props: {
            isAwesome: &#039;boolean&#039;,
            someNumber: &#039;number&#039;,
            state: {
                values: [&#039;CA&#039;, &#039;WA&#039;, &#039;NV&#039;],
                default: &#039;CA&#039;
            }
        }
    });

    var m = new Model();

    t.throws(function () {
        m.toggle(&#039;someNumber&#039;);
    }, TypeError, &#039;Throws exception when toggling a non-togglable property.&#039;);

    m.toggle(&#039;state&#039;);
    t.equal(m.state, &#039;WA&#039;, &#039;Should go to next&#039;);
    m.toggle(&#039;state&#039;);
    t.equal(m.state, &#039;NV&#039;, &#039;Should go to next&#039;);
    m.toggle(&#039;state&#039;);
    t.equal(m.state, &#039;CA&#039;, &#039;Should go to next with loop&#039;);

    m.toggle(&#039;isAwesome&#039;);
    t.strictEqual(m.isAwesome, true, &#039;Should toggle even if undefined&#039;);
    m.toggle(&#039;isAwesome&#039;);
    t.strictEqual(m.isAwesome, false, &#039;Should toggle if true.&#039;);
    m.toggle(&#039;isAwesome&#039;);
    t.strictEqual(m.isAwesome, true, &#039;Should toggle if false.&#039;);
    t.end();
});

test(&#039;property test function scope is correct.&#039;, function (t) {
    var m;
    var temp;
    var Model = State.extend({
        props: {
            truth: {
                type: &#039;boolean&#039;,
                test: function () {
                    temp = this;
                    return false;
                }
            }
        }
    });

    m = new Model();
    m.toggle(&#039;truth&#039;);
    t.equal(m, temp);
    t.end();
});

test(&#039;should be able to inherit for use in other objects&#039;, function (t) {
    var StateObj = State.extend({
        props: {
            name: &#039;string&#039;
        }
    });
    function AwesomeThing() {
        StateObj.apply(this, arguments);
    }

    AwesomeThing.prototype = Object.create(StateObj.prototype);

    AwesomeThing.prototype.hello = function () {
        return this.name;
    };

    var awe = new AwesomeThing({name: &#039;cool&#039;});

    t.equal(awe.hello(), &#039;cool&#039;);
    t.equal(awe.name, &#039;cool&#039;);
    t.end();
});

test(&#039;extended state objects should maintain child collections of parents&#039;, function (t) {
    var State1 = State.extend({
        collections: {
            myStuff: Collection
        }
    });
    var State2 = State1.extend({
        collections: {
            myOtherCollection: Collection
        }
    });
    var thing = new State2();
    t.ok(thing.myStuff);
    t.ok(thing.myOtherCollection);
    t.end();
});

test(&#039;`initialize` should have access to initialized child collections&#039;, function (t) {
    var StateObj = State.extend({
        initialize: function () {
            t.ok(this.myStuff);
            t.equal(this.myStuff.parent, this);
            t.end();
        },
        collections: {
            myStuff: Collection
        }
    });
    var thing = new StateObj();
});

test(&#039;parent collection references should be maintained when adding/removing to a collection&#039;, function (t) {
    var StateObj = State.extend({
        props: {
            id: &#039;string&#039;
        }
    });
    var c = new Collection();
    var s = new StateObj({id: &#039;47&#039;});
    c.add(s);
    t.equal(s.collection, c);
    c.remove(s);
    t.notOk(s.collection);
    t.end();
});

test(&#039;children and collections should be instantiated&#039;, function (t) {
    var GrandChild = State.extend({
        props: {
            id: &#039;string&#039;
        },
        collections: {
            nicknames: Collection
        }
    });

    var FirstChild = State.extend({
        props: {
            id: &#039;string&#039;
        },
        children: {
            grandChild: GrandChild
        }
    });

    var StateObj = State.extend({
        props: {
            id: &#039;string&#039;
        },
        children: {
            firstChild: FirstChild
        }
    });

    var data = {
        id: &#039;child&#039;,
        firstChild: {
            id: &#039;child&#039;,
            grandChild: {
                id: &#039;grandChild&#039;,
                nicknames: [
                    {name: &#039;munchkin&#039;},
                    {name: &#039;kiddo&#039;}
                ]
            }
        }
    };

    var first = new StateObj(data);

    t.ok(first.firstChild, &#039;child should be initted&#039;);
    t.ok(first.firstChild.grandChild, &#039;grand child should be initted&#039;);
    t.equal(first.firstChild.id, &#039;child&#039;);
    t.equal(first.firstChild.grandChild.id, &#039;grandChild&#039;);
    t.ok(first.firstChild.grandChild.nicknames instanceof Collection, &#039;should be collection&#039;);
    t.equal(first.firstChild.grandChild.nicknames.length, 2);

    t.deepEqual(first.serialize(), {
        id: &#039;child&#039;,
        firstChild: {
            id: &#039;child&#039;,
            grandChild: {
                id: &#039;grandChild&#039;,
                nicknames: [
                    {name: &#039;munchkin&#039;},
                    {name: &#039;kiddo&#039;}
                ]
            }
        }
    });

    t.equal(JSON.stringify(first), JSON.stringify({
        id: &#039;child&#039;,
        firstChild: {
            id: &#039;child&#039;,
            grandChild: {
                id: &#039;grandChild&#039;,
                nicknames: [
                    {name: &#039;munchkin&#039;},
                    {name: &#039;kiddo&#039;}
                ]
            }
        }
    }), &#039;should be able to pass whole object to JSON.stringify()&#039;);

    // using `set` should still apply to children
    first.set({
        firstChild: {
            id: &#039;firstChild&#039;,
            grandChild: {
                nicknames: [{name: &#039;runt&#039;}]
            }
        }
    });
    t.ok(first.firstChild instanceof FirstChild, &#039;should still be instanceof&#039;);
    t.equal(first.firstChild.id, &#039;firstChild&#039;, &#039;change should have been applied&#039;);
    t.equal(first.firstChild.grandChild.nicknames.length, 3, &#039;collection should have been updated&#039;);

    t.end();
});

test(&#039;issue #82, child collections should not be cleared if they add data to themselves when instantiated&#039;, function (t) {
    var Widget = State.extend({
        props: {
            title: &#039;string&#039;
        }
    });
    var Widgets = Collection.extend({
        initialize: function () {
            // some collections read from data they have immediate access to
            // like localstorage, or whatnot. This should not be wiped out
            // when instantiated by parent.
            this.add([{title: &#039;hi&#039;}]);
        },
        model: Widget
    });
    var Parent = State.extend({
        collections: {
            widgets: Widgets
        }
    });
    var parent = new Parent();

    t.equal(parent.widgets.length, 1, &#039;should contain data added by initialize method of child collection&#039;);
    t.end();
});

test(&#039;listens to child events&#039;, function (t) {
    var GrandChild = State.extend({
        props: {
            id: &#039;string&#039;,
            name: &#039;string&#039;
        },
        collections: {
            nicknames: Collection
        }
    });

    var FirstChild = State.extend({
        props: {
            id: &#039;string&#039;,
            name: &#039;string&#039;
        },
        children: {
            grandChild: GrandChild
        }
    });

    var StateObj = State.extend({
        props: {
            id: &#039;string&#039;,
            name: &#039;string&#039;
        },
        children: {
            firstChild: FirstChild
        }
    });

    var first = new StateObj({
        id: &#039;child&#039;,
        name: &#039;first-name&#039;,
        firstChild: {
            id: &#039;child&#039;,
            name: &#039;first-child-name&#039;,
            grandChild: {
                id: &#039;grandChild&#039;,
                name: &#039;Henrik&#039;,
                nicknames: [
                    {name: &#039;munchkin&#039;},
                    {name: &#039;kiddo&#039;}
                ]
            }
        }
    });

    t.plan(7);

    //Change property
    first.once(&#039;change:name&#039;, function (model, newVal) {
        t.equal(newVal, &#039;new-first-name&#039;);
    });
    first.name = &#039;new-first-name&#039;;
    t.equal(first.name, &#039;new-first-name&#039;);


    //Change child property
    first.once(&#039;change:firstChild.name&#039;, function (model, newVal) {
        t.equal(newVal, &#039;new-first-child-name&#039;);
    });
    first.firstChild.name = &#039;new-first-child-name&#039;;
    t.equal(first.firstChild.name, &#039;new-first-child-name&#039;);


    //Change grand child property
    first.once(&#039;change:firstChild.grandChild.name&#039;, function (unsure, name) {
        t.equal(name, &quot;Phil&quot;);
    });
    first.firstChild.grandChild.name = &#039;Phil&#039;;
    t.equal(first.firstChild.grandChild.name, &#039;Phil&#039;);

    //Propagates change events from children too
    first.once(&#039;change&#039;, function (model) {
        t.equal(model, first);
    });
    first.firstChild.grandChild.name = &#039;Bob&#039;;
});

test(&#039;Should be able to declare derived properties that have nested deps&#039;, function (t) {
    var GrandChild = State.extend({
        props: {
            id: &#039;string&#039;,
            name: &#039;string&#039;
        }
    });

    var FirstChild = State.extend({
        props: {
            id: &#039;string&#039;,
            name: &#039;string&#039;
        },
        children: {
            grandChild: GrandChild
        }
    });

    var StateObj = State.extend({
        props: {
            id: &#039;string&#039;,
            name: &#039;string&#039;
        },
        children: {
            child: FirstChild
        },
        derived: {
            relationship: {
                deps: [&#039;child.grandChild.name&#039;, &#039;name&#039;],
                fn: function () {
                    return this.name + &#039; has grandchild &#039; + (this.child.grandChild.name || &#039;&#039;);
                }
            }
        }
    });

    var first = new StateObj({
        name: &#039;henrik&#039;
    });

    t.equal(first.relationship, &#039;henrik has grandchild &#039;, &#039;basics properties working&#039;);

    first.on(&#039;change:relationship&#039;, function () {
        t.pass(&#039;got change event on derived property for child&#039;);
        t.end();
    });

    first.child.grandChild.name = &#039;something&#039;;
});

test(&#039;`state` properties&#039;, function (t) {
    var Person = State.extend({
        props: {
            sub: &#039;state&#039;,
            sub2: &#039;state&#039;
        }
    });

    var SubState = State.extend({
        props: {
            id: &#039;string&#039;
        }
    });

    var p = new Person();

    t.plan(4);

    t.equal(p.sub, undefined, &#039;should be undefined to start&#039;);

    t.throws(function () {
        p.sub = &#039;something silly&#039;;
    }, TypeError, &#039;Throws type error if not state object&#039;);

    p.once(&#039;change:sub&#039;, function () {
        t.pass(&#039;fired change for state&#039;);
    });

    var sub = new SubState({id: &#039;hello&#039;});

    p.sub = sub;

    p.on(&#039;change:sub&#039;, function () {
        t.fail(&#039;shouldnt fire if same instance&#039;);
    });

    p.sub = sub;

    p.on(&#039;change:sub.id&#039;, function () {
        t.pass(&#039;child property event bubbled&#039;);
    });

    p.sub.id = &#039;new&#039;;

    // new person
    var p2 = new Person();
    var sub1 = new SubState({id: &#039;first&#039;});
    var sub2 = new SubState({id: &#039;second&#039;});

    p2.on(&#039;change:sub.id&#039;, function () {
        t.fail(&#039;should not bubble on old one&#039;);
    });

    p2.sub = sub1;
    p2.sub = sub2;

    sub1.id = &#039;something different&#039;;

    t.end();
});

test(&#039;Issue: #75 `state` property from undefined -&gt; state&#039;, function (t) {
    t.plan(2);

    var Person = State.extend({
        props: {
            sub: &#039;state&#039;,
            sub2: &#039;state&#039;
        }
    });

    var SubState = State.extend({
        props: {
            foo: &#039;string&#039;
        }
    });

    var sub = new SubState({ foo: &#039;a&#039; });
    var p = new Person({ sub: sub });

    p.on(&#039;change:sub.foo&#039;, function () {
        t.ok(true);
    });

    sub.foo = &#039;b&#039;;

    p.sub2 = new SubState({ foo: &#039;bar&#039; });

    sub.foo = &#039;c&#039;;

    t.end();
});


test(&#039;`state` properties should invalidate dependent derived properties when changed&#039;, function (t) {
    var counter = 0;
    var Person = State.extend({
        props: {
            sub: &#039;state&#039;
        },
        derived: {
            subId: {
                deps: [&#039;sub.id&#039;],
                fn: function () {
                    return this.sub &amp;&amp; this.sub.id;
                }
            }
        }
    });

    var SubState = State.extend({
        props: {
            id: &#039;string&#039;
        }
    });

    var p = new Person();

    // count each time it&#039;s changed
    p.on(&#039;change:subId&#039;, function () {
        counter++;
    });

    var sub1 = new SubState({id: &#039;1&#039;});
    var sub2 = new SubState({id: &#039;2&#039;});

    t.equal(p.subId, undefined, &#039;should be undefined to start&#039;);

    p.sub = sub1;

    t.equal(p.subId, &#039;1&#039;, &#039;should invalidated cache&#039;);
    t.equal(counter, 1, &#039;should fire change callback for derived item&#039;);

    p.on(&#039;change:sub.id&#039;, function (model, newVal) {
        t.pass(&#039;change event should fire&#039;);
        t.equal(model, sub1, &#039;callback on these should be sub model&#039;);
        t.equal(newVal, &#039;newId&#039;, &#039;should include new val&#039;);
        t.end();
    });

    sub1.id = &#039;newId&#039;;
});

test(&quot;#1664 - Changing from one value, silently to another, back to original triggers a change.&quot;, function (t) {
    var Model = State.extend({
        props: {
            x: &#039;number&#039;
        }
    });
    var model = new Model({x: 1});
    model.on(&#039;change:x&#039;, function () { t.ok(true); t.end(); });
    model.set({x: 2}, {silent: true});
    model.set({x: 3}, {silent: true});
    model.set({x: 1});
});

test(&quot;#1664 - multiple silent changes nested inside a change event&quot;, function (t) {
    var changes = [];
    var Model = State.extend({
        props: {
            a: &#039;string&#039;,
            b: &#039;number&#039;,
            c: &#039;string&#039;
        }
    });
    var model = new Model();
    model.on(&#039;change&#039;, function () {
        model.set({a: &#039;c&#039;}, {silent: true});
        model.set({b: 2}, {silent: true});
        model.unset(&#039;c&#039;, {silent: true});
    });
    model.on(&#039;change:a change:b change:c&#039;, function (model, val) { changes.push(val); });
    model.set({a: &#039;a&#039;, b: 1, c: &#039;item&#039;});
    t.deepEqual(changes, [&#039;a&#039;, 1, &#039;item&#039;]);
    t.deepEqual(model.attributes, {a: &#039;c&#039;, b: 2});
    t.end();
});

test(&quot;silent changes in last `change` event back to original triggers change&quot;, function (t) {
    var changes = [];
    var Model = State.extend({
        props: {
            a: &#039;string&#039;
        }
    });
    var model = new Model();
    model.on(&#039;change:a change:b change:c&#039;, function (model, val) { changes.push(val); });
    model.on(&#039;change&#039;, function () {
        model.set({a: &#039;c&#039;}, {silent: true});
    });
    model.set({a: &#039;a&#039;});
    t.deepEqual(changes, [&#039;a&#039;]);
    model.set({a: &#039;a&#039;});
    t.deepEqual(changes, [&#039;a&#039;, &#039;a&#039;]);
    t.end();
});

test(&quot;#1943 change calculations should use _.isEqual&quot;, function (t) {
    var Model = State.extend({
        props: {
            a: &#039;object&#039;
        }
    });
    var model = new Model({a: {key: &#039;value&#039;}});
    model.set(&#039;a&#039;, {key: &#039;value&#039;}, {silent: true});
    t.equal(model.changedAttributes(), false);
    t.end();
});

test(&quot;#1964 - final `change` event is always fired, regardless of interim changes&quot;, function (t) {
    var Model = State.extend({
        props: {
            property: &#039;string&#039;
        }
    });
    var model = new Model();
    model.on(&#039;change:property&#039;, function () {
        model.set(&#039;property&#039;, &#039;bar&#039;);
    });
    model.on(&#039;change&#039;, function () {
        t.ok(true);
        t.end();
    });
    model.set(&#039;property&#039;, &#039;foo&#039;);
});

test(&quot;isValid&quot;, function (t) {
    var Model = State.extend({
        props: {
            valid: &#039;boolean&#039;
        }
    });
    var model = new Model({valid: true});
    model.validate = function (attrs) {
        if (!attrs.valid) return &quot;invalid&quot;;
    };
    t.equal(model.isValid(), true);
    t.equal(model.set({valid: false}, {validate: true}), false);
    t.equal(model.isValid(), true);
    model.set({valid: false});
    t.equal(model.isValid(), false);
    t.ok(!model.set(&#039;valid&#039;, false, {validate: true}));
    t.end();
});

test(&quot;#1545 - `undefined` can be passed to a model constructor without coersion&quot;, function (t) {
    var Model = State.extend({
        defaults: { one: 1 },
        initialize : function (attrs, opts) {
            t.equal(attrs, undefined);
        }
    });
    var emptyattrs = new Model();
    var undefinedattrs = new Model(undefined);
    t.end();
});

test(&quot;#1961 - Creating a model with {validate: true} will call validate and use the error callback&quot;, function (t) {
    var Model = State.extend({
        props: {
            id: &#039;number&#039;
        },
        validate: function (attrs) {
            if (attrs.id === 1) return &quot;This shouldn&#039;t happen&quot;;
        }
    });
    var model = new Model({id: 1}, {validate: true});
    t.equal(model.validationError, &quot;This shouldn&#039;t happen&quot;);
    t.end();
});

test(&quot;#2034 - nested set with silent only triggers one change&quot;, function (t) {
    var Model = State.extend({
        props: {
            a: &#039;boolean&#039;,
            b: &#039;boolean&#039;
        }
    });
    var model = new Model();
    model.on(&#039;change&#039;, function () {
        model.set({b: true}, {silent: true});
        t.ok(true);
        t.end();
    });
    model.set({a: true});
});

test(&quot;#2030 - set with failed validate, followed by another set triggers change&quot;, function (t) {
    var attr = 0, main = 0, error = 0;
    var Model = State.extend({
        props: {
            x: &#039;number&#039;
        },
        validate: function (attr) {
            if (attr.x &gt; 1) {
                error++;
                return &quot;this is an error&quot;;
            }
        }
    });
    var model = new Model({x: 0});
    model.on(&#039;change:x&#039;, function () { attr++; });
    model.on(&#039;change&#039;, function () { main++; });
    model.set({x: 2}, {validate: true});
    model.set({x: 1}, {validate: true});
    t.deepEqual([attr, main, error], [1, 1, 1]);
    t.end();
});

test(&quot;#1179 - isValid returns true in the absence of validate.&quot;, function(t) {
    var Model = State.extend({
        validate: null
    });
    var model = new Model();
    t.ok(model.isValid());
    t.end();
});

test(&quot;#1791 - `attributes` is available for `parse`&quot;, function(t) {
    var Model = State.extend({
        //Backbone test used this.has which was a this.get !== null test
        parse: function() { this.get(&#039;a&#039;) !== null; } // shouldn&#039;t throw an error
    });
    var model = new Model(null, {parse: true});
    t.end();
});

test(&quot;#96 - changedAttributes includes properties that are not direct model attributes&quot;, function(t) {
    var Submodel = State.extend({
        props: {
            b: &#039;number&#039;
        }
    });

    var Model = State.extend({
        props: {
            a: &#039;number&#039;
        },
        children: {
            submodels: Submodel
        }
    });

    var model = new Model({ a: 1 });
    var old = JSON.parse(JSON.stringify(model));
    var diff = model.changedAttributes(old);
    t.ok(diff === false, &#039;should return false&#039;);

    diff = model.changedAttributes({ a: 5, submodels: [] });
    t.ok(diff.hasOwnProperty(&#039;a&#039;), &#039;should return the changed `a`&#039;);
    t.ok(!diff.hasOwnProperty(&#039;submodels&#039;), &#039;should not return `submodels`&#039;);

    t.end();
});

test(&quot;#99 #101 - string dates can be parsed&quot;, function(t) {
    var Today = State.extend({
        props: {
            today: &#039;date&#039;
        }
    });

    var isDate = function (obj) { return Object.prototype.toString.call(obj) === &#039;[object Date]&#039;; };
    var isoString = &#039;2014-04-16T06:52:49.892Z&#039;;
    var date = new Date(isoString);

    var model = new Today();

    model.today = 1397631169892;
    t.ok(isDate(model.today));
    t.equal(model.today.valueOf(), date.valueOf(), &#039;date should accept an integer&#039;);

    model.today = &#039;1397631169892&#039;;
    t.ok(isDate(model.today));
    t.equal(model.today.valueOf(), date.valueOf(), &#039;date should accept a string which will be parsed to an integer&#039;);

    model.today = isoString;
    t.ok(isDate(model.today));
    t.equal(model.today.toJSON(), isoString, &#039;date should accept an iso string&#039;);

    model.today = new Date(isoString);
    t.ok(isDate(model.today));
    t.equal(model.today.toJSON(), isoString, &#039;date should accept a native date object&#039;);

    model.today = &#039;2014-11-13&#039;;
    t.ok(isDate(model.today));
    t.equal(model.today.toJSON(), &#039;2014-11-13T00:00:00.000Z&#039;, &#039;date should accept YYYY-MM-DD&#039;);

    model.today = &#039;2014-11-13T21:01Z&#039;;
    t.ok(isDate(model.today));
    t.equal(model.today.toJSON(), &#039;2014-11-13T21:01:00.000Z&#039;, &#039;date should accept YYYY-MM-DDTHH:MMZ&#039;);

    t.end();
});

test(&#039;#68, #110 mixin props should not be deleted&#039;, function (t) {
    var SelectedMixin = {
      session : {
        selected : &#039;boolean&#039;
      }
    };

    var Widget = State.extend(SelectedMixin,{});
    t.deepEqual(SelectedMixin.session, { selected: &#039;boolean&#039; });
    var Sprocket = State.extend(SelectedMixin,{});

    var widget = new Widget({selected : true});
    var sprocket = new Sprocket({selected : true});

    t.ok(widget.selected);
    t.ok(sprocket.selected);
    t.end();
});</textarea>
  </div>
</div>

<footer class="footer">
  <div class="container">
    <p>.</p>
  </div>
</footer>

<script type="text/html" id="complexity-popover-template">
  <div class="complexity-notice">
    Complexity : {{ complexity.cyclomatic }} <br>
    Length : {{ complexity.halstead.length }} <br>
    Difficulty : {{ complexity.halstead.difficulty.toFixed(2) }} <br>
    Est # bugs : {{ complexity.halstead.bugs.toFixed(2) }}<br>
  </div>
</script>

<script type="text/javascript" src="../../assets/scripts/bundles/core-bundle.js"></script>
<script type="text/javascript" src="../../assets/scripts/bundles/codemirror.js"></script>
<script type="text/javascript" src="../../assets/scripts/codemirror.markpopovertext.js"></script>
<script type="text/javascript" src="report.js"></script>
<script type="text/javascript" src="report.history.js"></script>
<script type="text/javascript" src="../../assets/scripts/plato-file.js"></script>
</body>
</html>
