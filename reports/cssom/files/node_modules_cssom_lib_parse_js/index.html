<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Plato - node_modules/cssom/lib/parse.js</title>

  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="">
  <meta name="author" content="">

  <!--[if lt IE 9]>
  <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->

  <link href="../../assets/css/vendor/morris.css" rel="stylesheet">
  <link href="../../assets/css/vendor/bootstrap.css" rel="stylesheet">
  <link href="../../assets/css/vendor/font-awesome.css" rel="stylesheet">
  <link href="../../assets/css/vendor/codemirror.css" rel="stylesheet">
  <link href="../../assets/css/plato.css" rel="stylesheet">
  <link href="../../assets/css/plato-file.css" rel="stylesheet">

</head>

<body>

<div class="navbar navbar-fixed-top">
  <div class="container">
    <a class="navbar-brand" href="http://github.com/es-analysis/plato">Plato on Github</a>
    <ul class="nav navbar-nav">
      <li>
        <a href="../../index.html">Report Home</a>
      </li>
    </ul>
  </div>
</div>

<div class="jumbotron">
  <div class="container">
    <h1>node_modules/cssom/lib/parse.js</h1>
  </div>
</div>

<div class="container aggregate-stats">
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Maintainability <a href="http://blogs.msdn.com/b/codeanalysis/archive/2007/11/20/maintainability-index-range-and-meaning.aspx"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="A value between 0 and 100 that represents the relative ease of maintaining the code. A high value means better maintainability." data-original-title="Maintainability Index"  data-container="body"></i></a></h2>
      <p class="stat">27.46</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Lines of code <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h2>
      <p class="stat">375</p>
    </div>
  </div>
  <div class="row historical">
    <div class="col-md-6">
      <p id="chart_historical_maint" class="chart"></p>
    </div>
    <div class="col-md-6">
      <p id="chart_historical_sloc" class="chart"></p>
    </div>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Difficulty  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="The difficulty measure is related to the difficulty of the program to write or understand." data-original-title="Difficulty" data-container="body"></i></a></h2>
      <p class="stat">63.58</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Estimated Errors  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Halstead's delivered bugs is an estimate for the number of errors in the implementation." data-original-title="Delivered Bugs" data-container="body"></i></a></h2>
      <p class="stat">2.98</p>
    </div>
  </div>
</div>

<div class="container charts">
  <div class="row">
    <h2 class="header">Function weight</h2>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h3 class="chart-header">By Complexity <a href="http://en.wikipedia.org/wiki/Cyclomatic_complexity"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="This metric counts the number of distinct paths through a block of code. Lower values are better." data-original-title="Cyclomatic Complexity" data-container="body"></i></a></h3>
      <div id="fn-by-complexity" class="stat"></div>
    </div>
    <div class="col-md-6">
      <h3 class="chart-header">By SLOC  <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h3>
      <div id="fn-by-sloc" class="stat"></div>
    </div>
  </div>
</div>

<div class="container">
  <div class="row">
    <textarea id="file-source" class="col-md-12">//.CommonJS
var CSSOM = {};
///CommonJS


/**
 * @param {string} token
 */
CSSOM.parse = function parse(token) {

	var i = 0;

	/**
		&quot;before-selector&quot; or
		&quot;selector&quot; or
		&quot;atRule&quot; or
		&quot;atBlock&quot; or
		&quot;before-name&quot; or
		&quot;name&quot; or
		&quot;before-value&quot; or
		&quot;value&quot;
	*/
	var state = &quot;before-selector&quot;;

	var index;
	var buffer = &quot;&quot;;

	var SIGNIFICANT_WHITESPACE = {
		&quot;selector&quot;: true,
		&quot;value&quot;: true,
		&quot;atRule&quot;: true,
		&quot;importRule-begin&quot;: true,
		&quot;importRule&quot;: true,
		&quot;atBlock&quot;: true,
		&#039;documentRule-begin&#039;: true
	};

	var styleSheet = new CSSOM.CSSStyleSheet;

	// @type CSSStyleSheet|CSSMediaRule|CSSFontFaceRule|CSSKeyframesRule|CSSDocumentRule
	var currentScope = styleSheet;

	// @type CSSMediaRule|CSSKeyframesRule|CSSDocumentRule
	var parentRule;

	var selector, name, value, priority=&quot;&quot;, styleRule, mediaRule, importRule, fontFaceRule, keyframesRule, keyframeRule, documentRule;

	var atKeyframesRegExp = /@(-(?:\w+-)+)?keyframes/g;

	var parseError = function(message) {
		var lines = token.substring(0, i).split(&#039;\n&#039;);
		var lineCount = lines.length;
		var charCount = lines.pop().length + 1;
		var error = new Error(message + &#039; (line &#039; + lineCount + &#039;, char &#039; + charCount + &#039;)&#039;);
		error.line = lineCount;
		error.char = charCount;
		error.styleSheet = styleSheet;
		throw error;
	};

	for (var character; character = token.charAt(i); i++) {

		switch (character) {

		case &quot; &quot;:
		case &quot;\t&quot;:
		case &quot;\r&quot;:
		case &quot;\n&quot;:
		case &quot;\f&quot;:
			if (SIGNIFICANT_WHITESPACE[state]) {
				buffer += character;
			}
			break;

		// String
		case &#039;&quot;&#039;:
			index = i + 1;
			do {
				index = token.indexOf(&#039;&quot;&#039;, index) + 1;
				if (!index) {
					parseError(&#039;Unmatched &quot;&#039;);
				}
			} while (token[index - 2] === &#039;\\&#039;)
			buffer += token.slice(i, index);
			i = index - 1;
			switch (state) {
				case &#039;before-value&#039;:
					state = &#039;value&#039;;
					break;
				case &#039;importRule-begin&#039;:
					state = &#039;importRule&#039;;
					break;
			}
			break;

		case &quot;&#039;&quot;:
			index = i + 1;
			do {
				index = token.indexOf(&quot;&#039;&quot;, index) + 1;
				if (!index) {
					parseError(&quot;Unmatched &#039;&quot;);
				}
			} while (token[index - 2] === &#039;\\&#039;)
			buffer += token.slice(i, index);
			i = index - 1;
			switch (state) {
				case &#039;before-value&#039;:
					state = &#039;value&#039;;
					break;
				case &#039;importRule-begin&#039;:
					state = &#039;importRule&#039;;
					break;
			}
			break;

		// Comment
		case &quot;/&quot;:
			if (token.charAt(i + 1) === &quot;*&quot;) {
				i += 2;
				index = token.indexOf(&quot;*/&quot;, i);
				if (index === -1) {
					parseError(&quot;Missing */&quot;);
				} else {
					i = index + 1;
				}
			} else {
				buffer += character;
			}
			if (state === &quot;importRule-begin&quot;) {
				buffer += &quot; &quot;;
				state = &quot;importRule&quot;;
			}
			break;

		// At-rule
		case &quot;@&quot;:
			if (token.indexOf(&quot;@-moz-document&quot;, i) === i) {
				state = &quot;documentRule-begin&quot;;
				documentRule = new CSSOM.CSSDocumentRule;
				documentRule.__starts = i;
				i += &quot;-moz-document&quot;.length;
				buffer = &quot;&quot;;
				break;
			} else if (token.indexOf(&quot;@media&quot;, i) === i) {
				state = &quot;atBlock&quot;;
				mediaRule = new CSSOM.CSSMediaRule;
				mediaRule.__starts = i;
				i += &quot;media&quot;.length;
				buffer = &quot;&quot;;
				break;
			} else if (token.indexOf(&quot;@import&quot;, i) === i) {
				state = &quot;importRule-begin&quot;;
				i += &quot;import&quot;.length;
				buffer += &quot;@import&quot;;
				break;
			} else if (token.indexOf(&quot;@font-face&quot;, i) === i) {
				state = &quot;fontFaceRule-begin&quot;;
				i += &quot;font-face&quot;.length;
				fontFaceRule = new CSSOM.CSSFontFaceRule;
				fontFaceRule.__starts = i;
				buffer = &quot;&quot;;
				break;
			} else {
				atKeyframesRegExp.lastIndex = i;
				var matchKeyframes = atKeyframesRegExp.exec(token);
				if (matchKeyframes &amp;&amp; matchKeyframes.index === i) {
					state = &quot;keyframesRule-begin&quot;;
					keyframesRule = new CSSOM.CSSKeyframesRule;
					keyframesRule.__starts = i;
					keyframesRule._vendorPrefix = matchKeyframes[1]; // Will come out as undefined if no prefix was found
					i += matchKeyframes[0].length - 1;
					buffer = &quot;&quot;;
					break;
				} else if (state == &quot;selector&quot;) {
					state = &quot;atRule&quot;;
				}
			}
			buffer += character;
			break;

		case &quot;{&quot;:
			if (state === &quot;selector&quot; || state === &quot;atRule&quot;) {
				styleRule.selectorText = buffer.trim();
				styleRule.style.__starts = i;
				buffer = &quot;&quot;;
				state = &quot;before-name&quot;;
			} else if (state === &quot;atBlock&quot;) {
				mediaRule.media.mediaText = buffer.trim();
				currentScope = parentRule = mediaRule;
				mediaRule.parentStyleSheet = styleSheet;
				buffer = &quot;&quot;;
				state = &quot;before-selector&quot;;
			} else if (state === &quot;fontFaceRule-begin&quot;) {
				if (parentRule) {
					fontFaceRule.parentRule = parentRule;
				}
				fontFaceRule.parentStyleSheet = styleSheet;
				styleRule = fontFaceRule;
				buffer = &quot;&quot;;
				state = &quot;before-name&quot;;
			} else if (state === &quot;keyframesRule-begin&quot;) {
				keyframesRule.name = buffer.trim();
				if (parentRule) {
					keyframesRule.parentRule = parentRule;
				}
				keyframesRule.parentStyleSheet = styleSheet;
				currentScope = parentRule = keyframesRule;
				buffer = &quot;&quot;;
				state = &quot;keyframeRule-begin&quot;;
			} else if (state === &quot;keyframeRule-begin&quot;) {
				styleRule = new CSSOM.CSSKeyframeRule;
				styleRule.keyText = buffer.trim();
				styleRule.__starts = i;
				buffer = &quot;&quot;;
				state = &quot;before-name&quot;;
			} else if (state === &quot;documentRule-begin&quot;) {
				// FIXME: what if this &#039;{&#039; is in the url text of the match function?
				documentRule.matcher.matcherText = buffer.trim();
				if (parentRule) {
					documentRule.parentRule = parentRule;
				}
				currentScope = parentRule = documentRule;
				documentRule.parentStyleSheet = styleSheet;
				buffer = &quot;&quot;;
				state = &quot;before-selector&quot;;
			}
			break;

		case &quot;:&quot;:
			if (state === &quot;name&quot;) {
				name = buffer.trim();
				buffer = &quot;&quot;;
				state = &quot;before-value&quot;;
			} else {
				buffer += character;
			}
			break;

		case &#039;(&#039;:
			if (state === &#039;value&#039;) {
				// ie css expression mode
				if (buffer.trim() == &#039;expression&#039;) {
					var info = (new CSSOM.CSSValueExpression(token, i)).parse();

					if (info.error) {
						parseError(info.error);
					} else {
						buffer += info.expression;
						i = info.idx;
					}
				} else {
					index = token.indexOf(&#039;)&#039;, i + 1);
					if (index === -1) {
						parseError(&#039;Unmatched &quot;(&quot;&#039;);
					}
					buffer += token.slice(i, index + 1);
					i = index;
				}
			} else {
				buffer += character;
			}

			break;

		case &quot;!&quot;:
			if (state === &quot;value&quot; &amp;&amp; token.indexOf(&quot;!important&quot;, i) === i) {
				priority = &quot;important&quot;;
				i += &quot;important&quot;.length;
			} else {
				buffer += character;
			}
			break;

		case &quot;;&quot;:
			switch (state) {
				case &quot;value&quot;:
					styleRule.style.setProperty(name, buffer.trim(), priority);
					priority = &quot;&quot;;
					buffer = &quot;&quot;;
					state = &quot;before-name&quot;;
					break;
				case &quot;atRule&quot;:
					buffer = &quot;&quot;;
					state = &quot;before-selector&quot;;
					break;
				case &quot;importRule&quot;:
					importRule = new CSSOM.CSSImportRule;
					importRule.parentStyleSheet = importRule.styleSheet.parentStyleSheet = styleSheet;
					importRule.cssText = buffer + character;
					styleSheet.cssRules.push(importRule);
					buffer = &quot;&quot;;
					state = &quot;before-selector&quot;;
					break;
				default:
					buffer += character;
					break;
			}
			break;

		case &quot;}&quot;:
			switch (state) {
				case &quot;value&quot;:
					styleRule.style.setProperty(name, buffer.trim(), priority);
					priority = &quot;&quot;;
				case &quot;before-name&quot;:
				case &quot;name&quot;:
					styleRule.__ends = i + 1;
					if (parentRule) {
						styleRule.parentRule = parentRule;
					}
					styleRule.parentStyleSheet = styleSheet;
					currentScope.cssRules.push(styleRule);
					buffer = &quot;&quot;;
					if (currentScope.constructor === CSSOM.CSSKeyframesRule) {
						state = &quot;keyframeRule-begin&quot;;
					} else {
						state = &quot;before-selector&quot;;
					}
					break;
				case &quot;keyframeRule-begin&quot;:
				case &quot;before-selector&quot;:
				case &quot;selector&quot;:
					// End of media/document rule.
					if (!parentRule) {
						parseError(&quot;Unexpected }&quot;);
					}
					currentScope.__ends = i + 1;
					// Nesting rules aren&#039;t supported yet
					styleSheet.cssRules.push(currentScope);
					currentScope = styleSheet;
					parentRule = null;
					buffer = &quot;&quot;;
					state = &quot;before-selector&quot;;
					break;
			}
			break;

		default:
			switch (state) {
				case &quot;before-selector&quot;:
					state = &quot;selector&quot;;
					styleRule = new CSSOM.CSSStyleRule;
					styleRule.__starts = i;
					break;
				case &quot;before-name&quot;:
					state = &quot;name&quot;;
					break;
				case &quot;before-value&quot;:
					state = &quot;value&quot;;
					break;
				case &quot;importRule-begin&quot;:
					state = &quot;importRule&quot;;
					break;
			}
			buffer += character;
			break;
		}
	}

	return styleSheet;
};


//.CommonJS
exports.parse = CSSOM.parse;
// The following modules cannot be included sooner due to the mutual dependency with parse.js
CSSOM.CSSStyleSheet = require(&quot;./CSSStyleSheet&quot;).CSSStyleSheet;
CSSOM.CSSStyleRule = require(&quot;./CSSStyleRule&quot;).CSSStyleRule;
CSSOM.CSSImportRule = require(&quot;./CSSImportRule&quot;).CSSImportRule;
CSSOM.CSSMediaRule = require(&quot;./CSSMediaRule&quot;).CSSMediaRule;
CSSOM.CSSFontFaceRule = require(&quot;./CSSFontFaceRule&quot;).CSSFontFaceRule;
CSSOM.CSSStyleDeclaration = require(&#039;./CSSStyleDeclaration&#039;).CSSStyleDeclaration;
CSSOM.CSSKeyframeRule = require(&#039;./CSSKeyframeRule&#039;).CSSKeyframeRule;
CSSOM.CSSKeyframesRule = require(&#039;./CSSKeyframesRule&#039;).CSSKeyframesRule;
CSSOM.CSSValueExpression = require(&#039;./CSSValueExpression&#039;).CSSValueExpression;
CSSOM.CSSDocumentRule = require(&#039;./CSSDocumentRule&#039;).CSSDocumentRule;
///CommonJS</textarea>
  </div>
</div>

<footer class="footer">
  <div class="container">
    <p>.</p>
  </div>
</footer>

<script type="text/html" id="complexity-popover-template">
  <div class="complexity-notice">
    Complexity : {{ complexity.cyclomatic }} <br>
    Length : {{ complexity.halstead.length }} <br>
    Difficulty : {{ complexity.halstead.difficulty.toFixed(2) }} <br>
    Est # bugs : {{ complexity.halstead.bugs.toFixed(2) }}<br>
  </div>
</script>

<script type="text/javascript" src="../../assets/scripts/bundles/core-bundle.js"></script>
<script type="text/javascript" src="../../assets/scripts/bundles/codemirror.js"></script>
<script type="text/javascript" src="../../assets/scripts/codemirror.markpopovertext.js"></script>
<script type="text/javascript" src="report.js"></script>
<script type="text/javascript" src="report.history.js"></script>
<script type="text/javascript" src="../../assets/scripts/plato-file.js"></script>
</body>
</html>
