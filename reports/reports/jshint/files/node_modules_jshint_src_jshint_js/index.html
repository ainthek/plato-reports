<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Plato - node_modules/jshint/src/jshint.js</title>

  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="">
  <meta name="author" content="">

  <!--[if lt IE 9]>
  <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->

  <link href="../../assets/css/vendor/morris.css" rel="stylesheet">
  <link href="../../assets/css/vendor/bootstrap.css" rel="stylesheet">
  <link href="../../assets/css/vendor/font-awesome.css" rel="stylesheet">
  <link href="../../assets/css/vendor/codemirror.css" rel="stylesheet">
  <link href="../../assets/css/plato.css" rel="stylesheet">
  <link href="../../assets/css/plato-file.css" rel="stylesheet">

</head>

<body>

<div class="navbar navbar-fixed-top">
  <div class="container">
    <a class="navbar-brand" href="http://github.com/es-analysis/plato">Plato on Github</a>
    <ul class="nav navbar-nav">
      <li>
        <a href="../../index.html">Report Home</a>
      </li>
    </ul>
  </div>
</div>

<div class="jumbotron">
  <div class="container">
    <h1>node_modules/jshint/src/jshint.js</h1>
  </div>
</div>

<div class="container aggregate-stats">
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Maintainability <a href="http://blogs.msdn.com/b/codeanalysis/archive/2007/11/20/maintainability-index-range-and-meaning.aspx"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="A value between 0 and 100 that represents the relative ease of maintaining the code. A high value means better maintainability." data-original-title="Maintainability Index"  data-container="body"></i></a></h2>
      <p class="stat">55.03</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Lines of code <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h2>
      <p class="stat">5357</p>
    </div>
  </div>
  <div class="row historical">
    <div class="col-md-6">
      <p id="chart_historical_maint" class="chart"></p>
    </div>
    <div class="col-md-6">
      <p id="chart_historical_sloc" class="chart"></p>
    </div>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Difficulty  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="The difficulty measure is related to the difficulty of the program to write or understand." data-original-title="Difficulty" data-container="body"></i></a></h2>
      <p class="stat">261.72</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Estimated Errors  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Halstead's delivered bugs is an estimate for the number of errors in the implementation." data-original-title="Delivered Bugs" data-container="body"></i></a></h2>
      <p class="stat">70.06</p>
    </div>
  </div>
</div>

<div class="container charts">
  <div class="row">
    <h2 class="header">Function weight</h2>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h3 class="chart-header">By Complexity <a href="http://en.wikipedia.org/wiki/Cyclomatic_complexity"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="This metric counts the number of distinct paths through a block of code. Lower values are better." data-original-title="Cyclomatic Complexity" data-container="body"></i></a></h3>
      <div id="fn-by-complexity" class="stat"></div>
    </div>
    <div class="col-md-6">
      <h3 class="chart-header">By SLOC  <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h3>
      <div id="fn-by-sloc" class="stat"></div>
    </div>
  </div>
</div>

<div class="container">
  <div class="row">
    <textarea id="file-source" class="col-md-12">/*!
 * JSHint, by JSHint Community.
 *
 * This file (and this file only) is licensed under the same slightly modified
 * MIT license that JSLint is. It stops evil-doers everywhere:
 *
 *   Copyright (c) 2002 Douglas Crockford  (www.JSLint.com)
 *
 *   Permission is hereby granted, free of charge, to any person obtaining
 *   a copy of this software and associated documentation files (the &quot;Software&quot;),
 *   to deal in the Software without restriction, including without limitation
 *   the rights to use, copy, modify, merge, publish, distribute, sublicense,
 *   and/or sell copies of the Software, and to permit persons to whom
 *   the Software is furnished to do so, subject to the following conditions:
 *
 *   The above copyright notice and this permission notice shall be included
 *   in all copies or substantial portions of the Software.
 *
 *   The Software shall be used for Good, not Evil.
 *
 *   THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *   IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *   FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *   AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *   LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 *   FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 *   DEALINGS IN THE SOFTWARE.
 *
 */

/*jshint quotmark:double */
/*global console:true */
/*exported console */

var _        = require(&quot;underscore&quot;);
var events   = require(&quot;events&quot;);
var vars     = require(&quot;./vars.js&quot;);
var messages = require(&quot;./messages.js&quot;);
var Lexer    = require(&quot;./lex.js&quot;).Lexer;
var reg      = require(&quot;./reg.js&quot;);
var state    = require(&quot;./state.js&quot;).state;
var style    = require(&quot;./style.js&quot;);

// We need this module here because environments such as IE and Rhino
// don&#039;t necessarilly expose the &#039;console&#039; API and browserify uses
// it to log things. It&#039;s a sad state of affair, really.
var console = require(&quot;console-browserify&quot;);

// We build the application inside a function so that we produce only a singleton
// variable. That function will be invoked immediately, and its return value is
// the JSHINT function itself.

var JSHINT = (function () {
  &quot;use strict&quot;;

  var anonname, // The guessed name for anonymous functions.
    api, // Extension API

    // These are operators that should not be used with the ! operator.
    bang = {
      &quot;&lt;&quot;  : true,
      &quot;&lt;=&quot; : true,
      &quot;==&quot; : true,
      &quot;===&quot;: true,
      &quot;!==&quot;: true,
      &quot;!=&quot; : true,
      &quot;&gt;&quot;  : true,
      &quot;&gt;=&quot; : true,
      &quot;+&quot;  : true,
      &quot;-&quot;  : true,
      &quot;*&quot;  : true,
      &quot;/&quot;  : true,
      &quot;%&quot;  : true
    },

    // These are the JSHint boolean options.
    boolOptions = {
      enforcing: {
        bitwise     : true, // if bitwise operators should not be allowed
        freeze      : true, // if modifying native object prototypes should be disallowed
        camelcase   : true, // if identifiers should be required in camel case
        curly       : true, // if curly braces around all blocks should be required
        dojo        : true, // if Dojo Toolkit globals should be predefined
        eqeqeq      : true, // if === should be required
        notypeof    : true, // if should report typos in typeof comparisons
        es3         : true, // if ES3 syntax should be allowed
        es5         : true, // if ES5 syntax should be allowed (is now set per default)
        forin       : true, // if for in statements must filter
        funcscope   : true, // if only function scope should be used for scope tests
        globalstrict: true, // if global &quot;use strict&quot;; should be allowed (also enables &#039;strict&#039;)
        immed       : true, // if immediate invocations must be wrapped in parens
        iterator    : true, // if the `__iterator__` property should be allowed
        // statements inside of a one-line blocks.
        newcap      : true, // if constructor names must be capitalized
        noarg       : true, // if arguments.caller and arguments.callee should be
        noempty     : true, // if empty blocks should be disallowed
        nonbsp      : true, // if non-breaking spaces should be disallowed
        nonew       : true, // if using `new` for side-effects should be disallowed
        // disallowed
        undef       : true, // if variables should be declared before used
        singleGroups: false,// if grouping operators for single-expression statements
        // should be disallowed
        enforceall : false // option to turn on all enforce options
        // by default and all relax options off by default
      },
      relaxing: {
        asi         : true, // if automatic semicolon insertion should be tolerated
        multistr    : true, // allow multiline strings
        debug       : true, // if debugger statements should be allowed
        boss        : true, // if advanced usage of assignments should be allowed
        phantom     : true, // if PhantomJS symbols should be allowed
        evil        : true, // if eval should be allowed
        plusplus    : true, // if increment/decrement should not be allowed
        proto       : true, // if the `__proto__` property should be allowed
        typed       : true, // if typed array globals should be predefined
        scripturl   : true, // if script-targeted URLs should be tolerated
        strict      : true, // require the &quot;use strict&quot;; pragma
        sub         : true, // if all forms of subscript notation are tolerated
        supernew    : true, // if `new function () { ... };` and `new Object;`
        // should be tolerated
        laxbreak    : true, // if line breaks should not be checked
        laxcomma    : true, // if line breaks should not be checked around commas
        validthis   : true, // if &#039;this&#039; inside a non-constructor function is valid.
        // This is a function scoped option only.
        withstmt    : true, // if with statements should be allowed
        moz         : true, // if mozilla specific syntax should be allowed
        noyield     : true,  // allow generators without a yield
        eqnull      : true, // if == null comparisons should be tolerated
        lastsemic   : true, // if semicolons may be ommitted for the trailing
        loopfunc    : true, // if functions should be allowed to be defined within
        expr        : true, // if ExpressionStatement should be allowed as Programs
        esnext      : true // if es.next specific syntax should be allowed
      },

      // Third party globals
      mootools    : true, // if MooTools globals should be predefined
      couch       : true, // if CouchDB globals should be predefined
      jasmine     : true, // Jasmine functions should be predefined
      jquery      : true, // if jQuery globals should be predefined
      node        : true, // if the Node.js environment globals should be
      // predefined
      qunit       : true, // if the QUnit environment globals should be predefined
      rhino       : true, // if the Rhino environment globals should be predefined
      shelljs     : true, // if ShellJS globals should be predefined
      prototypejs : true, // if Prototype and Scriptaculous globals should be
      // predefined
      yui         : true, // YUI variables should be predefined
      mocha       : true, // Mocha functions should be predefined
      wsh         : true, // if the Windows Scripting Host environment globals
      // should be predefined
      worker      : true, // if Web Worker script symbols should be allowed
      nonstandard : true, // if non-standard (but widely adopted) globals should
      // be predefined
      browser     : true, // if the standard browser globals should be predefined
      browserify  : true, // if the standard browserify globals should be predefined
      devel       : true, // if logging globals should be predefined (console, alert, etc.)

      // Obsolete options
      onecase     : true, // if one case switch statements should be allowed
      regexp      : true, // if the . should not be allowed in regexp literals
      regexdash   : true  // if unescaped first/last dash (-) inside brackets
                          // should be tolerated
    },

    // These are the JSHint options that can take any value
    // (we use this object to detect invalid options)
    valOptions = {
      maxlen       : false,
      indent       : false,
      maxerr       : false,
      predef       : false, // predef is deprecated and being replaced by globals
      globals      : false,
      quotmark     : false, // &#039;single&#039;|&#039;double&#039;|true
      scope        : false,
      maxstatements: false, // {int} max statements per function
      maxdepth     : false, // {int} max nested block depth per function
      maxparams    : false, // {int} max params per function
      maxcomplexity: false, // {int} max cyclomatic complexity per function
      shadow       : false, // if variable shadowing should be tolerated
                            //   &quot;inner&quot;  - check for variables defined in the same scope only
                            //   &quot;outer&quot;  - check for variables defined in outer scopes as well
                            //   false    - same as inner
                            //   true     - allow variable shadowing
      unused       : true,  // warn if variables are unused. Available options:
                            //   false    - don&#039;t check for unused variables
                            //   true     - &quot;vars&quot; + check last function param
                            //   &quot;vars&quot;   - skip checking unused function params
                            //   &quot;strict&quot; - &quot;vars&quot; + check all function params
      latedef      : false, // warn if the variable is used before its definition
                            //   false    - don&#039;t emit any warnings
                            //   true     - warn if any variable is used before its definition
                            //   &quot;nofunc&quot; - warn for any variable but function declarations
      ignore       : false, // start/end ignoring lines of code, bypassing the lexer
                            //   start    - start ignoring lines, including the current line
                            //   end      - stop ignoring lines, starting on the next line
                            //   line     - ignore warnings / errors for just a single line
                            //              (this option does not bypass the lexer)
      ignoreDelimiters: false // array of start/end delimiters used to ignore
                              // certain chunks from code
    },

    // These are JSHint boolean options which are shared with JSLint
    // where the definition in JSHint is opposite JSLint
    invertedOptions = {
      bitwise : true,
      forin   : true,
      newcap  : true,
      plusplus: true,
      regexp  : true,
      undef   : true,

      // Inverted and renamed, use JSHint name here
      eqeqeq  : true,
      strict  : true
    },

    // These are JSHint boolean options which are shared with JSLint
    // where the name has been changed but the effect is unchanged
    renamedOptions = {
      eqeq   : &quot;eqeqeq&quot;,
      windows: &quot;wsh&quot;,
      sloppy : &quot;strict&quot;
    },

    removedOptions = {
      nomen: true,
      onevar: true,
      passfail: true,
      white: true,
      gcl: true,
      smarttabs: true,
      trailing: true
    },

    declared, // Globals that were declared using /*global ... */ syntax.
    exported, // Variables that are used outside of the current file.

    functionicity = [
      &quot;closure&quot;, &quot;exception&quot;, &quot;global&quot;, &quot;label&quot;,
      &quot;outer&quot;, &quot;unused&quot;, &quot;var&quot;
    ],

    funct, // The current function
    functions, // All of the functions

    global, // The global scope
    implied, // Implied globals
    inblock,
    indent,
    lookahead,
    lex,
    member,
    membersOnly,
    noreach,
    predefined,    // Global variables defined by option

    scope,  // The current scope
    stack,
    unuseds,
    urls,

    extraModules = [],
    emitter = new events.EventEmitter();

  function checkOption(name, t) {
    name = name.trim();

    if (/^[+-]W\d{3}$/g.test(name)) {
      return true;
    }

    if (valOptions[name] === undefined &amp;&amp;
       (boolOptions[name] === undefined &amp;&amp;
        boolOptions.enforcing[name] === undefined &amp;&amp;
        boolOptions.relaxing[name] === undefined  ) ) {
      if (t.type !== &quot;jslint&quot; &amp;&amp; !removedOptions[name]) {
        error(&quot;E001&quot;, t, name);
        return false;
      }
    }

    return true;
  }

  function isString(obj) {
    return Object.prototype.toString.call(obj) === &quot;[object String]&quot;;
  }

  function isIdentifier(tkn, value) {
    if (!tkn)
      return false;

    if (!tkn.identifier || tkn.value !== value)
      return false;

    return true;
  }

  function isReserved(token) {
    if (!token.reserved) {
      return false;
    }
    var meta = token.meta;

    if (meta &amp;&amp; meta.isFutureReservedWord &amp;&amp; state.option.inES5()) {
      // ES3 FutureReservedWord in an ES5 environment.
      if (!meta.es5) {
        return false;
      }

      // Some ES5 FutureReservedWord identifiers are active only
      // within a strict mode environment.
      if (meta.strictOnly) {
        if (!state.option.strict &amp;&amp; !state.directive[&quot;use strict&quot;]) {
          return false;
        }
      }

      if (token.isProperty) {
        return false;
      }
    }

    return true;
  }

  function supplant(str, data) {
    return str.replace(/\{([^{}]*)\}/g, function (a, b) {
      var r = data[b];
      return typeof r === &quot;string&quot; || typeof r === &quot;number&quot; ? r : a;
    });
  }

  function combine(dest, src) {
    Object.keys(src).forEach(function (name) {
      if (_.has(JSHINT.blacklist, name)) return;
      dest[name] = src[name];
    });
  }

  function processenforceall() {
    if (state.option.enforceall) {
      for (var enforceopt in boolOptions.enforcing) {
        if (state.option[enforceopt] === undefined) {
          state.option[enforceopt] = true;
          }
      }
      for (var relaxopt in boolOptions.relaxing) {
        if (state.option[relaxopt] === undefined) {
          state.option[relaxopt] = false;
        }
      }
    }
  }

  function assume() {
    if (state.option.es5) {
      warning(&quot;I003&quot;);
    }

    processenforceall();

    if (state.option.esnext) {
      combine(predefined, vars.newEcmaIdentifiers);
    }

    if (state.option.couch) {
      combine(predefined, vars.couch);
    }

    if (state.option.qunit) {
      combine(predefined, vars.qunit);
    }

    if (state.option.rhino) {
      combine(predefined, vars.rhino);
    }

    if (state.option.shelljs) {
      combine(predefined, vars.shelljs);
      combine(predefined, vars.node);
    }
    if (state.option.typed) {
      combine(predefined, vars.typed);
    }

    if (state.option.phantom) {
      combine(predefined, vars.phantom);
    }

    if (state.option.prototypejs) {
      combine(predefined, vars.prototypejs);
    }

    if (state.option.node) {
      combine(predefined, vars.node);
      combine(predefined, vars.typed);
    }

    if (state.option.devel) {
      combine(predefined, vars.devel);
    }

    if (state.option.dojo) {
      combine(predefined, vars.dojo);
    }

    if (state.option.browser) {
      combine(predefined, vars.browser);
      combine(predefined, vars.typed);
    }

    if (state.option.browserify) {
      combine(predefined, vars.browser);
      combine(predefined, vars.typed);
      combine(predefined, vars.browserify);
    }

    if (state.option.nonstandard) {
      combine(predefined, vars.nonstandard);
    }

    if (state.option.jasmine) {
      combine(predefined, vars.jasmine);
    }

    if (state.option.jquery) {
      combine(predefined, vars.jquery);
    }

    if (state.option.mootools) {
      combine(predefined, vars.mootools);
    }

    if (state.option.worker) {
      combine(predefined, vars.worker);
    }

    if (state.option.wsh) {
      combine(predefined, vars.wsh);
    }

    if (state.option.globalstrict &amp;&amp; state.option.strict !== false) {
      state.option.strict = true;
    }

    if (state.option.yui) {
      combine(predefined, vars.yui);
    }

    if (state.option.mocha) {
      combine(predefined, vars.mocha);
    }

    // Let&#039;s assume that chronologically ES3 &lt; ES5 &lt; ES6/ESNext &lt; Moz

    state.option.inMoz = function (strict) {
      if (strict) {
        return state.option.moz &amp;&amp; !state.option.esnext;
      }
      return state.option.moz;
    };

    state.option.inESNext = function (strict) {
      if (strict) {
        return !state.option.moz &amp;&amp; state.option.esnext;
      }
      return state.option.moz || state.option.esnext;
    };

    state.option.inES5 = function (/* strict */) {
      return !state.option.es3;
    };

    state.option.inES3 = function (strict) {
      if (strict) {
        return !state.option.moz &amp;&amp; !state.option.esnext &amp;&amp; state.option.es3;
      }
      return state.option.es3;
    };
  }

  // Produce an error warning.
  function quit(code, line, chr) {
    var percentage = Math.floor((line / state.lines.length) * 100);
    var message = messages.errors[code].desc;

    throw {
      name: &quot;JSHintError&quot;,
      line: line,
      character: chr,
      message: message + &quot; (&quot; + percentage + &quot;% scanned).&quot;,
      raw: message,
      code: code
    };
  }

  function isundef(scope, code, token, a) {
    return JSHINT.undefs.push([scope, code, token, a]);
  }

  function removeIgnoredMessages() {
    var ignored = state.ignoredLines;

    if (_.isEmpty(ignored)) return;
    JSHINT.errors = _.reject(JSHINT.errors, function (err) { return ignored[err.line] });
  }

  function warning(code, t, a, b, c, d) {
    var ch, l, w, msg;

    if (/^W\d{3}$/.test(code)) {
      if (state.ignored[code])
        return;

      msg = messages.warnings[code];
    } else if (/E\d{3}/.test(code)) {
      msg = messages.errors[code];
    } else if (/I\d{3}/.test(code)) {
      msg = messages.info[code];
    }

    t = t || state.tokens.next;
    if (t.id === &quot;(end)&quot;) {  // `~
      t = state.tokens.curr;
    }

    l = t.line || 0;
    ch = t.from || 0;

    w = {
      id: &quot;(error)&quot;,
      raw: msg.desc,
      code: msg.code,
      evidence: state.lines[l - 1] || &quot;&quot;,
      line: l,
      character: ch,
      scope: JSHINT.scope,
      a: a,
      b: b,
      c: c,
      d: d
    };

    w.reason = supplant(msg.desc, w);
    JSHINT.errors.push(w);

    removeIgnoredMessages();

    if (JSHINT.errors.length &gt;= state.option.maxerr)
      quit(&quot;E043&quot;, l, ch);

    return w;
  }

  function warningAt(m, l, ch, a, b, c, d) {
    return warning(m, {
      line: l,
      from: ch
    }, a, b, c, d);
  }

  function error(m, t, a, b, c, d) {
    warning(m, t, a, b, c, d);
  }

  function errorAt(m, l, ch, a, b, c, d) {
    return error(m, {
      line: l,
      from: ch
    }, a, b, c, d);
  }

  // Tracking of &quot;internal&quot; scripts, like eval containing a static string
  function addInternalSrc(elem, src) {
    var i;
    i = {
      id: &quot;(internal)&quot;,
      elem: elem,
      value: src
    };
    JSHINT.internals.push(i);
    return i;
  }

  // name: string
  // opts: { type: string, token: token, islet: bool }
  function addlabel(name, opts) {
    opts = opts || {};

    var type  = opts.type;
    var token = opts.token;
    var islet = opts.islet;

    // Define label in the current function in the current scope.
    if (type === &quot;exception&quot;) {
      if (_.has(funct[&quot;(context)&quot;], name)) {
        if (funct[name] !== true &amp;&amp; !state.option.node) {
          warning(&quot;W002&quot;, state.tokens.next, name);
        }
      }
    }

    if (_.has(funct, name) &amp;&amp; !funct[&quot;(global)&quot;]) {
      if (funct[name] === true) {
        if (state.option.latedef) {
          if ((state.option.latedef === true &amp;&amp; _.contains([funct[name], type], &quot;unction&quot;)) ||
              !_.contains([funct[name], type], &quot;unction&quot;)) {
            warning(&quot;W003&quot;, state.tokens.next, name);
          }
        }
      } else {
        if ((!state.option.shadow || _.contains([ &quot;inner&quot;, &quot;outer&quot; ], state.option.shadow)) &amp;&amp;
            type !== &quot;exception&quot; || funct[&quot;(blockscope)&quot;].getlabel(name)) {
          warning(&quot;W004&quot;, state.tokens.next, name);
        }
      }
    }

    if (funct[&quot;(context)&quot;] &amp;&amp; _.has(funct[&quot;(context)&quot;], name) &amp;&amp; type !== &quot;function&quot;) {
      if (state.option.shadow === &quot;outer&quot;) {
        warning(&quot;W123&quot;, state.tokens.next, name);
      }
    }

    // if the identifier is from a let, adds it only to the current blockscope
    if (islet) {
      funct[&quot;(blockscope)&quot;].current.add(name, type, state.tokens.curr);
      if (funct[&quot;(blockscope)&quot;].atTop() &amp;&amp; exported[name]) {
        state.tokens.curr.exported = true;
      }
    } else {
      funct[&quot;(blockscope)&quot;].shadow(name);
      funct[name] = type;

      if (token) {
        funct[&quot;(tokens)&quot;][name] = token;
      }

      setprop(funct, name, { unused: opts.unused || false });

      if (funct[&quot;(global)&quot;]) {
        global[name] = funct;
        if (_.has(implied, name)) {
          if (state.option.latedef) {
            if ((state.option.latedef === true &amp;&amp; _.contains([funct[name], type], &quot;unction&quot;)) ||
                !_.contains([funct[name], type], &quot;unction&quot;)) {
              warning(&quot;W003&quot;, state.tokens.next, name);
            }
          }

          delete implied[name];
        }
      } else {
        scope[name] = funct;
      }
    }
  }

  function doOption() {
    var nt = state.tokens.next;
    var body = nt.body.split(&quot;,&quot;).map(function (s) { return s.trim(); });
    var predef = {};

    if (nt.type === &quot;globals&quot;) {
      body.forEach(function (g) {
        g = g.split(&quot;:&quot;);
        var key = (g[0] || &quot;&quot;).trim();
        var val = (g[1] || &quot;&quot;).trim();

        if (key.charAt(0) === &quot;-&quot;) {
          key = key.slice(1);
          val = false;

          JSHINT.blacklist[key] = key;
          delete predefined[key];
        } else {
          predef[key] = (val === &quot;true&quot;);
        }
      });

      combine(predefined, predef);

      for (var key in predef) {
        if (_.has(predef, key)) {
          declared[key] = nt;
        }
      }
    }

    if (nt.type === &quot;exported&quot;) {
      body.forEach(function (e) {
        exported[e] = true;
      });
    }

    if (nt.type === &quot;members&quot;) {
      membersOnly = membersOnly || {};

      body.forEach(function (m) {
        var ch1 = m.charAt(0);
        var ch2 = m.charAt(m.length - 1);

        if (ch1 === ch2 &amp;&amp; (ch1 === &quot;\&quot;&quot; || ch1 === &quot;&#039;&quot;)) {
          m = m
            .substr(1, m.length - 2)
            .replace(&quot;\\\&quot;&quot;, &quot;\&quot;&quot;);
        }

        membersOnly[m] = false;
      });
    }

    var numvals = [
      &quot;maxstatements&quot;,
      &quot;maxparams&quot;,
      &quot;maxdepth&quot;,
      &quot;maxcomplexity&quot;,
      &quot;maxerr&quot;,
      &quot;maxlen&quot;,
      &quot;indent&quot;
    ];

    if (nt.type === &quot;jshint&quot; || nt.type === &quot;jslint&quot;) {
      body.forEach(function (g) {
        g = g.split(&quot;:&quot;);
        var key = (g[0] || &quot;&quot;).trim();
        var val = (g[1] || &quot;&quot;).trim();

        if (!checkOption(key, nt)) {
          return;
        }

        if (numvals.indexOf(key) &gt;= 0) {
          // GH988 - numeric options can be disabled by setting them to `false`
          if (val !== &quot;false&quot;) {
            val = +val;

            if (typeof val !== &quot;number&quot; || !isFinite(val) || val &lt;= 0 || Math.floor(val) !== val) {
              error(&quot;E032&quot;, nt, g[1].trim());
              return;
            }

            state.option[key] = val;
          } else {
            state.option[key] = key === &quot;indent&quot; ? 4 : false;
          }

          return;
        }

        if (key === &quot;validthis&quot;) {
          // `validthis` is valid only within a function scope.

          if (funct[&quot;(global)&quot;])
            return void error(&quot;E009&quot;);

          if (val !== &quot;true&quot; &amp;&amp; val !== &quot;false&quot;)
            return void error(&quot;E002&quot;, nt);

          state.option.validthis = (val === &quot;true&quot;);
          return;
        }

        if (key === &quot;quotmark&quot;) {
          switch (val) {
          case &quot;true&quot;:
          case &quot;false&quot;:
            state.option.quotmark = (val === &quot;true&quot;);
            break;
          case &quot;double&quot;:
          case &quot;single&quot;:
            state.option.quotmark = val;
            break;
          default:
            error(&quot;E002&quot;, nt);
          }
          return;
        }

        if (key === &quot;shadow&quot;) {
          switch (val) {
          case &quot;true&quot;:
            state.option.shadow = true;
            break;
          case &quot;outer&quot;:
            state.option.shadow = &quot;outer&quot;;
            break;
          case &quot;false&quot;:
          case &quot;inner&quot;:
            state.option.shadow = &quot;inner&quot;;
            break;
          default:
            error(&quot;E002&quot;, nt);
          }
          return;
        }

        if (key === &quot;unused&quot;) {
          switch (val) {
          case &quot;true&quot;:
            state.option.unused = true;
            break;
          case &quot;false&quot;:
            state.option.unused = false;
            break;
          case &quot;vars&quot;:
          case &quot;strict&quot;:
            state.option.unused = val;
            break;
          default:
            error(&quot;E002&quot;, nt);
          }
          return;
        }

        if (key === &quot;latedef&quot;) {
          switch (val) {
          case &quot;true&quot;:
            state.option.latedef = true;
            break;
          case &quot;false&quot;:
            state.option.latedef = false;
            break;
          case &quot;nofunc&quot;:
            state.option.latedef = &quot;nofunc&quot;;
            break;
          default:
            error(&quot;E002&quot;, nt);
          }
          return;
        }

        if (key === &quot;ignore&quot;) {
          switch (val) {
          case &quot;start&quot;:
            state.ignoreLinterErrors = true;
            break;
          case &quot;end&quot;:
            state.ignoreLinterErrors = false;
            break;
          case &quot;line&quot;:
            state.ignoredLines[nt.line] = true;
            removeIgnoredMessages();
            break;
          default:
            error(&quot;E002&quot;, nt);
          }
          return;
        }

        var match = /^([+-])(W\d{3})$/g.exec(key);
        if (match) {
          // ignore for -W..., unignore for +W...
          state.ignored[match[2]] = (match[1] === &quot;-&quot;);
          return;
        }

        var tn;
        if (val === &quot;true&quot; || val === &quot;false&quot;) {
          if (nt.type === &quot;jslint&quot;) {
            tn = renamedOptions[key] || key;
            state.option[tn] = (val === &quot;true&quot;);

            if (invertedOptions[tn] !== undefined) {
              state.option[tn] = !state.option[tn];
            }
          } else {
            state.option[key] = (val === &quot;true&quot;);
          }

          if (key === &quot;newcap&quot;) {
            state.option[&quot;(explicitNewcap)&quot;] = true;
          }
          return;
        }

        error(&quot;E002&quot;, nt);
      });

      assume();
    }
  }

  // We need a peek function. If it has an argument, it peeks that much farther
  // ahead. It is used to distinguish
  //     for ( var i in ...
  // from
  //     for ( var i = ...

  function peek(p) {
    var i = p || 0, j = 0, t;

    while (j &lt;= i) {
      t = lookahead[j];
      if (!t) {
        t = lookahead[j] = lex.token();
      }
      j += 1;
    }
    return t;
  }

  function peekIgnoreEOL() {
    var i = 0;
    var t;
    do {
      t = peek(i++);
    } while (t.id === &quot;(endline)&quot;);
    return t;
  }

  // Produce the next token. It looks for programming errors.

  function advance(id, t) {

    switch (state.tokens.curr.id) {
    case &quot;(number)&quot;:
      if (state.tokens.next.id === &quot;.&quot;) {
        warning(&quot;W005&quot;, state.tokens.curr);
      }
      break;
    case &quot;-&quot;:
      if (state.tokens.next.id === &quot;-&quot; || state.tokens.next.id === &quot;--&quot;) {
        warning(&quot;W006&quot;);
      }
      break;
    case &quot;+&quot;:
      if (state.tokens.next.id === &quot;+&quot; || state.tokens.next.id === &quot;++&quot;) {
        warning(&quot;W007&quot;);
      }
      break;
    }

    if (state.tokens.curr.type === &quot;(string)&quot; || state.tokens.curr.identifier) {
      anonname = state.tokens.curr.value;
    }

    if (id &amp;&amp; state.tokens.next.id !== id) {
      if (t) {
        if (state.tokens.next.id === &quot;(end)&quot;) {
          error(&quot;E019&quot;, t, t.id);
        } else {
          error(&quot;E020&quot;, state.tokens.next, id, t.id, t.line, state.tokens.next.value);
        }
      } else if (state.tokens.next.type !== &quot;(identifier)&quot; || state.tokens.next.value !== id) {
        // parameter destructuring with rest operator
        if (state.tokens.next.value === &quot;...&quot;) {
          if (!state.option.esnext) {
            warning(&quot;W119&quot;, state.tokens.next, &quot;spread/rest operator&quot;);
          }
        } else {
          warning(&quot;W116&quot;, state.tokens.next, id, state.tokens.next.value);
        }
      }
    }

    state.tokens.prev = state.tokens.curr;
    state.tokens.curr = state.tokens.next;
    for (;;) {
      state.tokens.next = lookahead.shift() || lex.token();

      if (!state.tokens.next) { // No more tokens left, give up
        quit(&quot;E041&quot;, state.tokens.curr.line);
      }

      if (state.tokens.next.id === &quot;(end)&quot; || state.tokens.next.id === &quot;(error)&quot;) {
        return;
      }

      if (state.tokens.next.check) {
        state.tokens.next.check();
      }

      if (state.tokens.next.isSpecial) {
        doOption();
      } else {
        if (state.tokens.next.id !== &quot;(endline)&quot;) {
          break;
        }
      }
    }
  }

  function isInfix(token) {
    return token.infix || (!token.identifier &amp;&amp; !!token.led);
  }

  function isEndOfExpr() {
    var curr = state.tokens.curr;
    var next = state.tokens.next;
    if (next.id === &quot;;&quot; || next.id === &quot;}&quot; || next.id === &quot;:&quot;) {
      return true;
    }
    if (isInfix(next) === isInfix(curr) || (curr.id === &quot;yield&quot; &amp;&amp; state.option.inMoz(true))) {
      return curr.line !== next.line;
    }
    return false;
  }

  // This is the heart of JSHINT, the Pratt parser. In addition to parsing, it
  // is looking for ad hoc lint patterns. We add .fud to Pratt&#039;s model, which is
  // like .nud except that it is only used on the first token of a statement.
  // Having .fud makes it much easier to define statement-oriented languages like
  // JavaScript. I retained Pratt&#039;s nomenclature.

  // .nud  Null denotation
  // .fud  First null denotation
  // .led  Left denotation
  //  lbp  Left binding power
  //  rbp  Right binding power

  // They are elements of the parsing method called Top Down Operator Precedence.

  function expression(rbp, initial) {
    var left, isArray = false, isObject = false, isLetExpr = false,
      isFatArrowBody = state.tokens.curr.value === &quot;=&gt;&quot;;

    // if current expression is a let expression
    if (!initial &amp;&amp; state.tokens.next.value === &quot;let&quot; &amp;&amp; peek(0).value === &quot;(&quot;) {
      if (!state.option.inMoz(true)) {
        warning(&quot;W118&quot;, state.tokens.next, &quot;let expressions&quot;);
      }
      isLetExpr = true;
      // create a new block scope we use only for the current expression
      funct[&quot;(blockscope)&quot;].stack();
      advance(&quot;let&quot;);
      advance(&quot;(&quot;);
      state.syntax[&quot;let&quot;].fud.call(state.syntax[&quot;let&quot;].fud, false);
      advance(&quot;)&quot;);
    }

    if (state.tokens.next.id === &quot;(end)&quot;)
      error(&quot;E006&quot;, state.tokens.curr);

    if (state.tokens.next.type === &quot;(template)&quot;) {
      doTemplateLiteral();
    }

    var isDangerous =
      state.option.asi &amp;&amp;
      state.tokens.prev.line &lt; state.tokens.curr.line &amp;&amp;
      _.contains([&quot;]&quot;, &quot;)&quot;], state.tokens.prev.id) &amp;&amp;
      _.contains([&quot;[&quot;, &quot;(&quot;], state.tokens.curr.id);

    if (isDangerous)
      warning(&quot;W014&quot;, state.tokens.curr, state.tokens.curr.id);

    advance();

    if (initial) {
      anonname = &quot;anonymous&quot;;
      funct[&quot;(verb)&quot;] = state.tokens.curr.value;
    }

    if (initial === true &amp;&amp; state.tokens.curr.fud) {
      left = state.tokens.curr.fud();
    } else {
      if (state.tokens.curr.nud) {
        left = state.tokens.curr.nud();
      } else {
        error(&quot;E030&quot;, state.tokens.curr, state.tokens.curr.id);
      }

      while (rbp &lt; state.tokens.next.lbp &amp;&amp; !isEndOfExpr()) {
        isArray = state.tokens.curr.value === &quot;Array&quot;;
        isObject = state.tokens.curr.value === &quot;Object&quot;;

        // #527, new Foo.Array(), Foo.Array(), new Foo.Object(), Foo.Object()
        // Line breaks in IfStatement heads exist to satisfy the checkJSHint
        // &quot;Line too long.&quot; error.
        if (left &amp;&amp; (left.value || (left.first &amp;&amp; left.first.value))) {
          // If the left.value is not &quot;new&quot;, or the left.first.value is a &quot;.&quot;
          // then safely assume that this is not &quot;new Array()&quot; and possibly
          // not &quot;new Object()&quot;...
          if (left.value !== &quot;new&quot; ||
            (left.first &amp;&amp; left.first.value &amp;&amp; left.first.value === &quot;.&quot;)) {
            isArray = false;
            // ...In the case of Object, if the left.value and state.tokens.curr.value
            // are not equal, then safely assume that this not &quot;new Object()&quot;
            if (left.value !== state.tokens.curr.value) {
              isObject = false;
            }
          }
        }

        advance();

        if (isArray &amp;&amp; state.tokens.curr.id === &quot;(&quot; &amp;&amp; state.tokens.next.id === &quot;)&quot;) {
          warning(&quot;W009&quot;, state.tokens.curr);
        }

        if (isObject &amp;&amp; state.tokens.curr.id === &quot;(&quot; &amp;&amp; state.tokens.next.id === &quot;)&quot;) {
          warning(&quot;W010&quot;, state.tokens.curr);
        }

        if (left &amp;&amp; state.tokens.curr.led) {
          left = state.tokens.curr.led(left);
        } else {
          error(&quot;E033&quot;, state.tokens.curr, state.tokens.curr.id);
        }
      }
    }
    if (isLetExpr) {
      funct[&quot;(blockscope)&quot;].unstack();
    }

    if (state.option.singleGroups &amp;&amp; left &amp;&amp; left.paren &amp;&amp; !left.exprs &amp;&amp;
      !isFatArrowBody &amp;&amp; !left.triggerFnExpr) {
      warning(&quot;W126&quot;);
    }

    return left;
  }


  // Functions for conformance of style.

  function nobreaknonadjacent(left, right) {
    left = left || state.tokens.curr;
    right = right || state.tokens.next;
    if (!state.option.laxbreak &amp;&amp; left.line !== right.line) {
      warning(&quot;W014&quot;, right, right.value);
    }
  }

  function nolinebreak(t) {
    t = t || state.tokens.curr;
    if (t.line !== state.tokens.next.line) {
      warning(&quot;E022&quot;, t, t.value);
    }
  }

  function nobreakcomma(left, right) {
    if (left.line !== right.line) {
      if (!state.option.laxcomma) {
        if (comma.first) {
          warning(&quot;I001&quot;);
          comma.first = false;
        }
        warning(&quot;W014&quot;, left, right.value);
      }
    }
  }

  function comma(opts) {
    opts = opts || {};

    if (!opts.peek) {
      nobreakcomma(state.tokens.curr, state.tokens.next);
      advance(&quot;,&quot;);
    } else {
      nobreakcomma(state.tokens.prev, state.tokens.curr);
    }

    if (state.tokens.next.identifier &amp;&amp; !(opts.property &amp;&amp; state.option.inES5())) {
      // Keywords that cannot follow a comma operator.
      switch (state.tokens.next.value) {
      case &quot;break&quot;:
      case &quot;case&quot;:
      case &quot;catch&quot;:
      case &quot;continue&quot;:
      case &quot;default&quot;:
      case &quot;do&quot;:
      case &quot;else&quot;:
      case &quot;finally&quot;:
      case &quot;for&quot;:
      case &quot;if&quot;:
      case &quot;in&quot;:
      case &quot;instanceof&quot;:
      case &quot;return&quot;:
      case &quot;switch&quot;:
      case &quot;throw&quot;:
      case &quot;try&quot;:
      case &quot;var&quot;:
      case &quot;let&quot;:
      case &quot;while&quot;:
      case &quot;with&quot;:
        error(&quot;E024&quot;, state.tokens.next, state.tokens.next.value);
        return false;
      }
    }

    if (state.tokens.next.type === &quot;(punctuator)&quot;) {
      switch (state.tokens.next.value) {
      case &quot;}&quot;:
      case &quot;]&quot;:
      case &quot;,&quot;:
        if (opts.allowTrailing) {
          return true;
        }

        /* falls through */
      case &quot;)&quot;:
        error(&quot;E024&quot;, state.tokens.next, state.tokens.next.value);
        return false;
      }
    }
    return true;
  }

  // Functional constructors for making the symbols that will be inherited by
  // tokens.

  function symbol(s, p) {
    var x = state.syntax[s];
    if (!x || typeof x !== &quot;object&quot;) {
      state.syntax[s] = x = {
        id: s,
        lbp: p,
        value: s
      };
    }
    return x;
  }

  function delim(s) {
    return symbol(s, 0);
  }

  function stmt(s, f) {
    var x = delim(s);
    x.identifier = x.reserved = true;
    x.fud = f;
    return x;
  }

  function blockstmt(s, f) {
    var x = stmt(s, f);
    x.block = true;
    return x;
  }

  function reserveName(x) {
    var c = x.id.charAt(0);
    if ((c &gt;= &quot;a&quot; &amp;&amp; c &lt;= &quot;z&quot;) || (c &gt;= &quot;A&quot; &amp;&amp; c &lt;= &quot;Z&quot;)) {
      x.identifier = x.reserved = true;
    }
    return x;
  }

  function prefix(s, f) {
    var x = symbol(s, 150);
    reserveName(x);

    x.nud = (typeof f === &quot;function&quot;) ? f : function () {
      this.right = expression(150);
      this.arity = &quot;unary&quot;;

      if (this.id === &quot;++&quot; || this.id === &quot;--&quot;) {
        if (state.option.plusplus) {
          warning(&quot;W016&quot;, this, this.id);
        } else if (this.right &amp;&amp; (!this.right.identifier || isReserved(this.right)) &amp;&amp;
            this.right.id !== &quot;.&quot; &amp;&amp; this.right.id !== &quot;[&quot;) {
          warning(&quot;W017&quot;, this);
        }
      }

      return this;
    };

    return x;
  }

  function type(s, f) {
    var x = delim(s);
    x.type = s;
    x.nud = f;
    return x;
  }

  function reserve(name, func) {
    var x = type(name, func);
    x.identifier = true;
    x.reserved = true;
    return x;
  }

  function FutureReservedWord(name, meta) {
    var x = type(name, (meta &amp;&amp; meta.nud) || function () {
      return this;
    });

    meta = meta || {};
    meta.isFutureReservedWord = true;

    x.value = name;
    x.identifier = true;
    x.reserved = true;
    x.meta = meta;

    return x;
  }

  function reservevar(s, v) {
    return reserve(s, function () {
      if (typeof v === &quot;function&quot;) {
        v(this);
      }
      return this;
    });
  }

  function infix(s, f, p, w) {
    var x = symbol(s, p);
    reserveName(x);
    x.infix = true;
    x.led = function (left) {
      if (!w) {
        nobreaknonadjacent(state.tokens.prev, state.tokens.curr);
      }
      if (s === &quot;in&quot; &amp;&amp; left.id === &quot;!&quot;) {
        warning(&quot;W018&quot;, left, &quot;!&quot;);
      }
      if (typeof f === &quot;function&quot;) {
        return f(left, this);
      } else {
        this.left = left;
        this.right = expression(p);
        return this;
      }
    };
    return x;
  }


  function application(s) {
    var x = symbol(s, 42);

    x.led = function (left) {
      if (!state.option.esnext) {
        warning(&quot;W119&quot;, state.tokens.curr, &quot;arrow function syntax (=&gt;)&quot;);
      }

      nobreaknonadjacent(state.tokens.prev, state.tokens.curr);

      this.left = left;
      this.right = doFunction(undefined, undefined, false, left);
      return this;
    };
    return x;
  }

  function relation(s, f) {
    var x = symbol(s, 100);

    x.led = function (left) {
      nobreaknonadjacent(state.tokens.prev, state.tokens.curr);
      var right = expression(100);

      if (isIdentifier(left, &quot;NaN&quot;) || isIdentifier(right, &quot;NaN&quot;)) {
        warning(&quot;W019&quot;, this);
      } else if (f) {
        f.apply(this, [left, right]);
      }

      if (!left || !right) {
        quit(&quot;E041&quot;, state.tokens.curr.line);
      }

      if (left.id === &quot;!&quot;) {
        warning(&quot;W018&quot;, left, &quot;!&quot;);
      }

      if (right.id === &quot;!&quot;) {
        warning(&quot;W018&quot;, right, &quot;!&quot;);
      }

      this.left = left;
      this.right = right;
      return this;
    };
    return x;
  }

  function isPoorRelation(node) {
    return node &amp;&amp;
        ((node.type === &quot;(number)&quot; &amp;&amp; +node.value === 0) ||
         (node.type === &quot;(string)&quot; &amp;&amp; node.value === &quot;&quot;) ||
         (node.type === &quot;null&quot; &amp;&amp; !state.option.eqnull) ||
        node.type === &quot;true&quot; ||
        node.type === &quot;false&quot; ||
        node.type === &quot;undefined&quot;);
  }

  // Checks whether the &#039;typeof&#039; operator is used with the correct
  // value. For docs on &#039;typeof&#039; see:
  // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/typeof

  function isTypoTypeof(left, right) {
    if (state.option.notypeof)
      return false;

    if (!left || !right)
      return false;

    var values = [
      &quot;undefined&quot;, &quot;object&quot;, &quot;boolean&quot;, &quot;number&quot;,
      &quot;string&quot;, &quot;function&quot;, &quot;xml&quot;, &quot;object&quot;, &quot;unknown&quot;
    ];

    if (right.type === &quot;(identifier)&quot; &amp;&amp; right.value === &quot;typeof&quot; &amp;&amp; left.type === &quot;(string)&quot;)
      return !_.contains(values, left.value);

    return false;
  }

  function findNativePrototype(left) {
    var natives = [
      &quot;Array&quot;, &quot;ArrayBuffer&quot;, &quot;Boolean&quot;, &quot;Collator&quot;, &quot;DataView&quot;, &quot;Date&quot;,
      &quot;DateTimeFormat&quot;, &quot;Error&quot;, &quot;EvalError&quot;, &quot;Float32Array&quot;, &quot;Float64Array&quot;,
      &quot;Function&quot;, &quot;Infinity&quot;, &quot;Intl&quot;, &quot;Int16Array&quot;, &quot;Int32Array&quot;, &quot;Int8Array&quot;,
      &quot;Iterator&quot;, &quot;Number&quot;, &quot;NumberFormat&quot;, &quot;Object&quot;, &quot;RangeError&quot;,
      &quot;ReferenceError&quot;, &quot;RegExp&quot;, &quot;StopIteration&quot;, &quot;String&quot;, &quot;SyntaxError&quot;,
      &quot;TypeError&quot;, &quot;Uint16Array&quot;, &quot;Uint32Array&quot;, &quot;Uint8Array&quot;, &quot;Uint8ClampedArray&quot;,
      &quot;URIError&quot;
    ];

    function walkPrototype(obj) {
      if (typeof obj !== &quot;object&quot;) return;
      return obj.right === &quot;prototype&quot; ? obj : walkPrototype(obj.left);
    }

    function walkNative(obj) {
      while (!obj.identifier &amp;&amp; typeof obj.left === &quot;object&quot;)
        obj = obj.left;

      if (obj.identifier &amp;&amp; natives.indexOf(obj.value) &gt;= 0)
        return obj.value;
    }

    var prototype = walkPrototype(left);
    if (prototype) return walkNative(prototype);
  }

  function assignop(s, f, p) {
    var x = infix(s, typeof f === &quot;function&quot; ? f : function (left, that) {
      that.left = left;

      if (left) {
        if (state.option.freeze) {
          var nativeObject = findNativePrototype(left);
          if (nativeObject)
            warning(&quot;W121&quot;, left, nativeObject);
        }

        if (predefined[left.value] === false &amp;&amp;
            scope[left.value][&quot;(global)&quot;] === true) {
          warning(&quot;W020&quot;, left);
        } else if (left[&quot;function&quot;]) {
          warning(&quot;W021&quot;, left, left.value);
        }

        if (funct[left.value] === &quot;const&quot;) {
          error(&quot;E013&quot;, left, left.value);
        }

        if (left.id === &quot;.&quot;) {
          if (!left.left) {
            warning(&quot;E031&quot;, that);
          } else if (left.left.value === &quot;arguments&quot; &amp;&amp; !state.directive[&quot;use strict&quot;]) {
            warning(&quot;E031&quot;, that);
          }

          that.right = expression(10);
          return that;
        } else if (left.id === &quot;[&quot;) {
          if (state.tokens.curr.left.first) {
            state.tokens.curr.left.first.forEach(function (t) {
              if (t &amp;&amp; funct[t.value] === &quot;const&quot;) {
                error(&quot;E013&quot;, t, t.value);
              }
            });
          } else if (!left.left) {
            warning(&quot;E031&quot;, that);
          } else if (left.left.value === &quot;arguments&quot; &amp;&amp; !state.directive[&quot;use strict&quot;]) {
            warning(&quot;E031&quot;, that);
          }
          that.right = expression(10);
          return that;
        } else if (left.identifier &amp;&amp; !isReserved(left)) {
          if (funct[left.value] === &quot;exception&quot;) {
            warning(&quot;W022&quot;, left);
          }
          that.right = expression(10);
          return that;
        }

        if (left === state.syntax[&quot;function&quot;]) {
          warning(&quot;W023&quot;, state.tokens.curr);
        }
      }

      error(&quot;E031&quot;, that);
    }, p);

    x.exps = true;
    x.assign = true;
    return x;
  }


  function bitwise(s, f, p) {
    var x = symbol(s, p);
    reserveName(x);
    x.led = (typeof f === &quot;function&quot;) ? f : function (left) {
      if (state.option.bitwise) {
        warning(&quot;W016&quot;, this, this.id);
      }
      this.left = left;
      this.right = expression(p);
      return this;
    };
    return x;
  }


  function bitwiseassignop(s) {
    return assignop(s, function (left, that) {
      if (state.option.bitwise) {
        warning(&quot;W016&quot;, that, that.id);
      }

      if (left) {
        if (left.id === &quot;.&quot; || left.id === &quot;[&quot; ||
            (left.identifier &amp;&amp; !isReserved(left))) {
          expression(10);
          return that;
        }
        if (left === state.syntax[&quot;function&quot;]) {
          warning(&quot;W023&quot;, state.tokens.curr);
        }
        return that;
      }
      error(&quot;E031&quot;, that);
    }, 20);
  }


  function suffix(s) {
    var x = symbol(s, 150);

    x.led = function (left) {
      if (state.option.plusplus) {
        warning(&quot;W016&quot;, this, this.id);
      } else if ((!left.identifier || isReserved(left)) &amp;&amp; left.id !== &quot;.&quot; &amp;&amp; left.id !== &quot;[&quot;) {
        warning(&quot;W017&quot;, this);
      }

      this.left = left;
      return this;
    };
    return x;
  }

  // fnparam means that this identifier is being defined as a function
  // argument (see identifier())
  // prop means that this identifier is that of an object property
  // exported means that the identifier is part of a valid ES6 `export` declaration

  function optionalidentifier(fnparam, prop, preserve, exported) {
    if (!state.tokens.next.identifier) {
      return;
    }

    if (!preserve) {
      advance();
    }

    var curr = state.tokens.curr;
    var val  = state.tokens.curr.value;

    if (exported) {
      state.tokens.curr.exported = true;
    }

    if (!isReserved(curr)) {
      return val;
    }

    if (prop) {
      if (state.option.inES5()) {
        return val;
      }
    }

    if (fnparam &amp;&amp; val === &quot;undefined&quot;) {
      return val;
    }

    warning(&quot;W024&quot;, state.tokens.curr, state.tokens.curr.id);
    return val;
  }

  // fnparam means that this identifier is being defined as a function
  // argument
  // prop means that this identifier is that of an object property
  // `exported` means that the identifier token should be exported.
  function identifier(fnparam, prop, exported) {
    var i = optionalidentifier(fnparam, prop, false, exported);
    if (i) {
      return i;
    }

    // parameter destructuring with rest operator
    if (state.tokens.next.value === &quot;...&quot;) {
      if (!state.option.esnext) {
        warning(&quot;W119&quot;, state.tokens.next, &quot;spread/rest operator&quot;);
      }
    } else {
      error(&quot;E030&quot;, state.tokens.next, state.tokens.next.value);
    }
  }


  function reachable(s) {
    var i = 0, t;
    if (state.tokens.next.id !== &quot;;&quot; || noreach) {
      return;
    }
    for (;;) {
      do {
        t = peek(i);
        i += 1;
      } while (t.id != &quot;(end)&quot; &amp;&amp; t.id === &quot;(comment)&quot;);

      if (t.reach) {
        return;
      }
      if (t.id !== &quot;(endline)&quot;) {
        if (t.id === &quot;function&quot;) {
          if (state.option.latedef === true) {
            warning(&quot;W026&quot;, t);
          }
          break;
        }

        warning(&quot;W027&quot;, t, t.value, s);
        break;
      }
    }
  }

  function parseFinalSemicolon() {
    if (state.tokens.next.id !== &quot;;&quot;) {
      if (!state.option.asi) {
        // If this is the last statement in a block that ends on
        // the same line *and* option lastsemic is on, ignore the warning.
        // Otherwise, complain about missing semicolon.
        if (!state.option.lastsemic || state.tokens.next.id !== &quot;}&quot; ||
          state.tokens.next.line !== state.tokens.curr.line) {
          warningAt(&quot;W033&quot;, state.tokens.curr.line, state.tokens.curr.character);
        }
      }
    } else {
      advance(&quot;;&quot;);
    }
  }

  function statement() {
    var values;
    var i = indent, r, s = scope, t = state.tokens.next;

    if (t.id === &quot;;&quot;) {
      advance(&quot;;&quot;);
      return;
    }

    // Is this a labelled statement?
    var res = isReserved(t);

    // We&#039;re being more tolerant here: if someone uses
    // a FutureReservedWord as a label, we warn but proceed
    // anyway.

    if (res &amp;&amp; t.meta &amp;&amp; t.meta.isFutureReservedWord &amp;&amp; peek().id === &quot;:&quot;) {
      warning(&quot;W024&quot;, t, t.id);
      res = false;
    }

    // detect a module import declaration
    if (t.value === &quot;module&quot; &amp;&amp; t.type === &quot;(identifier)&quot;) {
      if (peek().type === &quot;(identifier)&quot;) {
        if (!state.option.inESNext()) {
          warning(&quot;W119&quot;, state.tokens.curr, &quot;module&quot;);
        }

        advance(&quot;module&quot;);
        var name = identifier();
        addlabel(name, { type: &quot;unused&quot;, token: state.tokens.curr });
        advance(&quot;from&quot;);
        advance(&quot;(string)&quot;);
        parseFinalSemicolon();
        return;
      }
    }

    // detect a destructuring assignment
    if (_.has([&quot;[&quot;, &quot;{&quot;], t.value)) {
      if (lookupBlockType().isDestAssign) {
        if (!state.option.inESNext()) {
          warning(&quot;W104&quot;, state.tokens.curr, &quot;destructuring expression&quot;);
        }
        values = destructuringExpression();
        values.forEach(function (tok) {
          isundef(funct, &quot;W117&quot;, tok.token, tok.id);
        });
        advance(&quot;=&quot;);
        destructuringExpressionMatch(values, expression(10, true));
        advance(&quot;;&quot;);
        return;
      }
    }
    if (t.identifier &amp;&amp; !res &amp;&amp; peek().id === &quot;:&quot;) {
      advance();
      advance(&quot;:&quot;);
      scope = Object.create(s);
      addlabel(t.value, { type: &quot;label&quot; });

      if (!state.tokens.next.labelled &amp;&amp; state.tokens.next.value !== &quot;{&quot;) {
        warning(&quot;W028&quot;, state.tokens.next, t.value, state.tokens.next.value);
      }

      state.tokens.next.label = t.value;
      t = state.tokens.next;
    }

    // Is it a lonely block?

    if (t.id === &quot;{&quot;) {
      // Is it a switch case block?
      //
      //  switch (foo) {
      //    case bar: { &lt;= here.
      //      ...
      //    }
      //  }
      var iscase = (funct[&quot;(verb)&quot;] === &quot;case&quot; &amp;&amp; state.tokens.curr.value === &quot;:&quot;);
      block(true, true, false, false, iscase);
      return;
    }

    // Parse the statement.

    r = expression(0, true);

    if (r &amp;&amp; (!r.identifier || r.value !== &quot;function&quot;) &amp;&amp; (r.type !== &quot;(punctuator)&quot;)) {
      if (!state.directive[&quot;use strict&quot;] &amp;&amp;
          state.option.globalstrict &amp;&amp;
          state.option.strict) {
        warning(&quot;E007&quot;);
      }
    }

    // Look for the final semicolon.

    if (!t.block) {
      if (!state.option.expr &amp;&amp; (!r || !r.exps)) {
        warning(&quot;W030&quot;, state.tokens.curr);
      } else if (state.option.nonew &amp;&amp; r &amp;&amp; r.left &amp;&amp; r.id === &quot;(&quot; &amp;&amp; r.left.id === &quot;new&quot;) {
        warning(&quot;W031&quot;, t);
      }
      parseFinalSemicolon();
    }


    // Restore the indentation.

    indent = i;
    scope = s;
    return r;
  }


  function statements() {
    var a = [], p;

    while (!state.tokens.next.reach &amp;&amp; state.tokens.next.id !== &quot;(end)&quot;) {
      if (state.tokens.next.id === &quot;;&quot;) {
        p = peek();

        if (!p || (p.id !== &quot;(&quot; &amp;&amp; p.id !== &quot;[&quot;)) {
          warning(&quot;W032&quot;);
        }

        advance(&quot;;&quot;);
      } else {
        a.push(statement());
      }
    }
    return a;
  }


  /*
   * read all directives
   * recognizes a simple form of asi, but always
   * warns, if it is used
   */
  function directives() {
    var i, p, pn;

    while (state.tokens.next.id === &quot;(string)&quot;) {
      p = peek(0);
      if (p.id === &quot;(endline)&quot;) {
        i = 1;
        do {
          pn = peek(i++);
        } while (pn.id === &quot;(endline)&quot;);
        if (pn.id === &quot;;&quot;) {
          p = pn;
        } else if (pn.value === &quot;[&quot; || pn.value === &quot;.&quot;) {
          // string -&gt; [ | . is a valid production
          return;
        } else if (!state.option.asi || pn.value === &quot;(&quot;) {
          // string -&gt; ( is not a valid production
          warning(&quot;W033&quot;, state.tokens.next);
        }
      } else if (p.id === &quot;.&quot; || p.id === &quot;[&quot;) {
        return;
      } else if (p.id !== &quot;;&quot;) {
        warning(&quot;W033&quot;, p);
      }

      advance();
      if (state.directive[state.tokens.curr.value]) {
        warning(&quot;W034&quot;, state.tokens.curr, state.tokens.curr.value);
      }

      if (state.tokens.curr.value === &quot;use strict&quot;) {
        if (!state.option[&quot;(explicitNewcap)&quot;]) {
          state.option.newcap = true;
        }
        state.option.undef = true;
      }

      // there&#039;s no directive negation, so always set to true
      state.directive[state.tokens.curr.value] = true;

      if (p.id === &quot;;&quot;) {
        advance(&quot;;&quot;);
      }
    }
  }


  /*
   * Parses a single block. A block is a sequence of statements wrapped in
   * braces.
   *
   * ordinary   - true for everything but function bodies and try blocks.
   * stmt       - true if block can be a single statement (e.g. in if/for/while).
   * isfunc     - true if block is a function body
   * isfatarrow - true if its a body of a fat arrow function
   * iscase      - true if block is a switch case block
   */
  function block(ordinary, stmt, isfunc, isfatarrow, iscase) {
    var a,
      b = inblock,
      old_indent = indent,
      m,
      s = scope,
      t,
      line,
      d;

    inblock = ordinary;

    if (!ordinary || !state.option.funcscope)
      scope = Object.create(scope);

    t = state.tokens.next;

    var metrics = funct[&quot;(metrics)&quot;];
    metrics.nestedBlockDepth += 1;
    metrics.verifyMaxNestedBlockDepthPerFunction();

    if (state.tokens.next.id === &quot;{&quot;) {
      advance(&quot;{&quot;);

      // create a new block scope
      funct[&quot;(blockscope)&quot;].stack();

      line = state.tokens.curr.line;
      if (state.tokens.next.id !== &quot;}&quot;) {
        indent += state.option.indent;
        while (!ordinary &amp;&amp; state.tokens.next.from &gt; indent) {
          indent += state.option.indent;
        }

        if (isfunc) {
          m = {};
          for (d in state.directive) {
            if (_.has(state.directive, d)) {
              m[d] = state.directive[d];
            }
          }
          directives();

          if (state.option.strict &amp;&amp; funct[&quot;(context)&quot;][&quot;(global)&quot;]) {
            if (!m[&quot;use strict&quot;] &amp;&amp; !state.directive[&quot;use strict&quot;]) {
              warning(&quot;E007&quot;);
            }
          }
        }

        a = statements();

        metrics.statementCount += a.length;

        if (isfunc) {
          state.directive = m;
        }

        indent -= state.option.indent;
      }

      advance(&quot;}&quot;, t);

      funct[&quot;(blockscope)&quot;].unstack();

      indent = old_indent;
    } else if (!ordinary) {
      if (isfunc) {
        m = {};
        if (stmt &amp;&amp; !isfatarrow &amp;&amp; !state.option.inMoz(true)) {
          error(&quot;W118&quot;, state.tokens.curr, &quot;function closure expressions&quot;);
        }

        if (!stmt) {
          for (d in state.directive) {
            if (_.has(state.directive, d)) {
              m[d] = state.directive[d];
            }
          }
        }
        expression(10);

        if (state.option.strict &amp;&amp; funct[&quot;(context)&quot;][&quot;(global)&quot;]) {
          if (!m[&quot;use strict&quot;] &amp;&amp; !state.directive[&quot;use strict&quot;]) {
            warning(&quot;E007&quot;);
          }
        }
      } else {
        error(&quot;E021&quot;, state.tokens.next, &quot;{&quot;, state.tokens.next.value);
      }
    } else {

      // check to avoid let declaration not within a block
      funct[&quot;(nolet)&quot;] = true;

      if (!stmt || state.option.curly) {
        warning(&quot;W116&quot;, state.tokens.next, &quot;{&quot;, state.tokens.next.value);
      }

      noreach = true;
      indent += state.option.indent;
      // test indentation only if statement is in new line
      a = [statement()];
      indent -= state.option.indent;
      noreach = false;

      delete funct[&quot;(nolet)&quot;];
    }

    // Don&#039;t clear and let it propagate out if it is &quot;break&quot;, &quot;return&quot; or similar in switch case
    switch (funct[&quot;(verb)&quot;]) {
    case &quot;break&quot;:
    case &quot;continue&quot;:
    case &quot;return&quot;:
    case &quot;throw&quot;:
      if (iscase) {
        break;
      }

      /* falls through */
    default:
      funct[&quot;(verb)&quot;] = null;
    }

    if (!ordinary || !state.option.funcscope) scope = s;
    inblock = b;
    if (ordinary &amp;&amp; state.option.noempty &amp;&amp; (!a || a.length === 0)) {
      warning(&quot;W035&quot;);
    }
    metrics.nestedBlockDepth -= 1;
    return a;
  }


  function countMember(m) {
    if (membersOnly &amp;&amp; typeof membersOnly[m] !== &quot;boolean&quot;) {
      warning(&quot;W036&quot;, state.tokens.curr, m);
    }
    if (typeof member[m] === &quot;number&quot;) {
      member[m] += 1;
    } else {
      member[m] = 1;
    }
  }


  function note_implied(tkn) {
    var name = tkn.value;
    var desc = Object.getOwnPropertyDescriptor(implied, name);

    if (!desc)
      implied[name] = [tkn.line];
    else
      desc.value.push(tkn.line);
  }


  // Build the syntax table by declaring the syntactic elements of the language.

  type(&quot;(number)&quot;, function () {
    return this;
  });

  type(&quot;(string)&quot;, function () {
    return this;
  });

  state.syntax[&quot;(identifier)&quot;] = {
    type: &quot;(identifier)&quot;,
    lbp: 0,
    identifier: true,

    nud: function () {
      var v = this.value;
      var s = scope[v];
      var f;
      var block;

      if (typeof s === &quot;function&quot;) {
        // Protection against accidental inheritance.
        s = undefined;
      } else if (!funct[&quot;(blockscope)&quot;].current.has(v) &amp;&amp; typeof s === &quot;boolean&quot;) {
        f = funct;
        funct = functions[0];
        addlabel(v, { type: &quot;var&quot; });
        s = funct;
        funct = f;
      }

      block = funct[&quot;(blockscope)&quot;].getlabel(v);

      // The name is in scope and defined in the current function.
      if (funct === s || block) {
        // Change &#039;unused&#039; to &#039;var&#039;, and reject labels.
        // the name is in a block scope.
        switch (block ? block[v][&quot;(type)&quot;] : funct[v]) {
        case &quot;unused&quot;:
          if (block) block[v][&quot;(type)&quot;] = &quot;var&quot;;
          else funct[v] = &quot;var&quot;;
          break;
        case &quot;unction&quot;:
          if (block) block[v][&quot;(type)&quot;] = &quot;function&quot;;
          else funct[v] = &quot;function&quot;;
          this[&quot;function&quot;] = true;
          break;
        case &quot;const&quot;:
          setprop(funct, v, { unused: false });
          break;
        case &quot;function&quot;:
          this[&quot;function&quot;] = true;
          break;
        case &quot;label&quot;:
          warning(&quot;W037&quot;, state.tokens.curr, v);
          break;
        }
      } else {
        // If the name is already defined in the current
        // function, but not as outer, then there is a scope error.

        switch (funct[v]) {
        case &quot;closure&quot;:
        case &quot;function&quot;:
        case &quot;var&quot;:
        case &quot;unused&quot;:
          warning(&quot;W038&quot;, state.tokens.curr, v);
          break;
        case &quot;label&quot;:
          warning(&quot;W037&quot;, state.tokens.curr, v);
          break;
        case &quot;outer&quot;:
        case &quot;global&quot;:
          break;
        default:
          // If the name is defined in an outer function, make an outer entry,
          // and if it was unused, make it var.
          if (s === true) {
            funct[v] = true;
          } else if (s === null) {
            warning(&quot;W039&quot;, state.tokens.curr, v);
            note_implied(state.tokens.curr);
          } else if (typeof s !== &quot;object&quot;) {
            // Operators typeof and delete do not raise runtime errors even
            // if the base object of a reference is null so no need to
            //
            // display warning if we&#039;re inside of typeof or delete.
            // Attempting to subscript a null reference will throw an
            // error, even within the typeof and delete operators
            if (!(anonname === &quot;typeof&quot; || anonname === &quot;delete&quot;) ||
              (state.tokens.next &amp;&amp;
                (state.tokens.next.value === &quot;.&quot; || state.tokens.next.value === &quot;[&quot;))) {

              // if we&#039;re in a list comprehension, variables are declared
              // locally and used before being defined. So we check
              // the presence of the given variable in the comp array
              // before declaring it undefined.

              if (!funct[&quot;(comparray)&quot;].check(v)) {
                isundef(funct, &quot;W117&quot;, state.tokens.curr, v);
              }
            }

            // Explicitly mark the variable as used within function scopes
            if (!funct[&quot;(global)&quot;]) {
              funct[v] = true;
            }

            note_implied(state.tokens.curr);
          } else {
            switch (s[v]) {
            case &quot;function&quot;:
            case &quot;unction&quot;:
              this[&quot;function&quot;] = true;
              s[v] = &quot;closure&quot;;
              funct[v] = s[&quot;(global)&quot;] ? &quot;global&quot; : &quot;outer&quot;;
              break;
            case &quot;var&quot;:
            case &quot;unused&quot;:
              s[v] = &quot;closure&quot;;
              funct[v] = s[&quot;(global)&quot;] ? &quot;global&quot; : &quot;outer&quot;;
              break;
            case &quot;const&quot;:
              setprop(s, v, { unused: false });
              break;
            case &quot;closure&quot;:
              funct[v] = s[&quot;(global)&quot;] ? &quot;global&quot; : &quot;outer&quot;;
              break;
            case &quot;label&quot;:
              warning(&quot;W037&quot;, state.tokens.curr, v);
            }
          }
        }
      }
      return this;
    },

    led: function () {
      error(&quot;E033&quot;, state.tokens.next, state.tokens.next.value);
    }
  };

  state.syntax[&quot;(template)&quot;] = {
    type: &quot;(template)&quot;,
    lbp: 0,
    identifier: false,
    fud: doTemplateLiteral
  };

  type(&quot;(template middle)&quot;, function () {
    return this;
  });

  type(&quot;(template tail)&quot;, function () {
    return this;
  });

  type(&quot;(regexp)&quot;, function () {
    return this;
  });

  // ECMAScript parser

  delim(&quot;(endline)&quot;);
  delim(&quot;(begin)&quot;);
  delim(&quot;(end)&quot;).reach = true;
  delim(&quot;(error)&quot;).reach = true;
  delim(&quot;}&quot;).reach = true;
  delim(&quot;)&quot;);
  delim(&quot;]&quot;);
  delim(&quot;\&quot;&quot;).reach = true;
  delim(&quot;&#039;&quot;).reach = true;
  delim(&quot;;&quot;);
  delim(&quot;:&quot;).reach = true;
  delim(&quot;#&quot;);

  reserve(&quot;else&quot;);
  reserve(&quot;case&quot;).reach = true;
  reserve(&quot;catch&quot;);
  reserve(&quot;default&quot;).reach = true;
  reserve(&quot;finally&quot;);
  reservevar(&quot;arguments&quot;, function (x) {
    if (state.directive[&quot;use strict&quot;] &amp;&amp; funct[&quot;(global)&quot;]) {
      warning(&quot;E008&quot;, x);
    }
  });
  reservevar(&quot;eval&quot;);
  reservevar(&quot;false&quot;);
  reservevar(&quot;Infinity&quot;);
  reservevar(&quot;null&quot;);
  reservevar(&quot;this&quot;, function (x) {
    if (state.directive[&quot;use strict&quot;] &amp;&amp; !isMethod() &amp;&amp;
        !state.option.validthis &amp;&amp; ((funct[&quot;(statement)&quot;] &amp;&amp;
        funct[&quot;(name)&quot;].charAt(0) &gt; &quot;Z&quot;) || funct[&quot;(global)&quot;])) {
      warning(&quot;W040&quot;, x);
    }
  });
  reservevar(&quot;true&quot;);
  reservevar(&quot;undefined&quot;);

  assignop(&quot;=&quot;, &quot;assign&quot;, 20);
  assignop(&quot;+=&quot;, &quot;assignadd&quot;, 20);
  assignop(&quot;-=&quot;, &quot;assignsub&quot;, 20);
  assignop(&quot;*=&quot;, &quot;assignmult&quot;, 20);
  assignop(&quot;/=&quot;, &quot;assigndiv&quot;, 20).nud = function () {
    error(&quot;E014&quot;);
  };
  assignop(&quot;%=&quot;, &quot;assignmod&quot;, 20);

  bitwiseassignop(&quot;&amp;=&quot;);
  bitwiseassignop(&quot;|=&quot;);
  bitwiseassignop(&quot;^=&quot;);
  bitwiseassignop(&quot;&lt;&lt;=&quot;);
  bitwiseassignop(&quot;&gt;&gt;=&quot;);
  bitwiseassignop(&quot;&gt;&gt;&gt;=&quot;);
  infix(&quot;,&quot;, function (left, that) {
    var expr;
    that.exprs = [left];
    if (!comma({peek: true})) {
      return that;
    }
    while (true) {
      if (!(expr = expression(10)))  {
        break;
      }
      that.exprs.push(expr);
      if (state.tokens.next.value !== &quot;,&quot; || !comma()) {
        break;
      }
    }
    return that;
  }, 10, true);

  infix(&quot;?&quot;, function (left, that) {
    increaseComplexityCount();
    that.left = left;
    that.right = expression(10);
    advance(&quot;:&quot;);
    that[&quot;else&quot;] = expression(10);
    return that;
  }, 30);

  var orPrecendence = 40;
  infix(&quot;||&quot;, function (left, that) {
    increaseComplexityCount();
    that.left = left;
    that.right = expression(orPrecendence);
    return that;
  }, orPrecendence);
  infix(&quot;&amp;&amp;&quot;, &quot;and&quot;, 50);
  bitwise(&quot;|&quot;, &quot;bitor&quot;, 70);
  bitwise(&quot;^&quot;, &quot;bitxor&quot;, 80);
  bitwise(&quot;&amp;&quot;, &quot;bitand&quot;, 90);
  relation(&quot;==&quot;, function (left, right) {
    var eqnull = state.option.eqnull &amp;&amp; (left.value === &quot;null&quot; || right.value === &quot;null&quot;);

    switch (true) {
      case !eqnull &amp;&amp; state.option.eqeqeq:
        this.from = this.character;
        warning(&quot;W116&quot;, this, &quot;===&quot;, &quot;==&quot;);
        break;
      case isPoorRelation(left):
        warning(&quot;W041&quot;, this, &quot;===&quot;, left.value);
        break;
      case isPoorRelation(right):
        warning(&quot;W041&quot;, this, &quot;===&quot;, right.value);
        break;
      case isTypoTypeof(right, left):
        warning(&quot;W122&quot;, this, right.value);
        break;
      case isTypoTypeof(left, right):
        warning(&quot;W122&quot;, this, left.value);
        break;
    }

    return this;
  });
  relation(&quot;===&quot;, function (left, right) {
    if (isTypoTypeof(right, left)) {
      warning(&quot;W122&quot;, this, right.value);
    } else if (isTypoTypeof(left, right)) {
      warning(&quot;W122&quot;, this, left.value);
    }
    return this;
  });
  relation(&quot;!=&quot;, function (left, right) {
    var eqnull = state.option.eqnull &amp;&amp;
        (left.value === &quot;null&quot; || right.value === &quot;null&quot;);

    if (!eqnull &amp;&amp; state.option.eqeqeq) {
      this.from = this.character;
      warning(&quot;W116&quot;, this, &quot;!==&quot;, &quot;!=&quot;);
    } else if (isPoorRelation(left)) {
      warning(&quot;W041&quot;, this, &quot;!==&quot;, left.value);
    } else if (isPoorRelation(right)) {
      warning(&quot;W041&quot;, this, &quot;!==&quot;, right.value);
    } else if (isTypoTypeof(right, left)) {
      warning(&quot;W122&quot;, this, right.value);
    } else if (isTypoTypeof(left, right)) {
      warning(&quot;W122&quot;, this, left.value);
    }
    return this;
  });
  relation(&quot;!==&quot;, function (left, right) {
    if (isTypoTypeof(right, left)) {
      warning(&quot;W122&quot;, this, right.value);
    } else if (isTypoTypeof(left, right)) {
      warning(&quot;W122&quot;, this, left.value);
    }
    return this;
  });
  relation(&quot;&lt;&quot;);
  relation(&quot;&gt;&quot;);
  relation(&quot;&lt;=&quot;);
  relation(&quot;&gt;=&quot;);
  bitwise(&quot;&lt;&lt;&quot;, &quot;shiftleft&quot;, 120);
  bitwise(&quot;&gt;&gt;&quot;, &quot;shiftright&quot;, 120);
  bitwise(&quot;&gt;&gt;&gt;&quot;, &quot;shiftrightunsigned&quot;, 120);
  infix(&quot;in&quot;, &quot;in&quot;, 120);
  infix(&quot;instanceof&quot;, &quot;instanceof&quot;, 120);
  infix(&quot;+&quot;, function (left, that) {
    var right = expression(130);
    if (left &amp;&amp; right &amp;&amp; left.id === &quot;(string)&quot; &amp;&amp; right.id === &quot;(string)&quot;) {
      left.value += right.value;
      left.character = right.character;
      if (!state.option.scripturl &amp;&amp; reg.javascriptURL.test(left.value)) {
        warning(&quot;W050&quot;, left);
      }
      return left;
    }
    that.left = left;
    that.right = right;
    return that;
  }, 130);
  prefix(&quot;+&quot;, &quot;num&quot;);
  prefix(&quot;+++&quot;, function () {
    warning(&quot;W007&quot;);
    this.right = expression(150);
    this.arity = &quot;unary&quot;;
    return this;
  });
  infix(&quot;+++&quot;, function (left) {
    warning(&quot;W007&quot;);
    this.left = left;
    this.right = expression(130);
    return this;
  }, 130);
  infix(&quot;-&quot;, &quot;sub&quot;, 130);
  prefix(&quot;-&quot;, &quot;neg&quot;);
  prefix(&quot;---&quot;, function () {
    warning(&quot;W006&quot;);
    this.right = expression(150);
    this.arity = &quot;unary&quot;;
    return this;
  });
  infix(&quot;---&quot;, function (left) {
    warning(&quot;W006&quot;);
    this.left = left;
    this.right = expression(130);
    return this;
  }, 130);
  infix(&quot;*&quot;, &quot;mult&quot;, 140);
  infix(&quot;/&quot;, &quot;div&quot;, 140);
  infix(&quot;%&quot;, &quot;mod&quot;, 140);

  suffix(&quot;++&quot;);
  prefix(&quot;++&quot;, &quot;preinc&quot;);
  state.syntax[&quot;++&quot;].exps = true;

  suffix(&quot;--&quot;);
  prefix(&quot;--&quot;, &quot;predec&quot;);
  state.syntax[&quot;--&quot;].exps = true;
  prefix(&quot;delete&quot;, function () {
    var p = expression(10);
    if (!p || (p.id !== &quot;.&quot; &amp;&amp; p.id !== &quot;[&quot;)) {
      warning(&quot;W051&quot;);
    }
    this.first = p;
    return this;
  }).exps = true;

  prefix(&quot;~&quot;, function () {
    if (state.option.bitwise) {
      warning(&quot;W052&quot;, this, &quot;~&quot;);
    }
    expression(150);
    return this;
  });

  prefix(&quot;...&quot;, function () {
    if (!state.option.esnext) {
      warning(&quot;W119&quot;, this, &quot;spread/rest operator&quot;);
    }
    if (!state.tokens.next.identifier) {
      error(&quot;E030&quot;, state.tokens.next, state.tokens.next.value);
    }
    expression(150);
    return this;
  });

  prefix(&quot;!&quot;, function () {
    this.right = expression(150);
    this.arity = &quot;unary&quot;;

    if (!this.right) { // &#039;!&#039; followed by nothing? Give up.
      quit(&quot;E041&quot;, this.line || 0);
    }

    if (bang[this.right.id] === true) {
      warning(&quot;W018&quot;, this, &quot;!&quot;);
    }
    return this;
  });

  prefix(&quot;typeof&quot;, &quot;typeof&quot;);
  prefix(&quot;new&quot;, function () {
    var c = expression(155), i;
    if (c &amp;&amp; c.id !== &quot;function&quot;) {
      if (c.identifier) {
        c[&quot;new&quot;] = true;
        switch (c.value) {
        case &quot;Number&quot;:
        case &quot;String&quot;:
        case &quot;Boolean&quot;:
        case &quot;Math&quot;:
        case &quot;JSON&quot;:
          warning(&quot;W053&quot;, state.tokens.prev, c.value);
          break;
        case &quot;Symbol&quot;:
          if (state.option.esnext) {
            warning(&quot;W053&quot;, state.tokens.prev, c.value);
          }
          break;
        case &quot;Function&quot;:
          if (!state.option.evil) {
            warning(&quot;W054&quot;);
          }
          break;
        case &quot;Date&quot;:
        case &quot;RegExp&quot;:
        case &quot;this&quot;:
          break;
        default:
          if (c.id !== &quot;function&quot;) {
            i = c.value.substr(0, 1);
            if (state.option.newcap &amp;&amp; (i &lt; &quot;A&quot; || i &gt; &quot;Z&quot;) &amp;&amp; !_.has(global, c.value)) {
              warning(&quot;W055&quot;, state.tokens.curr);
            }
          }
        }
      } else {
        if (c.id !== &quot;.&quot; &amp;&amp; c.id !== &quot;[&quot; &amp;&amp; c.id !== &quot;(&quot;) {
          warning(&quot;W056&quot;, state.tokens.curr);
        }
      }
    } else {
      if (!state.option.supernew)
        warning(&quot;W057&quot;, this);
    }
    if (state.tokens.next.id !== &quot;(&quot; &amp;&amp; !state.option.supernew) {
      warning(&quot;W058&quot;, state.tokens.curr, state.tokens.curr.value);
    }
    this.first = c;
    return this;
  });
  state.syntax[&quot;new&quot;].exps = true;

  prefix(&quot;void&quot;).exps = true;

  infix(&quot;.&quot;, function (left, that) {
    var m = identifier(false, true);

    if (typeof m === &quot;string&quot;) {
      countMember(m);
    }

    that.left = left;
    that.right = m;

    if (m &amp;&amp; m === &quot;hasOwnProperty&quot; &amp;&amp; state.tokens.next.value === &quot;=&quot;) {
      warning(&quot;W001&quot;);
    }

    if (left &amp;&amp; left.value === &quot;arguments&quot; &amp;&amp; (m === &quot;callee&quot; || m === &quot;caller&quot;)) {
      if (state.option.noarg)
        warning(&quot;W059&quot;, left, m);
      else if (state.directive[&quot;use strict&quot;])
        error(&quot;E008&quot;);
    } else if (!state.option.evil &amp;&amp; left &amp;&amp; left.value === &quot;document&quot; &amp;&amp;
        (m === &quot;write&quot; || m === &quot;writeln&quot;)) {
      warning(&quot;W060&quot;, left);
    }

    if (!state.option.evil &amp;&amp; (m === &quot;eval&quot; || m === &quot;execScript&quot;)) {
      warning(&quot;W061&quot;);
    }

    return that;
  }, 160, true);

  infix(&quot;(&quot;, function (left, that) {
    if (state.option.immed &amp;&amp; left &amp;&amp; !left.immed &amp;&amp; left.id === &quot;function&quot;) {
      warning(&quot;W062&quot;);
    }

    var n = 0;
    var p = [];

    if (left) {
      if (left.type === &quot;(identifier)&quot;) {
        if (left.value.match(/^[A-Z]([A-Z0-9_$]*[a-z][A-Za-z0-9_$]*)?$/)) {
          if (&quot;Number String Boolean Date Object Error&quot;.indexOf(left.value) === -1) {
            if (left.value === &quot;Math&quot;) {
              warning(&quot;W063&quot;, left);
            } else if (state.option.newcap) {
              warning(&quot;W064&quot;, left);
            }
          }
        }
      }
    }

    if (state.tokens.next.id !== &quot;)&quot;) {
      for (;;) {
        p[p.length] = expression(10);
        n += 1;
        if (state.tokens.next.id !== &quot;,&quot;) {
          break;
        }
        comma();
      }
    }

    advance(&quot;)&quot;);

    if (typeof left === &quot;object&quot;) {
      if (state.option.inES3() &amp;&amp; left.value === &quot;parseInt&quot; &amp;&amp; n === 1) {
        warning(&quot;W065&quot;, state.tokens.curr);
      }
      if (!state.option.evil) {
        if (left.value === &quot;eval&quot; || left.value === &quot;Function&quot; ||
            left.value === &quot;execScript&quot;) {
          warning(&quot;W061&quot;, left);

          if (p[0] &amp;&amp; [0].id === &quot;(string)&quot;) {
            addInternalSrc(left, p[0].value);
          }
        } else if (p[0] &amp;&amp; p[0].id === &quot;(string)&quot; &amp;&amp;
             (left.value === &quot;setTimeout&quot; ||
            left.value === &quot;setInterval&quot;)) {
          warning(&quot;W066&quot;, left);
          addInternalSrc(left, p[0].value);

        // window.setTimeout/setInterval
        } else if (p[0] &amp;&amp; p[0].id === &quot;(string)&quot; &amp;&amp;
             left.value === &quot;.&quot; &amp;&amp;
             left.left.value === &quot;window&quot; &amp;&amp;
             (left.right === &quot;setTimeout&quot; ||
            left.right === &quot;setInterval&quot;)) {
          warning(&quot;W066&quot;, left);
          addInternalSrc(left, p[0].value);
        }
      }
      if (!left.identifier &amp;&amp; left.id !== &quot;.&quot; &amp;&amp; left.id !== &quot;[&quot; &amp;&amp;
          left.id !== &quot;(&quot; &amp;&amp; left.id !== &quot;&amp;&amp;&quot; &amp;&amp; left.id !== &quot;||&quot; &amp;&amp;
          left.id !== &quot;?&quot; &amp;&amp; !(state.option.esnext &amp;&amp; left.id === &quot;=&gt;&quot;)) {
        warning(&quot;W067&quot;, left);
      }
    }

    that.left = left;
    return that;
  }, 155, true).exps = true;

  prefix(&quot;(&quot;, function () {
    var bracket, brackets = [];
    var pn, pn1, i = 0;
    var ret, triggerFnExpr;
    var parens = 1;

    do {
      pn = peek(i);

      if (pn.value === &quot;(&quot;) {
        parens += 1;
      } else if (pn.value === &quot;)&quot;) {
        parens -= 1;
      }

      i += 1;
      pn1 = peek(i);
    } while (!(parens === 0 &amp;&amp; pn.value === &quot;)&quot;) &amp;&amp;
             pn1.value !== &quot;=&gt;&quot; &amp;&amp; pn1.value !== &quot;;&quot; &amp;&amp; pn1.type !== &quot;(end)&quot;);

    if (state.tokens.next.id === &quot;function&quot;) {
      triggerFnExpr = state.tokens.next.immed = true;
    }

    var exprs = [];

    if (state.tokens.next.id !== &quot;)&quot;) {
      for (;;) {
        if (pn1.value === &quot;=&gt;&quot; &amp;&amp; _.contains([&quot;{&quot;, &quot;[&quot;], state.tokens.next.value)) {
          bracket = state.tokens.next;
          bracket.left = destructuringExpression();
          brackets.push(bracket);
          for (var t in bracket.left) {
            exprs.push(bracket.left[t].token);
          }
        } else {
          exprs.push(expression(10));
        }
        if (state.tokens.next.id !== &quot;,&quot;) {
          break;
        }
        comma();
      }
    }

    advance(&quot;)&quot;, this);
    if (state.option.immed &amp;&amp; exprs[0] &amp;&amp; exprs[0].id === &quot;function&quot;) {
      if (state.tokens.next.id !== &quot;(&quot; &amp;&amp;
        state.tokens.next.id !== &quot;.&quot; &amp;&amp; state.tokens.next.id !== &quot;[&quot;) {
        warning(&quot;W068&quot;, this);
      }
    }

    if (state.tokens.next.value === &quot;=&gt;&quot;) {
      return exprs;
    }
    if (!exprs.length) {
      return;
    }
    if (exprs.length &gt; 1) {
      ret = Object.create(state.syntax[&quot;,&quot;]);
      ret.exprs = exprs;
    } else {
      ret = exprs[0];
    }
    if (ret) {
      ret.paren = true;
      ret.triggerFnExpr = triggerFnExpr;
    }
    return ret;
  });

  application(&quot;=&gt;&quot;);

  infix(&quot;[&quot;, function (left, that) {
    var e = expression(10), s;
    if (e &amp;&amp; e.type === &quot;(string)&quot;) {
      if (!state.option.evil &amp;&amp; (e.value === &quot;eval&quot; || e.value === &quot;execScript&quot;)) {
        warning(&quot;W061&quot;, that);
      }

      countMember(e.value);
      if (!state.option.sub &amp;&amp; reg.identifier.test(e.value)) {
        s = state.syntax[e.value];
        if (!s || !isReserved(s)) {
          warning(&quot;W069&quot;, state.tokens.prev, e.value);
        }
      }
    }
    advance(&quot;]&quot;, that);

    if (e &amp;&amp; e.value === &quot;hasOwnProperty&quot; &amp;&amp; state.tokens.next.value === &quot;=&quot;) {
      warning(&quot;W001&quot;);
    }

    that.left = left;
    that.right = e;
    return that;
  }, 160, true);

  function comprehensiveArrayExpression() {
    var res = {};
    res.exps = true;
    funct[&quot;(comparray)&quot;].stack();

    // Handle reversed for expressions, used in spidermonkey
    var reversed = false;
    if (state.tokens.next.value !== &quot;for&quot;) {
      reversed = true;
      if (!state.option.inMoz(true)) {
        warning(&quot;W116&quot;, state.tokens.next, &quot;for&quot;, state.tokens.next.value);
      }
      funct[&quot;(comparray)&quot;].setState(&quot;use&quot;);
      res.right = expression(10);
    }

    advance(&quot;for&quot;);
    if (state.tokens.next.value === &quot;each&quot;) {
      advance(&quot;each&quot;);
      if (!state.option.inMoz(true)) {
        warning(&quot;W118&quot;, state.tokens.curr, &quot;for each&quot;);
      }
    }
    advance(&quot;(&quot;);
    funct[&quot;(comparray)&quot;].setState(&quot;define&quot;);
    res.left = expression(130);
    if (_.contains([&quot;in&quot;, &quot;of&quot;], state.tokens.next.value)) {
      advance();
    } else {
      error(&quot;E045&quot;, state.tokens.curr);
    }
    funct[&quot;(comparray)&quot;].setState(&quot;generate&quot;);
    expression(10);

    advance(&quot;)&quot;);
    if (state.tokens.next.value === &quot;if&quot;) {
      advance(&quot;if&quot;);
      advance(&quot;(&quot;);
      funct[&quot;(comparray)&quot;].setState(&quot;filter&quot;);
      res.filter = expression(10);
      advance(&quot;)&quot;);
    }

    if (!reversed) {
      funct[&quot;(comparray)&quot;].setState(&quot;use&quot;);
      res.right = expression(10);
    }

    advance(&quot;]&quot;);
    funct[&quot;(comparray)&quot;].unstack();
    return res;
  }

  prefix(&quot;[&quot;, function () {
    var blocktype = lookupBlockType();
    if (blocktype.isCompArray) {
      if (!state.option.inESNext()) {
        warning(&quot;W119&quot;, state.tokens.curr, &quot;array comprehension&quot;);
      }
      return comprehensiveArrayExpression();
    } else if (blocktype.isDestAssign &amp;&amp; !state.option.inESNext()) {
      warning(&quot;W104&quot;, state.tokens.curr, &quot;destructuring assignment&quot;);
    }
    var b = state.tokens.curr.line !== state.tokens.next.line;
    this.first = [];
    if (b) {
      indent += state.option.indent;
      if (state.tokens.next.from === indent + state.option.indent) {
        indent += state.option.indent;
      }
    }
    while (state.tokens.next.id !== &quot;(end)&quot;) {
      while (state.tokens.next.id === &quot;,&quot;) {
        if (!state.option.inES5())
          warning(&quot;W070&quot;);
        advance(&quot;,&quot;);
      }

      if (state.tokens.next.id === &quot;]&quot;) {
        break;
      }

      this.first.push(expression(10));
      if (state.tokens.next.id === &quot;,&quot;) {
        comma({ allowTrailing: true });
        if (state.tokens.next.id === &quot;]&quot; &amp;&amp; !state.option.inES5(true)) {
          warning(&quot;W070&quot;, state.tokens.curr);
          break;
        }
      } else {
        break;
      }
    }
    if (b) {
      indent -= state.option.indent;
    }
    advance(&quot;]&quot;, this);
    return this;
  });


  function isMethod() {
    return funct[&quot;(statement)&quot;] &amp;&amp; funct[&quot;(statement)&quot;].type === &quot;class&quot; ||
           funct[&quot;(context)&quot;] &amp;&amp; funct[&quot;(context)&quot;][&quot;(verb)&quot;] === &quot;class&quot;;
  }


  function isPropertyName(token) {
    return token.identifier || token.id === &quot;(string)&quot; || token.id === &quot;(number)&quot;;
  }


  function propertyName(preserveOrToken) {
    var id;
    var preserve = true;
    if (typeof preserveOrToken === &quot;object&quot;) {
      id = preserveOrToken;
    } else {
      preserve = preserveOrToken;
      id = optionalidentifier(false, true, preserve);
    }

    if (!id) {
      if (state.tokens.next.id === &quot;(string)&quot;) {
        id = state.tokens.next.value;
        if (!preserve) {
          advance();
        }
      } else if (state.tokens.next.id === &quot;(number)&quot;) {
        id = state.tokens.next.value.toString();
        if (!preserve) {
          advance();
        }
      }
    } else if (typeof id === &quot;object&quot;) {
      if (id.id === &quot;(string)&quot; || id.id === &quot;(identifier)&quot;) id = id.value;
      else if (id.id === &quot;(number)&quot;) id = id.value.toString();
    }

    if (id === &quot;hasOwnProperty&quot;) {
      warning(&quot;W001&quot;);
    }

    return id;
  }

  function functionparams(parsed) {
    var curr, next;
    var params = [];
    var ident;
    var tokens = [];
    var t;
    var pastDefault = false;

    if (parsed) {
      if (Array.isArray(parsed)) {
        for (var i in parsed) {
          curr = parsed[i];
          if (curr.value === &quot;...&quot;) {
            if (!state.option.esnext) {
              warning(&quot;W119&quot;, curr, &quot;spread/rest operator&quot;);
            }
            continue;
          } else if (curr.value !== &quot;,&quot;) {
            params.push(curr.value);
            addlabel(curr.value, { type: &quot;unused&quot;, token: curr });
          }
        }
        return params;
      } else {
        if (parsed.identifier === true) {
          addlabel(parsed.value, { type: &quot;unused&quot;, token: parsed });
          return [parsed];
        }
      }
    }

    next = state.tokens.next;

    advance(&quot;(&quot;);

    if (state.tokens.next.id === &quot;)&quot;) {
      advance(&quot;)&quot;);
      return;
    }

    for (;;) {
      if (_.contains([&quot;{&quot;, &quot;[&quot;], state.tokens.next.id)) {
        tokens = destructuringExpression();
        for (t in tokens) {
          t = tokens[t];
          if (t.id) {
            params.push(t.id);
            addlabel(t.id, { type: &quot;unused&quot;, token: t.token });
          }
        }
      } else if (state.tokens.next.value === &quot;...&quot;) {
        if (!state.option.esnext) {
          warning(&quot;W119&quot;, state.tokens.next, &quot;spread/rest operator&quot;);
        }
        advance(&quot;...&quot;);
        ident = identifier(true);
        params.push(ident);
        addlabel(ident, { type: &quot;unused&quot;, token: state.tokens.curr });
      } else {
        ident = identifier(true);
        params.push(ident);
        addlabel(ident, { type: &quot;unused&quot;, token: state.tokens.curr });
      }

      // it is a syntax error to have a regular argument after a default argument
      if (pastDefault) {
        if (state.tokens.next.id !== &quot;=&quot;) {
          error(&quot;E051&quot;, state.tokens.current);
        }
      }
      if (state.tokens.next.id === &quot;=&quot;) {
        if (!state.option.inESNext()) {
          warning(&quot;W119&quot;, state.tokens.next, &quot;default parameters&quot;);
        }
        advance(&quot;=&quot;);
        pastDefault = true;
        expression(10);
      }
      if (state.tokens.next.id === &quot;,&quot;) {
        comma();
      } else {
        advance(&quot;)&quot;, next);
        return params;
      }
    }
  }

  function setprop(funct, name, values) {
    if (!funct[&quot;(properties)&quot;][name]) {
      funct[&quot;(properties)&quot;][name] = { unused: false };
    }

    _.extend(funct[&quot;(properties)&quot;][name], values);
  }

  function getprop(funct, name, prop) {
    if (!funct[&quot;(properties)&quot;][name])
      return null;

    return funct[&quot;(properties)&quot;][name][prop] || null;
  }

  function functor(name, token, scope, overwrites) {
    var funct = {
      &quot;(name)&quot;      : name,
      &quot;(breakage)&quot;  : 0,
      &quot;(loopage)&quot;   : 0,
      &quot;(scope)&quot;     : scope,
      &quot;(tokens)&quot;    : {},
      &quot;(properties)&quot;: {},

      &quot;(catch)&quot;     : false,
      &quot;(global)&quot;    : false,

      &quot;(line)&quot;      : null,
      &quot;(character)&quot; : null,
      &quot;(metrics)&quot;   : null,
      &quot;(statement)&quot; : null,
      &quot;(context)&quot;   : null,
      &quot;(blockscope)&quot;: null,
      &quot;(comparray)&quot; : null,
      &quot;(generator)&quot; : null,
      &quot;(params)&quot;    : null
    };

    if (token) {
      _.extend(funct, {
        &quot;(line)&quot;     : token.line,
        &quot;(character)&quot;: token.character,
        &quot;(metrics)&quot;  : createMetrics(token)
      });
    }

    _.extend(funct, overwrites);

    if (funct[&quot;(context)&quot;]) {
      funct[&quot;(blockscope)&quot;] = funct[&quot;(context)&quot;][&quot;(blockscope)&quot;];
      funct[&quot;(comparray)&quot;]  = funct[&quot;(context)&quot;][&quot;(comparray)&quot;];
    }

    return funct;
  }

  function doTemplateLiteral() {
    while (state.tokens.next.type !== &quot;(template tail)&quot; &amp;&amp; state.tokens.next.id !== &quot;(end)&quot;) {
      advance();
      if (state.tokens.next.type === &quot;(template tail)&quot;) {
        break;
      } else if (state.tokens.next.type !== &quot;(template middle)&quot; &amp;&amp;
                 state.tokens.next.type !== &quot;(end)&quot;) {
        expression(10); // should probably have different rbp?
      }
    }
    return {
      id: &quot;(template)&quot;,
      type: &quot;(template)&quot;
    };
  }

  function doFunction(name, statement, generator, fatarrowparams) {
    var f;
    var oldOption = state.option;
    var oldIgnored = state.ignored;
    var oldScope  = scope;

    state.option = Object.create(state.option);
    state.ignored = Object.create(state.ignored);
    scope = Object.create(scope);

    funct = functor(name || &quot;\&quot;&quot; + anonname + &quot;\&quot;&quot;, state.tokens.next, scope, {
      &quot;(statement)&quot;: statement,
      &quot;(context)&quot;:   funct,
      &quot;(generator)&quot;: generator ? true : null
    });

    f = funct;
    state.tokens.curr.funct = funct;

    functions.push(funct);

    if (name) {
      addlabel(name, { type: &quot;function&quot; });
    }

    funct[&quot;(params)&quot;] = functionparams(fatarrowparams);
    funct[&quot;(metrics)&quot;].verifyMaxParametersPerFunction(funct[&quot;(params)&quot;]);

    // So we parse fat-arrow functions after we encounter =&gt;. So basically
    // doFunction is called with the left side of =&gt; as its last argument.
    // This means that the parser, at that point, had already added its
    // arguments to the undefs array and here we undo that.

    JSHINT.undefs = _.filter(JSHINT.undefs, function (item) {
      return !_.contains(_.union(fatarrowparams), item[2]);
    });

    block(false, true, true, fatarrowparams ? true : false);

    if (!state.option.noyield &amp;&amp; generator &amp;&amp;
        funct[&quot;(generator)&quot;] !== &quot;yielded&quot;) {
      warning(&quot;W124&quot;, state.tokens.curr);
    }

    funct[&quot;(metrics)&quot;].verifyMaxStatementsPerFunction();
    funct[&quot;(metrics)&quot;].verifyMaxComplexityPerFunction();
    funct[&quot;(unusedOption)&quot;] = state.option.unused;

    scope = oldScope;
    state.option = oldOption;
    state.ignored = oldIgnored;
    funct[&quot;(last)&quot;] = state.tokens.curr.line;
    funct[&quot;(lastcharacter)&quot;] = state.tokens.curr.character;

    _.map(Object.keys(funct), function (key) {
      if (key[0] === &quot;(&quot;) return;
      funct[&quot;(blockscope)&quot;].unshadow(key);
    });

    funct = funct[&quot;(context)&quot;];

    return f;
  }

  function createMetrics(functionStartToken) {
    return {
      statementCount: 0,
      nestedBlockDepth: -1,
      ComplexityCount: 1,

      verifyMaxStatementsPerFunction: function () {
        if (state.option.maxstatements &amp;&amp;
          this.statementCount &gt; state.option.maxstatements) {
          warning(&quot;W071&quot;, functionStartToken, this.statementCount);
        }
      },

      verifyMaxParametersPerFunction: function (params) {
        params = params || [];

        if (state.option.maxparams &amp;&amp; params.length &gt; state.option.maxparams) {
          warning(&quot;W072&quot;, functionStartToken, params.length);
        }
      },

      verifyMaxNestedBlockDepthPerFunction: function () {
        if (state.option.maxdepth &amp;&amp;
          this.nestedBlockDepth &gt; 0 &amp;&amp;
          this.nestedBlockDepth === state.option.maxdepth + 1) {
          warning(&quot;W073&quot;, null, this.nestedBlockDepth);
        }
      },

      verifyMaxComplexityPerFunction: function () {
        var max = state.option.maxcomplexity;
        var cc = this.ComplexityCount;
        if (max &amp;&amp; cc &gt; max) {
          warning(&quot;W074&quot;, functionStartToken, cc);
        }
      }
    };
  }

  function increaseComplexityCount() {
    funct[&quot;(metrics)&quot;].ComplexityCount += 1;
  }

  // Parse assignments that were found instead of conditionals.
  // For example: if (a = 1) { ... }

  function checkCondAssignment(expr) {
    var id, paren;
    if (expr) {
      id = expr.id;
      paren = expr.paren;
      if (id === &quot;,&quot; &amp;&amp; (expr = expr.exprs[expr.exprs.length - 1])) {
        id = expr.id;
        paren = paren || expr.paren;
      }
    }
    switch (id) {
    case &quot;=&quot;:
    case &quot;+=&quot;:
    case &quot;-=&quot;:
    case &quot;*=&quot;:
    case &quot;%=&quot;:
    case &quot;&amp;=&quot;:
    case &quot;|=&quot;:
    case &quot;^=&quot;:
    case &quot;/=&quot;:
      if (!paren &amp;&amp; !state.option.boss) {
        warning(&quot;W084&quot;);
      }
    }
  }


  (function (x) {
    x.nud = function () {
      var b, f, i, p, t, g, nextVal;
      var props = {}; // All properties, including accessors

      b = state.tokens.curr.line !== state.tokens.next.line;
      if (b) {
        indent += state.option.indent;
        if (state.tokens.next.from === indent + state.option.indent) {
          indent += state.option.indent;
        }
      }

      for (;;) {
        if (state.tokens.next.id === &quot;}&quot;) {
          break;
        }

        nextVal = state.tokens.next.value;
        if (peek().id !== &quot;:&quot; &amp;&amp; (nextVal === &quot;get&quot; || nextVal === &quot;set&quot;)) {
          advance(nextVal);

          if (!state.option.inES5()) {
            error(&quot;E034&quot;);
          }

          i = propertyName();

          // ES6 allows for get() {...} and set() {...} method
          // definition shorthand syntax, so we don&#039;t produce an error
          // if the esnext option is enabled.
          if (!i &amp;&amp; !state.option.inESNext()) {
            error(&quot;E035&quot;);
          }

          // We don&#039;t want to save this getter unless it&#039;s an actual getter
          // and not an ES6 concise method
          if (i) {
            if (nextVal === &quot;get&quot;) {
              saveGetter(props, i);
            } else {
              saveSetter(props, i, state.tokens.next);
            }
          }

          t = state.tokens.next;
          f = doFunction();
          p = f[&quot;(params)&quot;];

          // Don&#039;t warn about getter/setter pairs if this is an ES6 concise method
          if (nextVal === &quot;get&quot; &amp;&amp; i &amp;&amp; p) {
            warning(&quot;W076&quot;, t, p[0], i);
          } else if (nextVal === &quot;set&quot; &amp;&amp; i &amp;&amp; (!p || p.length !== 1)) {
            warning(&quot;W077&quot;, t, i);
          }
        } else {
          g = false;
          if (state.tokens.next.value === &quot;*&quot; &amp;&amp; state.tokens.next.type === &quot;(punctuator)&quot;) {
            if (!state.option.inESNext()) {
              warning(&quot;W104&quot;, state.tokens.next, &quot;generator functions&quot;);
            }
            advance(&quot;*&quot;);
            g = true;
          }
          if (state.tokens.next.identifier &amp;&amp;
              (peekIgnoreEOL().id === &quot;,&quot; || peekIgnoreEOL().id === &quot;}&quot;)) {
            if (!state.option.inESNext()) {
              warning(&quot;W104&quot;, state.tokens.next, &quot;object short notation&quot;);
            }
            i = propertyName(true);
            saveProperty(props, i, state.tokens.next);

            expression(10);
          } else {
            if (state.tokens.next.id === &quot;[&quot;) {
              i = computedPropertyName();
            } else {
              i = propertyName();
              saveProperty(props, i, state.tokens.next);

              if (typeof i !== &quot;string&quot;) {
                break;
              }
            }

            if (state.tokens.next.value === &quot;(&quot;) {
              if (!state.option.inESNext()) {
                warning(&quot;W104&quot;, state.tokens.curr, &quot;concise methods&quot;);
              }
              doFunction(i, undefined, g);
            } else {
              advance(&quot;:&quot;);
              expression(10);
            }
          }
        }

        countMember(i);

        if (state.tokens.next.id === &quot;,&quot;) {
          comma({ allowTrailing: true, property: true });
          if (state.tokens.next.id === &quot;,&quot;) {
            warning(&quot;W070&quot;, state.tokens.curr);
          } else if (state.tokens.next.id === &quot;}&quot; &amp;&amp; !state.option.inES5(true)) {
            warning(&quot;W070&quot;, state.tokens.curr);
          }
        } else {
          break;
        }
      }
      if (b) {
        indent -= state.option.indent;
      }
      advance(&quot;}&quot;, this);

      // Check for lonely setters if in the ES5 mode.
      if (state.option.inES5()) {
        for (var name in props) {
          if (_.has(props, name) &amp;&amp; props[name].setter &amp;&amp; !props[name].getter) {
            warning(&quot;W078&quot;, props[name].setterToken);
          }
        }
      }
      return this;
    };
    x.fud = function () {
      error(&quot;E036&quot;, state.tokens.curr);
    };
  }(delim(&quot;{&quot;)));

  function destructuringExpression() {
    var id, ids;
    var identifiers = [];
    if (!state.option.inESNext()) {
      warning(&quot;W104&quot;, state.tokens.curr, &quot;destructuring expression&quot;);
    }
    var nextInnerDE = function () {
      var ident;
      if (_.contains([&quot;[&quot;, &quot;{&quot;], state.tokens.next.value)) {
        ids = destructuringExpression();
        for (var id in ids) {
          id = ids[id];
          identifiers.push({ id: id.id, token: id.token });
        }
      } else if (state.tokens.next.value === &quot;,&quot;) {
        identifiers.push({ id: null, token: state.tokens.curr });
      } else if (state.tokens.next.value === &quot;(&quot;) {
        advance(&quot;(&quot;);
        nextInnerDE();
        advance(&quot;)&quot;);
      } else {
        ident = identifier();
        if (ident)
          identifiers.push({ id: ident, token: state.tokens.curr });
      }
    };
    if (state.tokens.next.value === &quot;[&quot;) {
      advance(&quot;[&quot;);
      nextInnerDE();
      while (state.tokens.next.value !== &quot;]&quot;) {
        advance(&quot;,&quot;);
        nextInnerDE();
      }
      advance(&quot;]&quot;);
    } else if (state.tokens.next.value === &quot;{&quot;) {
      advance(&quot;{&quot;);
      id = identifier();
      if (state.tokens.next.value === &quot;:&quot;) {
        advance(&quot;:&quot;);
        nextInnerDE();
      } else {
        identifiers.push({ id: id, token: state.tokens.curr });
      }
      while (state.tokens.next.value !== &quot;}&quot;) {
        advance(&quot;,&quot;);
        id = identifier();
        if (state.tokens.next.value === &quot;:&quot;) {
          advance(&quot;:&quot;);
          nextInnerDE();
        } else {
          identifiers.push({ id: id, token: state.tokens.curr });
        }
      }
      advance(&quot;}&quot;);
    }
    return identifiers;
  }

  function destructuringExpressionMatch(tokens, value) {
    var first = value.first;

    if (!first)
      return;

    _.zip(tokens, Array.isArray(first) ? first : [ first ]).forEach(function (val) {
      var token = val[0];
      var value = val[1];

      if (token &amp;&amp; value)
        token.first = value;
      else if (token &amp;&amp; token.first &amp;&amp; !value)
        warning(&quot;W080&quot;, token.first, token.first.value);
    });
  }

  var conststatement = stmt(&quot;const&quot;, function (prefix) {
    var tokens;
    var value;
    var lone; // State variable to know if it is a lone identifier, or a destructuring statement.

    if (!state.option.inESNext())
      warning(&quot;W104&quot;, state.tokens.curr, &quot;const&quot;);

    this.first = [];
    for (;;) {
      var names = [];
      if (_.contains([&quot;{&quot;, &quot;[&quot;], state.tokens.next.value)) {
        tokens = destructuringExpression();
        lone = false;
      } else {
        tokens = [ { id: identifier(), token: state.tokens.curr } ];
        lone = true;
      }
      for (var t in tokens) {
        if (tokens.hasOwnProperty(t)) {
          t = tokens[t];
          if (funct[t.id] === &quot;const&quot;) {
            warning(&quot;E011&quot;, null, t.id);
          }
          if (funct[&quot;(global)&quot;] &amp;&amp; predefined[t.id] === false) {
            warning(&quot;W079&quot;, t.token, t.id);
          }
          if (t.id) {
            addlabel(t.id, { token: t.token, type: &quot;const&quot;, unused: true });
            names.push(t.token);
          }
        }
      }
      if (prefix) {
        break;
      }

      this.first = this.first.concat(names);

      if (state.tokens.next.id !== &quot;=&quot;) {
        warning(&quot;E012&quot;, state.tokens.curr, state.tokens.curr.value);
      }

      if (state.tokens.next.id === &quot;=&quot;) {
        advance(&quot;=&quot;);
        if (state.tokens.next.id === &quot;undefined&quot;) {
          warning(&quot;W080&quot;, state.tokens.prev, state.tokens.prev.value);
        }
        if (peek(0).id === &quot;=&quot; &amp;&amp; state.tokens.next.identifier) {
          warning(&quot;W120&quot;, state.tokens.next, state.tokens.next.value);
        }
        value = expression(10);
        if (lone) {
          tokens[0].first = value;
        } else {
          destructuringExpressionMatch(names, value);
        }
      }

      if (state.tokens.next.id !== &quot;,&quot;) {
        break;
      }
      comma();
    }
    return this;
  });

  conststatement.exps = true;
  var varstatement = stmt(&quot;var&quot;, function (prefix) {
    // JavaScript does not have block scope. It only has function scope. So,
    // declaring a variable in a block can have unexpected consequences.
    var tokens, lone, value;

    this.first = [];
    for (;;) {
      var names = [];
      if (_.contains([&quot;{&quot;, &quot;[&quot;], state.tokens.next.value)) {
        tokens = destructuringExpression();
        lone = false;
      } else {
        tokens = [ { id: identifier(), token: state.tokens.curr } ];
        lone = true;
      }
      for (var t in tokens) {
        if (tokens.hasOwnProperty(t)) {
          t = tokens[t];
          if (state.option.inESNext() &amp;&amp; funct[t.id] === &quot;const&quot;) {
            warning(&quot;E011&quot;, null, t.id);
          }
          if (funct[&quot;(global)&quot;] &amp;&amp; predefined[t.id] === false) {
            warning(&quot;W079&quot;, t.token, t.id);
          }
          if (t.id) {
            addlabel(t.id, { type: &quot;unused&quot;, token: t.token });
            names.push(t.token);
          }
        }
      }
      if (prefix) {
        break;
      }

      this.first = this.first.concat(names);

      if (state.tokens.next.id === &quot;=&quot;) {
        advance(&quot;=&quot;);
        if (state.tokens.next.id === &quot;undefined&quot;) {
          warning(&quot;W080&quot;, state.tokens.prev, state.tokens.prev.value);
        }
        if (peek(0).id === &quot;=&quot; &amp;&amp; state.tokens.next.identifier) {
          if (!funct[&quot;(params)&quot;] || funct[&quot;(params)&quot;].indexOf(state.tokens.next.value) === -1) {
            warning(&quot;W120&quot;, state.tokens.next, state.tokens.next.value);
          }
        }
        value = expression(10);
        if (lone) {
          tokens[0].first = value;
        } else {
          destructuringExpressionMatch(names, value);
        }
      }

      if (state.tokens.next.id !== &quot;,&quot;) {
        break;
      }
      comma();
    }
    return this;
  });
  varstatement.exps = true;

  var letstatement = stmt(&quot;let&quot;, function (prefix) {
    var tokens, lone, value, letblock;

    if (!state.option.inESNext()) {
      warning(&quot;W104&quot;, state.tokens.curr, &quot;let&quot;);
    }

    if (state.tokens.next.value === &quot;(&quot;) {
      if (!state.option.inMoz(true)) {
        warning(&quot;W118&quot;, state.tokens.next, &quot;let block&quot;);
      }
      advance(&quot;(&quot;);
      funct[&quot;(blockscope)&quot;].stack();
      letblock = true;
    } else if (funct[&quot;(nolet)&quot;]) {
      error(&quot;E048&quot;, state.tokens.curr);
    }

    this.first = [];
    for (;;) {
      var names = [];
      if (_.contains([&quot;{&quot;, &quot;[&quot;], state.tokens.next.value)) {
        tokens = destructuringExpression();
        lone = false;
      } else {
        tokens = [ { id: identifier(), token: state.tokens.curr.value } ];
        lone = true;
      }
      for (var t in tokens) {
        if (tokens.hasOwnProperty(t)) {
          t = tokens[t];
          if (state.option.inESNext() &amp;&amp; funct[t.id] === &quot;const&quot;) {
            warning(&quot;E011&quot;, null, t.id);
          }
          if (funct[&quot;(global)&quot;] &amp;&amp; predefined[t.id] === false) {
            warning(&quot;W079&quot;, t.token, t.id);
          }
          if (t.id &amp;&amp; !funct[&quot;(nolet)&quot;]) {
            addlabel(t.id, { type: &quot;unused&quot;, token: t.token, islet: true });
            names.push(t.token);
          }
        }
      }
      if (prefix) {
        break;
      }

      this.first = this.first.concat(names);

      if (state.tokens.next.id === &quot;=&quot;) {
        advance(&quot;=&quot;);
        if (state.tokens.next.id === &quot;undefined&quot;) {
          warning(&quot;W080&quot;, state.tokens.prev, state.tokens.prev.value);
        }
        if (peek(0).id === &quot;=&quot; &amp;&amp; state.tokens.next.identifier) {
          warning(&quot;W120&quot;, state.tokens.next, state.tokens.next.value);
        }
        value = expression(10);
        if (lone) {
          tokens[0].first = value;
        } else {
          destructuringExpressionMatch(names, value);
        }
      }

      if (state.tokens.next.id !== &quot;,&quot;) {
        break;
      }
      comma();
    }
    if (letblock) {
      advance(&quot;)&quot;);
      block(true, true);
      this.block = true;
      funct[&quot;(blockscope)&quot;].unstack();
    }

    return this;
  });
  letstatement.exps = true;

  blockstmt(&quot;class&quot;, function () {
    return classdef.call(this, true);
  });

  function classdef(stmt) {
    /*jshint validthis:true */
    if (!state.option.inESNext()) {
      warning(&quot;W104&quot;, state.tokens.curr, &quot;class&quot;);
    }
    if (stmt) {
      // BindingIdentifier
      this.name = identifier();
      addlabel(this.name, { type: &quot;unused&quot;, token: state.tokens.curr });
    } else if (state.tokens.next.identifier &amp;&amp; state.tokens.next.value !== &quot;extends&quot;) {
      // BindingIdentifier(opt)
      this.name = identifier();
    }
    classtail(this);
    return this;
  }

  function classtail(c) {
    var strictness = state.directive[&quot;use strict&quot;];

    // ClassHeritage(opt)
    if (state.tokens.next.value === &quot;extends&quot;) {
      advance(&quot;extends&quot;);
      c.heritage = expression(10);
    }

    // A ClassBody is always strict code.
    state.directive[&quot;use strict&quot;] = true;
    advance(&quot;{&quot;);
    // ClassBody(opt)
    c.body = classbody(c);
    advance(&quot;}&quot;);
    state.directive[&quot;use strict&quot;] = strictness;
  }

  function classbody(c) {
    var name;
    var isStatic;
    var getset;
    var props = {};
    var staticProps = {};
    var computed;
    for (var i = 0; state.tokens.next.id !== &quot;}&quot;; ++i) {
      name = state.tokens.next;
      isStatic = false;
      getset = null;
      if (name.id === &quot;[&quot;) {
        name = computedPropertyName();
      } else if (isPropertyName(name)) {
        // Non-Computed PropertyName
        advance();
        computed = false;
        if (name.identifier &amp;&amp; name.value === &quot;static&quot;) {
          if (isPropertyName(state.tokens.next) || state.tokens.next.id === &quot;[&quot;) {
            computed = state.tokens.next.id === &quot;[&quot;;
            isStatic = true;
            name = state.tokens.next;
            if (state.tokens.next.id === &quot;[&quot;) {
              name = computedPropertyName();
            } else advance();
          }
        }

        if (name.identifier &amp;&amp; (name.value === &quot;get&quot; || name.value === &quot;set&quot;)) {
          if (isPropertyName(state.tokens.next) || state.tokens.next.id === &quot;[&quot;) {
            computed = state.tokens.next.id === &quot;[&quot;;
            getset = name;
            name = state.tokens.next;
            if (state.tokens.next.id === &quot;[&quot;) {
              name = computedPropertyName();
            } else advance();
          }
        }
      } else {
        warning(&quot;W052&quot;, state.tokens.next, state.tokens.next.value || state.tokens.next.type);
        advance();
        continue;
      }

      if (!checkPunctuators(state.tokens.next, [&quot;(&quot;])) {
        // error --- class properties must be methods
        error(&quot;E054&quot;, state.tokens.next, state.tokens.next.value);
        while (state.tokens.next.id !== &quot;}&quot; &amp;&amp;
               !checkPunctuators(state.tokens.next, [&quot;(&quot;])) {
          advance();
        }
        if (state.tokens.next.value !== &quot;(&quot;) {
          doFunction(undefined, c, false, null);
        }
      }

      if (!computed) {
        // We don&#039;t know how to determine if we have duplicate computed property names :(
        if (getset) {
          if (getset.value === &quot;get&quot;) {
            saveGetter(isStatic ? staticProps : props, name.value, true, isStatic);
          } else {
            saveSetter(isStatic ? staticProps : props, name.value, name, true, isStatic);
          }
        } else {
          saveProperty(isStatic ? staticProps : props, name.value, name, true, isStatic);
        }
      }

      if (getset &amp;&amp; name.value === &quot;constructor&quot;) {
        var propDesc = getset.value === &quot;get&quot; ? &quot;class getter method&quot; : &quot;class setter method&quot;;
        error(&quot;E049&quot;, name, propDesc, &quot;constructor&quot;);
      } else if (name.value === &quot;prototype&quot;) {
        error(&quot;E049&quot;, name, &quot;class method&quot;, &quot;prototype&quot;);
      }

      doFunction(!computed &amp;&amp; propertyName(name), c, false, null);
    }
  }

  blockstmt(&quot;function&quot;, function () {
    var generator = false;
    if (state.tokens.next.value === &quot;*&quot;) {
      advance(&quot;*&quot;);
      if (state.option.inESNext(true)) {
        generator = true;
      } else {
        warning(&quot;W119&quot;, state.tokens.curr, &quot;function*&quot;);
      }
    }
    if (inblock) {
      warning(&quot;W082&quot;, state.tokens.curr);

    }
    var i = optionalidentifier();

    if (i === undefined) {
      warning(&quot;W025&quot;);
    }

    if (funct[i] === &quot;const&quot;) {
      warning(&quot;E011&quot;, null, i);
    }
    addlabel(i, { type: &quot;unction&quot;, token: state.tokens.curr });

    doFunction(i, { statement: true }, generator);
    if (state.tokens.next.id === &quot;(&quot; &amp;&amp; state.tokens.next.line === state.tokens.curr.line) {
      error(&quot;E039&quot;);
    }
    return this;
  });

  prefix(&quot;function&quot;, function () {
    var generator = false;

    if (state.tokens.next.value === &quot;*&quot;) {
      if (!state.option.inESNext()) {
        warning(&quot;W119&quot;, state.tokens.curr, &quot;function*&quot;);
      }
      advance(&quot;*&quot;);
      generator = true;
    }

    var i = optionalidentifier();
    var fn = doFunction(i, undefined, generator);

    function isVariable(name) { return name[0] !== &quot;(&quot;; }
    function isLocal(name) { return fn[name] === &quot;var&quot;; }

    if (!state.option.loopfunc &amp;&amp; funct[&quot;(loopage)&quot;]) {
      // If the function we just parsed accesses any non-local variables
      // trigger a warning. Otherwise, the function is safe even within
      // a loop.
      if (_.some(fn, function (val, name) { return isVariable(name) &amp;&amp; !isLocal(name); })) {
        warning(&quot;W083&quot;);
      }
    }
    return this;
  });

  blockstmt(&quot;if&quot;, function () {
    var t = state.tokens.next;
    increaseComplexityCount();
    state.condition = true;
    advance(&quot;(&quot;);
    var expr = expression(0);
    checkCondAssignment(expr);

    // When the if is within a for-in loop, check if the condition
    // starts with a negation operator
    var forinifcheck = null;
    if (state.option.forin &amp;&amp; state.forinifcheckneeded) {
      state.forinifcheckneeded = false; // We only need to analyze the first if inside the loop
      forinifcheck = state.forinifchecks[state.forinifchecks.length - 1];
      if (expr.type === &quot;(punctuator)&quot; &amp;&amp; expr.value === &quot;!&quot;) {
        forinifcheck.type = &quot;(negative)&quot;;
      } else {
        forinifcheck.type = &quot;(positive)&quot;;
      }
    }

    advance(&quot;)&quot;, t);
    state.condition = false;
    var s = block(true, true);

    // When the if is within a for-in loop and the condition has a negative form,
    // check if the body contains nothing but a continue statement
    if (forinifcheck &amp;&amp; forinifcheck.type === &quot;(negative)&quot;) {
      if (s &amp;&amp; s.length === 1 &amp;&amp; s[0].type === &quot;(identifier)&quot; &amp;&amp; s[0].value === &quot;continue&quot;) {
        forinifcheck.type = &quot;(negative-with-continue)&quot;;
      }
    }

    if (state.tokens.next.id === &quot;else&quot;) {
      advance(&quot;else&quot;);
      if (state.tokens.next.id === &quot;if&quot; || state.tokens.next.id === &quot;switch&quot;) {
        statement();
      } else {
        block(true, true);
      }
    }
    return this;
  });

  blockstmt(&quot;try&quot;, function () {
    var b;

    function doCatch() {
      var oldScope = scope;
      var e;

      advance(&quot;catch&quot;);
      advance(&quot;(&quot;);

      scope = Object.create(oldScope);

      e = state.tokens.next.value;
      if (state.tokens.next.type !== &quot;(identifier)&quot;) {
        e = null;
        warning(&quot;E030&quot;, state.tokens.next, e);
      }

      advance();

      funct = functor(&quot;(catch)&quot;, state.tokens.next, scope, {
        &quot;(context)&quot;  : funct,
        &quot;(breakage)&quot; : funct[&quot;(breakage)&quot;],
        &quot;(loopage)&quot;  : funct[&quot;(loopage)&quot;],
        &quot;(statement)&quot;: false,
        &quot;(catch)&quot;    : true
      });

      if (e) {
        addlabel(e, { type: &quot;exception&quot; });
      }

      if (state.tokens.next.value === &quot;if&quot;) {
        if (!state.option.inMoz(true)) {
          warning(&quot;W118&quot;, state.tokens.curr, &quot;catch filter&quot;);
        }
        advance(&quot;if&quot;);
        expression(0);
      }

      advance(&quot;)&quot;);

      state.tokens.curr.funct = funct;
      functions.push(funct);

      block(false);

      scope = oldScope;

      funct[&quot;(last)&quot;] = state.tokens.curr.line;
      funct[&quot;(lastcharacter)&quot;] = state.tokens.curr.character;
      funct = funct[&quot;(context)&quot;];
    }

    block(true);

    while (state.tokens.next.id === &quot;catch&quot;) {
      increaseComplexityCount();
      if (b &amp;&amp; (!state.option.inMoz(true))) {
        warning(&quot;W118&quot;, state.tokens.next, &quot;multiple catch blocks&quot;);
      }
      doCatch();
      b = true;
    }

    if (state.tokens.next.id === &quot;finally&quot;) {
      advance(&quot;finally&quot;);
      block(true);
      return;
    }

    if (!b) {
      error(&quot;E021&quot;, state.tokens.next, &quot;catch&quot;, state.tokens.next.value);
    }

    return this;
  });

  blockstmt(&quot;while&quot;, function () {
    var t = state.tokens.next;
    funct[&quot;(breakage)&quot;] += 1;
    funct[&quot;(loopage)&quot;] += 1;
    increaseComplexityCount();
    advance(&quot;(&quot;);
    checkCondAssignment(expression(0));
    advance(&quot;)&quot;, t);
    block(true, true);
    funct[&quot;(breakage)&quot;] -= 1;
    funct[&quot;(loopage)&quot;] -= 1;
    return this;
  }).labelled = true;

  blockstmt(&quot;with&quot;, function () {
    var t = state.tokens.next;
    if (state.directive[&quot;use strict&quot;]) {
      error(&quot;E010&quot;, state.tokens.curr);
    } else if (!state.option.withstmt) {
      warning(&quot;W085&quot;, state.tokens.curr);
    }

    advance(&quot;(&quot;);
    expression(0);
    advance(&quot;)&quot;, t);
    block(true, true);

    return this;
  });

  blockstmt(&quot;switch&quot;, function () {
    var t = state.tokens.next;
    var g = false;
    var noindent = false;

    funct[&quot;(breakage)&quot;] += 1;
    advance(&quot;(&quot;);
    checkCondAssignment(expression(0));
    advance(&quot;)&quot;, t);
    t = state.tokens.next;
    advance(&quot;{&quot;);

    if (state.tokens.next.from === indent)
      noindent = true;

    if (!noindent)
      indent += state.option.indent;

    this.cases = [];

    for (;;) {
      switch (state.tokens.next.id) {
      case &quot;case&quot;:
        switch (funct[&quot;(verb)&quot;]) {
        case &quot;yield&quot;:
        case &quot;break&quot;:
        case &quot;case&quot;:
        case &quot;continue&quot;:
        case &quot;return&quot;:
        case &quot;switch&quot;:
        case &quot;throw&quot;:
          break;
        default:
          // You can tell JSHint that you don&#039;t use break intentionally by
          // adding a comment /* falls through */ on a line just before
          // the next `case`.
          if (!reg.fallsThrough.test(state.lines[state.tokens.next.line - 2])) {
            warning(&quot;W086&quot;, state.tokens.curr, &quot;case&quot;);
          }
        }

        advance(&quot;case&quot;);
        this.cases.push(expression(0));
        increaseComplexityCount();
        g = true;
        advance(&quot;:&quot;);
        funct[&quot;(verb)&quot;] = &quot;case&quot;;
        break;
      case &quot;default&quot;:
        switch (funct[&quot;(verb)&quot;]) {
        case &quot;yield&quot;:
        case &quot;break&quot;:
        case &quot;continue&quot;:
        case &quot;return&quot;:
        case &quot;throw&quot;:
          break;
        default:
          // Do not display a warning if &#039;default&#039; is the first statement or if
          // there is a special /* falls through */ comment.
          if (this.cases.length) {
            if (!reg.fallsThrough.test(state.lines[state.tokens.next.line - 2])) {
              warning(&quot;W086&quot;, state.tokens.curr, &quot;default&quot;);
            }
          }
        }

        advance(&quot;default&quot;);
        g = true;
        advance(&quot;:&quot;);
        break;
      case &quot;}&quot;:
        if (!noindent)
          indent -= state.option.indent;

        advance(&quot;}&quot;, t);
        funct[&quot;(breakage)&quot;] -= 1;
        funct[&quot;(verb)&quot;] = undefined;
        return;
      case &quot;(end)&quot;:
        error(&quot;E023&quot;, state.tokens.next, &quot;}&quot;);
        return;
      default:
        indent += state.option.indent;
        if (g) {
          switch (state.tokens.curr.id) {
          case &quot;,&quot;:
            error(&quot;E040&quot;);
            return;
          case &quot;:&quot;:
            g = false;
            statements();
            break;
          default:
            error(&quot;E025&quot;, state.tokens.curr);
            return;
          }
        } else {
          if (state.tokens.curr.id === &quot;:&quot;) {
            advance(&quot;:&quot;);
            error(&quot;E024&quot;, state.tokens.curr, &quot;:&quot;);
            statements();
          } else {
            error(&quot;E021&quot;, state.tokens.next, &quot;case&quot;, state.tokens.next.value);
            return;
          }
        }
        indent -= state.option.indent;
      }
    }
  }).labelled = true;

  stmt(&quot;debugger&quot;, function () {
    if (!state.option.debug) {
      warning(&quot;W087&quot;, this);
    }
    return this;
  }).exps = true;

  (function () {
    var x = stmt(&quot;do&quot;, function () {
      funct[&quot;(breakage)&quot;] += 1;
      funct[&quot;(loopage)&quot;] += 1;
      increaseComplexityCount();

      this.first = block(true, true);
      advance(&quot;while&quot;);
      var t = state.tokens.next;
      advance(&quot;(&quot;);
      checkCondAssignment(expression(0));
      advance(&quot;)&quot;, t);
      funct[&quot;(breakage)&quot;] -= 1;
      funct[&quot;(loopage)&quot;] -= 1;
      return this;
    });
    x.labelled = true;
    x.exps = true;
  }());

  blockstmt(&quot;for&quot;, function () {
    var s, t = state.tokens.next;
    var letscope = false;
    var foreachtok = null;

    if (t.value === &quot;each&quot;) {
      foreachtok = t;
      advance(&quot;each&quot;);
      if (!state.option.inMoz(true)) {
        warning(&quot;W118&quot;, state.tokens.curr, &quot;for each&quot;);
      }
    }

    funct[&quot;(breakage)&quot;] += 1;
    funct[&quot;(loopage)&quot;] += 1;
    increaseComplexityCount();
    advance(&quot;(&quot;);

    // what kind of for() statement it is? for(of)? for(in)? for(;;)?
    var nextop; // contains the token of the &quot;in&quot; or &quot;of&quot; operator
    var i = 0;
    var inof = [&quot;in&quot;, &quot;of&quot;];
    do {
      nextop = peek(i);
      ++i;
    } while (!_.contains(inof, nextop.value) &amp;&amp; nextop.value !== &quot;;&quot; &amp;&amp;
          nextop.type !== &quot;(end)&quot;);

    // if we&#039;re in a for ( in|of ) statement
    if (_.contains(inof, nextop.value)) {
      if (!state.option.inESNext() &amp;&amp; nextop.value === &quot;of&quot;) {
        error(&quot;W104&quot;, nextop, &quot;for of&quot;);
      }

      if (state.tokens.next.id === &quot;var&quot;) {
        advance(&quot;var&quot;);
        state.syntax[&quot;var&quot;].fud.call(state.syntax[&quot;var&quot;].fud, true);
      } else if (state.tokens.next.id === &quot;let&quot;) {
        advance(&quot;let&quot;);
        // create a new block scope
        letscope = true;
        funct[&quot;(blockscope)&quot;].stack();
        state.syntax[&quot;let&quot;].fud.call(state.syntax[&quot;let&quot;].fud, true);
      } else if (!state.tokens.next.identifier) {
        error(&quot;E030&quot;, state.tokens.next, state.tokens.next.type);
        advance();
      } else {
        switch (funct[state.tokens.next.value]) {
        case &quot;unused&quot;:
          funct[state.tokens.next.value] = &quot;var&quot;;
          break;
        case &quot;var&quot;:
          break;
        default:
          var ident = state.tokens.next.value;
          if (!funct[&quot;(blockscope)&quot;].getlabel(ident) &amp;&amp;
              !(scope[ident] || {})[ident])
            warning(&quot;W088&quot;, state.tokens.next, state.tokens.next.value);
        }
        advance();
      }
      advance(nextop.value);
      expression(20);
      advance(&quot;)&quot;, t);

      if (nextop.value === &quot;in&quot; &amp;&amp; state.option.forin) {
        state.forinifcheckneeded = true;

        if (state.forinifchecks === undefined) {
          state.forinifchecks = [];
        }

        // Push a new for-in-if check onto the stack. The type will be modified
        // when the loop&#039;s body is parsed and a suitable if statement exists.
        state.forinifchecks.push({
          type: &quot;(none)&quot;
        });
      }

      s = block(true, true);

      if (nextop.value === &quot;in&quot; &amp;&amp; state.option.forin) {
        if (state.forinifchecks &amp;&amp; state.forinifchecks.length &gt; 0) {
          var check = state.forinifchecks.pop();

          if (// No if statement or not the first statement in loop body
              s &amp;&amp; s.length &gt; 0 &amp;&amp; (typeof s[0] !== &quot;object&quot; || s[0].value !== &quot;if&quot;) ||
              // Positive if statement is not the only one in loop body
              check.type === &quot;(positive)&quot; &amp;&amp; s.length &gt; 1 ||
              // Negative if statement but no continue
              check.type === &quot;(negative)&quot;) {
            warning(&quot;W089&quot;, this);
          }
        }

        // Reset the flag in case no if statement was contained in the loop body
        state.forinifcheckneeded = false;
      }

      funct[&quot;(breakage)&quot;] -= 1;
      funct[&quot;(loopage)&quot;] -= 1;
    } else {
      if (foreachtok) {
        error(&quot;E045&quot;, foreachtok);
      }
      if (state.tokens.next.id !== &quot;;&quot;) {
        if (state.tokens.next.id === &quot;var&quot;) {
          advance(&quot;var&quot;);
          state.syntax[&quot;var&quot;].fud.call(state.syntax[&quot;var&quot;].fud);
        } else if (state.tokens.next.id === &quot;let&quot;) {
          advance(&quot;let&quot;);
          // create a new block scope
          letscope = true;
          funct[&quot;(blockscope)&quot;].stack();
          state.syntax[&quot;let&quot;].fud.call(state.syntax[&quot;let&quot;].fud);
        } else {
          for (;;) {
            expression(0, &quot;for&quot;);
            if (state.tokens.next.id !== &quot;,&quot;) {
              break;
            }
            comma();
          }
        }
      }
      nolinebreak(state.tokens.curr);
      advance(&quot;;&quot;);
      if (state.tokens.next.id !== &quot;;&quot;) {
        checkCondAssignment(expression(0));
      }
      nolinebreak(state.tokens.curr);
      advance(&quot;;&quot;);
      if (state.tokens.next.id === &quot;;&quot;) {
        error(&quot;E021&quot;, state.tokens.next, &quot;)&quot;, &quot;;&quot;);
      }
      if (state.tokens.next.id !== &quot;)&quot;) {
        for (;;) {
          expression(0, &quot;for&quot;);
          if (state.tokens.next.id !== &quot;,&quot;) {
            break;
          }
          comma();
        }
      }
      advance(&quot;)&quot;, t);
      block(true, true);
      funct[&quot;(breakage)&quot;] -= 1;
      funct[&quot;(loopage)&quot;] -= 1;

    }
    // unstack loop blockscope
    if (letscope) {
      funct[&quot;(blockscope)&quot;].unstack();
    }
    return this;
  }).labelled = true;


  stmt(&quot;break&quot;, function () {
    var v = state.tokens.next.value;

    if (funct[&quot;(breakage)&quot;] === 0)
      warning(&quot;W052&quot;, state.tokens.next, this.value);

    if (!state.option.asi)
      nolinebreak(this);

    if (state.tokens.next.id !== &quot;;&quot; &amp;&amp; !state.tokens.next.reach) {
      if (state.tokens.curr.line === state.tokens.next.line) {
        if (funct[v] !== &quot;label&quot;) {
          warning(&quot;W090&quot;, state.tokens.next, v);
        } else if (scope[v] !== funct) {
          warning(&quot;W091&quot;, state.tokens.next, v);
        }
        this.first = state.tokens.next;
        advance();
      }
    }
    reachable(&quot;break&quot;);
    return this;
  }).exps = true;


  stmt(&quot;continue&quot;, function () {
    var v = state.tokens.next.value;

    if (funct[&quot;(breakage)&quot;] === 0)
      warning(&quot;W052&quot;, state.tokens.next, this.value);

    if (!state.option.asi)
      nolinebreak(this);

    if (state.tokens.next.id !== &quot;;&quot; &amp;&amp; !state.tokens.next.reach) {
      if (state.tokens.curr.line === state.tokens.next.line) {
        if (funct[v] !== &quot;label&quot;) {
          warning(&quot;W090&quot;, state.tokens.next, v);
        } else if (scope[v] !== funct) {
          warning(&quot;W091&quot;, state.tokens.next, v);
        }
        this.first = state.tokens.next;
        advance();
      }
    } else if (!funct[&quot;(loopage)&quot;]) {
      warning(&quot;W052&quot;, state.tokens.next, this.value);
    }
    reachable(&quot;continue&quot;);
    return this;
  }).exps = true;


  stmt(&quot;return&quot;, function () {
    if (this.line === state.tokens.next.line) {
      if (state.tokens.next.id !== &quot;;&quot; &amp;&amp; !state.tokens.next.reach) {
        this.first = expression(0);

        if (this.first &amp;&amp;
            this.first.type === &quot;(punctuator)&quot; &amp;&amp; this.first.value === &quot;=&quot; &amp;&amp;
            !this.first.paren &amp;&amp; !state.option.boss) {
          warningAt(&quot;W093&quot;, this.first.line, this.first.character);
        }
      }
    } else {
      if (state.tokens.next.type === &quot;(punctuator)&quot; &amp;&amp;
        [&quot;[&quot;, &quot;{&quot;, &quot;+&quot;, &quot;-&quot;].indexOf(state.tokens.next.value) &gt; -1) {
        nolinebreak(this); // always warn (Line breaking error)
      }
    }
    reachable(&quot;return&quot;);
    return this;
  }).exps = true;

  (function (x) {
    x.exps = true;
    x.lbp = 25;
  }(prefix(&quot;yield&quot;, function () {
    var prev = state.tokens.prev;
    if (state.option.inESNext(true) &amp;&amp; !funct[&quot;(generator)&quot;]) {
      // If it&#039;s a yield within a catch clause inside a generator then that&#039;s ok
      if (!(&quot;(catch)&quot; === funct[&quot;(name)&quot;] &amp;&amp; funct[&quot;(context)&quot;][&quot;(generator)&quot;])) {
        error(&quot;E046&quot;, state.tokens.curr, &quot;yield&quot;);
      }
    } else if (!state.option.inESNext()) {
      warning(&quot;W104&quot;, state.tokens.curr, &quot;yield&quot;);
    }
    funct[&quot;(generator)&quot;] = &quot;yielded&quot;;
    var delegatingYield = false;

    if (state.tokens.next.value === &quot;*&quot;) {
      delegatingYield = true;
      advance(&quot;*&quot;);
    }

    if (this.line === state.tokens.next.line || !state.option.inMoz(true)) {
      if (delegatingYield ||
          (state.tokens.next.id !== &quot;;&quot; &amp;&amp; !state.tokens.next.reach &amp;&amp; state.tokens.next.nud)) {

        nobreaknonadjacent(state.tokens.curr, state.tokens.next);
        this.first = expression(10);

        if (this.first.type === &quot;(punctuator)&quot; &amp;&amp; this.first.value === &quot;=&quot; &amp;&amp;
            !this.first.paren &amp;&amp; !state.option.boss) {
          warningAt(&quot;W093&quot;, this.first.line, this.first.character);
        }
      }

      if (state.option.inMoz(true) &amp;&amp; state.tokens.next.id !== &quot;)&quot; &amp;&amp;
          (prev.lbp &gt; 30 || (!prev.assign &amp;&amp; !isEndOfExpr()) || prev.id === &quot;yield&quot;)) {
        error(&quot;E050&quot;, this);
      }
    } else if (!state.option.asi) {
      nolinebreak(this); // always warn (Line breaking error)
    }
    return this;
  })));


  stmt(&quot;throw&quot;, function () {
    nolinebreak(this);
    this.first = expression(20);
    reachable(&quot;throw&quot;);
    return this;
  }).exps = true;

  stmt(&quot;import&quot;, function () {
    if (!state.option.inESNext()) {
      warning(&quot;W119&quot;, state.tokens.curr, &quot;import&quot;);
    }

    if (state.tokens.next.type === &quot;(string)&quot;) {
      // ModuleSpecifier :: StringLiteral
      advance(&quot;(string)&quot;);
      return this;
    }

    if (state.tokens.next.identifier) {
      // ImportClause :: ImportedDefaultBinding
      this.name = identifier();
      addlabel(this.name, { type: &quot;unused&quot;, token: state.tokens.curr });
    } else if (state.tokens.next.id === &quot;*&quot;) {
      // ImportClause :: NameSpaceImport
      advance(&quot;*&quot;);
      advance(&quot;as&quot;);
      if (state.tokens.next.identifier) {
        this.name = identifier();
        addlabel(this.name, { type: &quot;unused&quot;, token: state.tokens.curr });
      }
    } else {
      advance(&quot;{&quot;);
      for (;;) {
        if (state.tokens.next.value === &quot;}&quot;) {
          advance(&quot;}&quot;);
          break;
        }
        var importName;
        if (state.tokens.next.type === &quot;default&quot;) {
          importName = &quot;default&quot;;
          advance(&quot;default&quot;);
        } else {
          importName = identifier();
        }
        if (state.tokens.next.value === &quot;as&quot;) {
          advance(&quot;as&quot;);
          importName = identifier();
        }
        addlabel(importName, { type: &quot;unused&quot;, token: state.tokens.curr });

        if (state.tokens.next.value === &quot;,&quot;) {
          advance(&quot;,&quot;);
        } else if (state.tokens.next.value === &quot;}&quot;) {
          advance(&quot;}&quot;);
          break;
        } else {
          error(&quot;E024&quot;, state.tokens.next, state.tokens.next.value);
          break;
        }
      }
    }

    // FromClause
    advance(&quot;from&quot;);
    advance(&quot;(string)&quot;);
    return this;
  }).exps = true;

  stmt(&quot;export&quot;, function () {
    var ok = true;
    if (!state.option.inESNext()) {
      warning(&quot;W119&quot;, state.tokens.curr, &quot;export&quot;);
      ok = false;
    }

    if (!funct[&quot;(global)&quot;] || !funct[&quot;(blockscope)&quot;].atTop()) {
      error(&quot;E053&quot;, state.tokens.curr);
      ok = false;
    }

    if (state.tokens.next.value === &quot;*&quot;) {
      advance(&quot;*&quot;);
      advance(&quot;from&quot;);
      advance(&quot;(string)&quot;);
      return this;
    }

    if (state.tokens.next.type === &quot;default&quot;) {
      advance(&quot;default&quot;);
      if (state.tokens.next.id === &quot;function&quot; || state.tokens.next.id === &quot;class&quot;) {
        this.block = true;
      }
      this.exportee = expression(10);

      return this;
    }

    if (state.tokens.next.value === &quot;{&quot;) {
      advance(&quot;{&quot;);
      for (;;) {
        var id;
        exported[id = identifier(false, false, ok)] = ok;
        if (ok) {
          funct[&quot;(blockscope)&quot;].setExported(id);
        }

        if (state.tokens.next.value === &quot;,&quot;) {
          advance(&quot;,&quot;);
        } else if (state.tokens.next.value === &quot;}&quot;) {
          advance(&quot;}&quot;);
          break;
        } else {
          error(&quot;E024&quot;, state.tokens.next, state.tokens.next.value);
          break;
        }
      }
      return this;
    }

    if (state.tokens.next.id === &quot;var&quot;) {
      advance(&quot;var&quot;);
      exported[state.tokens.next.value] = ok;
      state.tokens.next.exported = true;
      state.syntax[&quot;var&quot;].fud.call(state.syntax[&quot;var&quot;].fud);
    } else if (state.tokens.next.id === &quot;let&quot;) {
      advance(&quot;let&quot;);
      exported[state.tokens.next.value] = ok;
      state.tokens.next.exported = true;
      state.syntax[&quot;let&quot;].fud.call(state.syntax[&quot;let&quot;].fud);
    } else if (state.tokens.next.id === &quot;const&quot;) {
      advance(&quot;const&quot;);
      exported[state.tokens.next.value] = ok;
      state.tokens.next.exported = true;
      state.syntax[&quot;const&quot;].fud.call(state.syntax[&quot;const&quot;].fud);
    } else if (state.tokens.next.id === &quot;function&quot;) {
      this.block = true;
      advance(&quot;function&quot;);
      exported[state.tokens.next.value] = ok;
      state.tokens.next.exported = true;
      state.syntax[&quot;function&quot;].fud();
    } else if (state.tokens.next.id === &quot;class&quot;) {
      this.block = true;
      advance(&quot;class&quot;);
      exported[state.tokens.next.value] = ok;
      state.tokens.next.exported = true;
      state.syntax[&quot;class&quot;].fud();
    } else {
      error(&quot;E024&quot;, state.tokens.next, state.tokens.next.value);
    }

    return this;
  }).exps = true;

  // Future Reserved Words

  FutureReservedWord(&quot;abstract&quot;);
  FutureReservedWord(&quot;boolean&quot;);
  FutureReservedWord(&quot;byte&quot;);
  FutureReservedWord(&quot;char&quot;);
  FutureReservedWord(&quot;class&quot;, { es5: true, nud: classdef });
  FutureReservedWord(&quot;double&quot;);
  FutureReservedWord(&quot;enum&quot;, { es5: true });
  FutureReservedWord(&quot;export&quot;, { es5: true });
  FutureReservedWord(&quot;extends&quot;, { es5: true });
  FutureReservedWord(&quot;final&quot;);
  FutureReservedWord(&quot;float&quot;);
  FutureReservedWord(&quot;goto&quot;);
  FutureReservedWord(&quot;implements&quot;, { es5: true, strictOnly: true });
  FutureReservedWord(&quot;import&quot;, { es5: true });
  FutureReservedWord(&quot;int&quot;);
  FutureReservedWord(&quot;interface&quot;, { es5: true, strictOnly: true });
  FutureReservedWord(&quot;long&quot;);
  FutureReservedWord(&quot;native&quot;);
  FutureReservedWord(&quot;package&quot;, { es5: true, strictOnly: true });
  FutureReservedWord(&quot;private&quot;, { es5: true, strictOnly: true });
  FutureReservedWord(&quot;protected&quot;, { es5: true, strictOnly: true });
  FutureReservedWord(&quot;public&quot;, { es5: true, strictOnly: true });
  FutureReservedWord(&quot;short&quot;);
  FutureReservedWord(&quot;static&quot;, { es5: true, strictOnly: true });
  FutureReservedWord(&quot;super&quot;, { es5: true });
  FutureReservedWord(&quot;synchronized&quot;);
  FutureReservedWord(&quot;transient&quot;);
  FutureReservedWord(&quot;volatile&quot;);

  // this function is used to determine whether a squarebracket or a curlybracket
  // expression is a comprehension array, destructuring assignment or a json value.

  var lookupBlockType = function () {
    var pn, pn1;
    var i = -1;
    var bracketStack = 0;
    var ret = {};
    if (checkPunctuators(state.tokens.curr, [&quot;[&quot;, &quot;{&quot;]))
      bracketStack += 1;
    do {
      pn = (i === -1) ? state.tokens.next : peek(i);
      pn1 = peek(i + 1);
      i = i + 1;
      if (checkPunctuators(pn, [&quot;[&quot;, &quot;{&quot;])) {
        bracketStack += 1;
      } else if (checkPunctuators(pn, [&quot;]&quot;, &quot;}&quot;])) {
        bracketStack -= 1;
      }
      if (pn.identifier &amp;&amp; pn.value === &quot;for&quot; &amp;&amp; bracketStack === 1) {
        ret.isCompArray = true;
        ret.notJson = true;
        break;
      }
      if (checkPunctuators(pn, [&quot;}&quot;, &quot;]&quot;]) &amp;&amp; bracketStack === 0) {
        if (pn1.value === &quot;=&quot;) {
          ret.isDestAssign = true;
          ret.notJson = true;
          break;
        } else if (pn1.value === &quot;.&quot;) {
          ret.notJson = true;
          break;
        }
      }
      if (pn.value === &quot;;&quot;) {
        ret.isBlock = true;
        ret.notJson = true;
      }
    } while (bracketStack &gt; 0 &amp;&amp; pn.id !== &quot;(end)&quot; &amp;&amp; i &lt; 15);
    return ret;
  };

  function saveProperty(props, name, tkn, isClass, isStatic) {
    var msg = [&quot;key&quot;, &quot;class method&quot;, &quot;static class method&quot;];
    msg = msg[(isClass || false) + (isStatic || false)];
    if (tkn.identifier) {
      name = tkn.value;
    }

    if (props[name] &amp;&amp; _.has(props, name)) {
      warning(&quot;W075&quot;, state.tokens.next, msg, name);
    } else {
      props[name] = {};
    }

    props[name].basic = true;
    props[name].basictkn = tkn;
  }

  function saveSetter(props, name, tkn, isClass, isStatic) {
    var msg = [&quot;key&quot;, &quot;setter method&quot;, &quot;static setter method&quot;];
    msg = msg[(isClass || false) + (isStatic || false)];
    if (props[name] &amp;&amp; _.has(props, name)) {
      if (props[name].basic || props[name].setter) {
        warning(&quot;W075&quot;, state.tokens.next, msg, name);
      }
    } else {
      props[name] = {};
    }

    props[name].setter = true;
    props[name].setterToken = tkn;
  }

  function saveGetter(props, name, isClass, isStatic) {
    var msg = [&quot;key&quot;, &quot;getter method&quot;, &quot;static getter method&quot;];
    msg = msg[(isClass || false) + (isStatic || false)];
    if (props[name] &amp;&amp; _.has(props, name)) {
      if (props[name].basic || props[name].getter) {
        warning(&quot;W075&quot;, state.tokens.next, msg, name);
      }
    } else {
      props[name] = {};
    }

    props[name].getter = true;
    props[name].getterToken = state.tokens.curr;
  }

  function computedPropertyName() {
    advance(&quot;[&quot;);
    if (!state.option.esnext) {
      warning(&quot;W119&quot;, state.tokens.curr, &quot;computed property names&quot;);
    }
    var value = expression(10);
    advance(&quot;]&quot;);
    return value;
  }

  // Test whether a given token is a punctuator matching one of the specified values
  function checkPunctuators(token, values) {
    return token.type === &quot;(punctuator)&quot; &amp;&amp; _.contains(values, token.value);
  }

  // Check whether this function has been reached for a destructuring assign with undeclared values
  function destructuringAssignOrJsonValue() {
    // lookup for the assignment (esnext only)
    // if it has semicolons, it is a block, so go parse it as a block
    // or it&#039;s not a block, but there are assignments, check for undeclared variables

    var block = lookupBlockType();
    if (block.notJson) {
      if (!state.option.inESNext() &amp;&amp; block.isDestAssign) {
        warning(&quot;W104&quot;, state.tokens.curr, &quot;destructuring assignment&quot;);
      }
      statements();
    // otherwise parse json value
    } else {
      state.option.laxbreak = true;
      state.jsonMode = true;
      jsonValue();
    }
  }

  // array comprehension parsing function
  // parses and defines the three states of the list comprehension in order
  // to avoid defining global variables, but keeping them to the list comprehension scope
  // only. The order of the states are as follows:
  //  * &quot;use&quot; which will be the returned iterative part of the list comprehension
  //  * &quot;define&quot; which will define the variables local to the list comprehension
  //  * &quot;filter&quot; which will help filter out values

  var arrayComprehension = function () {
    var CompArray = function () {
      this.mode = &quot;use&quot;;
      this.variables = [];
    };
    var _carrays = [];
    var _current;
    function declare(v) {
      var l = _current.variables.filter(function (elt) {
        // if it has, change its undef state
        if (elt.value === v) {
          elt.undef = false;
          return v;
        }
      }).length;
      return l !== 0;
    }
    function use(v) {
      var l = _current.variables.filter(function (elt) {
        // and if it has been defined
        if (elt.value === v &amp;&amp; !elt.undef) {
          if (elt.unused === true) {
            elt.unused = false;
          }
          return v;
        }
      }).length;
      // otherwise we warn about it
      return (l === 0);
    }
    return {stack: function () {
          _current = new CompArray();
          _carrays.push(_current);
        },
        unstack: function () {
          _current.variables.filter(function (v) {
            if (v.unused)
              warning(&quot;W098&quot;, v.token, v.raw_text || v.value);
            if (v.undef)
              isundef(v.funct, &quot;W117&quot;, v.token, v.value);
          });
          _carrays.splice(-1, 1);
          _current = _carrays[_carrays.length - 1];
        },
        setState: function (s) {
          if (_.contains([&quot;use&quot;, &quot;define&quot;, &quot;generate&quot;, &quot;filter&quot;], s))
            _current.mode = s;
        },
        check: function (v) {
          if (!_current) {
            return;
          }
          // When we are in &quot;use&quot; state of the list comp, we enqueue that var
          if (_current &amp;&amp; _current.mode === &quot;use&quot;) {
            if (use(v)) {
              _current.variables.push({
                funct: funct,
                token: state.tokens.curr,
                value: v,
                undef: true,
                unused: false
              });
            }
            return true;
          // When we are in &quot;define&quot; state of the list comp,
          } else if (_current &amp;&amp; _current.mode === &quot;define&quot;) {
            // check if the variable has been used previously
            if (!declare(v)) {
              _current.variables.push({
                funct: funct,
                token: state.tokens.curr,
                value: v,
                undef: false,
                unused: true
              });
            }
            return true;
          // When we are in the &quot;generate&quot; state of the list comp,
          } else if (_current &amp;&amp; _current.mode === &quot;generate&quot;) {
            isundef(funct, &quot;W117&quot;, state.tokens.curr, v);
            return true;
          // When we are in &quot;filter&quot; state,
          } else if (_current &amp;&amp; _current.mode === &quot;filter&quot;) {
            // we check whether current variable has been declared
            if (use(v)) {
              // if not we warn about it
              isundef(funct, &quot;W117&quot;, state.tokens.curr, v);
            }
            return true;
          }
          return false;
        }
        };
  };


  // Parse JSON

  function jsonValue() {
    function jsonObject() {
      var o = {}, t = state.tokens.next;
      advance(&quot;{&quot;);
      if (state.tokens.next.id !== &quot;}&quot;) {
        for (;;) {
          if (state.tokens.next.id === &quot;(end)&quot;) {
            error(&quot;E026&quot;, state.tokens.next, t.line);
          } else if (state.tokens.next.id === &quot;}&quot;) {
            warning(&quot;W094&quot;, state.tokens.curr);
            break;
          } else if (state.tokens.next.id === &quot;,&quot;) {
            error(&quot;E028&quot;, state.tokens.next);
          } else if (state.tokens.next.id !== &quot;(string)&quot;) {
            warning(&quot;W095&quot;, state.tokens.next, state.tokens.next.value);
          }
          if (o[state.tokens.next.value] === true) {
            warning(&quot;W075&quot;, state.tokens.next, state.tokens.next.value);
          } else if ((state.tokens.next.value === &quot;__proto__&quot; &amp;&amp;
            !state.option.proto) || (state.tokens.next.value === &quot;__iterator__&quot; &amp;&amp;
            !state.option.iterator)) {
            warning(&quot;W096&quot;, state.tokens.next, state.tokens.next.value);
          } else {
            o[state.tokens.next.value] = true;
          }
          advance();
          advance(&quot;:&quot;);
          jsonValue();
          if (state.tokens.next.id !== &quot;,&quot;) {
            break;
          }
          advance(&quot;,&quot;);
        }
      }
      advance(&quot;}&quot;);
    }

    function jsonArray() {
      var t = state.tokens.next;
      advance(&quot;[&quot;);
      if (state.tokens.next.id !== &quot;]&quot;) {
        for (;;) {
          if (state.tokens.next.id === &quot;(end)&quot;) {
            error(&quot;E027&quot;, state.tokens.next, t.line);
          } else if (state.tokens.next.id === &quot;]&quot;) {
            warning(&quot;W094&quot;, state.tokens.curr);
            break;
          } else if (state.tokens.next.id === &quot;,&quot;) {
            error(&quot;E028&quot;, state.tokens.next);
          }
          jsonValue();
          if (state.tokens.next.id !== &quot;,&quot;) {
            break;
          }
          advance(&quot;,&quot;);
        }
      }
      advance(&quot;]&quot;);
    }

    switch (state.tokens.next.id) {
    case &quot;{&quot;:
      jsonObject();
      break;
    case &quot;[&quot;:
      jsonArray();
      break;
    case &quot;true&quot;:
    case &quot;false&quot;:
    case &quot;null&quot;:
    case &quot;(number)&quot;:
    case &quot;(string)&quot;:
      advance();
      break;
    case &quot;-&quot;:
      advance(&quot;-&quot;);
      advance(&quot;(number)&quot;);
      break;
    default:
      error(&quot;E003&quot;, state.tokens.next);
    }
  }

  var blockScope = function () {
    var _current = {};
    var _variables = [_current];

    function _checkBlockLabels() {
      for (var t in _current) {
        if (_current[t][&quot;(type)&quot;] === &quot;unused&quot;) {
          if (state.option.unused) {
            var tkn = _current[t][&quot;(token)&quot;];
            // Don&#039;t report exported labels as unused
            if (tkn.exported) {
              continue;
            }
            var line = tkn.line;
            var chr  = tkn.character;
            warningAt(&quot;W098&quot;, line, chr, t);
          }
        }
      }
    }

    return {
      stack: function () {
        _current = {};
        _variables.push(_current);
      },

      unstack: function () {
        _checkBlockLabels();
        _variables.splice(_variables.length - 1, 1);
        _current = _.last(_variables);
      },

      getlabel: function (l) {
        for (var i = _variables.length - 1 ; i &gt;= 0; --i) {
          if (_.has(_variables[i], l) &amp;&amp; !_variables[i][l][&quot;(shadowed)&quot;]) {
            return _variables[i];
          }
        }
      },

      shadow: function (name) {
        for (var i = _variables.length - 1; i &gt;= 0; i--) {
          if (_.has(_variables[i], name)) {
            _variables[i][name][&quot;(shadowed)&quot;] = true;
          }
        }
      },

      unshadow: function (name) {
        for (var i = _variables.length - 1; i &gt;= 0; i--) {
          if (_.has(_variables[i], name)) {
            _variables[i][name][&quot;(shadowed)&quot;] = false;
          }
        }
      },

      atTop: function () {
        return _variables.length === 1;
      },

      setExported: function (id) {
        if (funct[&quot;(blockscope)&quot;].atTop()) {
          var item = _current[id];
          if (item &amp;&amp; item[&quot;(token)&quot;]) {
            item[&quot;(token)&quot;].exported = true;
          }
        }
      },

      current: {
        has: function (t) {
          return _.has(_current, t);
        },

        add: function (t, type, tok) {
          _current[t] = { &quot;(type)&quot; : type, &quot;(token)&quot;: tok, &quot;(shadowed)&quot;: false };
        }
      }
    };
  };

  var escapeRegex = function(str) {
    return str.replace(/[-\/\\^$*+?.()|[\]{}]/g, &quot;\\$&amp;&quot;);
  };

  // The actual JSHINT function itself.
  var itself = function (s, o, g) {
    var i, k, x, reIgnoreStr, reIgnore;
    var optionKeys;
    var newOptionObj = {};
    var newIgnoredObj = {};

    o = _.clone(o);
    state.reset();

    if (o &amp;&amp; o.scope) {
      JSHINT.scope = o.scope;
    } else {
      JSHINT.errors = [];
      JSHINT.undefs = [];
      JSHINT.internals = [];
      JSHINT.blacklist = {};
      JSHINT.scope = &quot;(main)&quot;;
    }

    predefined = Object.create(null);
    combine(predefined, vars.ecmaIdentifiers);
    combine(predefined, vars.reservedVars);

    combine(predefined, g || {});

    declared = Object.create(null);
    exported = Object.create(null);

    function each(obj, cb) {
      if (!obj)
        return;

      if (!Array.isArray(obj) &amp;&amp; typeof obj === &quot;object&quot;)
        obj = Object.keys(obj);

      obj.forEach(cb);
    }

    if (o) {
      each(o.predef || null, function (item) {
        var slice, prop;

        if (item[0] === &quot;-&quot;) {
          slice = item.slice(1);
          JSHINT.blacklist[slice] = slice;
          // remove from predefined if there
          delete predefined[slice];
        } else {
          prop = Object.getOwnPropertyDescriptor(o.predef, item);
          predefined[item] = prop ? prop.value : false;
        }
      });

      each(o.exported || null, function (item) {
        exported[item] = true;
      });

      delete o.predef;
      delete o.exported;

      optionKeys = Object.keys(o);
      for (x = 0; x &lt; optionKeys.length; x++) {
        if (/^-W\d{3}$/g.test(optionKeys[x])) {
          newIgnoredObj[optionKeys[x].slice(1)] = true;
        } else {
          newOptionObj[optionKeys[x]] = o[optionKeys[x]];

          if (optionKeys[x] === &quot;newcap&quot; &amp;&amp; o[optionKeys[x]] === false)
            newOptionObj[&quot;(explicitNewcap)&quot;] = true;
        }
      }
    }

    state.option = newOptionObj;
    state.ignored = newIgnoredObj;

    state.option.indent = state.option.indent || 4;
    state.option.maxerr = state.option.maxerr || 50;

    indent = 1;
    global = Object.create(predefined);
    scope = global;

    funct = functor(&quot;(global)&quot;, null, scope, {
      &quot;(global)&quot;    : true,
      &quot;(blockscope)&quot;: blockScope(),
      &quot;(comparray)&quot; : arrayComprehension(),
      &quot;(metrics)&quot;   : createMetrics(state.tokens.next)
    });

    functions = [funct];
    urls = [];
    stack = null;
    member = {};
    membersOnly = null;
    implied = {};
    inblock = false;
    lookahead = [];
    unuseds = [];

    if (!isString(s) &amp;&amp; !Array.isArray(s)) {
      errorAt(&quot;E004&quot;, 0);
      return false;
    }

    api = {
      get isJSON() {
        return state.jsonMode;
      },

      getOption: function (name) {
        return state.option[name] || null;
      },

      getCache: function (name) {
        return state.cache[name];
      },

      setCache: function (name, value) {
        state.cache[name] = value;
      },

      warn: function (code, data) {
        warningAt.apply(null, [ code, data.line, data.char ].concat(data.data));
      },

      on: function (names, listener) {
        names.split(&quot; &quot;).forEach(function (name) {
          emitter.on(name, listener);
        }.bind(this));
      }
    };

    emitter.removeAllListeners();
    (extraModules || []).forEach(function (func) {
      func(api);
    });

    state.tokens.prev = state.tokens.curr = state.tokens.next = state.syntax[&quot;(begin)&quot;];

    if (o &amp;&amp; o.ignoreDelimiters) {

      if (!Array.isArray(o.ignoreDelimiters)) {
        o.ignoreDelimiters = [o.ignoreDelimiters];
      }

      o.ignoreDelimiters.forEach(function (delimiterPair) {
        if (!delimiterPair.start || !delimiterPair.end)
            return;

        reIgnoreStr = escapeRegex(delimiterPair.start) +
                      &quot;[\\s\\S]*?&quot; +
                      escapeRegex(delimiterPair.end);

        reIgnore = new RegExp(reIgnoreStr, &quot;ig&quot;);

        s = s.replace(reIgnore, function(match) {
          return match.replace(/./g, &quot; &quot;);
        });
      });
    }

    lex = new Lexer(s);

    lex.on(&quot;warning&quot;, function (ev) {
      warningAt.apply(null, [ ev.code, ev.line, ev.character].concat(ev.data));
    });

    lex.on(&quot;error&quot;, function (ev) {
      errorAt.apply(null, [ ev.code, ev.line, ev.character ].concat(ev.data));
    });

    lex.on(&quot;fatal&quot;, function (ev) {
      quit(&quot;E041&quot;, ev.line, ev.from);
    });

    lex.on(&quot;Identifier&quot;, function (ev) {
      emitter.emit(&quot;Identifier&quot;, ev);
    });

    lex.on(&quot;String&quot;, function (ev) {
      emitter.emit(&quot;String&quot;, ev);
    });

    lex.on(&quot;Number&quot;, function (ev) {
      emitter.emit(&quot;Number&quot;, ev);
    });

    lex.start();

    // Check options
    for (var name in o) {
      if (_.has(o, name)) {
        checkOption(name, state.tokens.curr);
      }
    }

    assume();

    // combine the passed globals after we&#039;ve assumed all our options
    combine(predefined, g || {});

    //reset values
    comma.first = true;

    try {
      advance();
      switch (state.tokens.next.id) {
      case &quot;{&quot;:
      case &quot;[&quot;:
        destructuringAssignOrJsonValue();
        break;
      default:
        directives();

        if (state.directive[&quot;use strict&quot;]) {
          if (!state.option.globalstrict) {
            if (!(state.option.node || state.option.phantom || state.option.browserify)) {
              warning(&quot;W097&quot;, state.tokens.prev);
            }
          }
        }

        statements();
      }
      advance((state.tokens.next &amp;&amp; state.tokens.next.value !== &quot;.&quot;)  ? &quot;(end)&quot; : undefined);
      funct[&quot;(blockscope)&quot;].unstack();

      var markDefined = function (name, context) {
        do {
          if (typeof context[name] === &quot;string&quot;) {
            // JSHINT marks unused variables as &#039;unused&#039; and
            // unused function declaration as &#039;unction&#039;. This
            // code changes such instances back &#039;var&#039; and
            // &#039;closure&#039; so that the code in JSHINT.data()
            // doesn&#039;t think they&#039;re unused.

            if (context[name] === &quot;unused&quot;)
              context[name] = &quot;var&quot;;
            else if (context[name] === &quot;unction&quot;)
              context[name] = &quot;closure&quot;;

            return true;
          }

          context = context[&quot;(context)&quot;];
        } while (context);

        return false;
      };

      var clearImplied = function (name, line) {
        if (!implied[name])
          return;

        var newImplied = [];
        for (var i = 0; i &lt; implied[name].length; i += 1) {
          if (implied[name][i] !== line)
            newImplied.push(implied[name][i]);
        }

        if (newImplied.length === 0)
          delete implied[name];
        else
          implied[name] = newImplied;
      };

      var warnUnused = function (name, tkn, type, unused_opt) {
        var line = tkn.line;
        var chr  = tkn.from;
        var raw_name = tkn.raw_text || name;

        if (unused_opt === undefined) {
          unused_opt = state.option.unused;
        }

        if (unused_opt === true) {
          unused_opt = &quot;last-param&quot;;
        }

        var warnable_types = {
          &quot;vars&quot;: [&quot;var&quot;],
          &quot;last-param&quot;: [&quot;var&quot;, &quot;param&quot;],
          &quot;strict&quot;: [&quot;var&quot;, &quot;param&quot;, &quot;last-param&quot;]
        };

        if (unused_opt) {
          if (warnable_types[unused_opt] &amp;&amp; warnable_types[unused_opt].indexOf(type) !== -1) {
            if (!tkn.exported) {
              warningAt(&quot;W098&quot;, line, chr, raw_name);
            }
          }
        }

        unuseds.push({
          name: name,
          line: line,
          character: chr
        });
      };

      var checkUnused = function (func, key) {
        var type = func[key];
        var tkn = func[&quot;(tokens)&quot;][key];

        if (key.charAt(0) === &quot;(&quot;)
          return;

        if (type !== &quot;unused&quot; &amp;&amp; type !== &quot;unction&quot; &amp;&amp; type !== &quot;const&quot;)
          return;

        // Params are checked separately from other variables.
        if (func[&quot;(params)&quot;] &amp;&amp; func[&quot;(params)&quot;].indexOf(key) !== -1)
          return;

        // Variable is in global scope and defined as exported.
        if (func[&quot;(global)&quot;] &amp;&amp; _.has(exported, key))
          return;

        // Is this constant unused?
        if (type === &quot;const&quot; &amp;&amp; !getprop(func, key, &quot;unused&quot;))
          return;

        warnUnused(key, tkn, &quot;var&quot;);
      };

      // Check queued &#039;x is not defined&#039; instances to see if they&#039;re still undefined.
      for (i = 0; i &lt; JSHINT.undefs.length; i += 1) {
        k = JSHINT.undefs[i].slice(0);

        if (markDefined(k[2].value, k[0])) {
          clearImplied(k[2].value, k[2].line);
        } else if (state.option.undef) {
          warning.apply(warning, k.slice(1));
        }
      }

      functions.forEach(function (func) {
        if (func[&quot;(unusedOption)&quot;] === false) {
          return;
        }

        for (var key in func) {
          if (_.has(func, key)) {
            checkUnused(func, key);
          }
        }

        if (!func[&quot;(params)&quot;])
          return;

        var params = func[&quot;(params)&quot;].slice();
        var param  = params.pop();
        var type, unused_opt;

        while (param) {
          type = func[param];
          unused_opt = func[&quot;(unusedOption)&quot;] || state.option.unused;
          unused_opt = unused_opt === true ? &quot;last-param&quot; : unused_opt;

          // &#039;undefined&#039; is a special case for (function (window, undefined) { ... })();
          // patterns.

          if (param === &quot;undefined&quot;)
            return;

          if (type === &quot;unused&quot; || type === &quot;unction&quot;) {
            warnUnused(param, func[&quot;(tokens)&quot;][param], &quot;param&quot;, func[&quot;(unusedOption)&quot;]);
          } else if (unused_opt === &quot;last-param&quot;) {
            return;
          }

          param = params.pop();
        }
      });

      for (var key in declared) {
        if (_.has(declared, key) &amp;&amp; !_.has(global, key) &amp;&amp; !_.has(exported, key)) {
          warnUnused(key, declared[key], &quot;var&quot;);
        }
      }

    } catch (err) {
      if (err &amp;&amp; err.name === &quot;JSHintError&quot;) {
        var nt = state.tokens.next || {};
        JSHINT.errors.push({
          scope     : &quot;(main)&quot;,
          raw       : err.raw,
          code      : err.code,
          reason    : err.message,
          line      : err.line || nt.line,
          character : err.character || nt.from
        }, null);
      } else {
        throw err;
      }
    }

    // Loop over the listed &quot;internals&quot;, and check them as well.

    if (JSHINT.scope === &quot;(main)&quot;) {
      o = o || {};

      for (i = 0; i &lt; JSHINT.internals.length; i += 1) {
        k = JSHINT.internals[i];
        o.scope = k.elem;
        itself(k.value, o, g);
      }
    }

    return JSHINT.errors.length === 0;
  };

  // Modules.
  itself.addModule = function (func) {
    extraModules.push(func);
  };

  itself.addModule(style.register);

  // Data summary.
  itself.data = function () {
    var data = {
      functions: [],
      options: state.option
    };

    var implieds = [];
    var members = [];
    var fu, f, i, j, n, globals;

    if (itself.errors.length) {
      data.errors = itself.errors;
    }

    if (state.jsonMode) {
      data.json = true;
    }

    for (n in implied) {
      if (_.has(implied, n)) {
        implieds.push({
          name: n,
          line: implied[n]
        });
      }
    }

    if (implieds.length &gt; 0) {
      data.implieds = implieds;
    }

    if (urls.length &gt; 0) {
      data.urls = urls;
    }

    globals = Object.keys(scope);
    if (globals.length &gt; 0) {
      data.globals = globals;
    }

    for (i = 1; i &lt; functions.length; i += 1) {
      f = functions[i];
      fu = {};

      for (j = 0; j &lt; functionicity.length; j += 1) {
        fu[functionicity[j]] = [];
      }

      for (j = 0; j &lt; functionicity.length; j += 1) {
        if (fu[functionicity[j]].length === 0) {
          delete fu[functionicity[j]];
        }
      }

      fu.name = f[&quot;(name)&quot;];
      fu.param = f[&quot;(params)&quot;];
      fu.line = f[&quot;(line)&quot;];
      fu.character = f[&quot;(character)&quot;];
      fu.last = f[&quot;(last)&quot;];
      fu.lastcharacter = f[&quot;(lastcharacter)&quot;];

      fu.metrics = {
        complexity: f[&quot;(metrics)&quot;].ComplexityCount,
        parameters: (f[&quot;(params)&quot;] || []).length,
        statements: f[&quot;(metrics)&quot;].statementCount
      };

      data.functions.push(fu);
    }

    if (unuseds.length &gt; 0) {
      data.unused = unuseds;
    }

    members = [];
    for (n in member) {
      if (typeof member[n] === &quot;number&quot;) {
        data.member = member;
        break;
      }
    }

    return data;
  };

  itself.jshint = itself;

  return itself;
}());

// Make JSHINT a Node module, if possible.
if (typeof exports === &quot;object&quot; &amp;&amp; exports) {
  exports.JSHINT = JSHINT;
}</textarea>
  </div>
</div>

<footer class="footer">
  <div class="container">
    <p>.</p>
  </div>
</footer>

<script type="text/html" id="complexity-popover-template">
  <div class="complexity-notice">
    Complexity : {{ complexity.cyclomatic }} <br>
    Length : {{ complexity.halstead.length }} <br>
    Difficulty : {{ complexity.halstead.difficulty.toFixed(2) }} <br>
    Est # bugs : {{ complexity.halstead.bugs.toFixed(2) }}<br>
  </div>
</script>

<script type="text/javascript" src="../../assets/scripts/bundles/core-bundle.js"></script>
<script type="text/javascript" src="../../assets/scripts/bundles/codemirror.js"></script>
<script type="text/javascript" src="../../assets/scripts/codemirror.markpopovertext.js"></script>
<script type="text/javascript" src="report.js"></script>
<script type="text/javascript" src="report.history.js"></script>
<script type="text/javascript" src="../../assets/scripts/plato-file.js"></script>
</body>
</html>
