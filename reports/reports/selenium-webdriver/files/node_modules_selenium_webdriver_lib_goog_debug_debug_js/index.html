<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Plato - node_modules/selenium-webdriver/lib/goog/debug/debug.js</title>

  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="">
  <meta name="author" content="">

  <!--[if lt IE 9]>
  <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->

  <link href="../../assets/css/vendor/morris.css" rel="stylesheet">
  <link href="../../assets/css/vendor/bootstrap.css" rel="stylesheet">
  <link href="../../assets/css/vendor/font-awesome.css" rel="stylesheet">
  <link href="../../assets/css/vendor/codemirror.css" rel="stylesheet">
  <link href="../../assets/css/plato.css" rel="stylesheet">
  <link href="../../assets/css/plato-file.css" rel="stylesheet">

</head>

<body>

<div class="navbar navbar-fixed-top">
  <div class="container">
    <a class="navbar-brand" href="http://github.com/es-analysis/plato">Plato on Github</a>
    <ul class="nav navbar-nav">
      <li>
        <a href="../../index.html">Report Home</a>
      </li>
    </ul>
  </div>
</div>

<div class="jumbotron">
  <div class="container">
    <h1>node_modules/selenium-webdriver/lib/goog/debug/debug.js</h1>
  </div>
</div>

<div class="container aggregate-stats">
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Maintainability <a href="http://blogs.msdn.com/b/codeanalysis/archive/2007/11/20/maintainability-index-range-and-meaning.aspx"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="A value between 0 and 100 that represents the relative ease of maintaining the code. A high value means better maintainability." data-original-title="Maintainability Index"  data-container="body"></i></a></h2>
      <p class="stat">57.13</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Lines of code <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h2>
      <p class="stat">570</p>
    </div>
  </div>
  <div class="row historical">
    <div class="col-md-6">
      <p id="chart_historical_maint" class="chart"></p>
    </div>
    <div class="col-md-6">
      <p id="chart_historical_sloc" class="chart"></p>
    </div>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Difficulty  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="The difficulty measure is related to the difficulty of the program to write or understand." data-original-title="Difficulty" data-container="body"></i></a></h2>
      <p class="stat">72.43</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Estimated Errors  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Halstead's delivered bugs is an estimate for the number of errors in the implementation." data-original-title="Delivered Bugs" data-container="body"></i></a></h2>
      <p class="stat">3.80</p>
    </div>
  </div>
</div>

<div class="container charts">
  <div class="row">
    <h2 class="header">Function weight</h2>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h3 class="chart-header">By Complexity <a href="http://en.wikipedia.org/wiki/Cyclomatic_complexity"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="This metric counts the number of distinct paths through a block of code. Lower values are better." data-original-title="Cyclomatic Complexity" data-container="body"></i></a></h3>
      <div id="fn-by-complexity" class="stat"></div>
    </div>
    <div class="col-md-6">
      <h3 class="chart-header">By SLOC  <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h3>
      <div id="fn-by-sloc" class="stat"></div>
    </div>
  </div>
</div>

<div class="container">
  <div class="row">
    <textarea id="file-source" class="col-md-12">// Copyright 2006 The Closure Library Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an &quot;AS-IS&quot; BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/**
 * @fileoverview Logging and debugging utilities.
 *
 * @see ../demos/debug.html
 */

goog.provide(&#039;goog.debug&#039;);

goog.require(&#039;goog.array&#039;);
goog.require(&#039;goog.string&#039;);
goog.require(&#039;goog.structs.Set&#039;);
goog.require(&#039;goog.userAgent&#039;);


/** @define {boolean} Whether logging should be enabled. */
goog.define(&#039;goog.debug.LOGGING_ENABLED&#039;, goog.DEBUG);


/**
 * Catches onerror events fired by windows and similar objects.
 * @param {function(Object)} logFunc The function to call with the error
 *    information.
 * @param {boolean=} opt_cancel Whether to stop the error from reaching the
 *    browser.
 * @param {Object=} opt_target Object that fires onerror events.
 */
goog.debug.catchErrors = function(logFunc, opt_cancel, opt_target) {
  var target = opt_target || goog.global;
  var oldErrorHandler = target.onerror;
  var retVal = !!opt_cancel;

  // Chrome interprets onerror return value backwards (http://crbug.com/92062)
  // until it was fixed in webkit revision r94061 (Webkit 535.3). This
  // workaround still needs to be skipped in Safari after the webkit change
  // gets pushed out in Safari.
  // See https://bugs.webkit.org/show_bug.cgi?id=67119
  if (goog.userAgent.WEBKIT &amp;&amp;
      !goog.userAgent.isVersionOrHigher(&#039;535.3&#039;)) {
    retVal = !retVal;
  }

  /**
   * New onerror handler for this target. This onerror handler follows the spec
   * according to
   * http://www.whatwg.org/specs/web-apps/current-work/#runtime-script-errors
   * The spec was changed in August 2013 to support receiving column information
   * and an error object for all scripts on the same origin or cross origin
   * scripts with the proper headers. See
   * https://mikewest.org/2013/08/debugging-runtime-errors-with-window-onerror
   *
   * @param {string} message The error message. For cross-origin errors, this
   *     will be scrubbed to just &quot;Script error.&quot;. For new browsers that have
   *     updated to follow the latest spec, errors that come from origins that
   *     have proper cross origin headers will not be scrubbed.
   * @param {string} url The URL of the script that caused the error. The URL
   *     will be scrubbed to &quot;&quot; for cross origin scripts unless the script has
   *     proper cross origin headers and the browser has updated to the latest
   *     spec.
   * @param {number} line The line number in the script that the error
   *     occurred on.
   * @param {number=} opt_col The optional column number that the error
   *     occurred on. Only browsers that have updated to the latest spec will
   *     include this.
   * @param {Error=} opt_error The optional actual error object for this
   *     error that should include the stack. Only browsers that have updated
   *     to the latest spec will inlude this parameter.
   * @return {boolean} Whether to prevent the error from reaching the browser.
   */
  target.onerror = function(message, url, line, opt_col, opt_error) {
    if (oldErrorHandler) {
      oldErrorHandler(message, url, line, opt_col, opt_error);
    }
    logFunc({
      message: message,
      fileName: url,
      line: line,
      col: opt_col,
      error: opt_error
    });
    return retVal;
  };
};


/**
 * Creates a string representing an object and all its properties.
 * @param {Object|null|undefined} obj Object to expose.
 * @param {boolean=} opt_showFn Show the functions as well as the properties,
 *     default is false.
 * @return {string} The string representation of {@code obj}.
 */
goog.debug.expose = function(obj, opt_showFn) {
  if (typeof obj == &#039;undefined&#039;) {
    return &#039;undefined&#039;;
  }
  if (obj == null) {
    return &#039;NULL&#039;;
  }
  var str = [];

  for (var x in obj) {
    if (!opt_showFn &amp;&amp; goog.isFunction(obj[x])) {
      continue;
    }
    var s = x + &#039; = &#039;;
    /** @preserveTry */
    try {
      s += obj[x];
    } catch (e) {
      s += &#039;*** &#039; + e + &#039; ***&#039;;
    }
    str.push(s);
  }
  return str.join(&#039;\n&#039;);
};


/**
 * Creates a string representing a given primitive or object, and for an
 * object, all its properties and nested objects.  WARNING: If an object is
 * given, it and all its nested objects will be modified.  To detect reference
 * cycles, this method identifies objects using goog.getUid() which mutates the
 * object.
 * @param {*} obj Object to expose.
 * @param {boolean=} opt_showFn Also show properties that are functions (by
 *     default, functions are omitted).
 * @return {string} A string representation of {@code obj}.
 */
goog.debug.deepExpose = function(obj, opt_showFn) {
  var str = [];

  var helper = function(obj, space, parentSeen) {
    var nestspace = space + &#039;  &#039;;
    var seen = new goog.structs.Set(parentSeen);

    var indentMultiline = function(str) {
      return str.replace(/\n/g, &#039;\n&#039; + space);
    };

    /** @preserveTry */
    try {
      if (!goog.isDef(obj)) {
        str.push(&#039;undefined&#039;);
      } else if (goog.isNull(obj)) {
        str.push(&#039;NULL&#039;);
      } else if (goog.isString(obj)) {
        str.push(&#039;&quot;&#039; + indentMultiline(obj) + &#039;&quot;&#039;);
      } else if (goog.isFunction(obj)) {
        str.push(indentMultiline(String(obj)));
      } else if (goog.isObject(obj)) {
        if (seen.contains(obj)) {
          str.push(&#039;*** reference loop detected ***&#039;);
        } else {
          seen.add(obj);
          str.push(&#039;{&#039;);
          for (var x in obj) {
            if (!opt_showFn &amp;&amp; goog.isFunction(obj[x])) {
              continue;
            }
            str.push(&#039;\n&#039;);
            str.push(nestspace);
            str.push(x + &#039; = &#039;);
            helper(obj[x], nestspace, seen);
          }
          str.push(&#039;\n&#039; + space + &#039;}&#039;);
        }
      } else {
        str.push(obj);
      }
    } catch (e) {
      str.push(&#039;*** &#039; + e + &#039; ***&#039;);
    }
  };

  helper(obj, &#039;&#039;, new goog.structs.Set());
  return str.join(&#039;&#039;);
};


/**
 * Recursively outputs a nested array as a string.
 * @param {Array} arr The array.
 * @return {string} String representing nested array.
 */
goog.debug.exposeArray = function(arr) {
  var str = [];
  for (var i = 0; i &lt; arr.length; i++) {
    if (goog.isArray(arr[i])) {
      str.push(goog.debug.exposeArray(arr[i]));
    } else {
      str.push(arr[i]);
    }
  }
  return &#039;[ &#039; + str.join(&#039;, &#039;) + &#039; ]&#039;;
};


/**
 * Exposes an exception that has been caught by a try...catch and outputs the
 * error with a stack trace.
 * @param {Object} err Error object or string.
 * @param {Function=} opt_fn Optional function to start stack trace from.
 * @return {string} Details of exception.
 */
goog.debug.exposeException = function(err, opt_fn) {
  /** @preserveTry */
  try {
    var e = goog.debug.normalizeErrorObject(err);

    // Create the error message
    var error = &#039;Message: &#039; + goog.string.htmlEscape(e.message) +
        &#039;\nUrl: &lt;a href=&quot;view-source:&#039; + e.fileName + &#039;&quot; target=&quot;_new&quot;&gt;&#039; +
        e.fileName + &#039;&lt;/a&gt;\nLine: &#039; + e.lineNumber + &#039;\n\nBrowser stack:\n&#039; +
        goog.string.htmlEscape(e.stack + &#039;-&gt; &#039;) +
        &#039;[end]\n\nJS stack traversal:\n&#039; + goog.string.htmlEscape(
            goog.debug.getStacktrace(opt_fn) + &#039;-&gt; &#039;);
    return error;
  } catch (e2) {
    return &#039;Exception trying to expose exception! You win, we lose. &#039; + e2;
  }
};


/**
 * Normalizes the error/exception object between browsers.
 * @param {Object} err Raw error object.
 * @return {!Object} Normalized error object.
 */
goog.debug.normalizeErrorObject = function(err) {
  var href = goog.getObjectByName(&#039;window.location.href&#039;);
  if (goog.isString(err)) {
    return {
      &#039;message&#039;: err,
      &#039;name&#039;: &#039;Unknown error&#039;,
      &#039;lineNumber&#039;: &#039;Not available&#039;,
      &#039;fileName&#039;: href,
      &#039;stack&#039;: &#039;Not available&#039;
    };
  }

  var lineNumber, fileName;
  var threwError = false;

  try {
    lineNumber = err.lineNumber || err.line || &#039;Not available&#039;;
  } catch (e) {
    // Firefox 2 sometimes throws an error when accessing &#039;lineNumber&#039;:
    // Message: Permission denied to get property UnnamedClass.lineNumber
    lineNumber = &#039;Not available&#039;;
    threwError = true;
  }

  try {
    fileName = err.fileName || err.filename || err.sourceURL ||
        // $googDebugFname may be set before a call to eval to set the filename
        // that the eval is supposed to present.
        goog.global[&#039;$googDebugFname&#039;] || href;
  } catch (e) {
    // Firefox 2 may also throw an error when accessing &#039;filename&#039;.
    fileName = &#039;Not available&#039;;
    threwError = true;
  }

  // The IE Error object contains only the name and the message.
  // The Safari Error object uses the line and sourceURL fields.
  if (threwError || !err.lineNumber || !err.fileName || !err.stack ||
      !err.message || !err.name) {
    return {
      &#039;message&#039;: err.message || &#039;Not available&#039;,
      &#039;name&#039;: err.name || &#039;UnknownError&#039;,
      &#039;lineNumber&#039;: lineNumber,
      &#039;fileName&#039;: fileName,
      &#039;stack&#039;: err.stack || &#039;Not available&#039;
    };
  }

  // Standards error object
  return err;
};


/**
 * Converts an object to an Error if it&#039;s a String,
 * adds a stacktrace if there isn&#039;t one,
 * and optionally adds an extra message.
 * @param {Error|string} err  the original thrown object or string.
 * @param {string=} opt_message  optional additional message to add to the
 *     error.
 * @return {!Error} If err is a string, it is used to create a new Error,
 *     which is enhanced and returned.  Otherwise err itself is enhanced
 *     and returned.
 */
goog.debug.enhanceError = function(err, opt_message) {
  var error;
  if (typeof err == &#039;string&#039;) {
    error = Error(err);
    if (Error.captureStackTrace) {
      // Trim this function off the call stack, if we can.
      Error.captureStackTrace(error, goog.debug.enhanceError);
    }
  } else {
    error = err;
  }

  if (!error.stack) {
    error.stack = goog.debug.getStacktrace(goog.debug.enhanceError);
  }
  if (opt_message) {
    // find the first unoccupied &#039;messageX&#039; property
    var x = 0;
    while (error[&#039;message&#039; + x]) {
      ++x;
    }
    error[&#039;message&#039; + x] = String(opt_message);
  }
  return error;
};


/**
 * Gets the current stack trace. Simple and iterative - doesn&#039;t worry about
 * catching circular references or getting the args.
 * @param {number=} opt_depth Optional maximum depth to trace back to.
 * @return {string} A string with the function names of all functions in the
 *     stack, separated by \n.
 * @suppress {es5Strict}
 */
goog.debug.getStacktraceSimple = function(opt_depth) {
  if (goog.STRICT_MODE_COMPATIBLE) {
    var stack = goog.debug.getNativeStackTrace_(goog.debug.getStacktraceSimple);
    if (stack) {
      return stack;
    }
    // NOTE: browsers that have strict mode support also have native &quot;stack&quot;
    // properties.  Fall-through for legacy browser support.
  }

  var sb = [];
  var fn = arguments.callee.caller;
  var depth = 0;

  while (fn &amp;&amp; (!opt_depth || depth &lt; opt_depth)) {
    sb.push(goog.debug.getFunctionName(fn));
    sb.push(&#039;()\n&#039;);
    /** @preserveTry */
    try {
      fn = fn.caller;
    } catch (e) {
      sb.push(&#039;[exception trying to get caller]\n&#039;);
      break;
    }
    depth++;
    if (depth &gt;= goog.debug.MAX_STACK_DEPTH) {
      sb.push(&#039;[...long stack...]&#039;);
      break;
    }
  }
  if (opt_depth &amp;&amp; depth &gt;= opt_depth) {
    sb.push(&#039;[...reached max depth limit...]&#039;);
  } else {
    sb.push(&#039;[end]&#039;);
  }

  return sb.join(&#039;&#039;);
};


/**
 * Max length of stack to try and output
 * @type {number}
 */
goog.debug.MAX_STACK_DEPTH = 50;


/**
 * @param {Function} fn The function to start getting the trace from.
 * @return {?string}
 * @private
 */
goog.debug.getNativeStackTrace_ = function(fn) {
  var tempErr = new Error();
  if (Error.captureStackTrace) {
    Error.captureStackTrace(tempErr, fn);
    return String(tempErr.stack);
  } else {
    // IE10, only adds stack traces when an exception is thrown.
    try {
      throw tempErr;
    } catch (e) {
      tempErr = e;
    }
    var stack = tempErr.stack;
    if (stack) {
      return String(stack);
    }
  }
  return null;
};


/**
 * Gets the current stack trace, either starting from the caller or starting
 * from a specified function that&#039;s currently on the call stack.
 * @param {Function=} opt_fn Optional function to start getting the trace from.
 *     If not provided, defaults to the function that called this.
 * @return {string} Stack trace.
 * @suppress {es5Strict}
 */
goog.debug.getStacktrace = function(opt_fn) {
  var stack;
  if (goog.STRICT_MODE_COMPATIBLE) {
    // Try to get the stack trace from the environment if it is available.
    var contextFn = opt_fn || goog.debug.getStacktrace;
    stack = goog.debug.getNativeStackTrace_(contextFn);
  }
  if (!stack) {
    // NOTE: browsers that have strict mode support also have native &quot;stack&quot;
    // properties. This function will throw in strict mode.
    stack = goog.debug.getStacktraceHelper_(
        opt_fn || arguments.callee.caller, []);
  }
  return stack;
};


/**
 * Private helper for getStacktrace().
 * @param {Function} fn Function to start getting the trace from.
 * @param {Array} visited List of functions visited so far.
 * @return {string} Stack trace starting from function fn.
 * @suppress {es5Strict}
 * @private
 */
goog.debug.getStacktraceHelper_ = function(fn, visited) {
  var sb = [];

  // Circular reference, certain functions like bind seem to cause a recursive
  // loop so we need to catch circular references
  if (goog.array.contains(visited, fn)) {
    sb.push(&#039;[...circular reference...]&#039;);

  // Traverse the call stack until function not found or max depth is reached
  } else if (fn &amp;&amp; visited.length &lt; goog.debug.MAX_STACK_DEPTH) {
    sb.push(goog.debug.getFunctionName(fn) + &#039;(&#039;);
    var args = fn.arguments;
    // Args may be null for some special functions such as host objects or eval.
    for (var i = 0; args &amp;&amp; i &lt; args.length; i++) {
      if (i &gt; 0) {
        sb.push(&#039;, &#039;);
      }
      var argDesc;
      var arg = args[i];
      switch (typeof arg) {
        case &#039;object&#039;:
          argDesc = arg ? &#039;object&#039; : &#039;null&#039;;
          break;

        case &#039;string&#039;:
          argDesc = arg;
          break;

        case &#039;number&#039;:
          argDesc = String(arg);
          break;

        case &#039;boolean&#039;:
          argDesc = arg ? &#039;true&#039; : &#039;false&#039;;
          break;

        case &#039;function&#039;:
          argDesc = goog.debug.getFunctionName(arg);
          argDesc = argDesc ? argDesc : &#039;[fn]&#039;;
          break;

        case &#039;undefined&#039;:
        default:
          argDesc = typeof arg;
          break;
      }

      if (argDesc.length &gt; 40) {
        argDesc = argDesc.substr(0, 40) + &#039;...&#039;;
      }
      sb.push(argDesc);
    }
    visited.push(fn);
    sb.push(&#039;)\n&#039;);
    /** @preserveTry */
    try {
      sb.push(goog.debug.getStacktraceHelper_(fn.caller, visited));
    } catch (e) {
      sb.push(&#039;[exception trying to get caller]\n&#039;);
    }

  } else if (fn) {
    sb.push(&#039;[...long stack...]&#039;);
  } else {
    sb.push(&#039;[end]&#039;);
  }
  return sb.join(&#039;&#039;);
};


/**
 * Set a custom function name resolver.
 * @param {function(Function): string} resolver Resolves functions to their
 *     names.
 */
goog.debug.setFunctionResolver = function(resolver) {
  goog.debug.fnNameResolver_ = resolver;
};


/**
 * Gets a function name
 * @param {Function} fn Function to get name of.
 * @return {string} Function&#039;s name.
 */
goog.debug.getFunctionName = function(fn) {
  if (goog.debug.fnNameCache_[fn]) {
    return goog.debug.fnNameCache_[fn];
  }
  if (goog.debug.fnNameResolver_) {
    var name = goog.debug.fnNameResolver_(fn);
    if (name) {
      goog.debug.fnNameCache_[fn] = name;
      return name;
    }
  }

  // Heuristically determine function name based on code.
  var functionSource = String(fn);
  if (!goog.debug.fnNameCache_[functionSource]) {
    var matches = /function ([^\(]+)/.exec(functionSource);
    if (matches) {
      var method = matches[1];
      goog.debug.fnNameCache_[functionSource] = method;
    } else {
      goog.debug.fnNameCache_[functionSource] = &#039;[Anonymous]&#039;;
    }
  }

  return goog.debug.fnNameCache_[functionSource];
};


/**
 * Makes whitespace visible by replacing it with printable characters.
 * This is useful in finding diffrences between the expected and the actual
 * output strings of a testcase.
 * @param {string} string whose whitespace needs to be made visible.
 * @return {string} string whose whitespace is made visible.
 */
goog.debug.makeWhitespaceVisible = function(string) {
  return string.replace(/ /g, &#039;[_]&#039;)
      .replace(/\f/g, &#039;[f]&#039;)
      .replace(/\n/g, &#039;[n]\n&#039;)
      .replace(/\r/g, &#039;[r]&#039;)
      .replace(/\t/g, &#039;[t]&#039;);
};


/**
 * Hash map for storing function names that have already been looked up.
 * @type {Object}
 * @private
 */
goog.debug.fnNameCache_ = {};


/**
 * Resolves functions to their names.  Resolved function names will be cached.
 * @type {function(Function):string}
 * @private
 */
goog.debug.fnNameResolver_;</textarea>
  </div>
</div>

<footer class="footer">
  <div class="container">
    <p>.</p>
  </div>
</footer>

<script type="text/html" id="complexity-popover-template">
  <div class="complexity-notice">
    Complexity : {{ complexity.cyclomatic }} <br>
    Length : {{ complexity.halstead.length }} <br>
    Difficulty : {{ complexity.halstead.difficulty.toFixed(2) }} <br>
    Est # bugs : {{ complexity.halstead.bugs.toFixed(2) }}<br>
  </div>
</script>

<script type="text/javascript" src="../../assets/scripts/bundles/core-bundle.js"></script>
<script type="text/javascript" src="../../assets/scripts/bundles/codemirror.js"></script>
<script type="text/javascript" src="../../assets/scripts/codemirror.markpopovertext.js"></script>
<script type="text/javascript" src="report.js"></script>
<script type="text/javascript" src="report.history.js"></script>
<script type="text/javascript" src="../../assets/scripts/plato-file.js"></script>
</body>
</html>
