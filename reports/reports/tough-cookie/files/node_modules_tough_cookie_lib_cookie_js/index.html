<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Plato - node_modules/tough-cookie/lib/cookie.js</title>

  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="">
  <meta name="author" content="">

  <!--[if lt IE 9]>
  <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->

  <link href="../../assets/css/vendor/morris.css" rel="stylesheet">
  <link href="../../assets/css/vendor/bootstrap.css" rel="stylesheet">
  <link href="../../assets/css/vendor/font-awesome.css" rel="stylesheet">
  <link href="../../assets/css/vendor/codemirror.css" rel="stylesheet">
  <link href="../../assets/css/plato.css" rel="stylesheet">
  <link href="../../assets/css/plato-file.css" rel="stylesheet">

</head>

<body>

<div class="navbar navbar-fixed-top">
  <div class="container">
    <a class="navbar-brand" href="http://github.com/es-analysis/plato">Plato on Github</a>
    <ul class="nav navbar-nav">
      <li>
        <a href="../../index.html">Report Home</a>
      </li>
    </ul>
  </div>
</div>

<div class="jumbotron">
  <div class="container">
    <h1>node_modules/tough-cookie/lib/cookie.js</h1>
  </div>
</div>

<div class="container aggregate-stats">
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Maintainability <a href="http://blogs.msdn.com/b/codeanalysis/archive/2007/11/20/maintainability-index-range-and-meaning.aspx"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="A value between 0 and 100 that represents the relative ease of maintaining the code. A high value means better maintainability." data-original-title="Maintainability Index"  data-container="body"></i></a></h2>
      <p class="stat">60.05</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Lines of code <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h2>
      <p class="stat">1086</p>
    </div>
  </div>
  <div class="row historical">
    <div class="col-md-6">
      <p id="chart_historical_maint" class="chart"></p>
    </div>
    <div class="col-md-6">
      <p id="chart_historical_sloc" class="chart"></p>
    </div>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Difficulty  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="The difficulty measure is related to the difficulty of the program to write or understand." data-original-title="Difficulty" data-container="body"></i></a></h2>
      <p class="stat">96.98</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Estimated Errors  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Halstead's delivered bugs is an estimate for the number of errors in the implementation." data-original-title="Delivered Bugs" data-container="body"></i></a></h2>
      <p class="stat">9.43</p>
    </div>
  </div>
</div>

<div class="container charts">
  <div class="row">
    <h2 class="header">Function weight</h2>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h3 class="chart-header">By Complexity <a href="http://en.wikipedia.org/wiki/Cyclomatic_complexity"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="This metric counts the number of distinct paths through a block of code. Lower values are better." data-original-title="Cyclomatic Complexity" data-container="body"></i></a></h3>
      <div id="fn-by-complexity" class="stat"></div>
    </div>
    <div class="col-md-6">
      <h3 class="chart-header">By SLOC  <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h3>
      <div id="fn-by-sloc" class="stat"></div>
    </div>
  </div>
</div>

<div class="container">
  <div class="row">
    <textarea id="file-source" class="col-md-12">/*
 * Copyright GoInstant, Inc. and other contributors. All rights reserved.
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the &quot;Software&quot;), to
 * deal in the Software without restriction, including without limitation the
 * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
 * sell copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
 * IN THE SOFTWARE.
 */

&#039;use strict&#039;;
var net = require(&#039;net&#039;);
var urlParse = require(&#039;url&#039;).parse;
var pubsuffix = require(&#039;./pubsuffix&#039;);
var Store = require(&#039;./store&#039;).Store;

var punycode;
try {
  punycode = require(&#039;punycode&#039;);
} catch(e) {
  console.warn(&quot;cookie: can&#039;t load punycode; won&#039;t use punycode for domain normalization&quot;);
}

var DATE_DELIM = /[\x09\x20-\x2F\x3B-\x40\x5B-\x60\x7B-\x7E]/;

// From RFC2616 S2.2:
var TOKEN = /[\x21\x23-\x26\x2A\x2B\x2D\x2E\x30-\x39\x41-\x5A\x5E-\x7A\x7C\x7E]/;

// From RFC6265 S4.1.1
// note that it excludes \x3B &quot;;&quot;
var COOKIE_OCTET  = /[\x21\x23-\x2B\x2D-\x3A\x3C-\x5B\x5D-\x7E]/;
var COOKIE_OCTETS = new RegExp(&#039;^&#039;+COOKIE_OCTET.source+&#039;$&#039;);

// The name/key cannot be empty but the value can (S5.2):
var COOKIE_PAIR_STRICT = new RegExp(&#039;^(&#039;+TOKEN.source+&#039;+)=(&quot;?)(&#039;+COOKIE_OCTET.source+&#039;*)\\2$&#039;);
var COOKIE_PAIR = /^([^=\s]+)\s*=\s*(&quot;?)\s*(.*)\s*\2\s*$/;

// RFC6265 S4.1.1 defines extension-av as &#039;any CHAR except CTLs or &quot;;&quot;&#039;
// Note &#039;;&#039; is \x3B
var NON_CTL_SEMICOLON = /[\x20-\x3A\x3C-\x7E]+/;
var EXTENSION_AV = NON_CTL_SEMICOLON;
var PATH_VALUE = NON_CTL_SEMICOLON;

// Used for checking whether or not there is a trailing semi-colon
var TRAILING_SEMICOLON = /;+$/;

/* RFC6265 S5.1.1.5:
 * [fail if] the day-of-month-value is less than 1 or greater than 31
 */
var DAY_OF_MONTH = /^(0?[1-9]|[12][0-9]|3[01])$/;

/* RFC6265 S5.1.1.5:
 * [fail if]
 * *  the hour-value is greater than 23,
 * *  the minute-value is greater than 59, or
 * *  the second-value is greater than 59.
 */
var TIME = /(0?[0-9]|1[0-9]|2[0-3]):([0-5][0-9]):([0-5][0-9])/;
var STRICT_TIME = /^(0?[0-9]|1[0-9]|2[0-3]):([0-5][0-9]):([0-5][0-9])$/;

var MONTH = /^(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)$/i;
var MONTH_TO_NUM = {
  jan:0, feb:1, mar:2, apr:3, may:4, jun:5,
  jul:6, aug:7, sep:8, oct:9, nov:10, dec:11
};
var NUM_TO_MONTH = [
  &#039;Jan&#039;,&#039;Feb&#039;,&#039;Mar&#039;,&#039;Apr&#039;,&#039;May&#039;,&#039;Jun&#039;,&#039;Jul&#039;,&#039;Aug&#039;,&#039;Sep&#039;,&#039;Oct&#039;,&#039;Nov&#039;,&#039;Dec&#039;
];
var NUM_TO_DAY = [
  &#039;Sun&#039;,&#039;Mon&#039;,&#039;Tue&#039;,&#039;Wed&#039;,&#039;Thu&#039;,&#039;Fri&#039;,&#039;Sat&#039;
];

var YEAR = /^([1-9][0-9]{1,3})$/; // 2 to 4 digits

var MAX_TIME = 2147483647000; // 31-bit max
var MIN_TIME = 0; // 31-bit min


// RFC6265 S5.1.1 date parser:
function parseDate(str,strict) {
  if (!str) {
    return;
  }
  var found_time, found_dom, found_month, found_year;

  /* RFC6265 S5.1.1:
   * 2. Process each date-token sequentially in the order the date-tokens
   * appear in the cookie-date
   */
  var tokens = str.split(DATE_DELIM);
  if (!tokens) {
    return;
  }

  var date = new Date();
  date.setMilliseconds(0);

  for (var i=0; i&lt;tokens.length; i++) {
    var token = tokens[i].trim();
    if (!token.length) {
      continue;
    }

    var result;

    /* 2.1. If the found-time flag is not set and the token matches the time
     * production, set the found-time flag and set the hour- value,
     * minute-value, and second-value to the numbers denoted by the digits in
     * the date-token, respectively.  Skip the remaining sub-steps and continue
     * to the next date-token.
     */
    if (!found_time) {
      result = (strict ? STRICT_TIME : TIME).exec(token);
      if (result) {
        found_time = true;
        date.setUTCHours(result[1]);
        date.setUTCMinutes(result[2]);
        date.setUTCSeconds(result[3]);
        continue;
      }
    }

    /* 2.2. If the found-day-of-month flag is not set and the date-token matches
     * the day-of-month production, set the found-day-of- month flag and set
     * the day-of-month-value to the number denoted by the date-token.  Skip
     * the remaining sub-steps and continue to the next date-token.
     */
    if (!found_dom) {
      result = DAY_OF_MONTH.exec(token);
      if (result) {
        found_dom = true;
        date.setUTCDate(result[1]);
        continue;
      }
    }

    /* 2.3. If the found-month flag is not set and the date-token matches the
     * month production, set the found-month flag and set the month-value to
     * the month denoted by the date-token.  Skip the remaining sub-steps and
     * continue to the next date-token.
     */
    if (!found_month) {
      result = MONTH.exec(token);
      if (result) {
        found_month = true;
        date.setUTCMonth(MONTH_TO_NUM[result[1].toLowerCase()]);
        continue;
      }
    }

    /* 2.4. If the found-year flag is not set and the date-token matches the year
     * production, set the found-year flag and set the year-value to the number
     * denoted by the date-token.  Skip the remaining sub-steps and continue to
     * the next date-token.
     */
    if (!found_year) {
      result = YEAR.exec(token);
      if (result) {
        var year = result[0];
        /* From S5.1.1:
         * 3.  If the year-value is greater than or equal to 70 and less
         * than or equal to 99, increment the year-value by 1900.
         * 4.  If the year-value is greater than or equal to 0 and less
         * than or equal to 69, increment the year-value by 2000.
         */
        if (70 &lt;= year &amp;&amp; year &lt;= 99) {
          year += 1900;
        } else if (0 &lt;= year &amp;&amp; year &lt;= 69) {
          year += 2000;
        }

        if (year &lt; 1601) {
          return; // 5. ... the year-value is less than 1601
        }

        found_year = true;
        date.setUTCFullYear(year);
        continue;
      }
    }
  }

  if (!(found_time &amp;&amp; found_dom &amp;&amp; found_month &amp;&amp; found_year)) {
    return; // 5. ... at least one of the found-day-of-month, found-month, found-
            // year, or found-time flags is not set,
  }

  return date;
}

function formatDate(date) {
  var d = date.getUTCDate(); d = d &gt;= 10 ? d : &#039;0&#039;+d;
  var h = date.getUTCHours(); h = h &gt;= 10 ? h : &#039;0&#039;+h;
  var m = date.getUTCMinutes(); m = m &gt;= 10 ? m : &#039;0&#039;+m;
  var s = date.getUTCSeconds(); s = s &gt;= 10 ? s : &#039;0&#039;+s;
  return NUM_TO_DAY[date.getUTCDay()] + &#039;, &#039; +
    d+&#039; &#039;+ NUM_TO_MONTH[date.getUTCMonth()] +&#039; &#039;+ date.getUTCFullYear() +&#039; &#039;+
    h+&#039;:&#039;+m+&#039;:&#039;+s+&#039; GMT&#039;;
}

// S5.1.2 Canonicalized Host Names
function canonicalDomain(str) {
  if (str == null) {
    return null;
  }
  str = str.trim().replace(/^\./,&#039;&#039;); // S4.1.2.3 &amp; S5.2.3: ignore leading .

  // convert to IDN if any non-ASCII characters
  if (punycode &amp;&amp; /[^\u0001-\u007f]/.test(str)) {
    str = punycode.toASCII(str);
  }

  return str.toLowerCase();
}

// S5.1.3 Domain Matching
function domainMatch(str, domStr, canonicalize) {
  if (str == null || domStr == null) {
    return null;
  }
  if (canonicalize !== false) {
    str = canonicalDomain(str);
    domStr = canonicalDomain(domStr);
  }

  /*
   * &quot;The domain string and the string are identical. (Note that both the
   * domain string and the string will have been canonicalized to lower case at
   * this point)&quot;
   */
  if (str == domStr) {
    return true;
  }

  /* &quot;All of the following [three] conditions hold:&quot; (order adjusted from the RFC) */

  /* &quot;* The string is a host name (i.e., not an IP address).&quot; */
  if (net.isIP(str)) {
    return false;
  }

  /* &quot;* The domain string is a suffix of the string&quot; */
  var idx = str.indexOf(domStr);
  if (idx &lt;= 0) {
    return false; // it&#039;s a non-match (-1) or prefix (0)
  }

  // e.g &quot;a.b.c&quot;.indexOf(&quot;b.c&quot;) === 2
  // 5 === 3+2
  if (str.length !== domStr.length + idx) { // it&#039;s not a suffix
    return false;
  }

  /* &quot;* The last character of the string that is not included in the domain
  * string is a %x2E (&quot;.&quot;) character.&quot; */
  if (str.substr(idx-1,1) !== &#039;.&#039;) {
    return false;
  }

  return true;
}


// RFC6265 S5.1.4 Paths and Path-Match

/*
 * &quot;The user agent MUST use an algorithm equivalent to the following algorithm
 * to compute the default-path of a cookie:&quot;
 *
 * Assumption: the path (and not query part or absolute uri) is passed in.
 */
function defaultPath(path) {
  // &quot;2. If the uri-path is empty or if the first character of the uri-path is not
  // a %x2F (&quot;/&quot;) character, output %x2F (&quot;/&quot;) and skip the remaining steps.
  if (!path || path.substr(0,1) !== &quot;/&quot;) {
    return &quot;/&quot;;
  }

  // &quot;3. If the uri-path contains no more than one %x2F (&quot;/&quot;) character, output
  // %x2F (&quot;/&quot;) and skip the remaining step.&quot;
  if (path === &quot;/&quot;) {
    return path;
  }

  var rightSlash = path.lastIndexOf(&quot;/&quot;);
  if (rightSlash === 0) {
    return &quot;/&quot;;
  }

  // &quot;4. Output the characters of the uri-path from the first character up to,
  // but not including, the right-most %x2F (&quot;/&quot;).&quot;
  return path.slice(0, rightSlash);
}

/*
 * &quot;A request-path path-matches a given cookie-path if at least one of the
 * following conditions holds:&quot;
 */
function pathMatch(reqPath,cookiePath) {
  // &quot;o  The cookie-path and the request-path are identical.&quot;
  if (cookiePath === reqPath) {
    return true;
  }

  var idx = reqPath.indexOf(cookiePath);
  if (idx === 0) {
    // &quot;o  The cookie-path is a prefix of the request-path, and the last
    // character of the cookie-path is %x2F (&quot;/&quot;).&quot;
    if (cookiePath.substr(-1) === &quot;/&quot;) {
      return true;
    }

    // &quot; o  The cookie-path is a prefix of the request-path, and the first
    // character of the request-path that is not included in the cookie- path
    // is a %x2F (&quot;/&quot;) character.&quot;
    if (reqPath.substr(cookiePath.length,1) === &quot;/&quot;) {
      return true;
    }
  }

  return false;
}

function parse(str, strict) {
  str = str.trim();

  // S4.1.1 Trailing semi-colons are not part of the specification.
  // If we are not in strict mode we remove the trailing semi-colons.
  var semiColonCheck = TRAILING_SEMICOLON.exec(str);
  if (semiColonCheck) {
    if (strict) {
      return;
    }
    str = str.slice(0, semiColonCheck.index);
  }

  // We use a regex to parse the &quot;name-value-pair&quot; part of S5.2
  var firstSemi = str.indexOf(&#039;;&#039;); // S5.2 step 1
  var pairRx = strict ? COOKIE_PAIR_STRICT : COOKIE_PAIR;
  var result = pairRx.exec(firstSemi === -1 ? str : str.substr(0,firstSemi));

  // Rx satisfies the &quot;the name string is empty&quot; and &quot;lacks a %x3D (&quot;=&quot;)&quot;
  // constraints as well as trimming any whitespace.
  if (!result) {
    return;
  }

  var c = new Cookie();
  c.key = result[1]; // the regexp should trim() already
  c.value = result[3]; // [2] is quotes or empty-string

  if (firstSemi === -1) {
    return c;
  }

  // S5.2.3 &quot;unparsed-attributes consist of the remainder of the set-cookie-string
  // (including the %x3B (&quot;;&quot;) in question).&quot; plus later on in the same section
  // &quot;discard the first &quot;;&quot; and trim&quot;.
  var unparsed = str.slice(firstSemi).replace(/^\s*;\s*/,&#039;&#039;).trim();

  // &quot;If the unparsed-attributes string is empty, skip the rest of these
  // steps.&quot;
  if (unparsed.length === 0) {
    return c;
  }

  /*
   * S5.2 says that when looping over the items &quot;[p]rocess the attribute-name
   * and attribute-value according to the requirements in the following
   * subsections&quot; for every item.  Plus, for many of the individual attributes
   * in S5.3 it says to use the &quot;attribute-value of the last attribute in the
   * cookie-attribute-list&quot;.  Therefore, in this implementation, we overwrite
   * the previous value.
   */
  var cookie_avs = unparsed.split(/\s*;\s*/);
  while (cookie_avs.length) {
    var av = cookie_avs.shift();

    if (strict &amp;&amp; !EXTENSION_AV.test(av)) {
      return;
    }

    var av_sep = av.indexOf(&#039;=&#039;);
    var av_key, av_value;
    if (av_sep === -1) {
      av_key = av;
      av_value = null;
    } else {
      av_key = av.substr(0,av_sep);
      av_value = av.substr(av_sep+1);
    }

    av_key = av_key.trim().toLowerCase();
    if (av_value) {
      av_value = av_value.trim();
    }

    switch(av_key) {
    case &#039;expires&#039;: // S5.2.1
      if (!av_value) {if(strict){return;}else{break;} }
      var exp = parseDate(av_value,strict);
      // &quot;If the attribute-value failed to parse as a cookie date, ignore the
      // cookie-av.&quot;
      if (exp == null) { if(strict){return;}else{break;} }
      c.expires = exp;
      // over and underflow not realistically a concern: V8&#039;s getTime() seems to
      // store something larger than a 32-bit time_t (even with 32-bit node)
      break;

    case &#039;max-age&#039;: // S5.2.2
      if (!av_value) { if(strict){return;}else{break;} }
      // &quot;If the first character of the attribute-value is not a DIGIT or a &quot;-&quot;
      // character ...[or]... If the remainder of attribute-value contains a
      // non-DIGIT character, ignore the cookie-av.&quot;
      if (!/^-?[0-9]+$/.test(av_value)) { if(strict){return;}else{break;} }
      var delta = parseInt(av_value,10);
      if (strict &amp;&amp; delta &lt;= 0) {
        return; // S4.1.1
      }
      // &quot;If delta-seconds is less than or equal to zero (0), let expiry-time
      // be the earliest representable date and time.&quot;
      c.setMaxAge(delta);
      break;

    case &#039;domain&#039;: // S5.2.3
      // &quot;If the attribute-value is empty, the behavior is undefined.  However,
      // the user agent SHOULD ignore the cookie-av entirely.&quot;
      if (!av_value) { if(strict){return;}else{break;} }
      // S5.2.3 &quot;Let cookie-domain be the attribute-value without the leading %x2E
      // (&quot;.&quot;) character.&quot;
      var domain = av_value.trim().replace(/^\./,&#039;&#039;);
      if (!domain) { if(strict){return;}else{break;} } // see &quot;is empty&quot; above
      // &quot;Convert the cookie-domain to lower case.&quot;
      c.domain = domain.toLowerCase();
      break;

    case &#039;path&#039;: // S5.2.4
      /*
       * &quot;If the attribute-value is empty or if the first character of the
       * attribute-value is not %x2F (&quot;/&quot;):
       *   Let cookie-path be the default-path.
       * Otherwise:
       *   Let cookie-path be the attribute-value.&quot;
       *
       * We&#039;ll represent the default-path as null since it depends on the
       * context of the parsing.
       */
      if (!av_value || av_value.substr(0,1) != &quot;/&quot;) {
        if(strict){return;}else{break;}
      }
      c.path = av_value;
      break;

    case &#039;secure&#039;: // S5.2.5
      /*
       * &quot;If the attribute-name case-insensitively matches the string &quot;Secure&quot;,
       * the user agent MUST append an attribute to the cookie-attribute-list
       * with an attribute-name of Secure and an empty attribute-value.&quot;
       */
      if (av_value != null) { if(strict){return;} }
      c.secure = true;
      break;

    case &#039;httponly&#039;: // S5.2.6 -- effectively the same as &#039;secure&#039;
      if (av_value != null) { if(strict){return;} }
      c.httpOnly = true;
      break;

    default:
      c.extensions = c.extensions || [];
      c.extensions.push(av);
      break;
    }
  }

  // ensure a default date for sorting:
  c.creation = new Date();
  return c;
}

function fromJSON(str) {
  if (!str) {
    return null;
  }

  var obj;
  try {
    obj = JSON.parse(str);
  } catch (e) {
    return null;
  }

  var c = new Cookie();
  for (var i=0; i&lt;numCookieProperties; i++) {
    var prop = cookieProperties[i];
    if (obj[prop] == null) {
      continue;
    }
    if (prop === &#039;expires&#039; ||
        prop === &#039;creation&#039; ||
        prop === &#039;lastAccessed&#039;)
    {
      c[prop] = obj[prop] == &quot;Infinity&quot; ? &quot;Infinity&quot; : new Date(obj[prop]);
    } else {
      c[prop] = obj[prop];
    }
  }


  // ensure a default date for sorting:
  c.creation = c.creation || new Date();

  return c;
}

/* Section 5.4 part 2:
 * &quot;*  Cookies with longer paths are listed before cookies with
 *     shorter paths.
 *
 *  *  Among cookies that have equal-length path fields, cookies with
 *     earlier creation-times are listed before cookies with later
 *     creation-times.&quot;
 */

function cookieCompare(a,b) {
  // descending for length: b CMP a
  var deltaLen = (b.path ? b.path.length : 0) - (a.path ? a.path.length : 0);
  if (deltaLen !== 0) {
    return deltaLen;
  }
  // ascending for time: a CMP b
  return (a.creation ? a.creation.getTime() : MAX_TIME) -
         (b.creation ? b.creation.getTime() : MAX_TIME);
}

// Gives the permutation of all possible domainMatch()es of a given domain. The
// array is in shortest-to-longest order.  Handy for indexing.
function permuteDomain(domain) {
  var pubSuf = pubsuffix.getPublicSuffix(domain);
  if (!pubSuf) {
    return null;
  }
  if (pubSuf == domain) {
    return [domain];
  }

  var prefix = domain.slice(0,-(pubSuf.length+1)); // &quot;.example.com&quot;
  var parts = prefix.split(&#039;.&#039;).reverse();
  var cur = pubSuf;
  var permutations = [cur];
  while (parts.length) {
    cur = parts.shift()+&#039;.&#039;+cur;
    permutations.push(cur);
  }
  return permutations;
}

// Gives the permutation of all possible pathMatch()es of a given path. The
// array is in longest-to-shortest order.  Handy for indexing.
function permutePath(path) {
  if (path === &#039;/&#039;) {
    return [&#039;/&#039;];
  }
  if (path.lastIndexOf(&#039;/&#039;) === path.length-1) {
    path = path.substr(0,path.length-1);
  }
  var permutations = [path];
  while (path.length &gt; 1) {
    var lindex = path.lastIndexOf(&#039;/&#039;);
    if (lindex === 0) {
      break;
    }
    path = path.substr(0,lindex);
    permutations.push(path);
  }
  permutations.push(&#039;/&#039;);
  return permutations;
}


function Cookie (opts) {
  if (typeof opts !== &quot;object&quot;) {
    return;
  }
  Object.keys(opts).forEach(function (key) {
    if (Cookie.prototype.hasOwnProperty(key)) {
      this[key] = opts[key] || Cookie.prototype[key];
    }
  }.bind(this));
}

Cookie.parse = parse;
Cookie.fromJSON = fromJSON;

Cookie.prototype.key = &quot;&quot;;
Cookie.prototype.value = &quot;&quot;;

// the order in which the RFC has them:
Cookie.prototype.expires = &quot;Infinity&quot;; // coerces to literal Infinity
Cookie.prototype.maxAge = null; // takes precedence over expires for TTL
Cookie.prototype.domain = null;
Cookie.prototype.path = null;
Cookie.prototype.secure = false;
Cookie.prototype.httpOnly = false;
Cookie.prototype.extensions = null;

// set by the CookieJar:
Cookie.prototype.hostOnly = null; // boolean when set
Cookie.prototype.pathIsDefault = null; // boolean when set
Cookie.prototype.creation = null; // Date when set; defaulted by Cookie.parse
Cookie.prototype.lastAccessed = null; // Date when set

var cookieProperties = Object.freeze(Object.keys(Cookie.prototype).map(function(p) {
  if (p instanceof Function) {
    return;
  }
  return p;
}));
var numCookieProperties = cookieProperties.length;

Cookie.prototype.inspect = function inspect() {
  var now = Date.now();
  return &#039;Cookie=&quot;&#039;+this.toString() +
    &#039;; hostOnly=&#039;+(this.hostOnly != null ? this.hostOnly : &#039;?&#039;) +
    &#039;; aAge=&#039;+(this.lastAccessed ? (now-this.lastAccessed.getTime())+&#039;ms&#039; : &#039;?&#039;) +
    &#039;; cAge=&#039;+(this.creation ? (now-this.creation.getTime())+&#039;ms&#039; : &#039;?&#039;) +
    &#039;&quot;&#039;;
};

Cookie.prototype.validate = function validate() {
  if (!COOKIE_OCTETS.test(this.value)) {
    return false;
  }
  if (this.expires != Infinity &amp;&amp; !(this.expires instanceof Date) &amp;&amp; !parseDate(this.expires,true)) {
    return false;
  }
  if (this.maxAge != null &amp;&amp; this.maxAge &lt;= 0) {
    return false; // &quot;Max-Age=&quot; non-zero-digit *DIGIT
  }
  if (this.path != null &amp;&amp; !PATH_VALUE.test(this.path)) {
    return false;
  }

  var cdomain = this.cdomain();
  if (cdomain) {
    if (cdomain.match(/\.$/)) {
      return false; // S4.1.2.3 suggests that this is bad. domainMatch() tests confirm this
    }
    var suffix = pubsuffix.getPublicSuffix(cdomain);
    if (suffix == null) { // it&#039;s a public suffix
      return false;
    }
  }
  return true;
};

Cookie.prototype.setExpires = function setExpires(exp) {
  if (exp instanceof Date) {
    this.expires = exp;
  } else {
    this.expires = parseDate(exp) || &quot;Infinity&quot;;
  }
};

Cookie.prototype.setMaxAge = function setMaxAge(age) {
  if (age === Infinity || age === -Infinity) {
    this.maxAge = age.toString(); // so JSON.stringify() works
  } else {
    this.maxAge = age;
  }
};

// gives Cookie header format
Cookie.prototype.cookieString = function cookieString() {
  var val = this.value;
  if (val == null) {
    val = &#039;&#039;;
  }
  return this.key+&#039;=&#039;+val;
};

// gives Set-Cookie header format
Cookie.prototype.toString = function toString() {
  var str = this.cookieString();

  if (this.expires != Infinity) {
    if (this.expires instanceof Date) {
      str += &#039;; Expires=&#039;+formatDate(this.expires);
    } else {
      str += &#039;; Expires=&#039;+this.expires;
    }
  }

  if (this.maxAge != null &amp;&amp; this.maxAge != Infinity) {
    str += &#039;; Max-Age=&#039;+this.maxAge;
  }

  if (this.domain &amp;&amp; !this.hostOnly) {
    str += &#039;; Domain=&#039;+this.domain;
  }
  if (this.path) {
    str += &#039;; Path=&#039;+this.path;
  }

  if (this.secure) {
    str += &#039;; Secure&#039;;
  }
  if (this.httpOnly) {
    str += &#039;; HttpOnly&#039;;
  }
  if (this.extensions) {
    this.extensions.forEach(function(ext) {
      str += &#039;; &#039;+ext;
    });
  }

  return str;
};

// TTL() partially replaces the &quot;expiry-time&quot; parts of S5.3 step 3 (setCookie()
// elsewhere)
// S5.3 says to give the &quot;latest representable date&quot; for which we use Infinity
// For &quot;expired&quot; we use 0
Cookie.prototype.TTL = function TTL(now) {
  /* RFC6265 S4.1.2.2 If a cookie has both the Max-Age and the Expires
   * attribute, the Max-Age attribute has precedence and controls the
   * expiration date of the cookie.
   * (Concurs with S5.3 step 3)
   */
  if (this.maxAge != null) {
    return this.maxAge&lt;=0 ? 0 : this.maxAge*1000;
  }

  var expires = this.expires;
  if (expires != Infinity) {
    if (!(expires instanceof Date)) {
      expires = parseDate(expires) || Infinity;
    }

    if (expires == Infinity) {
      return Infinity;
    }

    return expires.getTime() - (now || Date.now());
  }

  return Infinity;
};

// expiryTime() replaces the &quot;expiry-time&quot; parts of S5.3 step 3 (setCookie()
// elsewhere)
Cookie.prototype.expiryTime = function expiryTime(now) {
  if (this.maxAge != null) {
    var relativeTo = this.creation || now || new Date();
    var age = (this.maxAge &lt;= 0) ? -Infinity : this.maxAge*1000;
    return relativeTo.getTime() + age;
  }

  if (this.expires == Infinity) {
    return Infinity;
  }
  return this.expires.getTime();
};

// expiryDate() replaces the &quot;expiry-time&quot; parts of S5.3 step 3 (setCookie()
// elsewhere), except it returns a Date
Cookie.prototype.expiryDate = function expiryDate(now) {
  var millisec = this.expiryTime(now);
  if (millisec == Infinity) {
    return new Date(MAX_TIME);
  } else if (millisec == -Infinity) {
    return new Date(MIN_TIME);
  } else {
    return new Date(millisec);
  }
};

// This replaces the &quot;persistent-flag&quot; parts of S5.3 step 3
Cookie.prototype.isPersistent = function isPersistent() {
  return (this.maxAge != null || this.expires != Infinity);
};

// Mostly S5.1.2 and S5.2.3:
Cookie.prototype.cdomain =
Cookie.prototype.canonicalizedDomain = function canonicalizedDomain() {
  if (this.domain == null) {
    return null;
  }
  return canonicalDomain(this.domain);
};


var memstore;
function CookieJar(store, rejectPublicSuffixes) {
  if (rejectPublicSuffixes != null) {
    this.rejectPublicSuffixes = rejectPublicSuffixes;
  }

  if (!store) {
    memstore = memstore || require(&#039;./memstore&#039;);
    store = new memstore.MemoryCookieStore();
  }
  this.store = store;
}
CookieJar.prototype.store = null;
CookieJar.prototype.rejectPublicSuffixes = true;
var CAN_BE_SYNC = [];

CAN_BE_SYNC.push(&#039;setCookie&#039;);
CookieJar.prototype.setCookie = function(cookie, url, options, cb) {
  var err;
  var context = (url instanceof Object) ? url : urlParse(url);
  if (options instanceof Function) {
    cb = options;
    options = {};
  }

  var host = canonicalDomain(context.hostname);

  // S5.3 step 1
  if (!(cookie instanceof Cookie)) {
    cookie = Cookie.parse(cookie, options.strict === true);
  }
  if (!cookie) {
    err = new Error(&quot;Cookie failed to parse&quot;);
    return cb(options.ignoreError ? null : err);
  }

  // S5.3 step 2
  var now = options.now || new Date(); // will assign later to save effort in the face of errors

  // S5.3 step 3: NOOP; persistent-flag and expiry-time is handled by getCookie()

  // S5.3 step 4: NOOP; domain is null by default

  // S5.3 step 5: public suffixes
  if (this.rejectPublicSuffixes &amp;&amp; cookie.domain) {
    var suffix = pubsuffix.getPublicSuffix(cookie.cdomain());
    if (suffix == null) { // e.g. &quot;com&quot;
      err = new Error(&quot;Cookie has domain set to a public suffix&quot;);
      return cb(options.ignoreError ? null : err);
    }
  }

  // S5.3 step 6:
  if (cookie.domain) {
    if (!domainMatch(host, cookie.cdomain(), false)) {
      err = new Error(&quot;Cookie not in this host&#039;s domain. Cookie:&quot;+cookie.cdomain()+&quot; Request:&quot;+host);
      return cb(options.ignoreError ? null : err);
    }

    if (cookie.hostOnly == null) { // don&#039;t reset if already set
      cookie.hostOnly = false;
    }

  } else {
    cookie.hostOnly = true;
    cookie.domain = host;
  }

  // S5.3 step 7: &quot;Otherwise, set the cookie&#039;s path to the default-path of the
  // request-uri&quot;
  if (!cookie.path) {
    cookie.path = defaultPath(context.pathname);
    cookie.pathIsDefault = true;
  } else {
    if (cookie.path.length &gt; 1 &amp;&amp; cookie.path.substr(-1) == &#039;/&#039;) {
      cookie.path = cookie.path.slice(0,-1);
    }
  }

  // S5.3 step 8: NOOP; secure attribute
  // S5.3 step 9: NOOP; httpOnly attribute

  // S5.3 step 10
  if (options.http === false &amp;&amp; cookie.httpOnly) {
    err = new Error(&quot;Cookie is HttpOnly and this isn&#039;t an HTTP API&quot;);
    return cb(options.ignoreError ? null : err);
  }

  var store = this.store;

  if (!store.updateCookie) {
    store.updateCookie = function(oldCookie, newCookie, cb) {
      this.putCookie(newCookie, cb);
    };
  }

  function withCookie(err, oldCookie) {
    if (err) {
      return cb(err);
    }

    var next = function(err) {
      if (err) {
        return cb(err);
      } else {
        cb(null, cookie);
      }
    };

    if (oldCookie) {
      // S5.3 step 11 - &quot;If the cookie store contains a cookie with the same name,
      // domain, and path as the newly created cookie:&quot;
      if (options.http === false &amp;&amp; oldCookie.httpOnly) { // step 11.2
        err = new Error(&quot;old Cookie is HttpOnly and this isn&#039;t an HTTP API&quot;);
        return cb(options.ignoreError ? null : err);
      }
      cookie.creation = oldCookie.creation; // step 11.3
      cookie.lastAccessed = now;
      // Step 11.4 (delete cookie) is implied by just setting the new one:
      store.updateCookie(oldCookie, cookie, next); // step 12

    } else {
      cookie.creation = cookie.lastAccessed = now;
      store.putCookie(cookie, next); // step 12
    }
  }

  store.findCookie(cookie.domain, cookie.path, cookie.key, withCookie);
};

// RFC6365 S5.4
CAN_BE_SYNC.push(&#039;getCookies&#039;);
CookieJar.prototype.getCookies = function(url, options, cb) {
  var context = (url instanceof Object) ? url : urlParse(url);
  if (options instanceof Function) {
    cb = options;
    options = {};
  }

  var host = canonicalDomain(context.hostname);
  var path = context.pathname || &#039;/&#039;;

  var secure = options.secure;
  if (secure == null &amp;&amp; context.protocol &amp;&amp;
      (context.protocol == &#039;https:&#039; || context.protocol == &#039;wss:&#039;))
  {
    secure = true;
  }

  var http = options.http;
  if (http == null) {
    http = true;
  }

  var now = options.now || Date.now();
  var expireCheck = options.expire !== false;
  var allPaths = !!options.allPaths;
  var store = this.store;

  function matchingCookie(c) {
    // &quot;Either:
    //   The cookie&#039;s host-only-flag is true and the canonicalized
    //   request-host is identical to the cookie&#039;s domain.
    // Or:
    //   The cookie&#039;s host-only-flag is false and the canonicalized
    //   request-host domain-matches the cookie&#039;s domain.&quot;
    if (c.hostOnly) {
      if (c.domain != host) {
        return false;
      }
    } else {
      if (!domainMatch(host, c.domain, false)) {
        return false;
      }
    }

    // &quot;The request-uri&#039;s path path-matches the cookie&#039;s path.&quot;
    if (!allPaths &amp;&amp; !pathMatch(path, c.path)) {
      return false;
    }

    // &quot;If the cookie&#039;s secure-only-flag is true, then the request-uri&#039;s
    // scheme must denote a &quot;secure&quot; protocol&quot;
    if (c.secure &amp;&amp; !secure) {
      return false;
    }

    // &quot;If the cookie&#039;s http-only-flag is true, then exclude the cookie if the
    // cookie-string is being generated for a &quot;non-HTTP&quot; API&quot;
    if (c.httpOnly &amp;&amp; !http) {
      return false;
    }

    // deferred from S5.3
    // non-RFC: allow retention of expired cookies by choice
    if (expireCheck &amp;&amp; c.expiryTime() &lt;= now) {
      store.removeCookie(c.domain, c.path, c.key, function(){}); // result ignored
      return false;
    }

    return true;
  }

  store.findCookies(host, allPaths ? null : path, function(err,cookies) {
    if (err) {
      return cb(err);
    }

    cookies = cookies.filter(matchingCookie);

    // sorting of S5.4 part 2
    if (options.sort !== false) {
      cookies = cookies.sort(cookieCompare);
    }

    // S5.4 part 3
    var now = new Date();
    cookies.forEach(function(c) {
      c.lastAccessed = now;
    });
    // TODO persist lastAccessed

    cb(null,cookies);
  });
};

CAN_BE_SYNC.push(&#039;getCookieString&#039;);
CookieJar.prototype.getCookieString = function(/*..., cb*/) {
  var args = Array.prototype.slice.call(arguments,0);
  var cb = args.pop();
  var next = function(err,cookies) {
    if (err) {
      cb(err);
    } else {
      cb(null, cookies.map(function(c){
        return c.cookieString();
      }).join(&#039;; &#039;));
    }
  };
  args.push(next);
  this.getCookies.apply(this,args);
};

CAN_BE_SYNC.push(&#039;getSetCookieStrings&#039;);
CookieJar.prototype.getSetCookieStrings = function(/*..., cb*/) {
  var args = Array.prototype.slice.call(arguments,0);
  var cb = args.pop();
  var next = function(err,cookies) {
    if (err) {
      cb(err);
    } else {
      cb(null, cookies.map(function(c){
        return c.toString();
      }));
    }
  };
  args.push(next);
  this.getCookies.apply(this,args);
};

// Use a closure to provide a true imperative API for synchronous stores.
function syncWrap(method) {
  return function() {
    if (!this.store.synchronous) {
      throw new Error(&#039;CookieJar store is not synchronous; use async API instead.&#039;);
    }

    var args = Array.prototype.slice.call(arguments);
    var syncErr, syncResult;
    args.push(function syncCb(err, result) {
      syncErr = err;
      syncResult = result;
    });
    this[method].apply(this, args);

    if (syncErr) {
      throw syncErr;
    }
    return syncResult;
  };
}

// wrap all declared CAN_BE_SYNC methods in the sync wrapper
CAN_BE_SYNC.forEach(function(method) {
  CookieJar.prototype[method+&#039;Sync&#039;] = syncWrap(method);
});

module.exports = {
  CookieJar: CookieJar,
  Cookie: Cookie,
  Store: Store,
  parseDate: parseDate,
  formatDate: formatDate,
  parse: parse,
  fromJSON: fromJSON,
  domainMatch: domainMatch,
  defaultPath: defaultPath,
  pathMatch: pathMatch,
  getPublicSuffix: pubsuffix.getPublicSuffix,
  cookieCompare: cookieCompare,
  permuteDomain: permuteDomain,
  permutePath: permutePath,
  canonicalDomain: canonicalDomain,
};</textarea>
  </div>
</div>

<footer class="footer">
  <div class="container">
    <p>.</p>
  </div>
</footer>

<script type="text/html" id="complexity-popover-template">
  <div class="complexity-notice">
    Complexity : {{ complexity.cyclomatic }} <br>
    Length : {{ complexity.halstead.length }} <br>
    Difficulty : {{ complexity.halstead.difficulty.toFixed(2) }} <br>
    Est # bugs : {{ complexity.halstead.bugs.toFixed(2) }}<br>
  </div>
</script>

<script type="text/javascript" src="../../assets/scripts/bundles/core-bundle.js"></script>
<script type="text/javascript" src="../../assets/scripts/bundles/codemirror.js"></script>
<script type="text/javascript" src="../../assets/scripts/codemirror.markpopovertext.js"></script>
<script type="text/javascript" src="report.js"></script>
<script type="text/javascript" src="report.history.js"></script>
<script type="text/javascript" src="../../assets/scripts/plato-file.js"></script>
</body>
</html>
