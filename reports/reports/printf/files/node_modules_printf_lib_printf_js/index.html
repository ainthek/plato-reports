<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Plato - node_modules/printf/lib/printf.js</title>

  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="">
  <meta name="author" content="">

  <!--[if lt IE 9]>
  <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->

  <link href="../../assets/css/vendor/morris.css" rel="stylesheet">
  <link href="../../assets/css/vendor/bootstrap.css" rel="stylesheet">
  <link href="../../assets/css/vendor/font-awesome.css" rel="stylesheet">
  <link href="../../assets/css/vendor/codemirror.css" rel="stylesheet">
  <link href="../../assets/css/plato.css" rel="stylesheet">
  <link href="../../assets/css/plato-file.css" rel="stylesheet">

</head>

<body>

<div class="navbar navbar-fixed-top">
  <div class="container">
    <a class="navbar-brand" href="http://github.com/es-analysis/plato">Plato on Github</a>
    <ul class="nav navbar-nav">
      <li>
        <a href="../../index.html">Report Home</a>
      </li>
    </ul>
  </div>
</div>

<div class="jumbotron">
  <div class="container">
    <h1>node_modules/printf/lib/printf.js</h1>
  </div>
</div>

<div class="container aggregate-stats">
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Maintainability <a href="http://blogs.msdn.com/b/codeanalysis/archive/2007/11/20/maintainability-index-range-and-meaning.aspx"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="A value between 0 and 100 that represents the relative ease of maintaining the code. A high value means better maintainability." data-original-title="Maintainability Index"  data-container="body"></i></a></h2>
      <p class="stat">51.06</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Lines of code <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h2>
      <p class="stat">459</p>
    </div>
  </div>
  <div class="row historical">
    <div class="col-md-6">
      <p id="chart_historical_maint" class="chart"></p>
    </div>
    <div class="col-md-6">
      <p id="chart_historical_sloc" class="chart"></p>
    </div>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Difficulty  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="The difficulty measure is related to the difficulty of the program to write or understand." data-original-title="Difficulty" data-container="body"></i></a></h2>
      <p class="stat">109.32</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Estimated Errors  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Halstead's delivered bugs is an estimate for the number of errors in the implementation." data-original-title="Delivered Bugs" data-container="body"></i></a></h2>
      <p class="stat">5.14</p>
    </div>
  </div>
</div>

<div class="container charts">
  <div class="row">
    <h2 class="header">Function weight</h2>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h3 class="chart-header">By Complexity <a href="http://en.wikipedia.org/wiki/Cyclomatic_complexity"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="This metric counts the number of distinct paths through a block of code. Lower values are better." data-original-title="Cyclomatic Complexity" data-container="body"></i></a></h3>
      <div id="fn-by-complexity" class="stat"></div>
    </div>
    <div class="col-md-6">
      <h3 class="chart-header">By SLOC  <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h3>
      <div id="fn-by-sloc" class="stat"></div>
    </div>
  </div>
</div>

<div class="container">
  <div class="row">
    <textarea id="file-source" class="col-md-12">var util = require(&#039;util&#039;);

var tokenize = function(/*String*/ str, /*RegExp*/ re, /*Function?*/ parseDelim, /*Object?*/ instance){
  // summary:
  //    Split a string by a regular expression with the ability to capture the delimeters
  // parseDelim:
  //    Each group (excluding the 0 group) is passed as a parameter. If the function returns
  //    a value, it&#039;s added to the list of tokens.
  // instance:
  //    Used as the &quot;this&#039; instance when calling parseDelim
  var tokens = [];
  var match, content, lastIndex = 0;
  while(match = re.exec(str)){
    content = str.slice(lastIndex, re.lastIndex - match[0].length);
    if(content.length){
      tokens.push(content);
    }
    if(parseDelim){
      var parsed = parseDelim.apply(instance, match.slice(1).concat(tokens.length));
      if(typeof parsed != &#039;undefined&#039;){
        if(parsed.specifier === &#039;%&#039;){
          tokens.push(&#039;%&#039;);
        }else{
          tokens.push(parsed);
        }
      }
    }
    lastIndex = re.lastIndex;
  }
  content = str.slice(lastIndex);
  if(content.length){
    tokens.push(content);
  }
  return tokens;
}

var Formatter = function(/*String*/ format){
  var tokens = [];
  this._mapped = false;
  this._format = format;
  this._tokens = tokenize(format, this._re, this._parseDelim, this);
}

Formatter.prototype._re = /\%(?:\(([\w_]+)\)|([1-9]\d*)\$)?([0 +\-\#]*)(\*|\d+)?(\.)?(\*|\d+)?[hlL]?([\%bscdeEfFgGioOuxX])/g;
Formatter.prototype._parseDelim = function(mapping, intmapping, flags, minWidth, period, precision, specifier){
  if(mapping){
    this._mapped = true;
  }
  return {
    mapping: mapping,
    intmapping: intmapping,
    flags: flags,
    _minWidth: minWidth, // May be dependent on parameters
    period: period,
    _precision: precision, // May be dependent on parameters
    specifier: specifier
  };
};
Formatter.prototype._specifiers = {
  b: {
    base: 2,
    isInt: true
  },
  o: {
    base: 8,
    isInt: true
  },
  x: {
    base: 16,
    isInt: true
  },
  X: {
    extend: [&#039;x&#039;],
    toUpper: true
  },
  d: {
    base: 10,
    isInt: true
  },
  i: {
    extend: [&#039;d&#039;]
  },
  u: {
    extend: [&#039;d&#039;],
    isUnsigned: true
  },
  c: {
    setArg: function(token){
      if(!isNaN(token.arg)){
        var num = parseInt(token.arg);
        if(num &lt; 0 || num &gt; 127){
          throw new Error(&#039;invalid character code passed to %c in printf&#039;);
        }
        token.arg = isNaN(num) ? &#039;&#039; + num : String.fromCharCode(num);
      }
    }
  },
  s: {
    setMaxWidth: function(token){
      token.maxWidth = (token.period == &#039;.&#039;) ? token.precision : -1;
    }
  },
  e: {
    isDouble: true,
    doubleNotation: &#039;e&#039;
  },
  E: {
    extend: [&#039;e&#039;],
    toUpper: true
  },
  f: {
    isDouble: true,
    doubleNotation: &#039;f&#039;
  },
  F: {
    extend: [&#039;f&#039;]
  },
  g: {
    isDouble: true,
    doubleNotation: &#039;g&#039;
  },
  G: {
    extend: [&#039;g&#039;],
    toUpper: true
  },
  O: {
    isObject: true
  },
};
Formatter.prototype.format = function(/*mixed...*/ filler){
  if(this._mapped &amp;&amp; typeof filler != &#039;object&#039;){
    throw new Error(&#039;format requires a mapping&#039;);
  }

  var str = &#039;&#039;;
  var position = 0;
  for(var i = 0, token; i &lt; this._tokens.length; i++){
    token = this._tokens[i];
    
    if(typeof token == &#039;string&#039;){
      str += token;
    }else{
      if(this._mapped){
        if(typeof filler[token.mapping] == &#039;undefined&#039;){
          throw new Error(&#039;missing key &#039; + token.mapping);
        }
        token.arg = filler[token.mapping];
      }else{
        if(token.intmapping){
          var position = parseInt(token.intmapping) - 1;
        }
        if(position &gt;= arguments.length){
          throw new Error(&#039;got &#039; + arguments.length + &#039; printf arguments, insufficient for \&#039;&#039; + this._format + &#039;\&#039;&#039;);
        }
        token.arg = arguments[position++];
      }

      if(!token.compiled){
        token.compiled = true;
        token.sign = &#039;&#039;;
        token.zeroPad = false;
        token.rightJustify = false;
        token.alternative = false;

        var flags = {};
        for(var fi = token.flags.length; fi--;){
          var flag = token.flags.charAt(fi);
          flags[flag] = true;
          switch(flag){
            case &#039; &#039;:
              token.sign = &#039; &#039;;
              break;
            case &#039;+&#039;:
              token.sign = &#039;+&#039;;
              break;
            case &#039;0&#039;:
              token.zeroPad = (flags[&#039;-&#039;]) ? false : true;
              break;
            case &#039;-&#039;:
              token.rightJustify = true;
              token.zeroPad = false;
              break;
            case &#039;#&#039;:
              token.alternative = true;
              break;
            default:
              throw Error(&#039;bad formatting flag \&#039;&#039; + token.flags.charAt(fi) + &#039;\&#039;&#039;);
          }
        }

        token.minWidth = (token._minWidth) ? parseInt(token._minWidth) : 0;
        token.maxWidth = -1;
        token.toUpper = false;
        token.isUnsigned = false;
        token.isInt = false;
        token.isDouble = false;
        token.isObject = false;
        token.precision = 1;
        if(token.period == &#039;.&#039;){
          if(token._precision){
            token.precision = parseInt(token._precision);
          }else{
            token.precision = 0;
          }
        }

        var mixins = this._specifiers[token.specifier];
        if(typeof mixins == &#039;undefined&#039;){
          throw new Error(&#039;unexpected specifier \&#039;&#039; + token.specifier + &#039;\&#039;&#039;);
        }
        if(mixins.extend){
          var s = this._specifiers[mixins.extend];
          for(var k in s){
            mixins[k] = s[k]
          }
          delete mixins.extend;
        }
        for(var k in mixins){
          token[k] = mixins[k];
        }
      }

      if(typeof token.setArg == &#039;function&#039;){
        token.setArg(token);
      }

      if(typeof token.setMaxWidth == &#039;function&#039;){
        token.setMaxWidth(token);
      }

      if(token._minWidth == &#039;*&#039;){
        if(this._mapped){
          throw new Error(&#039;* width not supported in mapped formats&#039;);
        }
        token.minWidth = parseInt(arguments[position++]);
        if(isNaN(token.minWidth)){
          throw new Error(&#039;the argument for * width at position &#039; + position + &#039; is not a number in &#039; + this._format);
        }
        // negative width means rightJustify
        if (token.minWidth &lt; 0) {
          token.rightJustify = true;
          token.minWidth = -token.minWidth;
        }
      }

      if(token._precision == &#039;*&#039; &amp;&amp; token.period == &#039;.&#039;){
        if(this._mapped){
          throw new Error(&#039;* precision not supported in mapped formats&#039;);
        }
        token.precision = parseInt(arguments[position++]);
        if(isNaN(token.precision)){
          throw Error(&#039;the argument for * precision at position &#039; + position + &#039; is not a number in &#039; + this._format);
        }
        // negative precision means unspecified
        if (token.precision &lt; 0) {
          token.precision = 1;
          token.period = &#039;&#039;;
        }
      }
      if(token.isInt){
        // a specified precision means no zero padding
        if(token.period == &#039;.&#039;){
          token.zeroPad = false;
        }
        this.formatInt(token);
      }else if(token.isDouble){
        if(token.period != &#039;.&#039;){
          token.precision = 6;
        }
        this.formatDouble(token); 
      }else if(token.isObject){
        this.formatObject(token);
      }
      this.fitField(token);

      str += &#039;&#039; + token.arg;
    }
  }

  return str;
};
Formatter.prototype._zeros10 = &#039;0000000000&#039;;
Formatter.prototype._spaces10 = &#039;          &#039;;
Formatter.prototype.formatInt = function(token) {
  var i = parseInt(token.arg);
  if(!isFinite(i)){ // isNaN(f) || f == Number.POSITIVE_INFINITY || f == Number.NEGATIVE_INFINITY)
    // allow this only if arg is number
    if(typeof token.arg != &#039;number&#039;){
      throw new Error(&#039;format argument \&#039;&#039; + token.arg + &#039;\&#039; not an integer; parseInt returned &#039; + i);
    }
    //return &#039;&#039; + i;
    i = 0;
  }

  // if not base 10, make negatives be positive
  // otherwise, (-10).toString(16) is &#039;-a&#039; instead of &#039;fffffff6&#039;
  if(i &lt; 0 &amp;&amp; (token.isUnsigned || token.base != 10)){
    i = 0xffffffff + i + 1;
  } 

  if(i &lt; 0){
    token.arg = (- i).toString(token.base);
    this.zeroPad(token);
    token.arg = &#039;-&#039; + token.arg;
  }else{
    token.arg = i.toString(token.base);
    // need to make sure that argument 0 with precision==0 is formatted as &#039;&#039;
    if(!i &amp;&amp; !token.precision){
      token.arg = &#039;&#039;;
    }else{
      this.zeroPad(token);
    }
    if(token.sign){
      token.arg = token.sign + token.arg;
    }
  }
  if(token.base == 16){
    if(token.alternative){
      token.arg = &#039;0x&#039; + token.arg;
    }
    token.arg = token.toUpper ? token.arg.toUpperCase() : token.arg.toLowerCase();
  }
  if(token.base == 8){
    if(token.alternative &amp;&amp; token.arg.charAt(0) != &#039;0&#039;){
      token.arg = &#039;0&#039; + token.arg;
    }
  }
};
Formatter.prototype.formatDouble = function(token) {
  var f = parseFloat(token.arg);
  if(!isFinite(f)){ // isNaN(f) || f == Number.POSITIVE_INFINITY || f == Number.NEGATIVE_INFINITY)
    // allow this only if arg is number
    if(typeof token.arg != &#039;number&#039;){
      throw new Error(&#039;format argument \&#039;&#039; + token.arg + &#039;\&#039; not a float; parseFloat returned &#039; + f);
    }
    // C99 says that for &#039;f&#039;:
    //   infinity -&gt; &#039;[-]inf&#039; or &#039;[-]infinity&#039; (&#039;[-]INF&#039; or &#039;[-]INFINITY&#039; for &#039;F&#039;)
    //   NaN -&gt; a string  starting with &#039;nan&#039; (&#039;NAN&#039; for &#039;F&#039;)
    // this is not commonly implemented though.
    //return &#039;&#039; + f;
    f = 0;
  }

  switch(token.doubleNotation) {
    case &#039;e&#039;: {
      token.arg = f.toExponential(token.precision); 
      break;
    }
    case &#039;f&#039;: {
      token.arg = f.toFixed(token.precision); 
      break;
    }
    case &#039;g&#039;: {
      // C says use &#039;e&#039; notation if exponent is &lt; -4 or is &gt;= prec
      // ECMAScript for toPrecision says use exponential notation if exponent is &gt;= prec,
      // though step 17 of toPrecision indicates a test for &lt; -6 to force exponential.
      if(Math.abs(f) &lt; 0.0001){
        //print(&#039;forcing exponential notation for f=&#039; + f);
        token.arg = f.toExponential(token.precision &gt; 0 ? token.precision - 1 : token.precision);
      }else{
        token.arg = f.toPrecision(token.precision); 
      }

      // In C, unlike &#039;f&#039;, &#039;gG&#039; removes trailing 0s from fractional part, unless alternative format flag (&#039;#&#039;).
      // But ECMAScript formats toPrecision as 0.00100000. So remove trailing 0s.
      if(!token.alternative){ 
        //print(&#039;replacing trailing 0 in \&#039;&#039; + s + &#039;\&#039;&#039;);
        token.arg = token.arg.replace(/(\..*[^0])0*e/, &#039;$1e&#039;);
        // if fractional part is entirely 0, remove it and decimal point
        token.arg = token.arg.replace(/\.0*e/, &#039;e&#039;).replace(/\.0$/,&#039;&#039;);
      }
      break;
    }
    default: throw new Error(&#039;unexpected double notation \&#039;&#039; + token.doubleNotation + &#039;\&#039;&#039;);
  }

  // C says that exponent must have at least two digits.
  // But ECMAScript does not; toExponential results in things like &#039;1.000000e-8&#039; and &#039;1.000000e+8&#039;.
  // Note that s.replace(/e([\+\-])(\d)/, &#039;e$10$2&#039;) won&#039;t work because of the &#039;$10&#039; instead of &#039;$1&#039;.
  // And replace(re, func) isn&#039;t supported on IE50 or Safari1.
  token.arg = token.arg.replace(/e\+(\d)$/, &#039;e+0$1&#039;).replace(/e\-(\d)$/, &#039;e-0$1&#039;);

  // if alt, ensure a decimal point
  if(token.alternative){
    token.arg = token.arg.replace(/^(\d+)$/,&#039;$1.&#039;);
    token.arg = token.arg.replace(/^(\d+)e/,&#039;$1.e&#039;);
  }

  if(f &gt;= 0 &amp;&amp; token.sign){
    token.arg = token.sign + token.arg;
  }

  token.arg = token.toUpper ? token.arg.toUpperCase() : token.arg.toLowerCase();
};
Formatter.prototype.formatObject = function(token) {
  // If no precision is specified, then reset it to null (infinite depth).
  var precision = (token.period === &#039;.&#039;) ? token.precision : null;
  token.arg = util.inspect(token.arg, !token.alternative, precision);
};
Formatter.prototype.zeroPad = function(token, /*Int*/ length) {
  length = (arguments.length == 2) ? length : token.precision;
  var negative = false;
  if(typeof token.arg != &quot;string&quot;){
    token.arg = &quot;&quot; + token.arg;
  }
  if (token.arg.substr(0,1) === &#039;-&#039;) {
    negative = true;
    token.arg = token.arg.substr(1);
  }

  var tenless = length - 10;
  while(token.arg.length &lt; tenless){
    token.arg = (token.rightJustify) ? token.arg + this._zeros10 : this._zeros10 + token.arg;
  }
  var pad = length - token.arg.length;
  token.arg = (token.rightJustify) ? token.arg + this._zeros10.substring(0, pad) : this._zeros10.substring(0, pad) + token.arg;
  if (negative) token.arg = &#039;-&#039; + token.arg;
};
Formatter.prototype.fitField = function(token) {
  if(token.maxWidth &gt;= 0 &amp;&amp; token.arg.length &gt; token.maxWidth){
    return token.arg.substring(0, token.maxWidth);
  }
  if(token.zeroPad){
    this.zeroPad(token, token.minWidth);
    return;
  }
  this.spacePad(token);
};
Formatter.prototype.spacePad = function(token, /*Int*/ length) {
  length = (arguments.length == 2) ? length : token.minWidth;
  if(typeof token.arg != &#039;string&#039;){
    token.arg = &#039;&#039; + token.arg;
  }
  var tenless = length - 10;
  while(token.arg.length &lt; tenless){
    token.arg = (token.rightJustify) ? token.arg + this._spaces10 : this._spaces10 + token.arg;
  }
  var pad = length - token.arg.length;
  token.arg = (token.rightJustify) ? token.arg + this._spaces10.substring(0, pad) : this._spaces10.substring(0, pad) + token.arg;
};


module.exports = function(){
  var args = Array.prototype.slice.call(arguments),
    stream, format;
  if(args[0] instanceof require(&#039;stream&#039;).Stream){
    stream = args.shift();
  }
  format = args.shift();
  var formatter = new Formatter(format);
  var string = formatter.format.apply(formatter, args);
  if(stream){
    stream.write(string);
  }else{
    return string;
  }
};

module.exports.Formatter = Formatter;</textarea>
  </div>
</div>

<footer class="footer">
  <div class="container">
    <p>.</p>
  </div>
</footer>

<script type="text/html" id="complexity-popover-template">
  <div class="complexity-notice">
    Complexity : {{ complexity.cyclomatic }} <br>
    Length : {{ complexity.halstead.length }} <br>
    Difficulty : {{ complexity.halstead.difficulty.toFixed(2) }} <br>
    Est # bugs : {{ complexity.halstead.bugs.toFixed(2) }}<br>
  </div>
</script>

<script type="text/javascript" src="../../assets/scripts/bundles/core-bundle.js"></script>
<script type="text/javascript" src="../../assets/scripts/bundles/codemirror.js"></script>
<script type="text/javascript" src="../../assets/scripts/codemirror.markpopovertext.js"></script>
<script type="text/javascript" src="report.js"></script>
<script type="text/javascript" src="report.history.js"></script>
<script type="text/javascript" src="../../assets/scripts/plato-file.js"></script>
</body>
</html>
