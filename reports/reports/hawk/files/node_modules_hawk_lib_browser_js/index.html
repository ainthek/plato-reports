<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Plato - node_modules/hawk/lib/browser.js</title>

  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="">
  <meta name="author" content="">

  <!--[if lt IE 9]>
  <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->

  <link href="../../assets/css/vendor/morris.css" rel="stylesheet">
  <link href="../../assets/css/vendor/bootstrap.css" rel="stylesheet">
  <link href="../../assets/css/vendor/font-awesome.css" rel="stylesheet">
  <link href="../../assets/css/vendor/codemirror.css" rel="stylesheet">
  <link href="../../assets/css/plato.css" rel="stylesheet">
  <link href="../../assets/css/plato-file.css" rel="stylesheet">

</head>

<body>

<div class="navbar navbar-fixed-top">
  <div class="container">
    <a class="navbar-brand" href="http://github.com/es-analysis/plato">Plato on Github</a>
    <ul class="nav navbar-nav">
      <li>
        <a href="../../index.html">Report Home</a>
      </li>
    </ul>
  </div>
</div>

<div class="jumbotron">
  <div class="container">
    <h1>node_modules/hawk/lib/browser.js</h1>
  </div>
</div>

<div class="container aggregate-stats">
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Maintainability <a href="http://blogs.msdn.com/b/codeanalysis/archive/2007/11/20/maintainability-index-range-and-meaning.aspx"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="A value between 0 and 100 that represents the relative ease of maintaining the code. A high value means better maintainability." data-original-title="Maintainability Index"  data-container="body"></i></a></h2>
      <p class="stat">63.83</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Lines of code <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h2>
      <p class="stat">630</p>
    </div>
  </div>
  <div class="row historical">
    <div class="col-md-6">
      <p id="chart_historical_maint" class="chart"></p>
    </div>
    <div class="col-md-6">
      <p id="chart_historical_sloc" class="chart"></p>
    </div>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Difficulty  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="The difficulty measure is related to the difficulty of the program to write or understand." data-original-title="Difficulty" data-container="body"></i></a></h2>
      <p class="stat">165.16</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Estimated Errors  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Halstead's delivered bugs is an estimate for the number of errors in the implementation." data-original-title="Delivered Bugs" data-container="body"></i></a></h2>
      <p class="stat">13.52</p>
    </div>
  </div>
</div>

<div class="container charts">
  <div class="row">
    <h2 class="header">Function weight</h2>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h3 class="chart-header">By Complexity <a href="http://en.wikipedia.org/wiki/Cyclomatic_complexity"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="This metric counts the number of distinct paths through a block of code. Lower values are better." data-original-title="Cyclomatic Complexity" data-container="body"></i></a></h3>
      <div id="fn-by-complexity" class="stat"></div>
    </div>
    <div class="col-md-6">
      <h3 class="chart-header">By SLOC  <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h3>
      <div id="fn-by-sloc" class="stat"></div>
    </div>
  </div>
</div>

<div class="container">
  <div class="row">
    <textarea id="file-source" class="col-md-12">/*
    HTTP Hawk Authentication Scheme
    Copyright (c) 2012-2014, Eran Hammer &lt;eran@hammer.io&gt;
    BSD Licensed
*/


// Declare namespace

var hawk = {
    internals: {}
};


hawk.client = {

    // Generate an Authorization header for a given request

    /*
        uri: &#039;http://example.com/resource?a=b&#039; or object generated by hawk.utils.parseUri()
        method: HTTP verb (e.g. &#039;GET&#039;, &#039;POST&#039;)
        options: {

            // Required

            credentials: {
                id: &#039;dh37fgj492je&#039;,
                key: &#039;aoijedoaijsdlaksjdl&#039;,
                algorithm: &#039;sha256&#039;                                 // &#039;sha1&#039;, &#039;sha256&#039;
            },

            // Optional

            ext: &#039;application-specific&#039;,                        // Application specific data sent via the ext attribute
            timestamp: Date.now() / 1000,                       // A pre-calculated timestamp in seconds
            nonce: &#039;2334f34f&#039;,                                  // A pre-generated nonce
            localtimeOffsetMsec: 400,                           // Time offset to sync with server time (ignored if timestamp provided)
            payload: &#039;{&quot;some&quot;:&quot;payload&quot;}&#039;,                      // UTF-8 encoded string for body hash generation (ignored if hash provided)
            contentType: &#039;application/json&#039;,                    // Payload content-type (ignored if hash provided)
            hash: &#039;U4MKKSmiVxk37JCCrAVIjV=&#039;,                    // Pre-calculated payload hash
            app: &#039;24s23423f34dx&#039;,                               // Oz application id
            dlg: &#039;234sz34tww3sd&#039;                                // Oz delegated-by application id
        }
    */

    header: function (uri, method, options) {

        var result = {
            field: &#039;&#039;,
            artifacts: {}
        };

        // Validate inputs

        if (!uri || (typeof uri !== &#039;string&#039; &amp;&amp; typeof uri !== &#039;object&#039;) ||
            !method || typeof method !== &#039;string&#039; ||
            !options || typeof options !== &#039;object&#039;) {

            result.err = &#039;Invalid argument type&#039;;
            return result;
        }

        // Application time

        var timestamp = options.timestamp || hawk.utils.now(options.localtimeOffsetMsec);

        // Validate credentials

        var credentials = options.credentials;
        if (!credentials ||
            !credentials.id ||
            !credentials.key ||
            !credentials.algorithm) {

            result.err = &#039;Invalid credentials object&#039;;
            return result;
        }

        if (hawk.crypto.algorithms.indexOf(credentials.algorithm) === -1) {
            result.err = &#039;Unknown algorithm&#039;;
            return result;
        }

        // Parse URI

        if (typeof uri === &#039;string&#039;) {
            uri = hawk.utils.parseUri(uri);
        }

        // Calculate signature

        var artifacts = {
            ts: timestamp,
            nonce: options.nonce || hawk.utils.randomString(6),
            method: method,
            resource: uri.relative,
            host: uri.hostname,
            port: uri.port,
            hash: options.hash,
            ext: options.ext,
            app: options.app,
            dlg: options.dlg
        };

        result.artifacts = artifacts;

        // Calculate payload hash

        if (!artifacts.hash &amp;&amp;
            (options.payload || options.payload === &#039;&#039;)) {

            artifacts.hash = hawk.crypto.calculatePayloadHash(options.payload, credentials.algorithm, options.contentType);
        }

        var mac = hawk.crypto.calculateMac(&#039;header&#039;, credentials, artifacts);

        // Construct header

        var hasExt = artifacts.ext !== null &amp;&amp; artifacts.ext !== undefined &amp;&amp; artifacts.ext !== &#039;&#039;;       // Other falsey values allowed
        var header = &#039;Hawk id=&quot;&#039; + credentials.id +
                     &#039;&quot;, ts=&quot;&#039; + artifacts.ts +
                     &#039;&quot;, nonce=&quot;&#039; + artifacts.nonce +
                     (artifacts.hash ? &#039;&quot;, hash=&quot;&#039; + artifacts.hash : &#039;&#039;) +
                     (hasExt ? &#039;&quot;, ext=&quot;&#039; + hawk.utils.escapeHeaderAttribute(artifacts.ext) : &#039;&#039;) +
                     &#039;&quot;, mac=&quot;&#039; + mac + &#039;&quot;&#039;;

        if (artifacts.app) {
            header += &#039;, app=&quot;&#039; + artifacts.app +
                      (artifacts.dlg ? &#039;&quot;, dlg=&quot;&#039; + artifacts.dlg : &#039;&#039;) + &#039;&quot;&#039;;
        }

        result.field = header;

        return result;
    },

    // Generate a bewit value for a given URI

    /*
        uri: &#039;http://example.com/resource?a=b&#039;
        options: {

            // Required

            credentials: {
            id: &#039;dh37fgj492je&#039;,
            key: &#039;aoijedoaijsdlaksjdl&#039;,
            algorithm: &#039;sha256&#039;                             // &#039;sha1&#039;, &#039;sha256&#039;
            },
            ttlSec: 60 * 60,                                    // TTL in seconds

            // Optional

            ext: &#039;application-specific&#039;,                        // Application specific data sent via the ext attribute
            localtimeOffsetMsec: 400                            // Time offset to sync with server time
         };
    */

    bewit: function (uri, options) {

        // Validate inputs

        if (!uri ||
            (typeof uri !== &#039;string&#039;) ||
            !options ||
            typeof options !== &#039;object&#039; ||
            !options.ttlSec) {

            return &#039;&#039;;
        }

        options.ext = (options.ext === null || options.ext === undefined ? &#039;&#039; : options.ext);       // Zero is valid value

        // Application time

        var now = hawk.utils.now(options.localtimeOffsetMsec);

        // Validate credentials

        var credentials = options.credentials;
        if (!credentials ||
            !credentials.id ||
            !credentials.key ||
            !credentials.algorithm) {

            return &#039;&#039;;
        }

        if (hawk.crypto.algorithms.indexOf(credentials.algorithm) === -1) {
            return &#039;&#039;;
        }

        // Parse URI

        uri = hawk.utils.parseUri(uri);

        // Calculate signature

        var exp = now + options.ttlSec;
        var mac = hawk.crypto.calculateMac(&#039;bewit&#039;, credentials, {
            ts: exp,
            nonce: &#039;&#039;,
            method: &#039;GET&#039;,
            resource: uri.relative,                            // Maintain trailing &#039;?&#039; and query params
            host: uri.hostname,
            port: uri.port,
            ext: options.ext
        });

        // Construct bewit: id\exp\mac\ext

        var bewit = credentials.id + &#039;\\&#039; + exp + &#039;\\&#039; + mac + &#039;\\&#039; + options.ext;
        return hawk.utils.base64urlEncode(bewit);
    },

    // Validate server response

    /*
        request:    object created via &#039;new XMLHttpRequest()&#039; after response received
        artifacts:  object received from header().artifacts
        options: {
            payload:    optional payload received
            required:   specifies if a Server-Authorization header is required. Defaults to &#039;false&#039;
        }
    */

    authenticate: function (request, credentials, artifacts, options) {

        options = options || {};

        var getHeader = function (name) {

            return request.getResponseHeader ? request.getResponseHeader(name) : request.getHeader(name);
        };

        var wwwAuthenticate = getHeader(&#039;www-authenticate&#039;);
        if (wwwAuthenticate) {

            // Parse HTTP WWW-Authenticate header

            var attributes = hawk.utils.parseAuthorizationHeader(wwwAuthenticate, [&#039;ts&#039;, &#039;tsm&#039;, &#039;error&#039;]);
            if (!attributes) {
                return false;
            }

            if (attributes.ts) {
                var tsm = hawk.crypto.calculateTsMac(attributes.ts, credentials);
                if (tsm !== attributes.tsm) {
                    return false;
                }

                hawk.utils.setNtpOffset(attributes.ts - Math.floor((new Date()).getTime() / 1000));     // Keep offset at 1 second precision
            }
        }

        // Parse HTTP Server-Authorization header

        var serverAuthorization = getHeader(&#039;server-authorization&#039;);
        if (!serverAuthorization &amp;&amp;
            !options.required) {

            return true;
        }

        var attributes = hawk.utils.parseAuthorizationHeader(serverAuthorization, [&#039;mac&#039;, &#039;ext&#039;, &#039;hash&#039;]);
        if (!attributes) {
            return false;
        }

        var modArtifacts = {
            ts: artifacts.ts,
            nonce: artifacts.nonce,
            method: artifacts.method,
            resource: artifacts.resource,
            host: artifacts.host,
            port: artifacts.port,
            hash: attributes.hash,
            ext: attributes.ext,
            app: artifacts.app,
            dlg: artifacts.dlg
        };

        var mac = hawk.crypto.calculateMac(&#039;response&#039;, credentials, modArtifacts);
        if (mac !== attributes.mac) {
            return false;
        }

        if (!options.payload &amp;&amp;
            options.payload !== &#039;&#039;) {

            return true;
        }

        if (!attributes.hash) {
            return false;
        }

        var calculatedHash = hawk.crypto.calculatePayloadHash(options.payload, credentials.algorithm, getHeader(&#039;content-type&#039;));
        return (calculatedHash === attributes.hash);
    },

    message: function (host, port, message, options) {

        // Validate inputs

        if (!host || typeof host !== &#039;string&#039; ||
            !port || typeof port !== &#039;number&#039; ||
            message === null || message === undefined || typeof message !== &#039;string&#039; ||
            !options || typeof options !== &#039;object&#039;) {

            return null;
        }

        // Application time

        var timestamp = options.timestamp || hawk.utils.now(options.localtimeOffsetMsec);

        // Validate credentials

        var credentials = options.credentials;
        if (!credentials ||
            !credentials.id ||
            !credentials.key ||
            !credentials.algorithm) {

            // Invalid credential object
            return null;
        }

        if (hawk.crypto.algorithms.indexOf(credentials.algorithm) === -1) {
            return null;
        }

        // Calculate signature

        var artifacts = {
            ts: timestamp,
            nonce: options.nonce || hawk.utils.randomString(6),
            host: host,
            port: port,
            hash: hawk.crypto.calculatePayloadHash(message, credentials.algorithm)
        };

        // Construct authorization

        var result = {
            id: credentials.id,
            ts: artifacts.ts,
            nonce: artifacts.nonce,
            hash: artifacts.hash,
            mac: hawk.crypto.calculateMac(&#039;message&#039;, credentials, artifacts)
        };

        return result;
    },

    authenticateTimestamp: function (message, credentials, updateClock) {           // updateClock defaults to true

        var tsm = hawk.crypto.calculateTsMac(message.ts, credentials);
        if (tsm !== message.tsm) {
            return false;
        }

        if (updateClock !== false) {
            hawk.utils.setNtpOffset(message.ts - Math.floor((new Date()).getTime() / 1000));    // Keep offset at 1 second precision
        }

        return true;
    }
};


hawk.crypto = {

    headerVersion: &#039;1&#039;,

    algorithms: [&#039;sha1&#039;, &#039;sha256&#039;],

    calculateMac: function (type, credentials, options) {

        var normalized = hawk.crypto.generateNormalizedString(type, options);

        var hmac = CryptoJS[&#039;Hmac&#039; + credentials.algorithm.toUpperCase()](normalized, credentials.key);
        return hmac.toString(CryptoJS.enc.Base64);
    },

    generateNormalizedString: function (type, options) {

        var normalized = &#039;hawk.&#039; + hawk.crypto.headerVersion + &#039;.&#039; + type + &#039;\n&#039; +
                         options.ts + &#039;\n&#039; +
                         options.nonce + &#039;\n&#039; +
                         (options.method || &#039;&#039;).toUpperCase() + &#039;\n&#039; +
                         (options.resource || &#039;&#039;) + &#039;\n&#039; +
                         options.host.toLowerCase() + &#039;\n&#039; +
                         options.port + &#039;\n&#039; +
                         (options.hash || &#039;&#039;) + &#039;\n&#039;;

        if (options.ext) {
            normalized += options.ext.replace(&#039;\\&#039;, &#039;\\\\&#039;).replace(&#039;\n&#039;, &#039;\\n&#039;);
        }

        normalized += &#039;\n&#039;;

        if (options.app) {
            normalized += options.app + &#039;\n&#039; +
                          (options.dlg || &#039;&#039;) + &#039;\n&#039;;
        }

        return normalized;
    },

    calculatePayloadHash: function (payload, algorithm, contentType) {

        var hash = CryptoJS.algo[algorithm.toUpperCase()].create();
        hash.update(&#039;hawk.&#039; + hawk.crypto.headerVersion + &#039;.payload\n&#039;);
        hash.update(hawk.utils.parseContentType(contentType) + &#039;\n&#039;);
        hash.update(payload);
        hash.update(&#039;\n&#039;);
        return hash.finalize().toString(CryptoJS.enc.Base64);
    },

    calculateTsMac: function (ts, credentials) {

        var hash = CryptoJS[&#039;Hmac&#039; + credentials.algorithm.toUpperCase()](&#039;hawk.&#039; + hawk.crypto.headerVersion + &#039;.ts\n&#039; + ts + &#039;\n&#039;, credentials.key);
        return hash.toString(CryptoJS.enc.Base64);
    }
};


// localStorage compatible interface

hawk.internals.LocalStorage = function () {

    this._cache = {};
    this.length = 0;

    this.getItem = function (key) {

        return this._cache.hasOwnProperty(key) ? String(this._cache[key]) : null;
    };

    this.setItem = function (key, value) {

        this._cache[key] = String(value);
        this.length = Object.keys(this._cache).length;
    };

    this.removeItem = function (key) {

        delete this._cache[key];
        this.length = Object.keys(this._cache).length;
    };

    this.clear = function () {

        this._cache = {};
        this.length = 0;
    };

    this.key = function (i) {

        return Object.keys(this._cache)[i || 0];
    };
};


hawk.utils = {

    storage: new hawk.internals.LocalStorage(),

    setStorage: function (storage) {

        var ntpOffset = hawk.utils.storage.getItem(&#039;hawk_ntp_offset&#039;);
        hawk.utils.storage = storage;
        if (ntpOffset) {
            hawk.utils.setNtpOffset(ntpOffset);
        }
    },

    setNtpOffset: function (offset) {

        try {
            hawk.utils.storage.setItem(&#039;hawk_ntp_offset&#039;, offset);
        }
        catch (err) {
            console.error(&#039;[hawk] could not write to storage.&#039;);
            console.error(err);
        }
    },

    getNtpOffset: function () {

        var offset = hawk.utils.storage.getItem(&#039;hawk_ntp_offset&#039;);
        if (!offset) {
            return 0;
        }

        return parseInt(offset, 10);
    },

    now: function (localtimeOffsetMsec) {

        return Math.floor(((new Date()).getTime() + (localtimeOffsetMsec || 0)) / 1000) + hawk.utils.getNtpOffset();
    },

    escapeHeaderAttribute: function (attribute) {

        return attribute.replace(/\\/g, &#039;\\\\&#039;).replace(/\&quot;/g, &#039;\\&quot;&#039;);
    },

    parseContentType: function (header) {

        if (!header) {
            return &#039;&#039;;
        }

        return header.split(&#039;;&#039;)[0].replace(/^\s+|\s+$/g, &#039;&#039;).toLowerCase();
    },

    parseAuthorizationHeader: function (header, keys) {

        if (!header) {
            return null;
        }

        var headerParts = header.match(/^(\w+)(?:\s+(.*))?$/);       // Header: scheme[ something]
        if (!headerParts) {
            return null;
        }

        var scheme = headerParts[1];
        if (scheme.toLowerCase() !== &#039;hawk&#039;) {
            return null;
        }

        var attributesString = headerParts[2];
        if (!attributesString) {
            return null;
        }

        var attributes = {};
        var verify = attributesString.replace(/(\w+)=&quot;([^&quot;\\]*)&quot;\s*(?:,\s*|$)/g, function ($0, $1, $2) {

            // Check valid attribute names

            if (keys.indexOf($1) === -1) {
                return;
            }

            // Allowed attribute value characters: !#$%&amp;&#039;()*+,-./:;&lt;=&gt;?@[]^_`{|}~ and space, a-z, A-Z, 0-9

            if ($2.match(/^[ \w\!#\$%&amp;&#039;\(\)\*\+,\-\.\/\:;&lt;\=&gt;\?@\[\]\^`\{\|\}~]+$/) === null) {
                return;
            }

            // Check for duplicates

            if (attributes.hasOwnProperty($1)) {
                return;
            }

            attributes[$1] = $2;
            return &#039;&#039;;
        });

        if (verify !== &#039;&#039;) {
            return null;
        }

        return attributes;
    },

    randomString: function (size) {

        var randomSource = &#039;abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789&#039;;
        var len = randomSource.length;

        var result = [];
        for (var i = 0; i &lt; size; ++i) {
            result[i] = randomSource[Math.floor(Math.random() * len)];
        }

        return result.join(&#039;&#039;);
    },

    parseUri: function (input) {

        // Based on: parseURI 1.2.2
        // http://blog.stevenlevithan.com/archives/parseuri
        // (c) Steven Levithan &lt;stevenlevithan.com&gt;
        // MIT License

        var keys = [&#039;source&#039;, &#039;protocol&#039;, &#039;authority&#039;, &#039;userInfo&#039;, &#039;user&#039;, &#039;password&#039;, &#039;hostname&#039;, &#039;port&#039;, &#039;resource&#039;, &#039;relative&#039;, &#039;pathname&#039;, &#039;directory&#039;, &#039;file&#039;, &#039;query&#039;, &#039;fragment&#039;];

        var uriRegex = /^(?:([^:\/?#]+):)?(?:\/\/((?:(([^:@]*)(?::([^:@]*))?)?@)?([^:\/?#]*)(?::(\d*))?))?(((((?:[^?#\/]*\/)*)([^?#]*))(?:\?([^#]*))?)(?:#(.*))?)/;
        var uriByNumber = input.match(uriRegex);
        var uri = {};

        for (var i = 0, il = keys.length; i &lt; il; ++i) {
            uri[keys[i]] = uriByNumber[i] || &#039;&#039;;
        }

        if (uri.port === &#039;&#039;) {
            uri.port = (uri.protocol.toLowerCase() === &#039;http&#039; ? &#039;80&#039; : (uri.protocol.toLowerCase() === &#039;https&#039; ? &#039;443&#039; : &#039;&#039;));
        }

        return uri;
    },

    base64urlEncode: function (value) {

        var wordArray = CryptoJS.enc.Utf8.parse(value);
        var encoded = CryptoJS.enc.Base64.stringify(wordArray);
        return encoded.replace(/\+/g, &#039;-&#039;).replace(/\//g, &#039;_&#039;).replace(/\=/g, &#039;&#039;);
    }
};


// $lab:coverage:off$

// Based on: Crypto-JS v3.1.2
// Copyright (c) 2009-2013, Jeff Mott. All rights reserved.
// http://code.google.com/p/crypto-js/
// http://code.google.com/p/crypto-js/wiki/License

var CryptoJS = CryptoJS || function (h, r) { var k = {}, l = k.lib = {}, n = function () { }, f = l.Base = { extend: function (a) { n.prototype = this; var b = new n; a &amp;&amp; b.mixIn(a); b.hasOwnProperty(&quot;init&quot;) || (b.init = function () { b.$super.init.apply(this, arguments) }); b.init.prototype = b; b.$super = this; return b }, create: function () { var a = this.extend(); a.init.apply(a, arguments); return a }, init: function () { }, mixIn: function (a) { for (var b in a) a.hasOwnProperty(b) &amp;&amp; (this[b] = a[b]); a.hasOwnProperty(&quot;toString&quot;) &amp;&amp; (this.toString = a.toString) }, clone: function () { return this.init.prototype.extend(this) } }, j = l.WordArray = f.extend({ init: function (a, b) { a = this.words = a || []; this.sigBytes = b != r ? b : 4 * a.length }, toString: function (a) { return (a || s).stringify(this) }, concat: function (a) { var b = this.words, d = a.words, c = this.sigBytes; a = a.sigBytes; this.clamp(); if (c % 4) for (var e = 0; e &lt; a; e++) b[c + e &gt;&gt;&gt; 2] |= (d[e &gt;&gt;&gt; 2] &gt;&gt;&gt; 24 - 8 * (e % 4) &amp; 255) &lt;&lt; 24 - 8 * ((c + e) % 4); else if (65535 &lt; d.length) for (e = 0; e &lt; a; e += 4) b[c + e &gt;&gt;&gt; 2] = d[e &gt;&gt;&gt; 2]; else b.push.apply(b, d); this.sigBytes += a; return this }, clamp: function () { var a = this.words, b = this.sigBytes; a[b &gt;&gt;&gt; 2] &amp;= 4294967295 &lt;&lt; 32 - 8 * (b % 4); a.length = h.ceil(b / 4) }, clone: function () { var a = f.clone.call(this); a.words = this.words.slice(0); return a }, random: function (a) { for (var b = [], d = 0; d &lt; a; d += 4) b.push(4294967296 * h.random() | 0); return new j.init(b, a) } }), m = k.enc = {}, s = m.Hex = { stringify: function (a) { var b = a.words; a = a.sigBytes; for (var d = [], c = 0; c &lt; a; c++) { var e = b[c &gt;&gt;&gt; 2] &gt;&gt;&gt; 24 - 8 * (c % 4) &amp; 255; d.push((e &gt;&gt;&gt; 4).toString(16)); d.push((e &amp; 15).toString(16)) } return d.join(&quot;&quot;) }, parse: function (a) { for (var b = a.length, d = [], c = 0; c &lt; b; c += 2) d[c &gt;&gt;&gt; 3] |= parseInt(a.substr(c, 2), 16) &lt;&lt; 24 - 4 * (c % 8); return new j.init(d, b / 2) } }, p = m.Latin1 = { stringify: function (a) { var b = a.words; a = a.sigBytes; for (var d = [], c = 0; c &lt; a; c++) d.push(String.fromCharCode(b[c &gt;&gt;&gt; 2] &gt;&gt;&gt; 24 - 8 * (c % 4) &amp; 255)); return d.join(&quot;&quot;) }, parse: function (a) { for (var b = a.length, d = [], c = 0; c &lt; b; c++) d[c &gt;&gt;&gt; 2] |= (a.charCodeAt(c) &amp; 255) &lt;&lt; 24 - 8 * (c % 4); return new j.init(d, b) } }, t = m.Utf8 = { stringify: function (a) { try { return decodeURIComponent(escape(p.stringify(a))) } catch (b) { throw Error(&quot;Malformed UTF-8 data&quot;); } }, parse: function (a) { return p.parse(unescape(encodeURIComponent(a))) } }, q = l.BufferedBlockAlgorithm = f.extend({ reset: function () { this._data = new j.init; this._nDataBytes = 0 }, _append: function (a) { &quot;string&quot; == typeof a &amp;&amp; (a = t.parse(a)); this._data.concat(a); this._nDataBytes += a.sigBytes }, _process: function (a) { var b = this._data, d = b.words, c = b.sigBytes, e = this.blockSize, f = c / (4 * e), f = a ? h.ceil(f) : h.max((f | 0) - this._minBufferSize, 0); a = f * e; c = h.min(4 * a, c); if (a) { for (var g = 0; g &lt; a; g += e) this._doProcessBlock(d, g); g = d.splice(0, a); b.sigBytes -= c } return new j.init(g, c) }, clone: function () { var a = f.clone.call(this); a._data = this._data.clone(); return a }, _minBufferSize: 0 }); l.Hasher = q.extend({ cfg: f.extend(), init: function (a) { this.cfg = this.cfg.extend(a); this.reset() }, reset: function () { q.reset.call(this); this._doReset() }, update: function (a) { this._append(a); this._process(); return this }, finalize: function (a) { a &amp;&amp; this._append(a); return this._doFinalize() }, blockSize: 16, _createHelper: function (a) { return function (b, d) { return (new a.init(d)).finalize(b) } }, _createHmacHelper: function (a) { return function (b, d) { return (new u.HMAC.init(a, d)).finalize(b) } } }); var u = k.algo = {}; return k }(Math);
(function () { var k = CryptoJS, b = k.lib, m = b.WordArray, l = b.Hasher, d = [], b = k.algo.SHA1 = l.extend({ _doReset: function () { this._hash = new m.init([1732584193, 4023233417, 2562383102, 271733878, 3285377520]) }, _doProcessBlock: function (n, p) { for (var a = this._hash.words, e = a[0], f = a[1], h = a[2], j = a[3], b = a[4], c = 0; 80 &gt; c; c++) { if (16 &gt; c) d[c] = n[p + c] | 0; else { var g = d[c - 3] ^ d[c - 8] ^ d[c - 14] ^ d[c - 16]; d[c] = g &lt;&lt; 1 | g &gt;&gt;&gt; 31 } g = (e &lt;&lt; 5 | e &gt;&gt;&gt; 27) + b + d[c]; g = 20 &gt; c ? g + ((f &amp; h | ~f &amp; j) + 1518500249) : 40 &gt; c ? g + ((f ^ h ^ j) + 1859775393) : 60 &gt; c ? g + ((f &amp; h | f &amp; j | h &amp; j) - 1894007588) : g + ((f ^ h ^ j) - 899497514); b = j; j = h; h = f &lt;&lt; 30 | f &gt;&gt;&gt; 2; f = e; e = g } a[0] = a[0] + e | 0; a[1] = a[1] + f | 0; a[2] = a[2] + h | 0; a[3] = a[3] + j | 0; a[4] = a[4] + b | 0 }, _doFinalize: function () { var b = this._data, d = b.words, a = 8 * this._nDataBytes, e = 8 * b.sigBytes; d[e &gt;&gt;&gt; 5] |= 128 &lt;&lt; 24 - e % 32; d[(e + 64 &gt;&gt;&gt; 9 &lt;&lt; 4) + 14] = Math.floor(a / 4294967296); d[(e + 64 &gt;&gt;&gt; 9 &lt;&lt; 4) + 15] = a; b.sigBytes = 4 * d.length; this._process(); return this._hash }, clone: function () { var b = l.clone.call(this); b._hash = this._hash.clone(); return b } }); k.SHA1 = l._createHelper(b); k.HmacSHA1 = l._createHmacHelper(b) })();
(function (k) { for (var g = CryptoJS, h = g.lib, v = h.WordArray, j = h.Hasher, h = g.algo, s = [], t = [], u = function (q) { return 4294967296 * (q - (q | 0)) | 0 }, l = 2, b = 0; 64 &gt; b;) { var d; a: { d = l; for (var w = k.sqrt(d), r = 2; r &lt;= w; r++) if (!(d % r)) { d = !1; break a } d = !0 } d &amp;&amp; (8 &gt; b &amp;&amp; (s[b] = u(k.pow(l, 0.5))), t[b] = u(k.pow(l, 1 / 3)), b++); l++ } var n = [], h = h.SHA256 = j.extend({ _doReset: function () { this._hash = new v.init(s.slice(0)) }, _doProcessBlock: function (q, h) { for (var a = this._hash.words, c = a[0], d = a[1], b = a[2], k = a[3], f = a[4], g = a[5], j = a[6], l = a[7], e = 0; 64 &gt; e; e++) { if (16 &gt; e) n[e] = q[h + e] | 0; else { var m = n[e - 15], p = n[e - 2]; n[e] = ((m &lt;&lt; 25 | m &gt;&gt;&gt; 7) ^ (m &lt;&lt; 14 | m &gt;&gt;&gt; 18) ^ m &gt;&gt;&gt; 3) + n[e - 7] + ((p &lt;&lt; 15 | p &gt;&gt;&gt; 17) ^ (p &lt;&lt; 13 | p &gt;&gt;&gt; 19) ^ p &gt;&gt;&gt; 10) + n[e - 16] } m = l + ((f &lt;&lt; 26 | f &gt;&gt;&gt; 6) ^ (f &lt;&lt; 21 | f &gt;&gt;&gt; 11) ^ (f &lt;&lt; 7 | f &gt;&gt;&gt; 25)) + (f &amp; g ^ ~f &amp; j) + t[e] + n[e]; p = ((c &lt;&lt; 30 | c &gt;&gt;&gt; 2) ^ (c &lt;&lt; 19 | c &gt;&gt;&gt; 13) ^ (c &lt;&lt; 10 | c &gt;&gt;&gt; 22)) + (c &amp; d ^ c &amp; b ^ d &amp; b); l = j; j = g; g = f; f = k + m | 0; k = b; b = d; d = c; c = m + p | 0 } a[0] = a[0] + c | 0; a[1] = a[1] + d | 0; a[2] = a[2] + b | 0; a[3] = a[3] + k | 0; a[4] = a[4] + f | 0; a[5] = a[5] + g | 0; a[6] = a[6] + j | 0; a[7] = a[7] + l | 0 }, _doFinalize: function () { var d = this._data, b = d.words, a = 8 * this._nDataBytes, c = 8 * d.sigBytes; b[c &gt;&gt;&gt; 5] |= 128 &lt;&lt; 24 - c % 32; b[(c + 64 &gt;&gt;&gt; 9 &lt;&lt; 4) + 14] = k.floor(a / 4294967296); b[(c + 64 &gt;&gt;&gt; 9 &lt;&lt; 4) + 15] = a; d.sigBytes = 4 * b.length; this._process(); return this._hash }, clone: function () { var b = j.clone.call(this); b._hash = this._hash.clone(); return b } }); g.SHA256 = j._createHelper(h); g.HmacSHA256 = j._createHmacHelper(h) })(Math);
(function () { var c = CryptoJS, k = c.enc.Utf8; c.algo.HMAC = c.lib.Base.extend({ init: function (a, b) { a = this._hasher = new a.init; &quot;string&quot; == typeof b &amp;&amp; (b = k.parse(b)); var c = a.blockSize, e = 4 * c; b.sigBytes &gt; e &amp;&amp; (b = a.finalize(b)); b.clamp(); for (var f = this._oKey = b.clone(), g = this._iKey = b.clone(), h = f.words, j = g.words, d = 0; d &lt; c; d++) h[d] ^= 1549556828, j[d] ^= 909522486; f.sigBytes = g.sigBytes = e; this.reset() }, reset: function () { var a = this._hasher; a.reset(); a.update(this._iKey) }, update: function (a) { this._hasher.update(a); return this }, finalize: function (a) { var b = this._hasher; a = b.finalize(a); b.reset(); return b.finalize(this._oKey.clone().concat(a)) } }) })();
(function () { var h = CryptoJS, j = h.lib.WordArray; h.enc.Base64 = { stringify: function (b) { var e = b.words, f = b.sigBytes, c = this._map; b.clamp(); b = []; for (var a = 0; a &lt; f; a += 3) for (var d = (e[a &gt;&gt;&gt; 2] &gt;&gt;&gt; 24 - 8 * (a % 4) &amp; 255) &lt;&lt; 16 | (e[a + 1 &gt;&gt;&gt; 2] &gt;&gt;&gt; 24 - 8 * ((a + 1) % 4) &amp; 255) &lt;&lt; 8 | e[a + 2 &gt;&gt;&gt; 2] &gt;&gt;&gt; 24 - 8 * ((a + 2) % 4) &amp; 255, g = 0; 4 &gt; g &amp;&amp; a + 0.75 * g &lt; f; g++) b.push(c.charAt(d &gt;&gt;&gt; 6 * (3 - g) &amp; 63)); if (e = c.charAt(64)) for (; b.length % 4;) b.push(e); return b.join(&quot;&quot;) }, parse: function (b) { var e = b.length, f = this._map, c = f.charAt(64); c &amp;&amp; (c = b.indexOf(c), -1 != c &amp;&amp; (e = c)); for (var c = [], a = 0, d = 0; d &lt; e; d++) if (d % 4) { var g = f.indexOf(b.charAt(d - 1)) &lt;&lt; 2 * (d % 4), h = f.indexOf(b.charAt(d)) &gt;&gt;&gt; 6 - 2 * (d % 4); c[a &gt;&gt;&gt; 2] |= (g | h) &lt;&lt; 24 - 8 * (a % 4); a++ } return j.create(c, a) }, _map: &quot;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=&quot; } })();

hawk.crypto.internals = CryptoJS;


// Export if used as a module

if (typeof module !== &#039;undefined&#039; &amp;&amp; module.exports) {
    module.exports = hawk;
}

// $lab:coverage:on$</textarea>
  </div>
</div>

<footer class="footer">
  <div class="container">
    <p>.</p>
  </div>
</footer>

<script type="text/html" id="complexity-popover-template">
  <div class="complexity-notice">
    Complexity : {{ complexity.cyclomatic }} <br>
    Length : {{ complexity.halstead.length }} <br>
    Difficulty : {{ complexity.halstead.difficulty.toFixed(2) }} <br>
    Est # bugs : {{ complexity.halstead.bugs.toFixed(2) }}<br>
  </div>
</script>

<script type="text/javascript" src="../../assets/scripts/bundles/core-bundle.js"></script>
<script type="text/javascript" src="../../assets/scripts/bundles/codemirror.js"></script>
<script type="text/javascript" src="../../assets/scripts/codemirror.markpopovertext.js"></script>
<script type="text/javascript" src="report.js"></script>
<script type="text/javascript" src="report.history.js"></script>
<script type="text/javascript" src="../../assets/scripts/plato-file.js"></script>
</body>
</html>
