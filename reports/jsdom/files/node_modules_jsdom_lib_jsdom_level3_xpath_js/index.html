<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Plato - node_modules/jsdom/lib/jsdom/level3/xpath.js</title>

  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="">
  <meta name="author" content="">

  <!--[if lt IE 9]>
  <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->

  <link href="../../assets/css/vendor/morris.css" rel="stylesheet">
  <link href="../../assets/css/vendor/bootstrap.css" rel="stylesheet">
  <link href="../../assets/css/vendor/font-awesome.css" rel="stylesheet">
  <link href="../../assets/css/vendor/codemirror.css" rel="stylesheet">
  <link href="../../assets/css/plato.css" rel="stylesheet">
  <link href="../../assets/css/plato-file.css" rel="stylesheet">

</head>

<body>

<div class="navbar navbar-fixed-top">
  <div class="container">
    <a class="navbar-brand" href="http://github.com/es-analysis/plato">Plato on Github</a>
    <ul class="nav navbar-nav">
      <li>
        <a href="../../index.html">Report Home</a>
      </li>
    </ul>
  </div>
</div>

<div class="jumbotron">
  <div class="container">
    <h1>node_modules/jsdom/lib/jsdom/level3/xpath.js</h1>
  </div>
</div>

<div class="container aggregate-stats">
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Maintainability <a href="http://blogs.msdn.com/b/codeanalysis/archive/2007/11/20/maintainability-index-range-and-meaning.aspx"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="A value between 0 and 100 that represents the relative ease of maintaining the code. A high value means better maintainability." data-original-title="Maintainability Index"  data-container="body"></i></a></h2>
      <p class="stat">61.80</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Lines of code <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h2>
      <p class="stat">1832</p>
    </div>
  </div>
  <div class="row historical">
    <div class="col-md-6">
      <p id="chart_historical_maint" class="chart"></p>
    </div>
    <div class="col-md-6">
      <p id="chart_historical_sloc" class="chart"></p>
    </div>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Difficulty  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="The difficulty measure is related to the difficulty of the program to write or understand." data-original-title="Difficulty" data-container="body"></i></a></h2>
      <p class="stat">204.74</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Estimated Errors  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Halstead's delivered bugs is an estimate for the number of errors in the implementation." data-original-title="Delivered Bugs" data-container="body"></i></a></h2>
      <p class="stat">26.69</p>
    </div>
  </div>
</div>

<div class="container charts">
  <div class="row">
    <h2 class="header">Function weight</h2>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h3 class="chart-header">By Complexity <a href="http://en.wikipedia.org/wiki/Cyclomatic_complexity"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="This metric counts the number of distinct paths through a block of code. Lower values are better." data-original-title="Cyclomatic Complexity" data-container="body"></i></a></h3>
      <div id="fn-by-complexity" class="stat"></div>
    </div>
    <div class="col-md-6">
      <h3 class="chart-header">By SLOC  <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h3>
      <div id="fn-by-sloc" class="stat"></div>
    </div>
  </div>
</div>

<div class="container">
  <div class="row">
    <textarea id="file-source" class="col-md-12">/** Here is yet another implementation of XPath 1.0 in Javascript.
 *
 * My goal was to make it relatively compact, but as I fixed all the axis bugs
 * the axes became more and more complicated. :-(.
 *
 * I have not implemented namespaces or case-sensitive axes for XML yet.
 *
 * How to test it in Chrome: You can make a Chrome extension that replaces
 * the WebKit XPath parser with this one. But it takes a bit of effort to
 * get around isolated world and same-origin restrictions:
 * manifest.json:
    {
      &quot;name&quot;: &quot;XPathTest&quot;,
      &quot;version&quot;: &quot;0.1&quot;,
      &quot;content_scripts&quot;: [{
        &quot;matches&quot;: [&quot;http://localhost/*&quot;],  // or wildcard host
        &quot;js&quot;: [&quot;xpath.js&quot;, &quot;injection.js&quot;],
        &quot;all_frames&quot;: true, &quot;run_at&quot;: &quot;document_start&quot;
      }]
    }
 * injection.js:
    // goal: give my xpath object to the website&#039;s JS context.
    var script = document.createElement(&#039;script&#039;);
    script.textContent =
        &quot;document.addEventListener(&#039;xpathextend&#039;, function(e) {\n&quot; +
        &quot;  console.log(&#039;extending document with xpath...&#039;);\n&quot; +
        &quot;  e.detail(window);&quot; +
        &quot;});&quot;;
    document.documentElement.appendChild(script);
    document.documentElement.removeChild(script);
    var evt = document.createEvent(&#039;CustomEvent&#039;);
    evt.initCustomEvent(&#039;xpathextend&#039;, true, true, this.xpath.extend);
    document.dispatchEvent(evt);
 */
(function() {
  var core;
  var xpath;
  if (&#039;function&#039; === typeof require) {
    core = require(&quot;../level3/core&quot;).dom.level3.core;
    xpath = exports;
  } else {
    core = this;
    xpath = {};
  }


  /***************************************************************************
   *                            Tokenization                                 *
   ***************************************************************************/
  /**
   * The XPath lexer is basically a single regular expression, along with
   * some helper functions to pop different types.
   */
  var Stream = xpath.Stream = function Stream(str) {
    this.original = this.str = str;
    this.peeked = null;
    // TODO: not really needed, but supposedly tokenizer also disambiguates
    // a * b vs. node test *
    this.prev = null;  // for debugging
    this.prevprev = null;
  }
  Stream.prototype = {
    peek: function() {
      if (this.peeked) return this.peeked;
      var m = this.re.exec(this.str);
      if (!m) return null;
      this.str = this.str.substr(m[0].length);
      return this.peeked = m[1];
    },
    /** Peek 2 tokens ahead. */
    peek2: function() {
      this.peek();  // make sure this.peeked is set
      var m = this.re.exec(this.str);
      if (!m) return null;
      return m[1];
    },
    pop: function() {
      var r = this.peek();
      this.peeked = null;
      this.prevprev = this.prev;
      this.prev = r;
      return r;
    },
    trypop: function(tokens) {
      var tok = this.peek();
      if (tok === tokens) return this.pop();
      if (Array.isArray(tokens)) {
        for (var i = 0; i &lt; tokens.length; ++i) {
          var t = tokens[i];
          if (t == tok) return this.pop();;
        }
      }
    },
    trypopfuncname: function() {
      var tok = this.peek();
      if (!this.isQnameRe.test(tok))
        return null;
      switch (tok) {
        case &#039;comment&#039;: case &#039;text&#039;: case &#039;processing-instruction&#039;: case &#039;node&#039;:
          return null;
      }
      if (&#039;(&#039; != this.peek2()) return null;
      return this.pop();
    },
    trypopaxisname: function() {
      var tok = this.peek();
      switch (tok) {
        case &#039;ancestor&#039;: case &#039;ancestor-or-self&#039;: case &#039;attribute&#039;:
        case &#039;child&#039;: case &#039;descendant&#039;: case &#039;descendant-or-self&#039;:
        case &#039;following&#039;: case &#039;following-sibling&#039;: case &#039;namespace&#039;:
        case &#039;parent&#039;: case &#039;preceding&#039;: case &#039;preceding-sibling&#039;: case &#039;self&#039;:
          if (&#039;::&#039; == this.peek2()) return this.pop();
      }
      return null;
    },
    trypopnametest: function() {
      var tok = this.peek();
      if (&#039;*&#039; === tok || this.startsWithNcNameRe.test(tok)) return this.pop();
      return null;
    },
    trypopliteral: function() {
      var tok = this.peek();
      if (null == tok) return null;
      var first = tok.charAt(0);
      var last = tok.charAt(tok.length - 1);
      if (&#039;&quot;&#039; === first &amp;&amp; &#039;&quot;&#039; === last ||
          &quot;&#039;&quot; === first &amp;&amp; &quot;&#039;&quot; === last) {
        this.pop();
        return tok.substr(1, tok.length - 2);
      }
    },
    trypopnumber: function() {
      var tok = this.peek();
      if (this.isNumberRe.test(tok)) return parseFloat(this.pop());
      else return null;
    },
    trypopvarref: function() {
      var tok = this.peek();
      if (null == tok) return null;
      if (&#039;$&#039; === tok.charAt(0)) return this.pop().substr(1);
      else return null;
    },
    position: function() {
      return this.original.length - this.str.length;
    }
  };
  (function() {
    // http://www.w3.org/TR/REC-xml-names/#NT-NCName
    var nameStartCharsExceptColon =
        &#039;A-Z_a-z\xc0-\xd6\xd8-\xf6\xF8-\u02FF\u0370-\u037D\u037F-\u1FFF&#039; +
        &#039;\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF&#039; +
        &#039;\uFDF0-\uFFFD&#039;;  // JS doesn&#039;t support [#x10000-#xEFFFF]
    var nameCharExceptColon = nameStartCharsExceptColon +
        &#039;\\-\\.0-9\xb7\u0300-\u036F\u203F-\u2040&#039;;
    var ncNameChars = &#039;[&#039; + nameStartCharsExceptColon +
        &#039;][&#039; + nameCharExceptColon + &#039;]*&#039;
    // http://www.w3.org/TR/REC-xml-names/#NT-QName
    var qNameChars = ncNameChars + &#039;(?::&#039; + ncNameChars + &#039;)?&#039;;
    var otherChars = &#039;\\.\\.|[\\(\\)\\[\\].@,]|::&#039;;  // .. must come before [.]
    var operatorChars =
        &#039;and|or|mod|div|&#039; +
        &#039;//|!=|&lt;=|&gt;=|[*/|+\\-=&lt;&gt;]&#039;;  // //, !=, &lt;=, &gt;= before individual ones.
    var literal = &#039;&quot;[^&quot;]*&quot;|&#039; + &quot;&#039;[^&#039;]*&#039;&quot;;
    var numberChars = &#039;[0-9]+(?:\\.[0-9]*)?|\\.[0-9]+&#039;;
    var variableReference = &#039;\\$&#039; + qNameChars;
    var nameTestChars = &#039;\\*|&#039; + ncNameChars + &#039;:\\*|&#039; + qNameChars;
    var optionalSpace = &#039;[ \t\r\n]*&#039;;  // stricter than regexp \s.
    var nodeType = &#039;comment|text|processing-instruction|node&#039;;
    var re = new RegExp(
        // numberChars before otherChars so that leading-decimal doesn&#039;t become .
        &#039;^&#039; + optionalSpace + &#039;(&#039; + numberChars + &#039;|&#039; + otherChars + &#039;|&#039; +
        nameTestChars + &#039;|&#039; + operatorChars + &#039;|&#039; + literal + &#039;|&#039; +
        variableReference + &#039;)&#039;
        // operatorName | nodeType | functionName | axisName are lumped into
        // qName for now; we&#039;ll check them on pop.
    );
    Stream.prototype.re = re;
    Stream.prototype.startsWithNcNameRe = new RegExp(&#039;^&#039; + ncNameChars);
    Stream.prototype.isQnameRe = new RegExp(&#039;^&#039; + qNameChars + &#039;$&#039;);
    Stream.prototype.isNumberRe = new RegExp(&#039;^&#039; + numberChars + &#039;$&#039;);
  })();

  /***************************************************************************
   *                               Parsing                                   *
   ***************************************************************************/
  var parse = xpath.parse = function parse(stream, a) {
    var r = orExpr(stream,a);
    var x, unparsed = [];
    while (x = stream.pop()) {
      unparsed.push(x);
    }
    if (unparsed.length)
      throw new XPathException(XPathException.INVALID_EXPRESSION_ERR,
                               &#039;Position &#039; + stream.position() +
                               &#039;: Unparsed tokens: &#039; + unparsed.join(&#039; &#039;));
    return r;
  }

  /**
   * binaryL  ::= subExpr
   *            | binaryL op subExpr
   * so a op b op c becomes ((a op b) op c)
   */
  function binaryL(subExpr, stream, a, ops) {
    var lhs = subExpr(stream, a);
    if (lhs == null) return null;
    var op;
    while (op = stream.trypop(ops)) {
      var rhs = subExpr(stream, a);
      if (rhs == null)
        throw new XPathException(XPathException.INVALID_EXPRESSION_ERR,
                                 &#039;Position &#039; + stream.position() +
                                 &#039;: Expected something after &#039; + op);
      lhs = a.node(op, lhs, rhs);
    }
    return lhs;
  }
  /**
   * Too bad this is never used. If they made a ** operator (raise to power),
   ( we would use it.
   * binaryR  ::= subExpr
   *            | subExpr op binaryR
   * so a op b op c becomes (a op (b op c))
   */
  function binaryR(subExpr, stream, a, ops) {
    var lhs = subExpr(stream, a);
    if (lhs == null) return null;
    var op = stream.trypop(ops);
    if (op) {
      var rhs = binaryR(stream, a);
      if (rhs == null)
        throw new XPathException(XPathException.INVALID_EXPRESSION_ERR,
                                 &#039;Position &#039; + stream.position() +
                                 &#039;: Expected something after &#039; + op);
      return a.node(op, lhs, rhs);
    } else {
      return lhs;// TODO
    }
  }
  /** [1] LocationPath::= RelativeLocationPath | AbsoluteLocationPath
   * e.g. a, a/b, //a/b
   */
  function locationPath(stream, a) {
    return absoluteLocationPath(stream, a) ||
           relativeLocationPath(null, stream, a);
  }
  /** [2] AbsoluteLocationPath::= &#039;/&#039; RelativeLocationPath? | AbbreviatedAbsoluteLocationPath
   *  [10] AbbreviatedAbsoluteLocationPath::= &#039;//&#039; RelativeLocationPath
   */
  function absoluteLocationPath(stream, a) {
    var op = stream.peek();
    if (&#039;/&#039; === op || &#039;//&#039; === op) {
      var lhs = a.node(&#039;Root&#039;);
      return relativeLocationPath(lhs, stream, a, true);
    } else {
      return null;
    }
  }
  /** [3] RelativeLocationPath::= Step | RelativeLocationPath &#039;/&#039; Step |
   *                            | AbbreviatedRelativeLocationPath
   *  [11] AbbreviatedRelativeLocationPath::= RelativeLocationPath &#039;//&#039; Step
   * e.g. p/a, etc.
   */
  function relativeLocationPath(lhs, stream, a, isOnlyRootOk) {
    if (null == lhs) {
      lhs = step(stream, a);
      if (null == lhs) return lhs;
    }
    var op;
    while (op = stream.trypop([&#039;/&#039;, &#039;//&#039;])) {
      if (&#039;//&#039; === op) {
        lhs = a.node(&#039;/&#039;, lhs,
                     a.node(&#039;Axis&#039;, &#039;descendant-or-self&#039;, &#039;node&#039;, undefined));
      }
      var rhs = step(stream, a);
      if (null == rhs &amp;&amp; &#039;/&#039; === op &amp;&amp; isOnlyRootOk) return lhs;
      else isOnlyRootOk = false;
      if (null == rhs)
        throw new XPathException(XPathException.INVALID_EXPRESSION_ERR,
                                 &#039;Position &#039; + stream.position() +
                                 &#039;: Expected step after &#039; + op);
      lhs = a.node(&#039;/&#039;, lhs, rhs);
    }
    return lhs;
  }
  /** [4] Step::= AxisSpecifier NodeTest Predicate* | AbbreviatedStep
   *  [12] AbbreviatedStep::= &#039;.&#039; | &#039;..&#039;
   * e.g. @href, self::p, p, a[@href], ., ..
   */
  function step(stream, a) {
    var abbrStep = stream.trypop([&#039;.&#039;, &#039;..&#039;]);
    if (&#039;.&#039; === abbrStep)  // A location step of . is short for self::node().
      return a.node(&#039;Axis&#039;, &#039;self&#039;, &#039;node&#039;);
    if (&#039;..&#039; === abbrStep)  // A location step of .. is short for parent::node()
      return a.node(&#039;Axis&#039;, &#039;parent&#039;, &#039;node&#039;);

    var axis = axisSpecifier(stream, a);
    var nodeType = nodeTypeTest(stream, a);
    var nodeName;
    if (null == nodeType) nodeName = nodeNameTest(stream, a);
    if (null == axis &amp;&amp; null == nodeType &amp;&amp; null == nodeName) return null;
    if (null == nodeType &amp;&amp; null == nodeName)
        throw new XPathException(
            XPathException.INVALID_EXPRESSION_ERR,
            &#039;Position &#039; + stream.position() +
            &#039;: Expected nodeTest after axisSpecifier &#039; + axis);
    if (null == axis) axis = &#039;child&#039;;
    if (null == nodeType) {
      // When there&#039;s only a node name, then the node type is forced to be the
      // principal node type of the axis.
      // see http://www.w3.org/TR/xpath/#dt-principal-node-type
      if (&#039;attribute&#039; === axis) nodeType = &#039;attribute&#039;;
      else if (&#039;namespace&#039; === axis) nodeType = &#039;namespace&#039;;
      else nodeType = &#039;element&#039;;
    }
    var lhs = a.node(&#039;Axis&#039;, axis, nodeType, nodeName);
    var pred;
    while (null != (pred = predicate(lhs, stream, a))) {
      lhs = pred;
    }
    return lhs;
  }
  /** [5] AxisSpecifier::= AxisName &#039;::&#039; | AbbreviatedAxisSpecifier
   *  [6] AxisName::= &#039;ancestor&#039; | &#039;ancestor-or-self&#039; | &#039;attribute&#039; | &#039;child&#039;
   *                | &#039;descendant&#039; | &#039;descendant-or-self&#039; | &#039;following&#039;
   *                | &#039;following-sibling&#039; | &#039;namespace&#039; | &#039;parent&#039; |
   *                | &#039;preceding&#039; | &#039;preceding-sibling&#039; | &#039;self&#039;
   *  [13] AbbreviatedAxisSpecifier::= &#039;@&#039;?
   */
  function axisSpecifier(stream, a) {
    var attr = stream.trypop(&#039;@&#039;);
    if (null != attr) return &#039;attribute&#039;;
    var axisName = stream.trypopaxisname();
    if (null != axisName) {
      var coloncolon = stream.trypop(&#039;::&#039;);
      if (null == coloncolon)
        throw new XPathException(XPathException.INVALID_EXPRESSION_ERR,
                                 &#039;Position &#039; + stream.position() +
                                 &#039;: Should not happen. Should be ::.&#039;);
      return axisName;
    }
  }
  /** [7] NodeTest::= NameTest | NodeType &#039;(&#039; &#039;)&#039; | &#039;processing-instruction&#039; &#039;(&#039; Literal &#039;)&#039;
   *  [38] NodeType::= &#039;comment&#039; | &#039;text&#039; | &#039;processing-instruction&#039; | &#039;node&#039;
   * I&#039;ve split nodeTypeTest from nodeNameTest for convenience.
   */
  function nodeTypeTest(stream, a) {
    if (&#039;(&#039; !== stream.peek2()) {
      return null;
    }
    var type = stream.trypop([&#039;comment&#039;, &#039;text&#039;, &#039;processing-instruction&#039;, &#039;node&#039;]);
    if (null != type) {
      if (null == stream.trypop(&#039;(&#039;))
        throw new XPathException(XPathException.INVALID_EXPRESSION_ERR,
                                 &#039;Position &#039; + stream.position() +
                                 &#039;: Should not happen.&#039;);
      var param = undefined;
      if (type == &#039;processing-instruction&#039;) {
        param = stream.trypopliteral();
      }
      if (null == stream.trypop(&#039;)&#039;))
        throw new XPathException(XPathException.INVALID_EXPRESSION_ERR,
                                 &#039;Position &#039; + stream.position() +
                                 &#039;: Expected close parens.&#039;);
      return type
    }
  }
  function nodeNameTest(stream, a) {
    var name = stream.trypopnametest();
    if (name != null) return name;
    else return null;
  }
  /** [8] Predicate::= &#039;[&#039; PredicateExpr &#039;]&#039;
   *  [9] PredicateExpr::= Expr
   */
  function predicate(lhs, stream, a) {
    if (null == stream.trypop(&#039;[&#039;)) return null;
    var expr = orExpr(stream, a);
    if (null == expr)
      throw new XPathException(XPathException.INVALID_EXPRESSION_ERR,
                               &#039;Position &#039; + stream.position() +
                               &#039;: Expected expression after [&#039;);
    if (null == stream.trypop(&#039;]&#039;))
      throw new XPathException(XPathException.INVALID_EXPRESSION_ERR,
                               &#039;Position &#039; + stream.position() +
                               &#039;: Expected ] after expression.&#039;);
    return a.node(&#039;Predicate&#039;, lhs, expr);
  }
  /** [14] Expr::= OrExpr
   */
  /** [15] PrimaryExpr::= VariableReference | &#039;(&#039; Expr &#039;)&#039; | Literal | Number | FunctionCall
   * e.g. $x,  (3+4),  &quot;hi&quot;,  32,  f(x)
   */
  function primaryExpr(stream, a) {
    var x = stream.trypopliteral();
    if (null == x)
      x = stream.trypopnumber();
    if (null != x) {
      return x;
    }
    var varRef = stream.trypopvarref();
    if (null != varRef) return a.node(&#039;VariableReference&#039;, varRef);
    var funCall = functionCall(stream, a);
    if (null != funCall) {
      return funCall;
    }
    if (stream.trypop(&#039;(&#039;)) {
      var e = orExpr(stream, a);
      if (null == e)
        throw new XPathException(XPathException.INVALID_EXPRESSION_ERR,
                                 &#039;Position &#039; + stream.position() +
                                 &#039;: Expected expression after (.&#039;);
      if (null == stream.trypop(&#039;)&#039;))
        throw new XPathException(XPathException.INVALID_EXPRESSION_ERR,
                                 &#039;Position &#039; + stream.position() +
                                 &#039;: Expected ) after expression.&#039;);
      return e;
    }
    return null;
  }
  /** [16] FunctionCall::= FunctionName &#039;(&#039; ( Argument ( &#039;,&#039; Argument )* )? &#039;)&#039;
   *  [17] Argument::= Expr
   */
  function functionCall(stream, a) {
    var name = stream.trypopfuncname(stream, a);
    if (null == name) return null;
    if (null == stream.trypop(&#039;(&#039;))
      throw new XPathException(XPathException.INVALID_EXPRESSION_ERR,
                               &#039;Position &#039; + stream.position() +
                               &#039;: Expected ( ) after function name.&#039;);
    var params = [];
    var first = true;
    while (null == stream.trypop(&#039;)&#039;)) {
      if (!first &amp;&amp; null == stream.trypop(&#039;,&#039;))
        throw new XPathException(XPathException.INVALID_EXPRESSION_ERR,
                                 &#039;Position &#039; + stream.position() +
                                 &#039;: Expected , between arguments of the function.&#039;);
      first = false;
      var param = orExpr(stream, a);
      if (param == null)
        throw new XPathException(XPathException.INVALID_EXPRESSION_ERR,
                                 &#039;Position &#039; + stream.position() +
                                 &#039;: Expected expression as argument of function.&#039;);
      params.push(param);
    }
    return a.node(&#039;FunctionCall&#039;, name, params);
  }

  /** [18] UnionExpr::= PathExpr | UnionExpr &#039;|&#039; PathExpr
   */
  function unionExpr(stream, a) { return binaryL(pathExpr, stream, a, &#039;|&#039;); }
  /** [19] PathExpr ::= LocationPath
   *                  | FilterExpr
   *                  | FilterExpr &#039;/&#039; RelativeLocationPath
   *                  | FilterExpr &#039;//&#039; RelativeLocationPath
   * Unlike most other nodes, this one always generates a node because
   * at this point all reverse nodesets must turn into a forward nodeset
   */
  function pathExpr(stream, a) {
    // We have to do FilterExpr before LocationPath because otherwise
    // LocationPath will eat up the name from a function call.
    var filter = filterExpr(stream, a);
    if (null == filter) {
      var loc = locationPath(stream, a);
      if (null == loc) {
        throw new Error
        throw new XPathException(XPathException.INVALID_EXPRESSION_ERR,
                                 &#039;Position &#039; + stream.position() +
                                 &#039;: The expression shouldn\&#039;t be empty...&#039;);
      }
      return a.node(&#039;PathExpr&#039;, loc);
    }
    var rel = relativeLocationPath(filter, stream, a, false);
    if (filter === rel) return rel;
    else return a.node(&#039;PathExpr&#039;, rel);
  }
  /** [20] FilterExpr::= PrimaryExpr | FilterExpr Predicate
   * aka. FilterExpr ::= PrimaryExpr Predicate*
   */
  function filterExpr(stream, a) {
    var primary = primaryExpr(stream, a);
    if (primary == null) return null;
    var pred, lhs = primary;
    while (null != (pred = predicate(lhs, stream, a))) {
      lhs = pred;
    }
    return lhs;
  }

  /** [21] OrExpr::= AndExpr | OrExpr &#039;or&#039; AndExpr
   */
  function orExpr(stream, a) {
    var orig = (stream.peeked || &#039;&#039;) + stream.str
    var r = binaryL(andExpr, stream, a, &#039;or&#039;);
    var now = (stream.peeked || &#039;&#039;) + stream.str;
    return r;
  }
  /** [22] AndExpr::= EqualityExpr | AndExpr &#039;and&#039; EqualityExpr
   */
  function andExpr(stream, a) { return binaryL(equalityExpr, stream, a, &#039;and&#039;); }
  /** [23] EqualityExpr::= RelationalExpr | EqualityExpr &#039;=&#039; RelationalExpr
   *                     | EqualityExpr &#039;!=&#039; RelationalExpr
   */
  function equalityExpr(stream, a) { return binaryL(relationalExpr, stream, a, [&#039;=&#039;,&#039;!=&#039;]); }
  /** [24] RelationalExpr::= AdditiveExpr | RelationalExpr &#039;&lt;&#039; AdditiveExpr
   *                       | RelationalExpr &#039;&gt;&#039; AdditiveExpr
   *                       | RelationalExpr &#039;&lt;=&#039; AdditiveExpr
   *                       | RelationalExpr &#039;&gt;=&#039; AdditiveExpr
   */
  function relationalExpr(stream, a) { return binaryL(additiveExpr, stream, a, [&#039;&lt;&#039;,&#039;&gt;&#039;,&#039;&lt;=&#039;,&#039;&gt;=&#039;]); }
  /** [25] AdditiveExpr::= MultiplicativeExpr
   *                     | AdditiveExpr &#039;+&#039; MultiplicativeExpr
   *                     | AdditiveExpr &#039;-&#039; MultiplicativeExpr
   */
  function additiveExpr(stream, a) { return binaryL(multiplicativeExpr, stream, a, [&#039;+&#039;,&#039;-&#039;]); }
  /** [26] MultiplicativeExpr::= UnaryExpr
   *                           | MultiplicativeExpr MultiplyOperator UnaryExpr
   *                           | MultiplicativeExpr &#039;div&#039; UnaryExpr
   *                           | MultiplicativeExpr &#039;mod&#039; UnaryExpr
   */
  function multiplicativeExpr(stream, a) { return binaryL(unaryExpr, stream, a, [&#039;*&#039;,&#039;div&#039;,&#039;mod&#039;]); }
  /** [27] UnaryExpr::= UnionExpr | &#039;-&#039; UnaryExpr
   */
  function unaryExpr(stream, a) {
    if (stream.trypop(&#039;-&#039;)) {
      var e = unaryExpr(stream, a);
      if (null == e)
        throw new XPathException(XPathException.INVALID_EXPRESSION_ERR,
                                 &#039;Position &#039; + stream.position() +
                                 &#039;: Expected unary expression after -&#039;);
      return a.node(&#039;UnaryMinus&#039;, e);
    }
    else return unionExpr(stream, a);
  }
  var astFactory = {
    node: function() {return Array.prototype.slice.call(arguments);}
  };


  /***************************************************************************
   *                            Optimizations (TODO)                         *
   ***************************************************************************/
  /**
   * Some things I&#039;ve been considering:
   * 1) a//b becomes a/descendant::b if there&#039;s no predicate that uses
   *    position() or last()
   * 2) axis[pred]: when pred doesn&#039;t use position, evaluate it just once per
   *    node in the node-set rather than once per (node, position, last).
   * For more optimizations, look up Gecko&#039;s optimizer:
   * http://mxr.mozilla.org/mozilla-central/source/content/xslt/src/xpath/txXPathOptimizer.cpp
   */
  // TODO
  function optimize(ast) {
  }

  /***************************************************************************
   *                           Evaluation: axes                              *
   ***************************************************************************/

  /**
   * Data types: For string, number, boolean, we just use Javascript types.
   * Node-sets have the form
   *    {nodes: [node, ...]}
   * or {nodes: [node, ...], pos: [[1], [2], ...], lasts: [[1], [2], ...]}
   *
   * Most of the time, only the node is used and the position information is
   * discarded. But if you use a predicate, we need to try every value of
   * position and last in case the predicate calls position() or last().
   */

  /**
   * The NodeMultiSet is a helper class to help generate
   * {nodes:[], pos:[], lasts:[]} structures. It is useful for the
   * descendant, descendant-or-self, following-sibling, and
   * preceding-sibling axes for which we can use a stack to organize things.
   */
  function NodeMultiSet(isReverseAxis) {
    this.nodes = [];
    this.pos = [];
    this.lasts = [];
    this.nextPos = [];
    this.seriesIndexes = [];  // index within nodes that each series begins.
    this.isReverseAxis = isReverseAxis;
    this._pushToNodes = isReverseAxis ? Array.prototype.unshift : Array.prototype.push;
  }
  NodeMultiSet.prototype = {
    pushSeries: function pushSeries() {
      this.nextPos.push(1);
      this.seriesIndexes.push(this.nodes.length);
    },
    popSeries: function popSeries() {
      console.assert(0 &lt; this.nextPos.length, this.nextPos);
      var last = this.nextPos.pop() - 1,
          indexInPos = this.nextPos.length,
          seriesBeginIndex = this.seriesIndexes.pop(),
          seriesEndIndex = this.nodes.length;
      for (var i = seriesBeginIndex; i &lt; seriesEndIndex; ++i) {
        console.assert(indexInPos &lt; this.lasts[i].length);
        console.assert(undefined === this.lasts[i][indexInPos]);
        this.lasts[i][indexInPos] = last;
      }
    },
    finalize: function() {
      if (null == this.nextPos) return this;
      console.assert(0 === this.nextPos.length);
      for (var i = 0; i &lt; this.lasts.length; ++i) {
        for (var j = 0; j &lt; this.lasts[i].length; ++j) {
          console.assert(null != this.lasts[i][j], i + &#039;,&#039; + j + &#039;:&#039; + JSON.stringify(this.lasts));
        }
      }
      this.pushSeries = this.popSeries = this.addNode = function() {
        throw new Error(&#039;Already finalized.&#039;);
      };
      return this;
    },
    addNode: function addNode(node) {
      console.assert(node);
      this._pushToNodes.call(this.nodes, node)
      this._pushToNodes.call(this.pos, this.nextPos.slice());
      this._pushToNodes.call(this.lasts, new Array(this.nextPos.length));
      for (var i = 0; i &lt; this.nextPos.length; ++i) this.nextPos[i]++;
    },
    simplify: function() {
      this.finalize();
      return {nodes:this.nodes, pos:this.pos, lasts:this.lasts};
    }
  };
  function eachContext(nodeMultiSet) {
    var r = [];
    for (var i = 0; i &lt; nodeMultiSet.nodes.length; i++) {
      var node = nodeMultiSet.nodes[i];
      if (!nodeMultiSet.pos) {
        r.push({nodes:[node], pos: [[i + 1]], lasts: [[nodeMultiSet.nodes.length]]});
      } else {
        for (var j = 0; j &lt; nodeMultiSet.pos[i].length; ++j) {
          r.push({nodes:[node], pos: [[nodeMultiSet.pos[i][j]]], lasts: [[nodeMultiSet.lasts[i][j]]]});
        }
      }
    }
    return r;
  }
  /** Matcher used in the axes.
   */
  function NodeMatcher(nodeTypeNum, nodeName, shouldLowerCase) {
    this.nodeTypeNum = nodeTypeNum;
    this.nodeName = nodeName;
    this.shouldLowerCase = shouldLowerCase;
    this.nodeNameTest =
      null == nodeName ? this._alwaysTrue :
      shouldLowerCase ? this._nodeNameLowerCaseEquals :
      this._nodeNameEquals;
  }
  NodeMatcher.prototype = {
    matches: function matches(node) {
      return (0 === this.nodeTypeNum || node.nodeType === this.nodeTypeNum) &amp;&amp;
          this.nodeNameTest(node.nodeName);
    },
    _alwaysTrue: function(name) {return true;},
    _nodeNameEquals: function _nodeNameEquals(name) {
      return this.nodeName === name;
    },
    _nodeNameLowerCaseEquals: function _nodeNameLowerCaseEquals(name) {
      return this.nodeName === name.toLowerCase();
    }
  };

  function followingSiblingHelper(nodeList  /*destructive!*/, nodeTypeNum, nodeName, shouldLowerCase, shift, peek, followingNode, andSelf, isReverseAxis) {
    var matcher = new NodeMatcher(nodeTypeNum, nodeName, shouldLowerCase);
    var nodeMultiSet = new NodeMultiSet(isReverseAxis);
    while (0 &lt; nodeList.length) {  // can be if for following, preceding
      var node = shift.call(nodeList);
      console.assert(node != null);
      node = followingNode(node);
      nodeMultiSet.pushSeries();
      var numPushed = 1;
      while (null != node) {
        if (! andSelf &amp;&amp; matcher.matches(node))
          nodeMultiSet.addNode(node);
        if (node === peek.call(nodeList)) {
          shift.call(nodeList);
          nodeMultiSet.pushSeries();
          numPushed++;
        }
        if (andSelf &amp;&amp; matcher.matches(node))
          nodeMultiSet.addNode(node);
        node = followingNode(node);
      }
      while (0 &lt; numPushed--)
        nodeMultiSet.popSeries();
    }
    return nodeMultiSet;
  }

  /** Returns the next non-descendant node in document order.
   * This is the first node in following::node(), if node is the context.
   */
  function followingNonDescendantNode(node) {
    if (node.ownerElement) {
      if (node.ownerElement.firstChild)
        return node.ownerElement.firstChild;
      node = node.ownerElement;
    }
    do {
      if (node.nextSibling) return node.nextSibling;
    } while (node = node.parentNode);
    return null;
  }

  /** Returns the next node in a document-order depth-first search.
   * See the definition of document order[1]:
   *   1) element
   *   2) namespace nodes
   *   3) attributes
   *   4) children
   *   [1]: http://www.w3.org/TR/xpath/#dt-document-order
   */
  function followingNode(node) {
    if (node.ownerElement)  // attributes: following node of element.
      node = node.ownerElement;
    if (null != node.firstChild)
      return node.firstChild;
    do {
      if (null != node.nextSibling) {
        return node.nextSibling;
      }
      node = node.parentNode;
    } while (node);
    return null;
  }
  /** Returns the previous node in document order (excluding attributes
   * and namespace nodes).
   */
  function precedingNode(node) {
    if (node.ownerElement)
      return node.ownerElement;
    if (null != node.previousSibling) {
      node = node.previousSibling;
      while (null != node.lastChild) {
        node = node.lastChild;
      }
      return node;
    }
    if (null != node.parentNode) {
      return node.parentNode;
    }
    return null;
  }
  /** This axis is inefficient if there are many nodes in the nodeList.
   * But I think it&#039;s a pretty useless axis so it&#039;s ok. */
  function followingHelper(nodeList  /*destructive!*/, nodeTypeNum, nodeName, shouldLowerCase) {
    var matcher = new NodeMatcher(nodeTypeNum, nodeName, shouldLowerCase);
    var nodeMultiSet = new NodeMultiSet(false);
    var cursor = nodeList[0];
    var unorderedFollowingStarts = [];
    for (var i = 0; i &lt; nodeList.length; i++) {
      var node = nodeList[i];
      var start = followingNonDescendantNode(node);
      if (start)
        unorderedFollowingStarts.push(start);
    }
    if (0 === unorderedFollowingStarts.length)
      return {nodes:[]};
    var pos = [], nextPos = [];
    var started = 0;
    while (cursor = followingNode(cursor)) {
      for (var i = unorderedFollowingStarts.length - 1; i &gt;= 0; i--){
        if (cursor === unorderedFollowingStarts[i]) {
          nodeMultiSet.pushSeries();
          unorderedFollowingStarts.splice(i,i+1);
          started++;
        }
      }
      if (started &amp;&amp; matcher.matches(cursor)) {
        nodeMultiSet.addNode(cursor);
      }
    }
    console.assert(0 === unorderedFollowingStarts.length);
    for (var i = 0; i &lt; started; i++)
      nodeMultiSet.popSeries();
    return nodeMultiSet.finalize();
  }
  function precedingHelper(nodeList  /*destructive!*/, nodeTypeNum, nodeName, shouldLowerCase) {
    var matcher = new NodeMatcher(nodeTypeNum, nodeName, shouldLowerCase);
    var cursor = nodeList.pop();
    if (null == cursor) return {nodes:{}};
    var r = {nodes:[], pos:[], lasts:[]};
    var nextParents = [cursor.parentNode || cursor.ownerElement], nextPos = [1];
    while (cursor = precedingNode(cursor)) {
      if (cursor === nodeList[nodeList.length - 1]) {
        nextParents.push(nodeList.pop());
        nextPos.push(1);
      }
      var matches = matcher.matches(cursor);
      var pos, someoneUsed = false;
      if (matches)
        pos = nextPos.slice();

      for (var i = 0; i &lt; nextParents.length; ++i) {
        if (cursor === nextParents[i]) {
          nextParents[i] = cursor.parentNode || cursor.ownerElement;
          if (matches) {
            pos[i] = null;
          }
        } else {
          if (matches) {
            pos[i] = nextPos[i]++;
            someoneUsed = true;
          }
        }
      }
      if (someoneUsed) {
        r.nodes.unshift(cursor);
        r.pos.unshift(pos);
      }
    }
    for (var i = 0; i &lt; r.pos.length; ++i) {
      var lasts = [];
      r.lasts.push(lasts);
      for (var j = r.pos[i].length - 1; j &gt;= 0; j--) {
        if (null == r.pos[i][j]) {
          r.pos[i].splice(j, j+1);
        } else {
          lasts.unshift(nextPos[j] - 1);
        }
      }
    }
    return r;
  }

  /** node-set, axis -&gt; node-set */
  function descendantDfs(nodeMultiSet, node, remaining, matcher, andSelf, attrIndices, attrNodes) {
    while (0 &lt; remaining.length &amp;&amp; null != remaining[0].ownerElement) {
      var attr = remaining.shift();
      if (andSelf &amp;&amp; matcher.matches(attr)) {
        attrNodes.push(attr);
        attrIndices.push(nodeMultiSet.nodes.length);
      }
    }
    if (null != node &amp;&amp; !andSelf) {
      if (matcher.matches(node))
        nodeMultiSet.addNode(node);
    }
    var pushed = false;
    if (null == node) {
      if (0 === remaining.length) return;
      node = remaining.shift();
      nodeMultiSet.pushSeries();
      pushed = true;
    } else if (0 &lt; remaining.length &amp;&amp; node === remaining[0]) {
      nodeMultiSet.pushSeries();
      pushed = true;
      remaining.shift();
    }
    if (andSelf) {
      if (matcher.matches(node))
        nodeMultiSet.addNode(node);
    }
    // TODO: use optimization. Also try element.getElementsByTagName
    // var nodeList = 1 === nodeTypeNum &amp;&amp; null != node.children ? node.children : node.childNodes;
    var nodeList = node.childNodes;
    for (var j = 0; j &lt; nodeList.length; ++j) {
      var child = nodeList[j];
      descendantDfs(nodeMultiSet, child, remaining, matcher, andSelf, attrIndices, attrNodes);
    }
    if (pushed) {
      nodeMultiSet.popSeries();
    }
  }
  function descenantHelper(nodeList  /*destructive!*/, nodeTypeNum, nodeName, shouldLowerCase, andSelf) {
    var matcher = new NodeMatcher(nodeTypeNum, nodeName, shouldLowerCase);
    var nodeMultiSet = new NodeMultiSet(false);
    var attrIndices = [], attrNodes = [];
    while (0 &lt; nodeList.length) {
      // var node = nodeList.shift();
      descendantDfs(nodeMultiSet, null, nodeList, matcher, andSelf, attrIndices, attrNodes);
    }
    nodeMultiSet.finalize();
    for (var i = attrNodes.length-1; i &gt;= 0; --i) {
      nodeMultiSet.nodes.splice(attrIndices[i], attrIndices[i], attrNodes[i]);
      nodeMultiSet.pos.splice(attrIndices[i], attrIndices[i], [1]);
      nodeMultiSet.lasts.splice(attrIndices[i], attrIndices[i], [1]);
    }
    return nodeMultiSet;
  }
  /**
   */
  function ancestorHelper(nodeList  /*destructive!*/, nodeTypeNum, nodeName, shouldLowerCase, andSelf) {
    var matcher = new NodeMatcher(nodeTypeNum, nodeName, shouldLowerCase);
    var ancestors = []; // array of non-empty arrays of matching ancestors
    for (var i = 0; i &lt; nodeList.length; ++i) {
      var node = nodeList[i];
      var isFirst = true;
      var a = [];
      while (null != node) {
        if (!isFirst || andSelf) {
          if (matcher.matches(node))
            a.push(node);
        }
        isFirst = false;
        node = node.parentNode || node.ownerElement;
      }
      if (0 &lt; a.length)
        ancestors.push(a);
    }
    var lasts = [];
    for (var i = 0; i &lt; ancestors.length; ++i) lasts.push(ancestors[i].length);
    var nodeMultiSet = new NodeMultiSet(true);
    var newCtx = {nodes:[], pos:[], lasts:[]};
    while (0 &lt; ancestors.length) {
      var pos = [ancestors[0].length];
      var last = [lasts[0]];
      var node = ancestors[0].pop();
      for (var i = ancestors.length - 1; i &gt; 0; --i) {
        if (node === ancestors[i][ancestors[i].length - 1]) {
          pos.push(ancestors[i].length);
          last.push(lasts[i]);
          ancestors[i].pop();
          if (0 === ancestors[i].length) {
            ancestors.splice(i, i+1);
            lasts.splice(i, i+1);
          }
        }
      }
      if (0 === ancestors[0].length) {
        ancestors.shift();
        lasts.shift();
      }
      newCtx.nodes.push(node);
      newCtx.pos.push(pos);
      newCtx.lasts.push(last);
    }
    return newCtx;
  }
  /** Helper function for sortDocumentOrder. Returns a list of indices, from the
   * node to the root, of positions within parent.
   * For convenience, the node is the first element of the array.
   */
  function addressVector(node) {
    var r = [node];
    if (null != node.ownerElement) {
      node = node.ownerElement;
      r.push(-1);
    }
    while (null != node) {
      var i = 0;
      while (null != node.previousSibling) {
        node = node.previousSibling;
        i++;
      }
      r.push(i);
      node = node.parentNode
    }
    return r;
  }
  function addressComparator(a, b) {
    var minlen = Math.min(a.length - 1, b.length - 1),  // not including [0]=node
        alen = a.length,
        blen = b.length;
    if (a[0] === b[0]) return 0;
    var c;
    for (var i = 0; i &lt; minlen; ++i) {
      c = a[alen - i - 1] - b[blen - i - 1];
      if (0 !== c)
        break;
    }
    if (null == c || 0 === c) {
      // All equal until one of the nodes. The longer one is the descendant.
      c = alen - blen;
    }
    if (0 === c)
      c = a.nodeName - b.nodeName;
    if (0 === c)
      c = 1;
    return c;
  }
  var sortUniqDocumentOrder = xpath.sortUniqDocumentOrder = function(nodes) {
    var a = [];
    for (var i = 0; i &lt; nodes.length; i++) {
      var node = nodes[i];
      var v = addressVector(node);
      a.push(v);
    }
    a.sort(addressComparator);
    var b = [];
    for (var i = 0; i &lt; a.length; i++) {
      if (0 &lt; i &amp;&amp; a[i][0] === a[i - 1][0])
        continue;
      b.push(a[i][0]);
    }
    return b;
  }
  /** Sort node multiset. Does not do any de-duping. */
  function sortNodeMultiSet(nodeMultiSet) {
    var a = [];
    for (var i = 0; i &lt; nodeMultiSet.nodes.length; i++) {
      var v = addressVector(nodeMultiSet.nodes[i]);
      a.push({v:v, n:nodeMultiSet.nodes[i],
              p:nodeMultiSet.pos[i], l:nodeMultiSet.lasts[i]});
    }
    a.sort(compare);
    var r = {nodes:[], pos:[], lasts:[]};
    for (var i = 0; i &lt; a.length; ++i) {
      r.nodes.push(a[i].n);
      r.pos.push(a[i].p);
      r.lasts.push(a[i].l);
    }
    function compare(x, y) {
      return addressComparator(x.v, y.v);
    }
    return r;
  }
  /** Returns an array containing all the ancestors down to a node.
   * The array starts with document.
   */
  function nodeAndAncestors(node) {
    var ancestors = [node];
    var p = node;
    while (p = p.parentNode || p.ownerElement) {
      ancestors.unshift(p);
    }
    return ancestors;
  }
  function compareSiblings(a, b) {
    if (a === b) return 0;
    var c = a;
    while (c = c.previousSibling) {
      if (c === b)
        return 1;  // b &lt; a
    }
    c = b;
    while (c = c.previousSibling) {
      if (c === a)
        return -1;  // a &lt; b
    }
    throw new Error(&#039;a and b are not siblings: &#039; + xpath.stringifyObject(a) + &#039; vs &#039; + xpath.stringifyObject(b));
  }
  /** The merge in merge-sort.*/
  function mergeNodeLists(x, y) {
    var a, b, aanc, banc, r = [];
    if (&#039;object&#039; !== typeof x)
      throw new XPathException(XPathException.INVALID_EXPRESSION_ERR,
                               &#039;Invalid LHS for | operator &#039; +
                               &#039;(expected node-set): &#039; + x);
    if (&#039;object&#039; !== typeof y)
      throw new XPathException(XPathException.INVALID_EXPRESSION_ERR,
                               &#039;Invalid LHS for | operator &#039; +
                               &#039;(expected node-set): &#039; + y);
    while (true) {
      if (null == a) {
        a = x.shift();
        if (null != a)
          aanc = addressVector(a);
      }
      if (null == b) {
        b = y.shift();
        if (null != b)
          banc = addressVector(b);
      }
      if (null == a || null == b) break;
      var c = addressComparator(aanc, banc);
      if (c &lt; 0) {
        r.push(a);
        a = null;
        aanc = null;
      } else if (c &gt; 0) {
        r.push(b);
        b = null;
        banc = null;
      } else if (a.nodeName &lt; b.nodeName) {  // attributes
        r.push(a);
        a = null;
        aanc = null;
      } else if (a.nodeName &gt; b.nodeName) {  // attributes
        r.push(b);
        b = null;
        banc = null;
      } else if (a !== b) {
        // choose b arbitrarily
        r.push(b);
        b = null;
        banc = null;
      } else {
        console.assert(a === b, c);
        // just skip b without pushing it.
        b = null;
        banc = null;
      }
    }
    while (a) {
      r.push(a);
      a = x.shift();
    }
    while (b) {
      r.push(b);
      b = y.shift();
    }
    return r;
  }
  function comparisonHelper(test, x, y, isNumericComparison) {
    var coersion;
    if (isNumericComparison)
      coersion = fn.number;
    else coersion =
      &#039;boolean&#039; === typeof x || &#039;boolean&#039; === typeof y ? fn[&#039;boolean&#039;] :
      &#039;number&#039; === typeof x || &#039;number&#039; === typeof y ? fn.number :
      fn.string;
    if (&#039;object&#039; === typeof x &amp;&amp; &#039;object&#039; === typeof y) {
      var aMap = {};
      for (var i = 0; i &lt; x.nodes.length; ++i) {
        var xi = coersion({nodes:[x.nodes[i]]});
        for (var j = 0; j &lt; y.nodes.length; ++j) {
          var yj = coersion({nodes:[y.nodes[j]]});
          if (test(xi, yj)) return true;
        }
      }
      return false;
    } else if (&#039;object&#039; === typeof x &amp;&amp; x.nodes &amp;&amp; x.nodes.length) {
      for (var i = 0; i &lt; x.nodes.length; ++i) {
        var xi = coersion({nodes:[x.nodes[i]]}), yc = coersion(y);
        if (test(xi, yc))
          return true;
      }
      return false;
    } else if (&#039;object&#039; === typeof y &amp;&amp; x.nodes &amp;&amp; x.nodes.length) {
      for (var i = 0; i &lt; x.nodes.length; ++i) {
        var yi = coersion({nodes:[y.nodes[i]]}), xc = coersion(x);
        if (test(xc, yi))
          return true;
      }
      return false;
    } else {
      var xc = coersion(x), yc = coersion(y);
      return test(xc, yc);
    }
  }
  var axes = xpath.axes = {
    &#039;ancestor&#039;:
      function ancestor(nodeList  /*destructive!*/, nodeTypeNum, nodeName, shouldLowerCase) {
        return ancestorHelper(
          nodeList  /*destructive!*/, nodeTypeNum, nodeName, shouldLowerCase, false);
      },
    &#039;ancestor-or-self&#039;:
      function ancestorOrSelf(nodeList  /*destructive!*/, nodeTypeNum, nodeName, shouldLowerCase) {
        return ancestorHelper(
          nodeList  /*destructive!*/, nodeTypeNum, nodeName, shouldLowerCase, true);
      },
    &#039;attribute&#039;:
      function attribute(nodeList  /*destructive!*/, nodeTypeNum, nodeName, shouldLowerCase) {
        // TODO: figure out whether positions should be undefined here.
        var matcher = new NodeMatcher(nodeTypeNum, nodeName, shouldLowerCase);
        var nodeMultiSet = new NodeMultiSet(false);
        if (null != nodeName) {
          // TODO: with namespace
          for (var i = 0; i &lt; nodeList.length; ++i) {
            var node = nodeList[i];
            if (null == node.getAttributeNode)
              continue;  // only Element has .getAttributeNode
            var attr = node.getAttributeNode(nodeName);
            if (null != attr &amp;&amp; matcher.matches(attr)) {
              nodeMultiSet.pushSeries();
              nodeMultiSet.addNode(attr);
              nodeMultiSet.popSeries();
            }
          }
        } else {
          for (var i = 0; i &lt; nodeList.length; ++i) {
            var node = nodeList[i];
            if (null != node.attributes) {
              nodeMultiSet.pushSeries();
              for (var j = 0; j &lt; node.attributes.length; j++) {  // all nodes have .attributes
                var attr = node.attributes[j];
                if (matcher.matches(attr))  // TODO: I think this check is unnecessary
                  nodeMultiSet.addNode(attr);
              }
              nodeMultiSet.popSeries();
            }
          }
        }
        return nodeMultiSet.finalize();
      },
    &#039;child&#039;:
      function child(nodeList  /*destructive!*/, nodeTypeNum, nodeName, shouldLowerCase) {
        var matcher = new NodeMatcher(nodeTypeNum, nodeName, shouldLowerCase);
        var nodeMultiSet = new NodeMultiSet(false);
        for (var i = 0; i &lt; nodeList.length; ++i) {
          var n = nodeList[i];
          if (n.ownerElement)  // skip attribute nodes&#039; text child.
            continue;
          if (n.childNodes) {
            nodeMultiSet.pushSeries();
            var childList = 1 === nodeTypeNum &amp;&amp; null != n.children ?
                n.children : n.childNodes;
            for (var j = 0; j &lt; childList.length; ++j) {
              var child = childList[j];
              if (matcher.matches(child)) {
                nodeMultiSet.addNode(child);
              }
              // don&#039;t have to do de-duping because children have parent,
              // which are current context.
            }
            nodeMultiSet.popSeries();
          }
        }
        nodeMultiSet.finalize();
        return sortNodeMultiSet(nodeMultiSet);
      },
    &#039;descendant&#039;:
      function descenant(nodeList  /*destructive!*/, nodeTypeNum, nodeName, shouldLowerCase) {
        return descenantHelper(
          nodeList  /*destructive!*/, nodeTypeNum, nodeName, shouldLowerCase, false);
      },
    &#039;descendant-or-self&#039;:
      function descenantOrSelf(nodeList  /*destructive!*/, nodeTypeNum, nodeName, shouldLowerCase) {
        return descenantHelper(
          nodeList  /*destructive!*/, nodeTypeNum, nodeName, shouldLowerCase, true);
      },
    &#039;following&#039;:
      function following(nodeList  /*destructive!*/, nodeTypeNum, nodeName, shouldLowerCase) {
        return followingHelper(nodeList  /*destructive!*/, nodeTypeNum, nodeName, shouldLowerCase);
      },
    &#039;following-sibling&#039;:
      function followingSibling(nodeList  /*destructive!*/, nodeTypeNum, nodeName, shouldLowerCase) {
        return followingSiblingHelper(
          nodeList  /*destructive!*/, nodeTypeNum, nodeName, shouldLowerCase,
          Array.prototype.shift, function() {return this[0];},
          function(node) {return node.nextSibling;});
      },
    &#039;namespace&#039;:
      function namespace(nodeList  /*destructive!*/, nodeTypeNum, nodeName, shouldLowerCase) {
        // TODO
      },
    &#039;parent&#039;:
      function parent(nodeList  /*destructive!*/, nodeTypeNum, nodeName, shouldLowerCase) {
        var matcher = new NodeMatcher(nodeTypeNum, nodeName, shouldLowerCase);
        var nodes = [], pos = [];
        for (var i = 0; i &lt; nodeList.length; ++i) {
          var parent = nodeList[i].parentNode || nodeList[i].ownerElement;
          if (null == parent)
            continue;
          if (!matcher.matches(parent))
            continue;
          if (nodes.length &gt; 0 &amp;&amp; parent === nodes[nodes.length-1])
            continue;
          nodes.push(parent);
          pos.push([1]);
        }
        return {nodes:nodes, pos:pos, lasts:pos};
      },
    &#039;preceding&#039;:
      function preceding(nodeList  /*destructive!*/, nodeTypeNum, nodeName, shouldLowerCase) {
        return precedingHelper(
          nodeList  /*destructive!*/, nodeTypeNum, nodeName, shouldLowerCase);
      },
    &#039;preceding-sibling&#039;:
      function precedingSibling(nodeList  /*destructive!*/, nodeTypeNum, nodeName, shouldLowerCase) {
        return followingSiblingHelper(
          nodeList  /*destructive!*/, nodeTypeNum, nodeName, shouldLowerCase,
          Array.prototype.pop, function() {return this[this.length-1];},
          function(node) {return node.previousSibling},
          false, true);
      },
    &#039;self&#039;:
      function self(nodeList  /*destructive!*/, nodeTypeNum, nodeName, shouldLowerCase) {
        var nodes = [], pos = [];
        var matcher = new NodeMatcher(nodeTypeNum, nodeName, shouldLowerCase);
        for (var i = 0; i &lt; nodeList.length; ++i) {
          if (matcher.matches(nodeList[i])) {
            nodes.push(nodeList[i]);
            pos.push([1]);
          }
        }
        return {nodes: nodes, pos: pos, lasts: pos}
      }
  };

  /***************************************************************************
   *                         Evaluation: functions                           *
   ***************************************************************************/
  var fn = {
    &#039;number&#039;: function number(optObject) {
      if (&#039;number&#039; === typeof optObject)
        return optObject;
      if (&#039;string&#039; === typeof optObject)
        return parseFloat(optObject);  // note: parseFloat(&#039; &#039;) -&gt; NaN, unlike +&#039; &#039; -&gt; 0.
      if (&#039;boolean&#039; === typeof optObject)
        return +optObject;
      return fn.number(fn.string.call(this, optObject));  // for node-sets
    },
    &#039;string&#039;: function string(optObject) {
      if (null == optObject)
        return fn.string(this);
      if (&#039;string&#039; === typeof optObject || &#039;boolean&#039; === typeof optObject ||
          &#039;number&#039; === typeof optObject)
        return &#039;&#039; + optObject;
      if (0 == optObject.nodes.length) return &#039;&#039;;
      if (null != optObject.nodes[0].textContent)
        return optObject.nodes[0].textContent;
      return optObject.nodes[0].nodeValue;
    },
    &#039;boolean&#039;: function booleanVal(x) {
      return &#039;object&#039; === typeof x ? x.nodes.length &gt; 0 : !!x;
    },
    &#039;last&#039;: function last() {
      console.assert(Array.isArray(this.pos));
      console.assert(Array.isArray(this.lasts));
      console.assert(1 === this.pos.length);
      console.assert(1 === this.lasts.length);
      console.assert(1 === this.lasts[0].length);
      return this.lasts[0][0];
    },
    &#039;position&#039;: function position() {
      console.assert(Array.isArray(this.pos));
      console.assert(Array.isArray(this.lasts));
      console.assert(1 === this.pos.length);
      console.assert(1 === this.lasts.length);
      console.assert(1 === this.pos[0].length);
      return this.pos[0][0];
    },
    &#039;count&#039;: function count(nodeSet) {
      if (&#039;object&#039; !== typeof nodeSet)
        throw new XPathException(XPathException.INVALID_EXPRESSION_ERR,
                                 &#039;Position &#039; + stream.position() +
                                 &#039;: Function count(node-set) &#039; +
                                 &#039;got wrong argument type: &#039; + nodeSet);
      return nodeSet.nodes.length;
    },
    &#039;id&#039;: function id(object) {
      var r = {nodes: []};
      var doc = this.nodes[0].ownerDocument || this.nodes[0];
      console.assert(doc);
      var ids;
      if (&#039;object&#039; === typeof object) {
        // for node-sets, map id over each node value.
        ids = [];
        for (var i = 0; i &lt; object.nodes.length; ++i) {
          var idNode = object.nodes[i];
          var idsString = fn.string({nodes:[idNode]});
          var a = idsString.split(/[ \t\r\n]+/g);
          Array.prototype.push.apply(ids, a);
        }
      } else {
        var idsString = fn.string(object);
        var a = idsString.split(/[ \t\r\n]+/g);
        ids = a;
      }
      for (var i = 0; i &lt; ids.length; ++i) {
        var id = ids[i];
        if (0 === id.length)
          continue;
        var node = doc.getElementById(id);
        if (null != node)
          r.nodes.push(node);
      }
      r.nodes = sortUniqDocumentOrder(r.nodes);
      return r;
    },
    &#039;local-name&#039;: function(nodeSet) {
      if (null == nodeSet)
        return fn.name(this);
      if (null == nodeSet.nodes) {
        throw new XPathException(XPathException.INVALID_EXPRESSION_ERR,
                                 &#039;argument to name() must be a node-set. got &#039; + nodeSet);
      }
      // TODO: namespaced version
      return nodeSet.nodes[0].nodeName.toLowerCase();  // TODO: no toLowerCase for xml
    },
    &#039;namespace-uri&#039;: function(nodeSet) {
      // TODO
      throw new Error(&#039;not implemented yet&#039;);
    },
    &#039;name&#039;: function(nodeSet) {
      if (null == nodeSet)
        return fn.name(this);
      if (null == nodeSet.nodes) {
        throw new XPathException(XPathException.INVALID_EXPRESSION_ERR,
                                 &#039;argument to name() must be a node-set. got &#039; + nodeSet);
      }
      return nodeSet.nodes[0].nodeName.toLowerCase();  // TODO: no toLowerCase for xml
    },
    &#039;concat&#039;: function concat(x) {
      var l = [];
      for (var i = 0; i &lt; arguments.length; ++i) {
        l.push(fn.string(arguments[i]));
      }
      return l.join(&#039;&#039;);
    },
    &#039;starts-with&#039;: function startsWith(a, b) {
      var as = fn.string(a), bs = fn.string(b);
      return as.substr(0, bs.length) === bs;
    },
    &#039;contains&#039;: function contains(a, b) {
      var as = fn.string(a), bs = fn.string(b);
      var i = as.indexOf(bs);
      if (-1 === i) return false;
      return true;
    },
    &#039;substring-before&#039;: function substringBefore(a, b) {
      var as = fn.string(a), bs = fn.string(b);
      var i = as.indexOf(bs);
      if (-1 === i) return &#039;&#039;;
      return as.substr(0, i);
    },
    &#039;substring-after&#039;: function substringBefore(a, b) {
      var as = fn.string(a), bs = fn.string(b);
      var i = as.indexOf(bs);
      if (-1 === i) return &#039;&#039;;
      return as.substr(i + bs.length);
    },
    &#039;substring&#039;: function substring(string, start, optEnd) {
      if (null == string || null == start) {
        throw new XPathException(XPathException.INVALID_EXPRESSION_ERR,
                                 &#039;Must be at least 2 arguments to string()&#039;);
      }
      var sString = fn.string(string),
          iStart = fn.round(start),
          iEnd = optEnd == null ? null : fn.round(optEnd);
      // Note that xpath string positions user 1-based index
      if (iEnd == null)
        return sString.substr(iStart - 1);
      else
        return sString.substr(iStart - 1, iEnd);
    },
    &#039;string-length&#039;: function stringLength(optString) {
      return fn.string.call(this, optString).length;
    },
    &#039;normalize-space&#039;: function normalizeSpace(optString) {
      var s = fn.string.call(this, optString);
      return s.replace(/[ \t\r\n]+/g, &#039; &#039;).replace(/^ | $/g, &#039;&#039;);
    },
    &#039;translate&#039;: function translate(string, from, to) {
      var sString = fn.string.call(this, string),
          sFrom = fn.string(from),
          sTo = fn.string(to);
      var eachCharRe = [];
      var map = {};
      for (var i = 0; i &lt; sFrom.length; ++i) {
        var c = sFrom.charAt(i);
        map[c] = sTo.charAt(i);  // returns &#039;&#039; if beyond length of sTo.
        // copied from goog.string.regExpEscape in the Closure library.
        eachCharRe.push(
          c.replace(/([-()\[\]{}+?*.$\^|,:#&lt;!\\])/g, &#039;\\$1&#039;).
            replace(/\x08/g, &#039;\\x08&#039;));
      }
      var re = new RegExp(eachCharRe.join(&#039;|&#039;), &#039;g&#039;);
      return sString.replace(re, function(c) {return map[c];});
    },
    /// Boolean functions
    &#039;not&#039;: function not(x) {
      var bx = fn[&#039;boolean&#039;](x);
      return !bx;
    },
    &#039;true&#039;: function trueVal() { return true; },
    &#039;false&#039;: function falseVal() { return false; },
    // TODO
    &#039;lang&#039;: function lang(string) { throw new Error(&#039;Not implemented&#039;);},
    &#039;sum&#039;: function sum(optNodeSet) {
      if (null == optNodeSet) return fn.sum(this);
      // for node-sets, map id over each node value.
      var sum = 0;
      for (var i = 0; i &lt; optNodeSet.nodes.length; ++i) {
        var node = optNodeSet.nodes[i];
        var x = fn.number({nodes:[node]});
        sum += x;
      }
      return sum;
    },
    &#039;floor&#039;: function floor(number) {
      return Math.floor(fn.number(number));
    },
    &#039;ceiling&#039;: function ceiling(number) {
      return Math.ceil(fn.number(number));
    },
    &#039;round&#039;: function round(number) {
      return Math.round(fn.number(number));
    }
  };
  /***************************************************************************
   *                         Evaluation: operators                           *
   ***************************************************************************/
  var more = {
    UnaryMinus: function(x) { return -fn.number(x); },
    &#039;+&#039;: function(x, y) { return fn.number(x) + fn.number(y); },
    &#039;-&#039;: function(x, y) { return fn.number(x) - fn.number(y); },
    &#039;*&#039;: function(x, y) { return fn.number(x) * fn.number(y); },
    &#039;div&#039;: function(x, y) { return fn.number(x) / fn.number(y); },
    &#039;mod&#039;: function(x, y) { return fn.number(x) % fn.number(y); },
    &#039;&lt;&#039;: function(x, y) {
      return comparisonHelper(function(x, y) { return fn.number(x) &lt; fn.number(y);}, x, y, true);
    },
    &#039;&lt;=&#039;: function(x, y) {
      return comparisonHelper(function(x, y) { return fn.number(x) &lt;= fn.number(y);}, x, y, true);
    },
    &#039;&gt;&#039;:  function(x, y) {
      return comparisonHelper(function(x, y) { return fn.number(x) &gt; fn.number(y);}, x, y, true);
    },
    &#039;&gt;=&#039;: function(x, y) {
      return comparisonHelper(function(x, y) { return fn.number(x) &gt;= fn.number(y);}, x, y, true);
    },
    &#039;and&#039;: function(x, y) { return fn[&#039;boolean&#039;](x) &amp;&amp; fn[&#039;boolean&#039;](y); },
    &#039;or&#039;: function(x, y) { return fn[&#039;boolean&#039;](x) || fn[&#039;boolean&#039;](y); },
    &#039;|&#039;: function(x, y) { return {nodes: mergeNodeLists(x.nodes, y.nodes)}; },
    &#039;=&#039;: function(x, y) {
      // optimization for two node-sets case: avoid n^2 comparisons.
      if (&#039;object&#039; === typeof x &amp;&amp; &#039;object&#039; === typeof y) {
        var aMap = {};
        for (var i = 0; i &lt; x.nodes.length; ++i) {
          var s = fn.string({nodes:[x.nodes[i]]});
          aMap[s] = true;
        }
        for (var i = 0; i &lt; y.nodes.length; ++i) {
          var s = fn.string({nodes:[y.nodes[i]]});
          if (aMap[s]) return true;
        }
        return false;
      } else {
        return comparisonHelper(function(x, y) {return x === y;}, x, y);
      }
    },
    &#039;!=&#039;: function(x, y) {
      // optimization for two node-sets case: avoid n^2 comparisons.
      if (&#039;object&#039; === typeof x &amp;&amp; &#039;object&#039; === typeof y) {
        if (0 === x.nodes.length || 0 === y.nodes.length) return false;
        var aMap = {};
        for (var i = 0; i &lt; x.nodes.length; ++i) {
          var s = fn.string({nodes:[x.nodes[i]]});
          aMap[s] = true;
        }
        for (var i = 0; i &lt; y.nodes.length; ++i) {
          var s = fn.string({nodes:[y.nodes[i]]});
          if (!aMap[s]) return true;
        }
        return false;
      } else {
        return comparisonHelper(function(x, y) {return x !== y;}, x, y);
      }
    }
  };
  var nodeTypes = xpath.nodeTypes = {
    &#039;node&#039;: 0,
    &#039;attribute&#039;: 2,
    &#039;comment&#039;: 8, // this.doc.COMMENT_NODE,
    &#039;text&#039;: 3, // this.doc.TEXT_NODE,
    &#039;processing-instruction&#039;: 7, // this.doc.PROCESSING_INSTRUCTION_NODE,
    &#039;element&#039;: 1  //this.doc.ELEMENT_NODE
  };
  /** For debugging and unit tests: returnjs a stringified version of the
   * argument. */
  var stringifyObject = xpath.stringifyObject = function stringifyObject(ctx) {
    var seenKey = &#039;seen&#039; + Math.floor(Math.random()*1000000000);
    return JSON.stringify(helper(ctx));

    function helper(ctx) {
      if (Array.isArray(ctx)) {
        return ctx.map(function(x) {return helper(x);});
      }
      if (&#039;object&#039; !== typeof ctx) return ctx;
      if (null == ctx) return ctx;
    //  if (ctx.toString) return ctx.toString();
      if (null != ctx.outerHTML) return ctx.outerHTML;
      if (null != ctx.nodeValue) return ctx.nodeName + &#039;=&#039; + ctx.nodeValue;
      if (ctx[seenKey]) return &#039;[circular]&#039;;
      ctx[seenKey] = true;
      var nicer = {};
      for (var key in ctx) {
        if (seenKey === key)
          continue;
        try {
          nicer[key] = helper(ctx[key]);
        } catch (e) {
          nicer[key] = &#039;[exception: &#039; + e.message + &#039;]&#039;;
        }
      }
      delete ctx[seenKey];
      return nicer;
    }
  }
  var Evaluator = xpath.Evaluator = function Evaluator(doc) {
    this.doc = doc;
  }
  Evaluator.prototype = {
    val: function val(ast, ctx) {
      console.assert(ctx.nodes);

      if (&#039;number&#039; === typeof ast || &#039;string&#039; === typeof ast) return ast;
      if (more[ast[0]]) {
        var evaluatedParams = [];
        for (var i = 1; i &lt; ast.length; ++i) {
          evaluatedParams.push(this.val(ast[i], ctx));
        }
        var r = more[ast[0]].apply(ctx, evaluatedParams);
        return r;
      }
      switch (ast[0]) {
        case &#039;Root&#039;: return {nodes: [this.doc]};
        case &#039;FunctionCall&#039;:
          var functionName = ast[1], functionParams = ast[2];
          if (null == fn[functionName])
            throw new XPathException(XPathException.INVALID_EXPRESSION_ERR,
                                     &#039;Unknown function: &#039; + functionName);
          var evaluatedParams = [];
          for (var i = 0; i &lt; functionParams.length; ++i) {
            evaluatedParams.push(this.val(functionParams[i], ctx));
          }
          var r = fn[functionName].apply(ctx, evaluatedParams);
          return r;
        case &#039;Predicate&#039;:
          var lhs = this.val(ast[1], ctx);
          var ret = {nodes: []};
          var contexts = eachContext(lhs);
          for (var i = 0; i &lt; contexts.length; ++i) {
            var singleNodeSet = contexts[i];
            var rhs = this.val(ast[2], singleNodeSet);
            var success;
            if (&#039;number&#039; === typeof rhs) {
              success = rhs === singleNodeSet.pos[0][0];
            } else {
              success = fn[&#039;boolean&#039;](rhs);
            }
            if (success) {
              var node = singleNodeSet.nodes[0];
              ret.nodes.push(node);
              // skip over all the rest of the same node.
              while (i+1 &lt; contexts.length &amp;&amp; node === contexts[i+1].nodes[0]) {
                i++;
              }
            }
          }
          return ret;
        case &#039;PathExpr&#039;:
          // turn the path into an expressoin; i.e., remove the position
          // information of the last axis.
          var x = this.val(ast[1], ctx);
          // Make the nodeset a forward-direction-only one.
          if (x.finalize) {  // it is a NodeMultiSet
            for (var i = 0; i &lt; x.nodes.length; ++i) {
              console.assert(null != x.nodes[i].nodeType);
            }
            return {nodes: x.nodes};
          } else {
            return x;
          }
        case &#039;/&#039;:
          // TODO: don&#039;t generate &#039;/&#039; nodes, just Axis nodes.
          var lhs = this.val(ast[1], ctx);
          console.assert(null != lhs);
          var r = this.val(ast[2], lhs);
          console.assert(null != r);
          return r;
        case &#039;Axis&#039;:
          // All the axis tests from Step. We only get AxisSpecifier NodeTest,
          // not the predicate (which is applied later)
          var axis = ast[1],
              nodeType = ast[2],
              nodeTypeNum = nodeTypes[nodeType],
              shouldLowerCase = true,  // TODO: give option
              nodeName = ast[3] &amp;&amp; shouldLowerCase ? ast[3].toLowerCase() : ast[3];
          nodeName = nodeName === &#039;*&#039; ? null : nodeName;
          if (&#039;object&#039; !== typeof ctx) return {nodes:[], pos:[]};
          var nodeList = ctx.nodes.slice();  // TODO: is copy needed?
          var r = axes[axis](nodeList  /*destructive!*/, nodeTypeNum, nodeName, shouldLowerCase);
          return r;
      }
    }
  };
  var evaluate = xpath.evaluate = function evaluate(expr, doc, context) {
    //var astFactory = new AstEvaluatorFactory(doc, context);
    var stream = new Stream(expr);
    var ast = parse(stream, astFactory);
    var val = new Evaluator(doc).val(ast, {nodes: [context]});
    return val;
  }

  /***************************************************************************
   *                           DOM interface                                 *
   ***************************************************************************/
  var XPathException = xpath.XPathException = function XPathException(code, message) {
    var e = new Error(message);
    e.name = &#039;XPathException&#039;;
    e.code = code;
    return e;
  }
  XPathException.INVALID_EXPRESSION_ERR = 51;
  XPathException.TYPE_ERR = 52;


  var XPathEvaluator = xpath.XPathEvaluator = function XPathEvaluator() {}
  XPathEvaluator.prototype = {
    createExpression: function(expression, resolver) {
      return new XPathExpression(expression, resolver);
    },
    createNSResolver: function(nodeResolver) {
      // TODO
    },
    evaluate: function evaluate(expression, contextNode, resolver, type, result) {
      var expr = new XPathExpression(expression, resolver);
      return expr.evaluate(contextNode, type, result);
    }
  };


  var XPathExpression = xpath.XPathExpression = function XPathExpression(expression, resolver, optDoc) {
    var stream = new Stream(expression);
    this._ast = parse(stream, astFactory);
    this._doc = optDoc;
  }
  XPathExpression.prototype = {
    evaluate: function evaluate(contextNode, type, result) {
      if (null == contextNode.nodeType)
        throw new Error(&#039;bad argument (expected context node): &#039; + contextNode);
      var doc = contextNode.ownerDocument || contextNode;
      if (null != this._doc &amp;&amp; this._doc !== doc) {
        throw new core.DOMException(
            core.WRONG_DOCUMENT_ERR,
            &#039;The document must be the same as the context node\&#039;s document.&#039;);
      }
      var evaluator = new Evaluator(doc);
      var value = evaluator.val(this._ast, {nodes: [contextNode]});
      if (XPathResult.NUMBER_TYPE === type)
        value = fn.number(value);
      else if (XPathResult.STRING_TYPE === type)
        value = fn.string(value);
      else if (XPathResult.BOOLEAN_TYPE === type)
        value = fn[&#039;boolean&#039;](value);
      else if (XPathResult.ANY_TYPE !== type &amp;&amp;
               XPathResult.UNORDERED_NODE_ITERATOR_TYPE !== type &amp;&amp;
               XPathResult.ORDERED_NODE_ITERATOR_TYPE !== type &amp;&amp;
               XPathResult.UNORDERED_NODE_SNAPSHOT_TYPE !== type &amp;&amp;
               XPathResult.ORDERED_NODE_SNAPSHOT_TYPE !== type &amp;&amp;
               XPathResult.ANY_UNORDERED_NODE_TYPE !== type &amp;&amp;
               XPathResult.FIRST_ORDERED_NODE_TYPE !== type)
        throw new core.DOMException(
            core.NOT_SUPPORTED_ERR,
            &#039;You must provide an XPath result type (0=any).&#039;);
      else if (XPathResult.ANY_TYPE !== type &amp;&amp;
               &#039;object&#039; !== typeof value)
        throw new XPathException(
            XPathException.TYPE_ERR,
            &#039;Value should be a node-set: &#039; + value);
      return new XPathResult(doc, value, type);
    }
  }

  var XPathResult = xpath.XPathResult = function XPathResult(doc, value, resultType) {
    this._value = value;
    this._resultType = resultType;
    this._i = 0;
    this._invalidated = false;
    if (this.resultType === XPathResult.UNORDERED_NODE_ITERATOR_TYPE ||
        this.resultType === XPathResult.ORDERED_NODE_ITERATOR_TYPE) {
      doc.addEventListener(&#039;DOMSubtreeModified&#039;, invalidate, true);
      var self = this;
      function invalidate() {
        self._invalidated = true;
        doc.removeEventListener(&#039;DOMSubtreeModified&#039;, invalidate, true);
      }
    }
  }
  XPathResult.ANY_TYPE = 0;
  XPathResult.NUMBER_TYPE = 1;
  XPathResult.STRING_TYPE = 2;
  XPathResult.BOOLEAN_TYPE = 3;
  XPathResult.UNORDERED_NODE_ITERATOR_TYPE = 4;
  XPathResult.ORDERED_NODE_ITERATOR_TYPE = 5;
  XPathResult.UNORDERED_NODE_SNAPSHOT_TYPE = 6;
  XPathResult.ORDERED_NODE_SNAPSHOT_TYPE = 7;
  XPathResult.ANY_UNORDERED_NODE_TYPE = 8;
  XPathResult.FIRST_ORDERED_NODE_TYPE = 9;
  var proto = {
    // XPathResultType
    get resultType() {
      if (this._resultType) return this._resultType;
      switch (typeof this._value) {
        case &#039;number&#039;: return XPathResult.NUMBER_TYPE;
        case &#039;string&#039;: return XPathResult.STRING_TYPE;
        case &#039;boolean&#039;: return XPathResult.BOOLEAN_TYPE;
        default: return XPathResult.UNORDERED_NODE_ITERATOR_TYPE;
      }
    },
    get numberValue() {
      if (XPathResult.NUMBER_TYPE !== this.resultType)
        throw new XPathException(XPathException.TYPE_ERR,
                                 &#039;You should have asked for a NUMBER_TYPE.&#039;);
      return this._value;
    },
    get stringValue() {
      if (XPathResult.STRING_TYPE !== this.resultType)
        throw new XPathException(XPathException.TYPE_ERR,
                                 &#039;You should have asked for a STRING_TYPE.&#039;);
      return this._value;
    },
    get booleanValue() {
      if (XPathResult.BOOLEAN_TYPE !== this.resultType)
        throw new XPathException(XPathException.TYPE_ERR,
                                 &#039;You should have asked for a BOOLEAN_TYPE.&#039;);
      return this._value;
    },
    get singleNodeValue() {
      if (XPathResult.ANY_UNORDERED_NODE_TYPE !== this.resultType &amp;&amp;
          XPathResult.FIRST_ORDERED_NODE_TYPE !== this.resultType)
        throw new XPathException(
            XPathException.TYPE_ERR,
            &#039;You should have asked for a FIRST_ORDERED_NODE_TYPE.&#039;);
      return this._value.nodes[0] || null;
    },
    get invalidIteratorState() {
      if (XPathResult.UNORDERED_NODE_ITERATOR_TYPE !== this.resultType &amp;&amp;
          XPathResult.ORDERED_NODE_ITERATOR_TYPE !== this.resultType)
        return false;
      return !!this._invalidated;
    },
    get snapshotLength() {
      if (XPathResult.UNORDERED_NODE_SNAPSHOT_TYPE !== this.resultType &amp;&amp;
          XPathResult.ORDERED_NODE_SNAPSHOT_TYPE !== this.resultType)
        throw new XPathException(
            XPathException.TYPE_ERR,
            &#039;You should have asked for a ORDERED_NODE_SNAPSHOT_TYPE.&#039;);
      return this._value.nodes.length;
    },
    iterateNext: function iterateNext() {
      if (XPathResult.UNORDERED_NODE_ITERATOR_TYPE !== this.resultType &amp;&amp;
          XPathResult.ORDERED_NODE_ITERATOR_TYPE !== this.resultType)
        throw new XPathException(
            XPathException.TYPE_ERR,
            &#039;You should have asked for a ORDERED_NODE_ITERATOR_TYPE.&#039;);
      if (this.invalidIteratorState)
        throw new core.DOMException(
            core.INVALID_STATE_ERR,
            &#039;The document has been mutated since the result was returned&#039;);
      return this._value.nodes[this._i++] || null;
    },
    snapshotItem: function snapshotItem(index) {
      if (XPathResult.UNORDERED_NODE_SNAPSHOT_TYPE !== this.resultType &amp;&amp;
          XPathResult.ORDERED_NODE_SNAPSHOT_TYPE !== this.resultType)
        throw new XPathException(
            XPathException.TYPE_ERR,
            &#039;You should have asked for a ORDERED_NODE_SNAPSHOT_TYPE.&#039;);
      return this._value.nodes[index] || null;
    }
  };
  // so you can access ANY_TYPE etc. from the instances:
  XPathResult.prototype = Object.create(XPathResult,
      Object.keys(proto).reduce(function (descriptors, name) {
        descriptors[name] = Object.getOwnPropertyDescriptor(proto, name);
        return descriptors;
      }, {
        constructor: {
          value: XPathResult,
          writable: true,
          configurable: true
        }
      }));

  core.XPathException = XPathException;
  core.XPathExpression = XPathExpression;
  core.XPathResult = XPathResult;
  core.XPathEvaluator = XPathEvaluator;

  core.Document.prototype.createExpression =
    XPathEvaluator.prototype.createExpression;

  core.Document.prototype.createNSResolver =
      XPathEvaluator.prototype.createNSResolver;

  core.Document.prototype.evaluate = XPathEvaluator.prototype.evaluate;

})();</textarea>
  </div>
</div>

<footer class="footer">
  <div class="container">
    <p>.</p>
  </div>
</footer>

<script type="text/html" id="complexity-popover-template">
  <div class="complexity-notice">
    Complexity : {{ complexity.cyclomatic }} <br>
    Length : {{ complexity.halstead.length }} <br>
    Difficulty : {{ complexity.halstead.difficulty.toFixed(2) }} <br>
    Est # bugs : {{ complexity.halstead.bugs.toFixed(2) }}<br>
  </div>
</script>

<script type="text/javascript" src="../../assets/scripts/bundles/core-bundle.js"></script>
<script type="text/javascript" src="../../assets/scripts/bundles/codemirror.js"></script>
<script type="text/javascript" src="../../assets/scripts/codemirror.markpopovertext.js"></script>
<script type="text/javascript" src="report.js"></script>
<script type="text/javascript" src="report.history.js"></script>
<script type="text/javascript" src="../../assets/scripts/plato-file.js"></script>
</body>
</html>
