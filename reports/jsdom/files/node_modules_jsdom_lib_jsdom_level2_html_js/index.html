<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Plato - node_modules/jsdom/lib/jsdom/level2/html.js</title>

  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="">
  <meta name="author" content="">

  <!--[if lt IE 9]>
  <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->

  <link href="../../assets/css/vendor/morris.css" rel="stylesheet">
  <link href="../../assets/css/vendor/bootstrap.css" rel="stylesheet">
  <link href="../../assets/css/vendor/font-awesome.css" rel="stylesheet">
  <link href="../../assets/css/vendor/codemirror.css" rel="stylesheet">
  <link href="../../assets/css/plato.css" rel="stylesheet">
  <link href="../../assets/css/plato-file.css" rel="stylesheet">

</head>

<body>

<div class="navbar navbar-fixed-top">
  <div class="container">
    <a class="navbar-brand" href="http://github.com/es-analysis/plato">Plato on Github</a>
    <ul class="nav navbar-nav">
      <li>
        <a href="../../index.html">Report Home</a>
      </li>
    </ul>
  </div>
</div>

<div class="jumbotron">
  <div class="container">
    <h1>node_modules/jsdom/lib/jsdom/level2/html.js</h1>
  </div>
</div>

<div class="container aggregate-stats">
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Maintainability <a href="http://blogs.msdn.com/b/codeanalysis/archive/2007/11/20/maintainability-index-range-and-meaning.aspx"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="A value between 0 and 100 that represents the relative ease of maintaining the code. A high value means better maintainability." data-original-title="Maintainability Index"  data-container="body"></i></a></h2>
      <p class="stat">73.82</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Lines of code <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h2>
      <p class="stat">1999</p>
    </div>
  </div>
  <div class="row historical">
    <div class="col-md-6">
      <p id="chart_historical_maint" class="chart"></p>
    </div>
    <div class="col-md-6">
      <p id="chart_historical_sloc" class="chart"></p>
    </div>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Difficulty  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="The difficulty measure is related to the difficulty of the program to write or understand." data-original-title="Difficulty" data-container="body"></i></a></h2>
      <p class="stat">109.60</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Estimated Errors  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Halstead's delivered bugs is an estimate for the number of errors in the implementation." data-original-title="Delivered Bugs" data-container="body"></i></a></h2>
      <p class="stat">22.75</p>
    </div>
  </div>
</div>

<div class="container charts">
  <div class="row">
    <h2 class="header">Function weight</h2>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h3 class="chart-header">By Complexity <a href="http://en.wikipedia.org/wiki/Cyclomatic_complexity"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="This metric counts the number of distinct paths through a block of code. Lower values are better." data-original-title="Cyclomatic Complexity" data-container="body"></i></a></h3>
      <div id="fn-by-complexity" class="stat"></div>
    </div>
    <div class="col-md-6">
      <h3 class="chart-header">By SLOC  <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h3>
      <div id="fn-by-sloc" class="stat"></div>
    </div>
  </div>
</div>

<div class="container">
  <div class="row">
    <textarea id="file-source" class="col-md-12">var core                  = require(&quot;./core&quot;).dom.level2.core,
    events                = require(&quot;./events&quot;).dom.level2.events,
    applyDocumentFeatures = require(&#039;../browser/documentfeatures&#039;).applyDocumentFeatures,
    defineGetter          = require(&#039;../utils&#039;).defineGetter,
    defineSetter          = require(&#039;../utils&#039;).defineSetter,
    inheritFrom           = require(&quot;../utils&quot;).inheritFrom,
    URL                   = require(&quot;url&quot;),
    Path                  = require(&#039;path&#039;),
    fs                    = require(&quot;fs&quot;),
    http                  = require(&#039;http&#039;),
    https                 = require(&#039;https&#039;);

// modify cloned instance for more info check: https://github.com/tmpvar/jsdom/issues/325
core = Object.create(core);

// Setup the javascript language processor
core.languageProcessors = {
  javascript : require(&quot;./languages/javascript&quot;).javascript
};

// TODO its own package? Pull request to Node?
function resolveHref(baseUrl, href) {
  if (baseUrl === resolveHref.memoizedUrl &amp;&amp; resolveHref.cache &amp;&amp; resolveHref.cache[href]) {
    return resolveHref.cache[href];
  }
  // When switching protocols, the path doesn&#039;t get canonicalized (i.e. .s and ..s are still left):
  // https://github.com/joyent/node/issues/5453
  var intermediate = URL.resolve(baseUrl, href);

  // This canonicalizes the path, at the cost of overwriting the hash.
  var nextStep = URL.resolve(intermediate, &#039;#&#039;);

  // So, insert the hash back in, if there was one.
  var parsed = URL.parse(intermediate);
  var fixed = nextStep.slice(0, -1) + (parsed.hash || &#039;&#039;);

  // Finally, fix file:/// URLs on Windows, where Node removes their drive letters:
  // https://github.com/joyent/node/issues/5452
  if (/^file\:\/\/\/[a-z]\:\//i.test(baseUrl) &amp;&amp; /^file\:\/\/\//.test(fixed) &amp;&amp; !/^file\:\/\/\/[a-z]\:\//i.test(fixed)) {
    fixed = fixed.replace(/^file\:\/\/\//, baseUrl.substring(0, 11));
  }

  // HORRIBLE HACK: encode \u00E4 correctly just so that we pass
  // https://github.com/w3c/web-platform-tests/blob/e75f01a689a3481f5c773315c2c2527712cf8c2c/dom/nodes/DOMImplementation-createHTMLDocument.html#L71-L72
  // Eventually we should replace this with a real URL parser based on the URL standard.
  fixed = fixed.replace(/\u00E4/, &quot;%C3%A4&quot;);

  if (baseUrl !== resolveHref.memoizedUrl) {
    resolveHref.memoizedUrl = baseUrl;
    resolveHref.cache = {};
  }
  resolveHref.cache[href] = fixed;
  return fixed;
}

core.resourceLoader = {
  load: function(element, href, callback) {
    var ownerImplementation = element._ownerDocument.implementation;

    if (ownerImplementation.hasFeature(&#039;FetchExternalResources&#039;, element.tagName.toLowerCase())) {
      var full = this.resolve(element._ownerDocument, href);
      var url = URL.parse(full);
      if (ownerImplementation.hasFeature(&#039;SkipExternalResources&#039;, full)) {
        return false;
      }
      if (url.hostname) {
        this.download(url, element._ownerDocument._cookie, element._ownerDocument._cookieDomain, this.baseUrl(element._ownerDocument), this.enqueue(element, callback, full));
      }
      else {
        this.readFile(url.pathname, this.enqueue(element, callback, full));
      }
    }
  },
  enqueue: function(element, callback, filename) {
    var loader = this,
        doc    = element.nodeType === core.Node.DOCUMENT_NODE ?
                 element                :
                 element._ownerDocument;

    if (!doc._queue) {
      return function() {};
    }

    return doc._queue.push(function(err, data) {
      var ev = doc.createEvent(&#039;HTMLEvents&#039;);

      if (!err) {
        try {
          callback.call(element, data, filename || doc.URL);
          ev.initEvent(&#039;load&#039;, false, false);
        }
        catch(e) {
          err = e;
        }
      }

      if (err) {
        ev.initEvent(&#039;error&#039;, false, false);
        ev.error = err;
      }

      element.dispatchEvent(ev);
    });
  },

  baseUrl: function(document) {
    var baseElements = document.getElementsByTagName(&#039;base&#039;);
    var baseUrl = document.URL;

    if (baseElements.length &gt; 0) {
      var baseHref = baseElements.item(0).href;
      if (baseHref) {
        baseUrl = resolveHref(baseUrl, baseHref);
      }
    }

    return baseUrl;
  },
  resolve: function(document, href) {
    // if getAttribute returns null, there is no href
    // lets resolve to an empty string (nulls are not expected farther up)
    if (href === null) {
      return &#039;&#039;;
    }

    var baseUrl = this.baseUrl(document);

    return resolveHref(baseUrl, href);
  },
  download: function(url, cookie, cookieDomain, referrer, callback) {
    var path    = url.pathname + (url.search || &#039;&#039;),
        options = {&#039;method&#039;: &#039;GET&#039;, &#039;host&#039;: url.hostname, &#039;path&#039;: path},
        request;
    if (url.protocol === &#039;https:&#039;) {
      options.port = url.port || 443;
      request = https.request(options);
    } else {
      options.port = url.port || 80;
      request = http.request(options);
    }

    // set header.
    if (referrer) {
        request.setHeader(&#039;Referer&#039;, referrer);
    }
    if (cookie) {
      var host = url.host.split(&#039;:&#039;)[0];
      if (host.indexOf(cookieDomain, host.length - cookieDomain.length) !== -1) {
        request.setHeader(&#039;cookie&#039;, cookie);
      }
    }

    request.on(&#039;response&#039;, function (response) {
      var data = &#039;&#039;;
      function success () {
        if ([301, 302, 303, 307].indexOf(response.statusCode) &gt; -1) {
          var redirect = URL.resolve(url, response.headers[&quot;location&quot;]);
          core.resourceLoader.download(URL.parse(redirect), cookie, cookieDomain, referrer, callback);
        } else {
          callback(null, data);
        }
      }
      response.setEncoding(&#039;utf8&#039;);
      response.on(&#039;data&#039;, function (chunk) {
        data += chunk.toString();
      });
      response.on(&#039;end&#039;, function() {
        // According to node docs, &#039;close&#039; can fire after &#039;end&#039;, but not
        // vice versa.  Remove &#039;close&#039; listener so we don&#039;t call success twice.
        response.removeAllListeners(&#039;close&#039;);
        success();
      });
      response.on(&#039;close&#039;, function (err) {
        if (err) {
          callback(err);
        } else {
          success();
        }
      });
    });

    request.on(&#039;error&#039;, callback);
    request.end();
  },
  readFile: function(url, callback) {
    fs.readFile(url.replace(/^file:\/\//, &quot;&quot;).replace(/^\/([a-z]):\//i, &#039;$1:/&#039;).replace(/%20/g, &#039; &#039;), &#039;utf8&#039;, callback);
  }
};

function define(elementClass, def) {
  var tagName = def.tagName,
    tagNames = def.tagNames || (tagName? [tagName] : []),
    parentClass = def.parentClass || core.HTMLElement,
    attrs = def.attributes || [],
    proto = def.proto || {};

  var elem = core[elementClass] = function(document, name) {
    parentClass.call(this, document, name || tagName.toUpperCase());
    if (elem._init) {
      elem._init.call(this);
    }
  };
  elem._init = def.init;

  inheritFrom(parentClass, elem, proto);

  attrs.forEach(function(n) {
      var prop = n.prop || n,
        attr = n.attr || prop.toLowerCase();

      if (!n.prop || n.read !== false) {
        defineGetter(elem.prototype, prop, function() {
          var s = this.getAttribute(attr);
          if (n.type &amp;&amp; n.type === &#039;boolean&#039;) {
            return s !== null;
          }
          if (n.type &amp;&amp; n.type === &#039;long&#039;) {
            return +s;
          }
          if (typeof n === &#039;object&#039; &amp;&amp; n.normalize) { // see GH-491
            return n.normalize(s);
          }
          if (s === null) {
            s = &#039;&#039;;
          }
          return s;
        });
      }

      if (!n.prop || n.write !== false) {
        defineSetter(elem.prototype, prop, function(val) {
          if (!val) {
            this.removeAttribute(attr);
          }
          else {
            var s = val.toString();
            if (typeof n === &#039;object&#039; &amp;&amp; n.normalize) {
              s = n.normalize(s);
            }
            this.setAttribute(attr, s);
          }
        });
      }
  });

  tagNames.forEach(function(tag) {
    core.Document.prototype._elementBuilders[tag.toLowerCase()] = function(doc, s) {
      var el = new elem(doc, s);

      if (def.elementBuilder) {
        return def.elementBuilder(el, doc, s);
      }

      return el;
    };
  });
}



core.HTMLCollection = function HTMLCollection(element, query) {
  this._keys = [];
  core.NodeList.call(this, element, query);
};
inheritFrom(core.NodeList, core.HTMLCollection, {
  namedItem: function(name) {
    // Try property shortcut; should work in most cases
    if (Object.prototype.hasOwnProperty.call(this, name)) {
      return this[name];
    }

    var results = this._toArray(),
        l       = results.length,
        node,
        matchingName = null;

    for (var i=0; i&lt;l; i++) {
      node = results[i];
      if (node.getAttribute(&#039;id&#039;) === name) {
        return node;
      } else if (node.getAttribute(&#039;name&#039;) === name) {
        matchingName = node;
      }
    }
    return matchingName;
  },
  toString: function() {
    return &#039;[ jsdom HTMLCollection ]: contains &#039; + this.length + &#039; items&#039;;
  },
  _resetTo: function(array) {
    var i, _this = this;

    for (i = 0; i &lt; this._keys.length; ++i) {
      delete this[this._keys[i]];
    }
    this._keys = [];

    core.NodeList.prototype._resetTo.apply(this, arguments);

    function testAttr(node, attr) {
      var val = node.getAttribute(attr);
      if (val &amp;&amp; !Object.prototype.hasOwnProperty.call(_this, val)) {
        _this[val] = node;
        _this._keys.push(val);
      }
    }
    for (i = 0; i &lt; array.length; ++i) {
      testAttr(array[i], &#039;id&#039;);
    }
    for (i = 0; i &lt; array.length; ++i) {
      testAttr(array[i], &#039;name&#039;);
    }
  }
});
Object.defineProperty(core.HTMLCollection.prototype, &#039;constructor&#039;, {
  value: core.NodeList,
  writable: true,
  configurable: true
});

core.HTMLOptionsCollection = core.HTMLCollection;

function closest(e, tagName) {
  tagName = tagName.toUpperCase();
  while (e) {
    if (e.nodeName.toUpperCase() === tagName ||
        (e.tagName &amp;&amp; e.tagName.toUpperCase() === tagName))
    {
      return e;
    }
    e = e._parentNode;
  }
  return null;
}

function descendants(e, tagName, recursive) {
  var owner = recursive ? e._ownerDocument || e : e;
  return new core.HTMLCollection(owner, core.mapper(e, function(n) {
    return n.nodeName === tagName &amp;&amp; typeof n._publicId == &#039;undefined&#039;;
  }, recursive));
}

function firstChild(e, tagName) {
  if (!e) {
    return null;
  }
  var c = descendants(e, tagName, false);
  return c.length &gt; 0 ? c[0] : null;
}

function ResourceQueue(paused) {
  this.paused = !!paused;
}
ResourceQueue.prototype = {
  push: function(callback) {
    var q = this;
    var item = {
      prev: q.tail,
      check: function() {
        if (!q.paused &amp;&amp; !this.prev &amp;&amp; this.fired){
          callback(this.err, this.data);
          if (this.next) {
            this.next.prev = null;
            this.next.check();
          }else{//q.tail===this
      q.tail = null;
    }
        }
      }
    };
    if (q.tail) {
      q.tail.next = item;
    }
    q.tail = item;
    return function(err, data) {
      item.fired = 1;
      item.err = err;
      item.data = data;
      item.check();
    };
  },
  resume: function() {
    if(!this.paused){
      return;
    }
    this.paused = false;
    var head = this.tail;
    while(head &amp;&amp; head.prev){
      head = head.prev;
    }
    if(head){
      head.check();
    }
  }
};

core.HTMLDocument = function HTMLDocument(options) {
  options = options || {};
  if (!options.contentType) {
    options.contentType = &#039;text/html&#039;;
  }
  core.Document.call(this, options);
  this._referrer = options.referrer;
  this._cookie = options.cookie;
  this._cookieDomain = options.cookieDomain || &#039;127.0.0.1&#039;;
  this._URL = options.url || &#039;/&#039;;
  this._documentRoot = options.documentRoot || Path.dirname(this._URL);
  this._queue = new ResourceQueue(options.deferClose);
  this.readyState = &#039;loading&#039;;

  // Add level2 features
  this.implementation.addFeature(&#039;core&#039;  , &#039;2.0&#039;);
  this.implementation.addFeature(&#039;html&#039;  , &#039;2.0&#039;);
  this.implementation.addFeature(&#039;xhtml&#039; , &#039;2.0&#039;);
  this.implementation.addFeature(&#039;xml&#039;   , &#039;2.0&#039;);
};

inheritFrom(core.Document, core.HTMLDocument, {
  _referrer : &quot;&quot;,
  get referrer() {
    return this._referrer || &#039;&#039;;
  },
  get domain() {
    return &quot;&quot;;
  },
  _URL : &quot;&quot;,
  get URL() {
    return this._URL;
  },
  get images() {
    return this.getElementsByTagName(&#039;IMG&#039;);
  },
  get applets() {
    return new core.HTMLCollection(this, core.mapper(this, function(el) {
      if (el &amp;&amp; el.tagName) {
        var upper = el.tagName.toUpperCase();
        if (upper === &quot;APPLET&quot;) {
          return true;
        } else if (upper === &quot;OBJECT&quot; &amp;&amp;
          el.getElementsByTagName(&#039;APPLET&#039;).length &gt; 0)
        {
          return true;
        }
      }
    }));
  },
  get links() {
    return new core.HTMLCollection(this, core.mapper(this, function(el) {
      if (el &amp;&amp; el.tagName) {
        var upper = el.tagName.toUpperCase();
        if (upper === &quot;AREA&quot; || (upper === &quot;A&quot; &amp;&amp; el.href)) {
          return true;
        }
      }
    }));
  },
  get forms() {
    return this.getElementsByTagName(&#039;FORM&#039;);
  },
  get anchors() {
    return this.getElementsByTagName(&#039;A&#039;);
  },
  open  : function() {
    this._childNodes = new core.NodeList();
    this._documentElement = null;
    this._modified();
  },
  close : function() {
    this._queue.resume();
    // Set the readyState to &#039;complete&#039; once all resources are loaded.
    // As a side-effect the document&#039;s load-event will be dispatched.
    core.resourceLoader.enqueue(this, function() {
      this.readyState = &#039;complete&#039;;
      var ev = this.createEvent(&#039;HTMLEvents&#039;);
      ev.initEvent(&#039;DOMContentLoaded&#039;, false, false);
      this.dispatchEvent(ev);
    })(null, true);
  },

  // document.write is defined in browser/index.js.

  writeln : function(text) {
    this.write(text + &#039;\n&#039;);
  },

  getElementsByName : function(elementName) {
    return new core.HTMLCollection(this, core.mapper(this, function(el) {
      return (el.getAttribute &amp;&amp; el.getAttribute(&quot;name&quot;) === elementName);
    }));
  },

  get title() {
    var head = this.head,
      title = head ? firstChild(head, &#039;TITLE&#039;) : null;
    return title ? title.textContent : &#039;&#039;;
  },

  set title(val) {
    var title = firstChild(this.head, &#039;TITLE&#039;);
    if (!title) {
      title = this.createElement(&#039;TITLE&#039;);
      var head = this.head;
      if (!head) {
        head = this.createElement(&#039;HEAD&#039;);
        this.documentElement.insertBefore(head, this.documentElement.firstChild);
      }
      head.appendChild(title);
    }
    title.textContent = val;
  },

  get head() {
    return firstChild(this.documentElement, &#039;HEAD&#039;);
  },

  set head(unused) { /* noop */ },

  get body() {
    var body = firstChild(this.documentElement, &#039;BODY&#039;);
    if (!body) {
      body = firstChild(this.documentElement, &#039;FRAMESET&#039;);
    }
    return body;
  },

  get documentElement() {
    if (!this._documentElement) {
      this._documentElement = firstChild(this, &#039;HTML&#039;);
    }
    return this._documentElement;
  },

  _cookie : &quot;&quot;,
  get cookie() {
    var cookies = Array.isArray(this._cookie) ?
      this._cookie :
      (this._cookie &amp;&amp; this._cookie.length &gt; 0 ? [this._cookie] : []);

    return cookies.map(function (x) {
      return x.split(&#039;;&#039;)[0];
    }).join(&#039;; &#039;);
  },
  set cookie(val) {
    if (val == null) return val;
    var key = val.split(&#039;=&#039;)[0];
    var cookies = Array.isArray(this._cookie) ?
      this._cookie :
      (this._cookie &amp;&amp; this._cookie.length &gt; 0 ? [this._cookie] : []);
    for (var i = 0; i &lt; cookies.length; i++) {
      if (cookies[i].lastIndexOf(key + &#039;=&#039;, 0) === 0) {
        cookies[i] = val;
        key = null;
        break;
      }
    }
    if (key) {
      cookies.push(val);
    }
    if (cookies.length === 1) {
      this._cookie = cookies[0];
    } else {
      this._cookie = cookies;
    }
    return val;
  }
});

define(&#039;HTMLElement&#039;, {
  parentClass: core.Element,
  proto : {
    // Add default event behavior (click link to navigate, click button to submit
    // form, etc). We start by wrapping dispatchEvent so we can forward events to
    // the element&#039;s _eventDefault function (only events that did not incur
    // preventDefault).
    dispatchEvent : function (event) {
      var outcome = core.Node.prototype.dispatchEvent.call(this, event)

      if (!event._preventDefault     &amp;&amp;
          event.target._eventDefaults[event.type] &amp;&amp;
          typeof event.target._eventDefaults[event.type] === &#039;function&#039;)
      {
        event.target._eventDefaults[event.type](event)
      }
      return outcome;
    },
    getBoundingClientRect: function () {
      return {
        bottom: 0,
        height: 0,
        left: 0,
        right: 0,
        top: 0,
        width: 0
      };
    },
    focus : function() {
      this._ownerDocument.activeElement = this;
    },
    blur : function() {
      this._ownerDocument.activeElement = this._ownerDocument.body;
    },
    _eventDefaults : {}
  },
  attributes: [
    &#039;id&#039;,
    &#039;title&#039;,
    &#039;lang&#039;,
    &#039;dir&#039;,
    {prop: &#039;className&#039;, attr: &#039;class&#039;, normalize: function(s) { return s || &#039;&#039;; }}
  ]
});

core.Document.prototype._defaultElementBuilder = function(document, tagName) {
  return new core.HTMLElement(document, tagName);
};

// http://www.whatwg.org/specs/web-apps/current-work/#category-listed
var listedElements = /button|fieldset|input|keygen|object|select|textarea/i;

define(&#039;HTMLFormElement&#039;, {
  tagName: &#039;FORM&#039;,
  proto: {
    get elements() {
      return new core.HTMLCollection(this._ownerDocument, core.mapper(this, function(e) {
        return listedElements.test(e.nodeName) ; // TODO exclude &lt;input type=&quot;image&quot;&gt;
      }));
    },
    get length() {
      return this.elements.length;
    },
    _dispatchSubmitEvent: function() {
      var ev = this._ownerDocument.createEvent(&#039;HTMLEvents&#039;);
      ev.initEvent(&#039;submit&#039;, true, true);
      if (!this.dispatchEvent(ev)) {
        this.submit();
      };
    },
    submit: function() {
    },
    reset: function() {
      this.elements._toArray().forEach(function(el) {
        el.value = el.defaultValue;
      });
    }
  },
  attributes: [
    &#039;name&#039;,
    {prop: &#039;acceptCharset&#039;, attr: &#039;accept-charset&#039;},
    &#039;action&#039;,
    &#039;enctype&#039;,
    &#039;method&#039;,
    &#039;target&#039;
  ]
});

define(&#039;HTMLLinkElement&#039;, {
  tagName: &#039;LINK&#039;,
  proto: {
    get href() {
      return core.resourceLoader.resolve(this._ownerDocument, this.getAttribute(&#039;href&#039;));
    }
  },
  attributes: [
    {prop: &#039;disabled&#039;, type: &#039;boolean&#039;},
    &#039;charset&#039;,
    &#039;href&#039;,
    &#039;hreflang&#039;,
    &#039;media&#039;,
    &#039;rel&#039;,
    &#039;rev&#039;,
    &#039;target&#039;,
    &#039;type&#039;
  ]
});

define(&#039;HTMLMetaElement&#039;, {
  tagName: &#039;META&#039;,
  attributes: [
    &#039;content&#039;,
    {prop: &#039;httpEquiv&#039;, attr: &#039;http-equiv&#039;},
    &#039;name&#039;,
    &#039;scheme&#039;
  ]
});

define(&#039;HTMLHtmlElement&#039;, {
  tagName: &#039;HTML&#039;,
  attributes: [
    &#039;version&#039;
  ]
});

define(&#039;HTMLHeadElement&#039;, {
  tagName: &#039;HEAD&#039;,
  attributes: [
    &#039;profile&#039;
  ]
});

define(&#039;HTMLTitleElement&#039;, {
  tagName: &#039;TITLE&#039;,
  proto: {
    get text() {
      return this.innerHTML;
    },
    set text(s) {
      this.innerHTML = s;
    }
  }
});

define(&#039;HTMLBaseElement&#039;, {
  tagName: &#039;BASE&#039;,
  attributes: [
    &#039;href&#039;,
    &#039;target&#039;
  ]
});


//**Deprecated**
define(&#039;HTMLIsIndexElement&#039;, {
  tagName : &#039;ISINDEX&#039;,
  parentClass : core.Element,
  proto : {
    get form() {
      return closest(this, &#039;FORM&#039;);
    }
  },
  attributes : [
    &#039;prompt&#039;
  ]
});


define(&#039;HTMLStyleElement&#039;, {
  tagName: &#039;STYLE&#039;,
  attributes: [
    {prop: &#039;disabled&#039;, type: &#039;boolean&#039;},
    &#039;media&#039;,
    &#039;type&#039;,
  ]
});

define(&#039;HTMLBodyElement&#039;, {
  proto: (function() {
    var proto = {};
    // The body element&#039;s &quot;traditional&quot; event handlers are proxied to the
    // window object.
    // See: http://www.whatwg.org/specs/web-apps/current-work/#the-body-element
    [&#039;onafterprint&#039;, &#039;onbeforeprint&#039;, &#039;onbeforeunload&#039;, &#039;onblur&#039;, &#039;onerror&#039;,
     &#039;onfocus&#039;, &#039;onhashchange&#039;, &#039;onload&#039;, &#039;onmessage&#039;, &#039;onoffline&#039;, &#039;ononline&#039;,
     &#039;onpagehide&#039;, &#039;onpageshow&#039;, &#039;onpopstate&#039;, &#039;onresize&#039;, &#039;onscroll&#039;,
     &#039;onstorage&#039;, &#039;onunload&#039;].forEach(function (name) {
      defineSetter(proto, name, function (handler) {
        this._ownerDocument.parentWindow[name] = handler;
      });
      defineGetter(proto, name, function () {
        return this._ownerDocument.parentWindow[name];
      });
    });
    return proto;
  })(),
  tagName: &#039;BODY&#039;,
  attributes: [
    &#039;aLink&#039;,
    &#039;background&#039;,
    &#039;bgColor&#039;,
    &#039;link&#039;,
    &#039;text&#039;,
    &#039;vLink&#039;
  ]
});

define(&#039;HTMLSelectElement&#039;, {
  tagName: &#039;SELECT&#039;,
  proto: {
    get options() {
      return new core.HTMLOptionsCollection(this, core.mapper(this, function(n) {
        return n.nodeName === &#039;OPTION&#039;;
      }));
    },

    get length() {
      return this.options.length;
    },

    get selectedIndex() {
      return this.options._toArray().reduceRight(function(prev, option, i) {
        return option.selected ? i : prev;
      }, -1);
    },

    set selectedIndex(index) {
      this.options._toArray().forEach(function(option, i) {
        option.selected = i === index;
      });
    },

    get value() {
      var i = this.selectedIndex;
      if (this.options.length &amp;&amp; (i === -1)) {
        i = 0;
      }
      if (i === -1) {
        return &#039;&#039;;
      }
      return this.options[i].value;
    },

    set value(val) {
      var self = this;
      this.options._toArray().forEach(function(option) {
        if (option.value === val) {
          option.selected = true;
        } else {
          if (!self.hasAttribute(&#039;multiple&#039;)) {
            // Remove the selected bit from all other options in this group
            // if the multiple attr is not present on the select
            option.selected = false;
          }
        }
      });
    },

    get form() {
      return closest(this, &#039;FORM&#039;);
    },

    get type() {
      return this.multiple ? &#039;select-multiple&#039; : &#039;select-one&#039;;
    },

    add: function(opt, before) {
      if (before) {
        this.insertBefore(opt, before);
      }
      else {
        this.appendChild(opt);
      }
    },

    remove: function(index) {
      var opts = this.options._toArray();
      if (index &gt;= 0 &amp;&amp; index &lt; opts.length) {
        var el = opts[index];
        el._parentNode.removeChild(el);
      }
    }

  },
  attributes: [
    {prop: &#039;disabled&#039;, type: &#039;boolean&#039;},
    {prop: &#039;multiple&#039;, type: &#039;boolean&#039;},
    &#039;name&#039;,
    {prop: &#039;size&#039;, type: &#039;long&#039;},
    {prop: &#039;tabIndex&#039;, type: &#039;long&#039;},
  ]
});

define(&#039;HTMLOptGroupElement&#039;, {
  tagName: &#039;OPTGROUP&#039;,
  attributes: [
    {prop: &#039;disabled&#039;, type: &#039;boolean&#039;},
    &#039;label&#039;
  ]
});

define(&#039;HTMLOptionElement&#039;, {
  tagName: &#039;OPTION&#039;,
  proto: {
    _attrModified: function(name, value) {
      if (name === &#039;selected&#039;) {
        this.selected = this.defaultSelected;
      }
      core.HTMLElement.prototype._attrModified.apply(this, arguments);
    },
    get form() {
      return closest(this, &#039;FORM&#039;);
    },
    get defaultSelected() {
      return this.getAttribute(&#039;selected&#039;) !== null;
    },
    set defaultSelected(s) {
      if (s) this.setAttribute(&#039;selected&#039;, &#039;selected&#039;);
      else this.removeAttribute(&#039;selected&#039;);
    },
    get text() {
      return this.innerHTML;
    },
    get value() {
      return (this.hasAttribute(&#039;value&#039;)) ? this.getAttribute(&#039;value&#039;) : this.innerHTML;
    },
    set value(val) {
      this.setAttribute(&#039;value&#039;, val);
    },
    get index() {
      return closest(this, &#039;SELECT&#039;).options._toArray().indexOf(this);
    },
    get selected() {
      if (this._selected === undefined) {
        this._selected = this.defaultSelected;
      }

      if (!this._selected &amp;&amp; this.parentNode) {
        var select = closest(this, &#039;SELECT&#039;);

        if (select) {
          var options = select.options;

          if (options.item(0) === this &amp;&amp; !select.hasAttribute(&#039;multiple&#039;)) {
            var found = false, optArray = options._toArray();

            for (var i = 1, l = optArray.length; i&lt;l; i++) {
              if (optArray[i]._selected) {
                return false;
              }
            }
            return true;
          }
        }
      }

      return this._selected;
    },
    set selected(s) {
      // TODO: The &#039;selected&#039; content attribute is the initial value of the
      // IDL attribute, but the IDL attribute should not relfect the content
      this._selected = !!s;
      if (s) {
        //Remove the selected bit from all other options in this select
        var select = this._parentNode;
        if (!select) return;
        if (select.nodeName !== &#039;SELECT&#039;) {
          select = select._parentNode;
          if (!select) return;
          if (select.nodeName !== &#039;SELECT&#039;) return;
        }
        if (!select.multiple) {
          var o = select.options;
          for (var i = 0; i &lt; o.length; i++) {
            if (o[i] !== this) {
                o[i].selected = false;
            }
          }
        }
      }
    }
  },
  attributes: [
    {prop: &#039;disabled&#039;, type: &#039;boolean&#039;},
    &#039;label&#039;
  ]
});

define(&#039;HTMLInputElement&#039;, {
  tagName: &#039;INPUT&#039;,
  init: function() {
    if (!this.type) {
      this.type = &#039;text&#039;;
    }
  },
  proto: {
    _value: null,

    _initDefaultChecked: function() {
      if (this._defaultChecked === undefined) {
        this._defaultChecked = !!this.getAttribute(&#039;checked&#039;);
      }
      return this._defaultChecked;
    },
    get form() {
      return closest(this, &#039;FORM&#039;);
    },
    get defaultValue() {
      var val = this.getAttribute(&#039;value&#039;);
      return val !== null ? val : &quot;&quot;;
    },
    set defaultValue(val) {
      this.setAttribute(&#039;value&#039;, String(val));
    },
    get defaultChecked() {
      return this._initDefaultChecked();
    },
    get checked() {
      return !!this._attributes.getNamedItem(&#039;checked&#039;);
    },
    set checked(checked) {
      this._initDefaultChecked();
      if (checked) {
        this.setAttribute(&#039;checked&#039;, &#039;checked&#039;);
        if (this.type === &#039;radio&#039;) {
          var elements = this._ownerDocument.getElementsByName(this.name);
          for (var i = 0; i &lt; elements.length; i++) {
            if (elements[i] !== this &amp;&amp; elements[i].tagName === &quot;INPUT&quot; &amp;&amp; elements[i].type === &quot;radio&quot; &amp;&amp; elements[i].form === this.form) {
              elements[i].checked = false;
            }
          }
        }
      } else {
        this.removeAttribute(&#039;checked&#039;);
      }
    },
    get value() {
      return this._value !== null ? this._value : this.defaultValue;
    },
    set value(val) {
      if (val === null) {
        this._value = null;
        return;
      } else {
        this._value = String(val);
      }
    },
    get type() {
        var type = this.getAttribute(&#039;type&#039;);
        return type ? type : &#039;text&#039;;
    },
    set type(type) {
        this.setAttribute(&#039;type&#039;, type);
    },
    select: function() {
    },

    _dispatchClickEvent: function() {
      var event = this._ownerDocument.createEvent(&quot;HTMLEvents&quot;);
      event.initEvent(&quot;click&quot;, true, true);
      this.dispatchEvent(event);
    },

    click: function() {
      if (this.type === &#039;checkbox&#039;) {
        this.checked = !this.checked;
      }
      else if (this.type === &#039;radio&#039;) {
        this.checked = true;
      }
      else if (this.type === &#039;submit&#039;) {
        var form = this.form;
        if (form) {
          form._dispatchSubmitEvent();
        }
      }
      this._dispatchClickEvent();
    }
  },
  attributes: [
    &#039;accept&#039;,
    &#039;accessKey&#039;,
    &#039;align&#039;,
    &#039;alt&#039;,
    {prop: &#039;disabled&#039;, type: &#039;boolean&#039;},
    {prop: &#039;maxLength&#039;, type: &#039;long&#039;},
    &#039;name&#039;,
    {prop: &#039;readOnly&#039;, type: &#039;boolean&#039;},
    {prop: &#039;size&#039;, type: &#039;long&#039;},
    &#039;src&#039;,
    {prop: &#039;tabIndex&#039;, type: &#039;long&#039;},
    {prop: &#039;type&#039;, normalize: function(val) {
        return val ? val.toLowerCase() : &#039;text&#039;;
    }},
    &#039;useMap&#039;
  ]
});

define(&#039;HTMLTextAreaElement&#039;, {
  tagName: &#039;TEXTAREA&#039;,
  proto: {
    _initDefaultValue: function() {
      if (this._defaultValue === undefined) {
        this._defaultValue = this.textContent;
      }
      return this._defaultValue;
    },
    get form() {
      return closest(this, &#039;FORM&#039;);
    },
    get defaultValue() {
      return this._initDefaultValue();
    },
    get value() {
      return this.textContent;
    },
    set value(val) {
      this._initDefaultValue();
      this.textContent = val;
    },
    get type() {
      return &#039;textarea&#039;;
    },
    select: function() {
    }
  },
  attributes: [
    &#039;accessKey&#039;,
    {prop: &#039;cols&#039;, type: &#039;long&#039;},
    {prop: &#039;disabled&#039;, type: &#039;boolean&#039;},
    {prop: &#039;maxLength&#039;, type: &#039;long&#039;},
    &#039;name&#039;,
    {prop: &#039;readOnly&#039;, type: &#039;boolean&#039;},
    {prop: &#039;rows&#039;, type: &#039;long&#039;},
    {prop: &#039;tabIndex&#039;, type: &#039;long&#039;}
  ]
});

define(&#039;HTMLButtonElement&#039;, {
  tagName: &#039;BUTTON&#039;,
  proto: {
    get form() {
      return closest(this, &#039;FORM&#039;);
    }
  },
  attributes: [
    &#039;accessKey&#039;,
    {prop: &#039;disabled&#039;, type: &#039;boolean&#039;},
    &#039;name&#039;,
    {prop: &#039;tabIndex&#039;, type: &#039;long&#039;},
    &#039;type&#039;,
    &#039;value&#039;
  ]
});

define(&#039;HTMLLabelElement&#039;, {
  tagName: &#039;LABEL&#039;,
  proto: {
    get form() {
      return closest(this, &#039;FORM&#039;);
    }
  },
  attributes: [
    &#039;accessKey&#039;,
    {prop: &#039;htmlFor&#039;, attr: &#039;for&#039;}
  ]
});

define(&#039;HTMLFieldSetElement&#039;, {
  tagName: &#039;FIELDSET&#039;,
  proto: {
    get form() {
      return closest(this, &#039;FORM&#039;);
    }
  }
});

define(&#039;HTMLLegendElement&#039;, {
  tagName: &#039;LEGEND&#039;,
  proto: {
    get form() {
      return closest(this, &#039;FORM&#039;);
    }
  },
  attributes: [
    &#039;accessKey&#039;,
    &#039;align&#039;
  ]
});

define(&#039;HTMLUListElement&#039;, {
  tagName: &#039;UL&#039;,
  attributes: [
    {prop: &#039;compact&#039;, type: &#039;boolean&#039;},
    &#039;type&#039;
  ]
});

define(&#039;HTMLOListElement&#039;, {
  tagName: &#039;OL&#039;,
  attributes: [
    {prop: &#039;compact&#039;, type: &#039;boolean&#039;},
    {prop: &#039;start&#039;, type: &#039;long&#039;},
    &#039;type&#039;
  ]
});

define(&#039;HTMLDListElement&#039;, {
  tagName: &#039;DL&#039;,
  attributes: [
    {prop: &#039;compact&#039;, type: &#039;boolean&#039;}
  ]
});

define(&#039;HTMLDirectoryElement&#039;, {
  tagName: &#039;DIR&#039;,
  attributes: [
    {prop: &#039;compact&#039;, type: &#039;boolean&#039;}
  ]
});

define(&#039;HTMLMenuElement&#039;, {
  tagName: &#039;MENU&#039;,
  attributes: [
    {prop: &#039;compact&#039;, type: &#039;boolean&#039;}
  ]
});

define(&#039;HTMLLIElement&#039;, {
  tagName: &#039;LI&#039;,
  attributes: [
    &#039;type&#039;,
    {prop: &#039;value&#039;, type: &#039;long&#039;}
  ]
});

define(&#039;HTMLCanvasElement&#039;, {
  tagName: &#039;CANVAS&#039;,
  attributes: [
    &#039;align&#039;
  ],
  elementBuilder: function (element) {
    // require node-canvas and catch the error if it blows up
    try {
      var canvas = new (require(&#039;canvas&#039;))(0,0);
      for (var attr in element) {
        if (!canvas[attr]) {
          canvas[attr] = element[attr];
        }
      }
      return canvas;
    } catch (e) {
      return element;
    }
  }
});

define(&#039;HTMLDivElement&#039;, {
  tagName: &#039;DIV&#039;,
  attributes: [
    &#039;align&#039;
  ]
});

define(&#039;HTMLParagraphElement&#039;, {
  tagName: &#039;P&#039;,
  attributes: [
    &#039;align&#039;
  ]
});

define(&#039;HTMLHeadingElement&#039;, {
  tagNames: [&#039;H1&#039;,&#039;H2&#039;,&#039;H3&#039;,&#039;H4&#039;,&#039;H5&#039;,&#039;H6&#039;],
  attributes: [
    &#039;align&#039;
  ]
});

define(&#039;HTMLQuoteElement&#039;, {
  tagNames: [&#039;Q&#039;,&#039;BLOCKQUOTE&#039;],
  attributes: [
    &#039;cite&#039;
  ]
});

define(&#039;HTMLPreElement&#039;, {
  tagName: &#039;PRE&#039;,
  attributes: [
    {prop: &#039;width&#039;, type: &#039;long&#039;}
  ]
});

define(&#039;HTMLBRElement&#039;, {
  tagName: &#039;BR&#039;,
  attributes: [
    &#039;clear&#039;
  ]
});

define(&#039;HTMLBaseFontElement&#039;, {
  tagName: &#039;BASEFONT&#039;,
  attributes: [
    &#039;color&#039;,
    &#039;face&#039;,
    {prop: &#039;size&#039;, type: &#039;long&#039;}
  ]
});

define(&#039;HTMLFontElement&#039;, {
  tagName: &#039;FONT&#039;,
  attributes: [
    &#039;color&#039;,
    &#039;face&#039;,
    &#039;size&#039;
  ]
});

define(&#039;HTMLHRElement&#039;, {
  tagName: &#039;HR&#039;,
  attributes: [
    &#039;align&#039;,
    {prop: &#039;noShade&#039;, type: &#039;boolean&#039;},
    &#039;size&#039;,
    &#039;width&#039;
  ]
});

define(&#039;HTMLModElement&#039;, {
  tagNames: [&#039;INS&#039;, &#039;DEL&#039;],
  attributes: [
    &#039;cite&#039;,
    &#039;dateTime&#039;
  ]
});

define(&#039;HTMLAnchorElement&#039;, {
  tagName: &#039;A&#039;,

  proto: {
    get href() {
      return core.resourceLoader.resolve(this._ownerDocument, this.getAttribute(&#039;href&#039;));
    },
    get hostname() {
      return URL.parse(this.href).hostname || &#039;&#039;;
    },
    get host() {
      return URL.parse(this.href).host || &#039;&#039;;
    },
    get origin() {
      var proto = URL.parse(this.href).protocol;

      if (proto !== undefined &amp;&amp; proto !== null) {
        proto += &#039;//&#039;;
      }

      return proto + URL.parse(this.href).host || &#039;&#039;;
    },
    get port() {
      return URL.parse(this.href).port || &#039;&#039;;
    },
    get protocol() {
      var protocol = URL.parse(this.href).protocol;
      return (protocol == null) ? &#039;:&#039; : protocol;
    },
    get password() {
      var auth = URL.parse(this.href).auth;
      return auth.substr(auth.indexOf(&#039;:&#039;) + 1);
    },
    get pathname() {
      return URL.parse(this.href).pathname || &#039;&#039;;
    },
    get username() {
      var auth = URL.parse(this.href).auth;
      return auth.substr(0, auth.indexOf(&#039;:&#039;));
    },
    get search() {
      return URL.parse(this.href).search || &#039;&#039;;
    },
    get hash() {
      return URL.parse(this.href).hash || &#039;&#039;;
    }
  },
  attributes: [
    &#039;accessKey&#039;,
    &#039;charset&#039;,
    &#039;coords&#039;,
    {prop: &#039;href&#039;, type: &#039;string&#039;, read: false},
    &#039;hreflang&#039;,
    &#039;name&#039;,
    &#039;rel&#039;,
    &#039;rev&#039;,
    &#039;shape&#039;,
    {prop: &#039;tabIndex&#039;, type: &#039;long&#039;},
    &#039;target&#039;,
    &#039;type&#039;
  ]
});

define(&#039;HTMLImageElement&#039;, {
  tagName: &#039;IMG&#039;,
  proto: {
    _attrModified: function(name, value, oldVal) {
      if (name == &#039;src&#039; &amp;&amp; value !== oldVal) {
        core.resourceLoader.enqueue(this, function() {})();
      }
    },
    get src() {
      return core.resourceLoader.resolve(this._ownerDocument, this.getAttribute(&#039;src&#039;));
    }
  },
  attributes: [
    &#039;name&#039;,
    &#039;align&#039;,
    &#039;alt&#039;,
    &#039;border&#039;,
    {prop: &#039;height&#039;, type: &#039;long&#039;},
    {prop: &#039;hspace&#039;, type: &#039;long&#039;},
    {prop: &#039;isMap&#039;, type: &#039;boolean&#039;},
    &#039;longDesc&#039;,
    {prop: &#039;src&#039;, type: &#039;string&#039;, read: false},
    &#039;useMap&#039;,
    {prop: &#039;vspace&#039;, type: &#039;long&#039;},
    {prop: &#039;width&#039;, type: &#039;long&#039;}
  ]
});

define(&#039;HTMLObjectElement&#039;, {
  tagName: &#039;OBJECT&#039;,
  proto: {
    get form() {
      return closest(this, &#039;FORM&#039;);
    },
    get contentDocument() {
      return null;
    }
  },
  attributes: [
    &#039;code&#039;,
    &#039;align&#039;,
    &#039;archive&#039;,
    &#039;border&#039;,
    &#039;codeBase&#039;,
    &#039;codeType&#039;,
    &#039;data&#039;,
    {prop: &#039;declare&#039;, type: &#039;boolean&#039;},
    {prop: &#039;height&#039;,  type: &#039;long&#039;},
    {prop: &#039;hspace&#039;,  type: &#039;long&#039;},
    &#039;name&#039;,
    &#039;standby&#039;,
    {prop: &#039;tabIndex&#039;, type: &#039;long&#039;},
    &#039;type&#039;,
    &#039;useMap&#039;,
    {prop: &#039;vspace&#039;, type: &#039;long&#039;},
    {prop: &#039;width&#039;, type: &#039;long&#039;}
  ]
});

define(&#039;HTMLParamElement&#039;, {
  tagName: &#039;PARAM&#039;,
  attributes: [
    &#039;name&#039;,
    &#039;type&#039;,
    &#039;value&#039;,
    &#039;valueType&#039;
  ]
});

define(&#039;HTMLAppletElement&#039;, {
  tagName: &#039;APPLET&#039;,
  attributes: [
    &#039;align&#039;,
    &#039;alt&#039;,
    &#039;archive&#039;,
    &#039;code&#039;,
    &#039;codeBase&#039;,
    &#039;height&#039;,
    {prop: &#039;hspace&#039;, type: &#039;long&#039;},
    &#039;name&#039;,
    &#039;object&#039;,
    {prop: &#039;vspace&#039;, type: &#039;long&#039;},
    &#039;width&#039;
  ]
});

define(&#039;HTMLMapElement&#039;, {
  tagName: &#039;MAP&#039;,
  proto: {
    get areas() {
      return this.getElementsByTagName(&quot;AREA&quot;);
    }
  },
  attributes: [
    &#039;name&#039;
  ]
});

define(&#039;HTMLAreaElement&#039;, {
  tagName: &#039;AREA&#039;,
  attributes: [
    &#039;accessKey&#039;,
    &#039;alt&#039;,
    &#039;coords&#039;,
    &#039;href&#039;,
    {prop: &#039;noHref&#039;, type: &#039;boolean&#039;},
    &#039;shape&#039;,
    {prop: &#039;tabIndex&#039;, type: &#039;long&#039;},
    &#039;target&#039;
  ]
});

define(&#039;HTMLScriptElement&#039;, {
  tagName: &#039;SCRIPT&#039;,
  init: function() {
    this.addEventListener(&#039;DOMNodeInsertedIntoDocument&#039;, function() {
      if (this.src) {
        core.resourceLoader.load(this, this.src, this._eval);
      }
      else {
        var src = this.sourceLocation || {},
            filename = src.file || this._ownerDocument.URL;

        if (src) {
          filename += &#039;:&#039; + src.line + &#039;:&#039; + src.col;
        }
        filename += &#039;&lt;script&gt;&#039;;

        core.resourceLoader.enqueue(this, this._eval, filename)(null, this.text);
      }
    });
  },
  proto: {
    _eval: function(text, filename) {
      if (this._ownerDocument.implementation.hasFeature(&quot;ProcessExternalResources&quot;, &quot;script&quot;) &amp;&amp;
          this.language                                                                      &amp;&amp;
          core.languageProcessors[this.language])
      {
        this._ownerDocument._writeAfterElement = this;
        core.languageProcessors[this.language](this, text, filename);
        delete this._ownerDocument._writeAfterElement;
      }
    },
    get language() {
      var type = this.type || &quot;text/javascript&quot;;
      return type.split(&quot;/&quot;).pop().toLowerCase();
    },
    get text() {
      var i=0, children = this.childNodes, l = children.length, ret = [];

      for (i; i&lt;l; i++) {
        ret.push(children.item(i).nodeValue);
      }

      return ret.join(&quot;&quot;);
    },
    set text(text) {
      while (this.childNodes.length) {
        this.removeChild(this.childNodes[0]);
      }
      this.appendChild(this._ownerDocument.createTextNode(text));
    }
  },
  attributes : [
    {prop: &#039;defer&#039;, &#039;type&#039;: &#039;boolean&#039;},
    &#039;htmlFor&#039;,
    &#039;event&#039;,
    &#039;charset&#039;,
    &#039;type&#039;,
    &#039;src&#039;
  ]
})

define(&#039;HTMLTableElement&#039;, {
  tagName: &#039;TABLE&#039;,
  proto: {
    get caption() {
      return firstChild(this, &#039;CAPTION&#039;);
    },
    get tHead() {
      return firstChild(this, &#039;THEAD&#039;);
    },
    get tFoot() {
      return firstChild(this, &#039;TFOOT&#039;);
    },
    get rows() {
      if (!this._rows) {
        var table = this;
        this._rows = new core.HTMLCollection(this._ownerDocument, function() {
          var sections = [table.tHead].concat(table.tBodies._toArray(), table.tFoot).filter(function(s) { return !!s });

          if (sections.length === 0) {
            return core.mapDOMNodes(table, false, function(el) {
              return el.tagName === &#039;TR&#039;;
            });
          }

          return sections.reduce(function(prev, s) {
            return prev.concat(s.rows._toArray());
          }, []);

        });
      }
      return this._rows;
    },
    get tBodies() {
      if (!this._tBodies) {
        this._tBodies = descendants(this, &#039;TBODY&#039;, false);
      }
      return this._tBodies;
    },
    createTHead: function() {
      var el = this.tHead;
      if (!el) {
        el = this._ownerDocument.createElement(&#039;THEAD&#039;);
        this.appendChild(el);
      }
      return el;
    },
    deleteTHead: function() {
      var el = this.tHead;
      if (el) {
        el._parentNode.removeChild(el);
      }
    },
    createTFoot: function() {
      var el = this.tFoot;
      if (!el) {
        el = this._ownerDocument.createElement(&#039;TFOOT&#039;);
        this.appendChild(el);
      }
      return el;
    },
    deleteTFoot: function() {
      var el = this.tFoot;
      if (el) {
        el._parentNode.removeChild(el);
      }
    },
    createCaption: function() {
      var el = this.caption;
      if (!el) {
        el = this._ownerDocument.createElement(&#039;CAPTION&#039;);
        this.appendChild(el);
      }
      return el;
    },
    deleteCaption: function() {
      var c = this.caption;
      if (c) {
        c._parentNode.removeChild(c);
      }
    },
    insertRow: function(index) {
      var tr = this._ownerDocument.createElement(&#039;TR&#039;);
      if (this.childNodes.length === 0) {
        this.appendChild(this._ownerDocument.createElement(&#039;TBODY&#039;));
      }
      var rows = this.rows._toArray();
      if (index &lt; -1 || index &gt; rows.length) {
        throw new core.DOMException(core.INDEX_SIZE_ERR);
      }
      if (index === -1 || (index === 0 &amp;&amp; rows.length === 0)) {
        this.tBodies.item(0).appendChild(tr);
      }
      else if (index === rows.length) {
        var ref = rows[index-1];
        ref._parentNode.appendChild(tr);
      }
      else {
        var ref = rows[index];
        ref._parentNode.insertBefore(tr, ref);
      }
      return tr;
    },
    deleteRow: function(index) {
      var rows = this.rows._toArray(), l = rows.length;
      if (index === -1) {
        index = l-1;
      }
      if (index &lt; 0 || index &gt;= l) {
        throw new core.DOMException(core.INDEX_SIZE_ERR);
      }
      var tr = rows[index];
      tr._parentNode.removeChild(tr);
    }
  },
  attributes: [
    &#039;align&#039;,
    &#039;bgColor&#039;,
    &#039;border&#039;,
    &#039;cellPadding&#039;,
    &#039;cellSpacing&#039;,
    &#039;frame&#039;,
    &#039;rules&#039;,
    &#039;summary&#039;,
    &#039;width&#039;
  ]
});

define(&#039;HTMLTableCaptionElement&#039;, {
  tagName: &#039;CAPTION&#039;,
  attributes: [
    &#039;align&#039;
  ]
});

define(&#039;HTMLTableColElement&#039;, {
  tagNames: [&#039;COL&#039;,&#039;COLGROUP&#039;],
  attributes: [
    &#039;align&#039;,
    {prop: &#039;ch&#039;, attr: &#039;char&#039;},
    {prop: &#039;chOff&#039;, attr: &#039;charoff&#039;},
    {prop: &#039;span&#039;, type: &#039;long&#039;},
    &#039;vAlign&#039;,
    &#039;width&#039;,
  ]
});

define(&#039;HTMLTableSectionElement&#039;, {
  tagNames: [&#039;THEAD&#039;,&#039;TBODY&#039;,&#039;TFOOT&#039;],
  proto: {
    get rows() {
      if (!this._rows) {
        this._rows = descendants(this, &#039;TR&#039;, false);
      }
      return this._rows;
    },
    insertRow: function(index) {
      var tr = this._ownerDocument.createElement(&#039;TR&#039;);
      var rows = this.rows._toArray();
      if (index &lt; -1 || index &gt; rows.length) {
        throw new core.DOMException(core.INDEX_SIZE_ERR);
      }
      if (index === -1 || index === rows.length) {
        this.appendChild(tr);
      }
      else {
        var ref = rows[index];
        this.insertBefore(tr, ref);
      }
      return tr;
    },
    deleteRow: function(index) {
      var rows = this.rows._toArray();
      if (index === -1) {
        index = rows.length-1;
      }
      if (index &lt; 0 || index &gt;= rows.length) {
        throw new core.DOMException(core.INDEX_SIZE_ERR);
      }
      var tr = this.rows[index];
      this.removeChild(tr);
    }
  },
  attributes: [
    &#039;align&#039;,
    {prop: &#039;ch&#039;, attr: &#039;char&#039;},
    {prop: &#039;chOff&#039;, attr: &#039;charoff&#039;},
    {prop: &#039;span&#039;, type: &#039;long&#039;},
    &#039;vAlign&#039;,
    &#039;width&#039;,
  ]
});

define(&#039;HTMLTableRowElement&#039;, {
  tagName: &#039;TR&#039;,
  proto: {
    get cells() {
      if (!this._cells) {
        this._cells = new core.HTMLCollection(this, core.mapper(this, function(n) {
          return n.nodeName === &#039;TD&#039; || n.nodeName === &#039;TH&#039;;
        }, false));
      }
      return this._cells;
    },
    get rowIndex() {
      var table = closest(this, &#039;TABLE&#039;);
      return table ? table.rows._toArray().indexOf(this) : -1;
    },

    get sectionRowIndex() {
      return this._parentNode.rows._toArray().indexOf(this);
    },
    insertCell: function(index) {
      var td = this._ownerDocument.createElement(&#039;TD&#039;);
      var cells = this.cells._toArray();
      if (index &lt; -1 || index &gt; cells.length) {
        throw new core.DOMException(core.INDEX_SIZE_ERR);
      }
      if (index === -1 || index === cells.length) {
        this.appendChild(td);
      }
      else {
        var ref = cells[index];
        this.insertBefore(td, ref);
      }
      return td;
    },
    deleteCell: function(index) {
      var cells = this.cells._toArray();
      if (index === -1) {
        index = cells.length-1;
      }
      if (index &lt; 0 || index &gt;= cells.length) {
        throw new core.DOMException(core.INDEX_SIZE_ERR);
      }
      var td = this.cells[index];
      this.removeChild(td);
    }
  },
  attributes: [
    &#039;align&#039;,
    &#039;bgColor&#039;,
    {prop: &#039;ch&#039;, attr: &#039;char&#039;},
    {prop: &#039;chOff&#039;, attr: &#039;charoff&#039;},
    &#039;vAlign&#039;
  ]
});

define(&#039;HTMLTableCellElement&#039;, {
  tagNames: [&#039;TH&#039;,&#039;TD&#039;],
  proto: {
    _headers: null,
    set headers(h) {
      if (h === &#039;&#039;) {
        //Handle resetting headers so the dynamic getter returns a query
        this._headers = null;
        return;
      }
      if (!(h instanceof Array)) {
        h = [h];
      }
      this._headers = h;
    },
    get headers() {
      if (this._headers) {
        return this._headers.join(&#039; &#039;);
      }
      var cellIndex = this.cellIndex,
          headings  = [],
          siblings  = this._parentNode.getElementsByTagName(this.tagName);

      for (var i=0; i&lt;siblings.length; i++) {
        if (siblings.item(i).cellIndex &gt;= cellIndex) {
          break;
        }
        headings.push(siblings.item(i).id);
      }
      this._headers = headings;
      return headings.join(&#039; &#039;);
    },
    get cellIndex() {
      return closest(this, &#039;TR&#039;).cells._toArray().indexOf(this);
    }
  },
  attributes: [
    &#039;abbr&#039;,
    &#039;align&#039;,
    &#039;axis&#039;,
    &#039;bgColor&#039;,
    {prop: &#039;ch&#039;, attr: &#039;char&#039;},
    {prop: &#039;chOff&#039;, attr: &#039;charoff&#039;},
    {prop: &#039;colSpan&#039;, type: &#039;long&#039;},
    &#039;height&#039;,
    {prop: &#039;noWrap&#039;, type: &#039;boolean&#039;},
    {prop: &#039;rowSpan&#039;, type: &#039;long&#039;},
    &#039;scope&#039;,
    &#039;vAlign&#039;,
    &#039;width&#039;
  ]
});

define(&#039;HTMLFrameSetElement&#039;, {
  tagName: &#039;FRAMESET&#039;,
  attributes: [
    &#039;cols&#039;,
    &#039;rows&#039;
  ]
});

function loadFrame (frame) {
  if (frame._contentDocument) {
    // We don&#039;t want to access document.parentWindow, since the getter will
    // cause a new window to be allocated if it doesn&#039;t exist.  Probe the
    // private variable instead.
    if (frame._contentDocument._parentWindow) {
      // close calls delete on its document.
      frame._contentDocument.parentWindow.close();
    } else {
      delete frame._contentDocument;
    }
  }

  var src = frame.src.trim() === &#039;&#039; ? &#039;about:blank&#039; : frame.src;
  var parentDoc = frame._ownerDocument;

  // If the URL can&#039;t be resolved or the src attribute is missing / blank,
  // then url should be set to the string &quot;about:blank&quot;.
  // (http://www.whatwg.org/specs/web-apps/current-work/#the-iframe-element)
  var url = core.resourceLoader.resolve(parentDoc, src);
  var contentDoc = frame._contentDocument = new core.HTMLDocument({
    url: url,
    documentRoot: Path.dirname(url)
  });
  applyDocumentFeatures(contentDoc, parentDoc.implementation._features);

  var parent = parentDoc.parentWindow;
  var contentWindow = contentDoc.parentWindow;
  contentWindow.parent = parent;
  contentWindow.top = parent.top;

  // Handle about:blank with a simulated load of an empty document.
  if(url === &#039;about:blank&#039;) {
    core.resourceLoader.enqueue(frame, function() {
      contentDoc.write();
      contentDoc.close();
    })();
  } else {
    core.resourceLoader.load(frame, url, function(html, filename) {
      contentDoc.write(html);
      contentDoc.close();
    });
  }
}

define(&#039;HTMLFrameElement&#039;, {
  tagName: &#039;FRAME&#039;,
  init : function () {
    // Set up the frames array.  window.frames really just returns a reference
    // to the window object, so the frames array is just implemented as indexes
    // on the window.
    var parent = this._ownerDocument.parentWindow;
    var frameID = parent._length++;
    var self = this;
    defineGetter(parent, frameID, function () {
      return self.contentWindow;
    });

    // The contentDocument/contentWindow shouldn&#039;t be created until the frame
    // is inserted:
    // &quot;When an iframe element is first inserted into a document, the user
    //  agent must create a nested browsing context, and then process the
    //  iframe attributes for the first time.&quot;
    //  (http://www.whatwg.org/specs/web-apps/current-work/#the-iframe-element)
    this._initInsertListener = function () {
      loadFrame(self);
    };
    this.addEventListener(&#039;DOMNodeInsertedIntoDocument&#039;, this._initInsertListener, false);
  },
  proto: {
    _attrModified: function(name, value, oldVal) {
      core.HTMLElement.prototype._attrModified.call(this, name, value, oldVal);
      var self = this;
      if (name === &#039;name&#039;) {
        // Remove named frame access.
        if (oldVal) {
          this._ownerDocument.parentWindow._frame(oldVal);
        }
        // Set up named frame access.
        if (value) {
          this._ownerDocument.parentWindow._frame(value, this);
        }
      } else if (name === &#039;src&#039;) {
        // Page we don&#039;t fetch the page until the node is inserted. This at
        // least seems to be the way Chrome does it.
        if (!this._attachedToDocument) {
          if (!this._waitingOnInsert) {
            // First, remove the listener added in &#039;init&#039;.
            this.removeEventListener(&#039;DOMNodeInsertedIntoDocument&#039;,
                                     this._initInsertListener, false)

            // If we aren&#039;t already waiting on an insert, add a listener.
            // This guards against src being set multiple times before the frame
            // is inserted into the document - we don&#039;t want to register multiple
            // callbacks.
            this.addEventListener(&#039;DOMNodeInsertedIntoDocument&#039;, function loader () {
              self.removeEventListener(&#039;DOMNodeInsertedIntoDocument&#039;, loader, false);
              this._waitingOnInsert = false;
              loadFrame(self);
            }, false);
            this._waitingOnInsert = true;
          }
        } else {
          loadFrame(self);
        }
      }
    },
    _contentDocument : null,
    get contentDocument() {
      if (this._contentDocument == null) {
        this._contentDocument = new core.HTMLDocument();
      }
      return this._contentDocument;
    },
    get contentWindow() {
      return this.contentDocument.parentWindow;
    }
  },
  attributes: [
    &#039;frameBorder&#039;,
    &#039;longDesc&#039;,
    &#039;marginHeight&#039;,
    &#039;marginWidth&#039;,
    &#039;name&#039;,
    {prop: &#039;noResize&#039;, type: &#039;boolean&#039;},
    &#039;scrolling&#039;,
    {prop: &#039;src&#039;, type: &#039;string&#039;, write: false}
  ]
});

define(&#039;HTMLIFrameElement&#039;, {
  tagName: &#039;IFRAME&#039;,
  parentClass: core.HTMLFrameElement,
  attributes: [
    &#039;align&#039;,
    &#039;frameBorder&#039;,
    &#039;height&#039;,
    &#039;longDesc&#039;,
    &#039;marginHeight&#039;,
    &#039;marginWidth&#039;,
    &#039;name&#039;,
    &#039;scrolling&#039;,
    &#039;src&#039;,
    &#039;width&#039;
  ]
});

exports.define = define;
exports.dom = {
  level2 : {
    html : core
  }
}</textarea>
  </div>
</div>

<footer class="footer">
  <div class="container">
    <p>.</p>
  </div>
</footer>

<script type="text/html" id="complexity-popover-template">
  <div class="complexity-notice">
    Complexity : {{ complexity.cyclomatic }} <br>
    Length : {{ complexity.halstead.length }} <br>
    Difficulty : {{ complexity.halstead.difficulty.toFixed(2) }} <br>
    Est # bugs : {{ complexity.halstead.bugs.toFixed(2) }}<br>
  </div>
</script>

<script type="text/javascript" src="../../assets/scripts/bundles/core-bundle.js"></script>
<script type="text/javascript" src="../../assets/scripts/bundles/codemirror.js"></script>
<script type="text/javascript" src="../../assets/scripts/codemirror.markpopovertext.js"></script>
<script type="text/javascript" src="report.js"></script>
<script type="text/javascript" src="report.history.js"></script>
<script type="text/javascript" src="../../assets/scripts/plato-file.js"></script>
</body>
</html>
