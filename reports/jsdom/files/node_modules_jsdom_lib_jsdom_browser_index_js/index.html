<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Plato - node_modules/jsdom/lib/jsdom/browser/index.js</title>

  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="">
  <meta name="author" content="">

  <!--[if lt IE 9]>
  <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->

  <link href="../../assets/css/vendor/morris.css" rel="stylesheet">
  <link href="../../assets/css/vendor/bootstrap.css" rel="stylesheet">
  <link href="../../assets/css/vendor/font-awesome.css" rel="stylesheet">
  <link href="../../assets/css/vendor/codemirror.css" rel="stylesheet">
  <link href="../../assets/css/plato.css" rel="stylesheet">
  <link href="../../assets/css/plato-file.css" rel="stylesheet">

</head>

<body>

<div class="navbar navbar-fixed-top">
  <div class="container">
    <a class="navbar-brand" href="http://github.com/es-analysis/plato">Plato on Github</a>
    <ul class="nav navbar-nav">
      <li>
        <a href="../../index.html">Report Home</a>
      </li>
    </ul>
  </div>
</div>

<div class="jumbotron">
  <div class="container">
    <h1>node_modules/jsdom/lib/jsdom/browser/index.js</h1>
  </div>
</div>

<div class="container aggregate-stats">
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Maintainability <a href="http://blogs.msdn.com/b/codeanalysis/archive/2007/11/20/maintainability-index-range-and-meaning.aspx"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="A value between 0 and 100 that represents the relative ease of maintaining the code. A high value means better maintainability." data-original-title="Maintainability Index"  data-container="body"></i></a></h2>
      <p class="stat">66.95</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Lines of code <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h2>
      <p class="stat">631</p>
    </div>
  </div>
  <div class="row historical">
    <div class="col-md-6">
      <p id="chart_historical_maint" class="chart"></p>
    </div>
    <div class="col-md-6">
      <p id="chart_historical_sloc" class="chart"></p>
    </div>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Difficulty  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="The difficulty measure is related to the difficulty of the program to write or understand." data-original-title="Difficulty" data-container="body"></i></a></h2>
      <p class="stat">63.05</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Estimated Errors  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Halstead's delivered bugs is an estimate for the number of errors in the implementation." data-original-title="Delivered Bugs" data-container="body"></i></a></h2>
      <p class="stat">6.96</p>
    </div>
  </div>
</div>

<div class="container charts">
  <div class="row">
    <h2 class="header">Function weight</h2>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h3 class="chart-header">By Complexity <a href="http://en.wikipedia.org/wiki/Cyclomatic_complexity"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="This metric counts the number of distinct paths through a block of code. Lower values are better." data-original-title="Cyclomatic Complexity" data-container="body"></i></a></h3>
      <div id="fn-by-complexity" class="stat"></div>
    </div>
    <div class="col-md-6">
      <h3 class="chart-header">By SLOC  <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h3>
      <div id="fn-by-sloc" class="stat"></div>
    </div>
  </div>
</div>

<div class="container">
  <div class="row">
    <textarea id="file-source" class="col-md-12">var http          = require(&#039;http&#039;),
    URL           = require(&#039;url&#039;),
    HtmlToDom     = require(&#039;./htmltodom&#039;).HtmlToDom,
    domToHtml     = require(&#039;./domtohtml&#039;).domToHtml,
    jsdom         = require(&#039;../../jsdom&#039;),
    Location      = require(&#039;./location&#039;),
    History       = require(&#039;./history&#039;),
    NOT_IMPLEMENTED = require(&#039;./utils&#039;).NOT_IMPLEMENTED,
    CSSStyleDeclaration = require(&#039;cssstyle&#039;).CSSStyleDeclaration,
    toFileUrl = require(&#039;../utils&#039;).toFileUrl,
    defineGetter  = require(&#039;../utils&#039;).defineGetter,
    defineSetter  = require(&#039;../utils&#039;).defineSetter,
    createFrom    = require(&#039;../utils&#039;).createFrom,
    Contextify    = require(&#039;contextify&#039;);

function matchesDontThrow(el, selector) {
  try {
    return el.matchesSelector(selector);
  } catch (e) {
    return false;
  }
}

/**
 * Creates a window having a document. The document can be passed as option,
 * if omitted, a new document will be created.
 */
exports.windowAugmentation = function(dom, options) {
  options = options || {};
  var window = exports.createWindow(dom, options);

  if (!options.document) {
    var browser = browserAugmentation(dom, options);

    options.document = (browser.HTMLDocument)             ?
                        new browser.HTMLDocument(options) :
                        new browser.Document(options);



    options.document.write(&#039;&lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt;&#039;);
  }

  var doc = window.document = options.document;

  if (doc.addEventListener) {
    if (doc.readyState == &#039;complete&#039;) {
      var ev = doc.createEvent(&#039;HTMLEvents&#039;);
      ev.initEvent(&#039;load&#039;, false, false);
      process.nextTick(function () {
        window.dispatchEvent(ev);
      });
    }
    else {
      doc.addEventListener(&#039;load&#039;, function(ev) {
        window.dispatchEvent(ev);
      });
    }
  }

  return window;
};

/**
 * Creates a document-less window.
 */
exports.createWindow = function(dom, options) {
  var timers = [];
  var cssSelectorSplitRE = /((?:[^,&quot;&#039;]|&quot;[^&quot;]*&quot;|&#039;[^&#039;]*&#039;)+)/;

  function startTimer(startFn, stopFn, callback, ms) {
    var res = startFn(callback, ms);
    timers.push( [ res, stopFn ] );
    return res;
  }

  function stopTimer(id) {
    if (typeof id === &#039;undefined&#039;) {
      return;
    }
    for (var i in timers) {
      if (timers[i][0] === id) {
        timers[i][1].call(this, id);
        timers.splice(i, 1);
        break;
      }
    }
  }

  function stopAllTimers() {
    timers.forEach(function (t) {
      t[1].call(this, t[0]);
    });
    timers = [];
  }

  function DOMWindow(options) {
    var url = (options || {}).url || toFileUrl(__filename);
    this.location = new Location(url, this);
    this.history = new History(this);

    this.console._window = this;

    if (options &amp;&amp; options.document) {
      options.document.location = this.location;
    }

    this.addEventListener = function() {
      dom.Node.prototype.addEventListener.apply(window, arguments);
    };
    this.removeEventListener = function() {
      dom.Node.prototype.removeEventListener.apply(window, arguments);
    };
    this.dispatchEvent = function() {
      dom.Node.prototype.dispatchEvent.apply(window, arguments);
    };
    this.raise = function(){
      dom.Node.prototype.raise.apply(window.document, arguments);
    };

    this.setTimeout = function (fn, ms) { return startTimer(setTimeout, clearTimeout, fn, ms); };
    this.setInterval = function (fn, ms) { return startTimer(setInterval, clearInterval, fn, ms); };
    this.clearInterval = stopTimer;
    this.clearTimeout = stopTimer;
    this.__stopAllTimers = stopAllTimers;
  }

  DOMWindow.prototype = createFrom(dom || null, {
    constructor: DOMWindow,
    // This implements window.frames.length, since window.frames returns a
    // self reference to the window object.  This value is incremented in the
    // HTMLFrameElement init function (see: level2/html.js).
    _length : 0,
    get length () {
      return this._length;
    },
    close : function() {
      // Recursively close child frame windows, then ourselves.
      var currentWindow = this;
      (function windowCleaner (window) {
        var i;
        // We could call window.frames.length etc, but window.frames just points
        // back to window.
        if (window.length &gt; 0) {
          for (i = 0; i &lt; window.length; i++) {
            windowCleaner(window[i]);
          }
        }
        // We&#039;re already in our own window.close().
        if (window !== currentWindow) {
          window.close();
        }
      })(this);

      if (this.document) {
        if (this.document.body) {
          this.document.body.innerHTML = &quot;&quot;;
        }

        if (this.document.close) {
          // We need to empty out the event listener array because
          // document.close() causes &#039;load&#039; event to re-fire.
          this.document._listeners = [];
          this.document.close();
        }
        delete this.document;
      }

      stopAllTimers();
      // Clean up the window&#039;s execution context.
      // dispose() is added by Contextify.
      setTimeout(this.dispose.bind(this), 0);
    },
    getComputedStyle: function(node) {
      var s = node.style,
          cs = new CSSStyleDeclaration(),
          forEach = Array.prototype.forEach;

      function setPropertiesFromRule(rule) {
        if (!rule.selectorText) {
          return;
        }

        var selectors = rule.selectorText.split(cssSelectorSplitRE);
        var matched = false;
        selectors.forEach(function (selectorText) {
          if (selectorText !== &#039;&#039; &amp;&amp; selectorText !== &#039;,&#039; &amp;&amp; !matched &amp;&amp; matchesDontThrow(node, selectorText)) {
            matched = true;
            forEach.call(rule.style, function (property) {
              cs.setProperty(property, rule.style.getPropertyValue(property), rule.style.getPropertyPriority(property));
            });
          }
        });
      }

      forEach.call(node.ownerDocument.styleSheets, function (sheet) {
        forEach.call(sheet.cssRules, function (rule) {
          if (rule.media) {
            if (Array.prototype.indexOf.call(rule.media, &#039;screen&#039;) !== -1) {
              forEach.call(rule.cssRules, setPropertiesFromRule);
            }
          } else {
            setPropertiesFromRule(rule);
          }
        });
      });

      forEach.call(s, function (property) {
        cs.setProperty(property, s.getPropertyValue(property), s.getPropertyPriority(property));
      });

      return cs;
    },
    console: {
      log:   function(message) { this._window.raise(&#039;log&#039;,   message) },
      info:  function(message) { this._window.raise(&#039;info&#039;,  message) },
      warn:  function(message) { this._window.raise(&#039;warn&#039;,  message) },
      error: function(message) { this._window.raise(&#039;error&#039;, message) }
    },
    navigator: {
      get userAgent() { return &#039;Node.js (&#039; + process.platform + &#039;; U; rv:&#039; + process.version + &#039;)&#039;; },
      get appName() { return &#039;Node.js jsDom&#039;; },
      get platform() { return process.platform; },
      get appVersion() { return process.version; },
      noUI: true,
      get cookieEnabled() { return true; }
    },
    XMLHttpRequest: function() {
      var XMLHttpRequest = require(&#039;xmlhttprequest&#039;).XMLHttpRequest;
      var xhr = new XMLHttpRequest();
      var lastUrl = &#039;&#039;;
      xhr._open = xhr.open;
      xhr.open = function(method, url, async, user, password) {
        url = URL.resolve(options.url, url);
        lastUrl = url;
        return xhr._open(method, url, async, user, password);
      };
      xhr._send = xhr.send;
      xhr.send = function(data) {
        if (window.document.cookie) {
          var cookieDomain = window.document._cookieDomain;
          var url = URL.parse(lastUrl);
          var host = url.host.split(&#039;:&#039;)[0];
          if (host.indexOf(cookieDomain, host.length - cookieDomain.length) !== -1) {
            xhr.setDisableHeaderCheck(true);
            xhr.setRequestHeader(&#039;cookie&#039;, window.document.cookie);
            xhr.setDisableHeaderCheck(false);
          }
        }
        return xhr._send(data);
      };
      return xhr;
    },

    name: &#039;nodejs&#039;,
    innerWidth: 1024,
    innerHeight: 768,
    outerWidth: 1024,
    outerHeight: 768,
    pageXOffset: 0,
    pageYOffset: 0,
    screenX: 0,
    screenY: 0,
    screenLeft: 0,
    screenTop: 0,
    scrollX: 0,
    scrollY: 0,
    scrollTop: 0,
    scrollLeft: 0,
    alert: NOT_IMPLEMENTED(null, &#039;window.alert&#039;),
    blur: NOT_IMPLEMENTED(null, &#039;window.blur&#039;),
    confirm: NOT_IMPLEMENTED(null, &#039;window.confirm&#039;),
    createPopup: NOT_IMPLEMENTED(null, &#039;window.createPopup&#039;),
    focus: NOT_IMPLEMENTED(null, &#039;window.focus&#039;),
    moveBy: NOT_IMPLEMENTED(null, &#039;window.moveBy&#039;),
    moveTo: NOT_IMPLEMENTED(null, &#039;window.moveTo&#039;),
    open: NOT_IMPLEMENTED(null, &#039;window.open&#039;),
    print: NOT_IMPLEMENTED(null, &#039;window.print&#039;),
    prompt: NOT_IMPLEMENTED(null, &#039;window.prompt&#039;),
    resizeBy: NOT_IMPLEMENTED(null, &#039;window.resizeBy&#039;),
    resizeTo: NOT_IMPLEMENTED(null, &#039;window.resizeTo&#039;),
    scroll: NOT_IMPLEMENTED(null, &#039;window.scroll&#039;),
    scrollBy: NOT_IMPLEMENTED(null, &#039;window.scrollBy&#039;),
    scrollTo: NOT_IMPLEMENTED(null, &#039;window.scrollTo&#039;),
    screen : {
      width : 0,
      height : 0
    },
    Image : NOT_IMPLEMENTED(null, &#039;window.Image&#039;),

    // Note: these will not be necessary for newer Node.js versions, which have
    // typed arrays in V8 and thus on every global object. (That is, in newer
    // versions we&#039;ll get `ArrayBuffer` just as automatically as we get
    // `Array`.) But to support older versions, we explicitly set them here.
    Int8Array: global.Int8Array,
    Int16Array: global.Int16Array,
    Int32Array: global.Int32Array,
    Float32Array: global.Float32Array,
    Float64Array: global.Float64Array,
    Uint8Array: global.Uint8Array,
    Uint8ClampedArray: global.Uint8ClampedArray,
    Uint16Array: global.Uint16Array,
    Uint32Array: global.Uint32Array,
    ArrayBuffer: global.ArrayBuffer
  });

  var window = new DOMWindow(options);

  Contextify(window);

  // We need to set up self references using Contextify&#039;s getGlobal() so that
  // the global object identity is correct (window === this).
  // See Contextify README for more info.
  var windowGlobal = window.getGlobal();

  // Set up the window as if it&#039;s a top level window.
  // If it&#039;s not, then references will be corrected by frame/iframe code.
  // Note: window.frames is maintained in the HTMLFrameElement init function.
  window.window = window.frames
                = window.self
                = window.parent
                = window.top = windowGlobal;

  return window;
};

/**
 * Augments the given DOM by adding browser-specific properties and methods (BOM).
 * Returns the augmented DOM.
 */
var browserAugmentation = exports.browserAugmentation = function(dom, options) {

  if(!options) {
    options = {};
  }

  // set up html parser - use a provided one or try and load from library
  var parser = options.parser;

  if (dom._augmented &amp;&amp; dom._parser === parser &amp;&amp; dom._parsingMode === options.parsingMode) {
    return dom;
  }

  dom._parser = parser;
  dom._parsingMode = options.parsingMode;
  var htmltodom = new HtmlToDom(parser, options.parsingMode);

  function setInnerHTML(node, html) {
    //Clear the children first:
    var child;
    while ((child = node._childNodes[0])) {
      node.removeChild(child);
    }

    var isDoc = node.nodeName === &#039;#document&#039;;
    if (isDoc) {
      parseDocType(node, html);

      if (node._doctype) {
        node._childNodes[0] = node._doctype;
      }
    }
    if (html !== &quot;&quot; &amp;&amp; html != null) {
      if (isDoc) {
        htmltodom.appendHtmlToDocument(html, node);
      } else {
        htmltodom.appendHtmlToElement(html, node);
      }
    }
  }

  if (!dom.HTMLDocument) {
    dom.HTMLDocument = dom.Document;
  }

  dom.HTMLDocument.prototype.write = function(text) {
    if (this._writeAfterElement) {
      // If called from an script element directly (during the first tick),
      // the new elements are inserted right after that element.
      var tempDiv       = this.createElement(&#039;div&#039;);
      setInnerHTML(tempDiv, text);

      var child    = tempDiv.firstChild;
      var previous = this._writeAfterElement;
      var parent   = this._writeAfterElement.parentNode;

      while (child) {
        var node = child;
        child    = child.nextSibling;
        parent.insertBefore(node, previous.nextSibling);
        previous = node;
      }
    } else if (this.readyState === &quot;loading&quot;) {
      // During page loading, document.write appends to the current element
      // Find the last child that has been added to the document.
      var node = this;
      while (node.lastChild &amp;&amp; node.lastChild.nodeType === this.ELEMENT_NODE) {
        node = node.lastChild;
      }
      setInnerHTML(node, text || &quot;&lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt;&quot;);
    } else if (text) {
      setInnerHTML(this, text);
    }
  };

  dom.HTMLDocument.prototype.toString = function() {
    return &#039;[object HTMLDocument]&#039;;
  };

  dom.Element.prototype.getElementsByClassName = function(className) {

    function filterByClassName(child) {
      if (!child) {
        return false;
      }

      if (child.nodeType &amp;&amp;
          child.nodeType === dom.Node.ENTITY_REFERENCE_NODE)
      {
        child = child._entity;
      }

      var classString = child.className;
      if (classString) {
        var s = classString.split(&quot; &quot;);
        for (var i=0; i&lt;s.length; i++) {
          if (s[i] === className) {
            return true;
          }
        }
      }
      return false;
    }

    return new dom.NodeList(this.ownerDocument || this, dom.mapper(this, filterByClassName));
  };

  defineGetter(dom.Element.prototype, &#039;sourceIndex&#039;, function() {
    /*
    * According to QuirksMode:
    * Get the sourceIndex of element x. This is also the index number for
    * the element in the document.getElementsByTagName(&#039;*&#039;) array.
    * http://www.quirksmode.org/dom/w3c_core.html#t77
    */
    var items = this.ownerDocument.getElementsByTagName(&#039;*&#039;),
        len = items.length;

    for (var i = 0; i &lt; len; i++) {
      if (items[i] === this) {
        return i;
      }
    }
  });

  defineGetter(dom.Element.prototype, &#039;outerHTML&#039;, function() {
    return domToHtml(this, true);
  });

  defineGetter(dom.Element.prototype, &#039;innerHTML&#039;, function() {
    if (/^(?:script|style)$/.test(this._tagName)) {
      var type = this.getAttribute(&#039;type&#039;);
      if (!type || /^text\//i.test(type) || /\/javascript$/i.test(type)) {
        return domToHtml(this._childNodes, true, true);
      }
    }

    // In case of &lt;template&gt; we should pass it&#039;s content fragment as a serialization root if we have one
    if(this._tagName === &#039;template&#039; &amp;&amp;
       this._namespaceURI === &#039;http://www.w3.org/1999/xhtml&#039; &amp;&amp;
       this.childNodes[0] &amp;&amp; this.childNodes[0]._templateContent) {
       return domToHtml(this.childNodes[0]._childNodes, true);
    }

    return domToHtml(this._childNodes, true);
  });

  defineSetter(dom.Element.prototype, &#039;doctype&#039;, function() {
    throw new dom.DOMException(dom.NO_MODIFICATION_ALLOWED_ERR);
  });
  defineGetter(dom.Element.prototype, &#039;doctype&#039;, function() {
    var r = null;
    if (this.nodeName == &#039;#document&#039;) {
        if (this._doctype) {
         r = this._doctype;
        }
    }
    return r;
  });

  defineSetter(dom.Element.prototype, &#039;innerHTML&#039;, function(html) {
    setInnerHTML(this, html);
    return html;
  });

  var DOC_HTML5      = /&lt;!doctype html&gt;/i,
      DOC_TYPE       = /&lt;!DOCTYPE (\w(.|\n)*)&quot;&gt;/i,
      DOC_TYPE_START = &#039;&lt;!DOCTYPE &#039;,
      DOC_TYPE_END   = &#039;&quot;&gt;&#039;;

  function parseDocType(doc, html) {
    var publicID = &#039;&#039;,
        systemID = &#039;&#039;,
        fullDT = &#039;&#039;,
        name = &#039;html&#039;,
        set = true,
        doctype = html.match(DOC_HTML5);

    //Default, No doctype === null
    doc._doctype = null;

    if (doctype &amp;&amp; doctype[0]) { //Handle the HTML shorty doctype
      fullDT = doctype[0];
    } else { //Parse the doctype
      // find the start
      var start     = html.indexOf(DOC_TYPE_START),
          end       = html.indexOf(DOC_TYPE_END),
          docString;

      if (start &lt; 0 || end &lt; 0) {
        return;
      }

      docString = html.substr(start, (end-start)+DOC_TYPE_END.length);
      doctype = docString.replace(/[\n\r]/g,&#039;&#039;).match(DOC_TYPE);

      if (!doctype) {
        return;
      }

      fullDT = doctype[0];
      doctype = doctype[1].split(&#039; &quot;&#039;);
      var _id1 = doctype.length ? doctype.pop().replace(/&quot;/g, &#039;&#039;) : &#039;&#039;,
          _id2 = doctype.length ? doctype.pop().replace(/&quot;/g, &#039;&#039;) : &#039;&#039;;

      if (_id1.indexOf(&#039;-//&#039;) !== -1) {
        publicID = _id1;
      }
      if (_id2.indexOf(&#039;-//&#039;) !== -1) {
        publicID = _id2;
      }
      if (_id1.indexOf(&#039;://&#039;) !== -1) {
        systemID = _id1;
      }
      if (_id2.indexOf(&#039;://&#039;) !== -1) {
        systemID = _id2;
      }
      if (doctype.length) {
        doctype = doctype[0].split(&#039; &#039;);
        name = doctype[0];
      }
    }
    doc._doctype = new dom.DOMImplementation().createDocumentType(name, publicID, systemID);
    doc._doctype._ownerDocument = doc;
    doc._doctype._parentNode = doc;
    doc._doctype._fullDT = fullDT;
    doc._doctype.toString = function() {
      return this._fullDT;
    };
  }

  dom.Document.prototype.getElementsByClassName = function(className) {

    function filterByClassName(child) {
      if (!child) {
        return false;
      }

      if (child.nodeType &amp;&amp;
          child.nodeType === dom.Node.ENTITY_REFERENCE_NODE)
      {
        child = child._entity;
      }

      var classString = child.className;
      if (classString) {
        var s = classString.split(&quot; &quot;);
        for (var i=0; i&lt;s.length; i++) {
          if (s[i] === className) {
            return true;
          }
        }
      }
      return false;
    }

    return new dom.NodeList(this.ownerDocument || this, dom.mapper(this, filterByClassName));
  };

  defineGetter(dom.Element.prototype, &#039;nodeName&#039;, function(val) {
    return this._nodeName.toUpperCase();
  });

  defineGetter(dom.Element.prototype, &#039;tagName&#039;, function(val) {
    var t = this._tagName.toUpperCase();
    //Document should not return a tagName
    if (this.nodeName === &#039;#document&#039;) {
      t = null;
    }
    return t;
  });

  dom.Element.prototype.scrollTop = 0;
  dom.Element.prototype.scrollLeft = 0;

  defineGetter(dom.Document.prototype, &#039;parentWindow&#039;, function() {
    if (!this._parentWindow) {
      this.parentWindow = exports.windowAugmentation(dom, {document: this, url: this.URL});
    }
    return this._parentWindow;
  });

  defineSetter(dom.Document.prototype, &#039;parentWindow&#039;, function(window) {
    // Contextify does not support getters and setters, so we have to set them
    // on the original object instead.
    window._frame = function (name, frame) {
      if (typeof frame === &#039;undefined&#039;) {
        delete window[name];
      } else {
        defineGetter(window, name, function () { return frame.contentWindow; });
      }
    };
    this._parentWindow = window.getGlobal();
  });

  defineGetter(dom.Document.prototype, &#039;defaultView&#039;, function() {
    return this.parentWindow;
  });

  dom._augmented = true;
  return dom;
};</textarea>
  </div>
</div>

<footer class="footer">
  <div class="container">
    <p>.</p>
  </div>
</footer>

<script type="text/html" id="complexity-popover-template">
  <div class="complexity-notice">
    Complexity : {{ complexity.cyclomatic }} <br>
    Length : {{ complexity.halstead.length }} <br>
    Difficulty : {{ complexity.halstead.difficulty.toFixed(2) }} <br>
    Est # bugs : {{ complexity.halstead.bugs.toFixed(2) }}<br>
  </div>
</script>

<script type="text/javascript" src="../../assets/scripts/bundles/core-bundle.js"></script>
<script type="text/javascript" src="../../assets/scripts/bundles/codemirror.js"></script>
<script type="text/javascript" src="../../assets/scripts/codemirror.markpopovertext.js"></script>
<script type="text/javascript" src="report.js"></script>
<script type="text/javascript" src="report.history.js"></script>
<script type="text/javascript" src="../../assets/scripts/plato-file.js"></script>
</body>
</html>
