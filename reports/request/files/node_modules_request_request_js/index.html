<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Plato - node_modules/request/request.js</title>

  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="">
  <meta name="author" content="">

  <!--[if lt IE 9]>
  <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->

  <link href="../../assets/css/vendor/morris.css" rel="stylesheet">
  <link href="../../assets/css/vendor/bootstrap.css" rel="stylesheet">
  <link href="../../assets/css/vendor/font-awesome.css" rel="stylesheet">
  <link href="../../assets/css/vendor/codemirror.css" rel="stylesheet">
  <link href="../../assets/css/plato.css" rel="stylesheet">
  <link href="../../assets/css/plato-file.css" rel="stylesheet">

</head>

<body>

<div class="navbar navbar-fixed-top">
  <div class="container">
    <a class="navbar-brand" href="http://github.com/es-analysis/plato">Plato on Github</a>
    <ul class="nav navbar-nav">
      <li>
        <a href="../../index.html">Report Home</a>
      </li>
    </ul>
  </div>
</div>

<div class="jumbotron">
  <div class="container">
    <h1>node_modules/request/request.js</h1>
  </div>
</div>

<div class="container aggregate-stats">
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Maintainability <a href="http://blogs.msdn.com/b/codeanalysis/archive/2007/11/20/maintainability-index-range-and-meaning.aspx"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="A value between 0 and 100 that represents the relative ease of maintaining the code. A high value means better maintainability." data-original-title="Maintainability Index"  data-container="body"></i></a></h2>
      <p class="stat">55.29</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Lines of code <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h2>
      <p class="stat">1766</p>
    </div>
  </div>
  <div class="row historical">
    <div class="col-md-6">
      <p id="chart_historical_maint" class="chart"></p>
    </div>
    <div class="col-md-6">
      <p id="chart_historical_sloc" class="chart"></p>
    </div>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Difficulty  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="The difficulty measure is related to the difficulty of the program to write or understand." data-original-title="Difficulty" data-container="body"></i></a></h2>
      <p class="stat">125.34</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Estimated Errors  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Halstead's delivered bugs is an estimate for the number of errors in the implementation." data-original-title="Delivered Bugs" data-container="body"></i></a></h2>
      <p class="stat">21.91</p>
    </div>
  </div>
</div>

<div class="container charts">
  <div class="row">
    <h2 class="header">Function weight</h2>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h3 class="chart-header">By Complexity <a href="http://en.wikipedia.org/wiki/Cyclomatic_complexity"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="This metric counts the number of distinct paths through a block of code. Lower values are better." data-original-title="Cyclomatic Complexity" data-container="body"></i></a></h3>
      <div id="fn-by-complexity" class="stat"></div>
    </div>
    <div class="col-md-6">
      <h3 class="chart-header">By SLOC  <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h3>
      <div id="fn-by-sloc" class="stat"></div>
    </div>
  </div>
</div>

<div class="container">
  <div class="row">
    <textarea id="file-source" class="col-md-12">&#039;use strict&#039;

var http = require(&#039;http&#039;)
  , https = require(&#039;https&#039;)
  , url = require(&#039;url&#039;)
  , util = require(&#039;util&#039;)
  , stream = require(&#039;stream&#039;)
  , qs = require(&#039;qs&#039;)
  , querystring = require(&#039;querystring&#039;)
  , zlib = require(&#039;zlib&#039;)
  , helpers = require(&#039;./lib/helpers&#039;)
  , bl = require(&#039;bl&#039;)
  , oauth = require(&#039;oauth-sign&#039;)
  , hawk = require(&#039;hawk&#039;)
  , aws = require(&#039;aws-sign2&#039;)
  , httpSignature = require(&#039;http-signature&#039;)
  , uuid = require(&#039;node-uuid&#039;)
  , mime = require(&#039;mime-types&#039;)
  , tunnel = require(&#039;tunnel-agent&#039;)
  , stringstream = require(&#039;stringstream&#039;)
  , caseless = require(&#039;caseless&#039;)
  , ForeverAgent = require(&#039;forever-agent&#039;)
  , FormData = require(&#039;form-data&#039;)
  , cookies = require(&#039;./lib/cookies&#039;)
  , copy = require(&#039;./lib/copy&#039;)
  , debug = require(&#039;./lib/debug&#039;)
  , net = require(&#039;net&#039;)
  , CombinedStream = require(&#039;combined-stream&#039;)

var safeStringify = helpers.safeStringify
  , md5 = helpers.md5
  , isReadStream = helpers.isReadStream
  , toBase64 = helpers.toBase64
  , defer = helpers.defer
  , globalCookieJar = cookies.jar()


var globalPool = {}
  , isUrl = /^https?:/

var defaultProxyHeaderWhiteList = [
  &#039;accept&#039;,
  &#039;accept-charset&#039;,
  &#039;accept-encoding&#039;,
  &#039;accept-language&#039;,
  &#039;accept-ranges&#039;,
  &#039;cache-control&#039;,
  &#039;content-encoding&#039;,
  &#039;content-language&#039;,
  &#039;content-length&#039;,
  &#039;content-location&#039;,
  &#039;content-md5&#039;,
  &#039;content-range&#039;,
  &#039;content-type&#039;,
  &#039;connection&#039;,
  &#039;date&#039;,
  &#039;expect&#039;,
  &#039;max-forwards&#039;,
  &#039;pragma&#039;,
  &#039;referer&#039;,
  &#039;te&#039;,
  &#039;transfer-encoding&#039;,
  &#039;user-agent&#039;,
  &#039;via&#039;
]

var defaultProxyHeaderExclusiveList = [
  &#039;proxy-authorization&#039;
]

function filterForNonReserved(reserved, options) {
  // Filter out properties that are not reserved.
  // Reserved values are passed in at call site.

  var object = {}
  for (var i in options) {
    var notReserved = (reserved.indexOf(i) === -1)
    if (notReserved) {
      object[i] = options[i]
    }
  }
  return object
}

function filterOutReservedFunctions(reserved, options) {
  // Filter out properties that are functions and are reserved.
  // Reserved values are passed in at call site.

  var object = {}
  for (var i in options) {
    var isReserved = !(reserved.indexOf(i) === -1)
    var isFunction = (typeof options[i] === &#039;function&#039;)
    if (!(isReserved &amp;&amp; isFunction)) {
      object[i] = options[i]
    }
  }
  return object

}

function constructProxyHost(uriObject) {
  var port = uriObject.portA
    , protocol = uriObject.protocol
    , proxyHost = uriObject.hostname + &#039;:&#039;

  if (port) {
    proxyHost += port
  } else if (protocol === &#039;https:&#039;) {
    proxyHost += &#039;443&#039;
  } else {
    proxyHost += &#039;80&#039;
  }

  return proxyHost
}

function constructProxyHeaderWhiteList(headers, proxyHeaderWhiteList) {
  var whiteList = proxyHeaderWhiteList
    .reduce(function (set, header) {
      set[header.toLowerCase()] = true
      return set
    }, {})

  return Object.keys(headers)
    .filter(function (header) {
      return whiteList[header.toLowerCase()]
    })
    .reduce(function (set, header) {
      set[header] = headers[header]
      return set
    }, {})
}

function construcTunnelOptions(request) {
  var proxy = request.proxy

  var tunnelOptions = {
    proxy: {
      host: proxy.hostname,
      port: +proxy.port,
      proxyAuth: proxy.auth,
      headers: request.proxyHeaders
    },
    rejectUnauthorized: request.rejectUnauthorized,
    headers: request.headers,
    ca: request.ca,
    cert: request.cert,
    key: request.key
  }

  return tunnelOptions
}

function constructTunnelFnName(uri, proxy) {
  var uriProtocol = (uri.protocol === &#039;https:&#039; ? &#039;https&#039; : &#039;http&#039;)
  var proxyProtocol = (proxy.protocol === &#039;https:&#039; ? &#039;Https&#039; : &#039;Http&#039;)
  return [uriProtocol, proxyProtocol].join(&#039;Over&#039;)
}

function getTunnelFn(request) {
  var uri = request.uri
  var proxy = request.proxy
  var tunnelFnName = constructTunnelFnName(uri, proxy)
  return tunnel[tunnelFnName]
}

// Decide the proper request proxy to use based on the request URI object and the
// environmental variables (NO_PROXY, HTTP_PROXY, etc.)
function getProxyFromURI(uri) {
  // respect NO_PROXY environment variables (see: http://lynx.isc.org/current/breakout/lynx_help/keystrokes/environments.html)
  var noProxy = process.env.NO_PROXY || process.env.no_proxy || null

  // easy case first - if NO_PROXY is &#039;*&#039;
  if (noProxy === &#039;*&#039;) {
    return null
  }

  // otherwise, parse the noProxy value to see if it applies to the URL
  if (noProxy !== null) {
    var noProxyItem, hostname, port, noProxyItemParts, noProxyHost, noProxyPort, noProxyList

    // canonicalize the hostname, so that &#039;oogle.com&#039; won&#039;t match &#039;google.com&#039;
    hostname = uri.hostname.replace(/^\.*/, &#039;.&#039;).toLowerCase()
    noProxyList = noProxy.split(&#039;,&#039;)

    for (var i = 0, len = noProxyList.length; i &lt; len; i++) {
      noProxyItem = noProxyList[i].trim().toLowerCase()

      // no_proxy can be granular at the port level, which complicates things a bit.
      if (noProxyItem.indexOf(&#039;:&#039;) &gt; -1) {
        noProxyItemParts = noProxyItem.split(&#039;:&#039;, 2)
        noProxyHost = noProxyItemParts[0].replace(/^\.*/, &#039;.&#039;)
        noProxyPort = noProxyItemParts[1]
        port = uri.port || (uri.protocol === &#039;https:&#039; ? &#039;443&#039; : &#039;80&#039;)

        // we&#039;ve found a match - ports are same and host ends with no_proxy entry.
        if (port === noProxyPort &amp;&amp; hostname.indexOf(noProxyHost) === hostname.length - noProxyHost.length) {
          return null
        }
      } else {
        noProxyItem = noProxyItem.replace(/^\.*/, &#039;.&#039;)
        var isMatchedAt = hostname.indexOf(noProxyItem)
        if (isMatchedAt &gt; -1 &amp;&amp; isMatchedAt === hostname.length - noProxyItem.length) {
          return null
        }
      }
    }
  }

  // check for HTTP(S)_PROXY environment variables
  if (uri.protocol === &#039;http:&#039;) {
      return process.env.HTTP_PROXY || process.env.http_proxy || null
  } else if (uri.protocol === &#039;https:&#039;) {
      return process.env.HTTPS_PROXY || process.env.https_proxy || process.env.HTTP_PROXY || process.env.http_proxy || null
  }

  // return null if all else fails (What uri protocol are you using then?)
  return null
}

// Function for properly handling a connection error
function connectionErrorHandler(error) {
  var socket = this
  if (socket.res) {
    if (socket.res.request) {
      socket.res.request.emit(&#039;error&#039;, error)
    } else {
      socket.res.emit(&#039;error&#039;, error)
    }
  } else {
    socket._httpMessage.emit(&#039;error&#039;, error)
  }
}

// Return a simpler request object to allow serialization
function requestToJSON() {
  var self = this
  return {
    uri: self.uri,
    method: self.method,
    headers: self.headers
  }
}

// Return a simpler response object to allow serialization
function responseToJSON() {
  var self = this
  return {
    statusCode: self.statusCode,
    body: self.body,
    headers: self.headers,
    request: requestToJSON.call(self.request)
  }
}

function Request (options) {
  // if tunnel property of options was not given default to false
  // if given the method property in options, set property explicitMethod to true

  // extend the Request instance with any non-reserved properties
  // remove any reserved functions from the options object
  // set Request instance to be readable and writable
  // call init

  var self = this
  stream.Stream.call(self)
  var reserved = Object.keys(Request.prototype)
  var nonReserved = filterForNonReserved(reserved, options)

  stream.Stream.call(self)
  util._extend(self, nonReserved)
  options = filterOutReservedFunctions(reserved, options)

  self.readable = true
  self.writable = true
  if (typeof options.tunnel === &#039;undefined&#039;) {
    options.tunnel = false
  }
  if (options.method) {
    self.explicitMethod = true
  }
  self.canTunnel = options.tunnel !== false &amp;&amp; tunnel
  self.init(options)
}

util.inherits(Request, stream.Stream)

Request.prototype.setupTunnel = function () {
  // Set up the tunneling agent if necessary
  // Only send the proxy whitelisted header names.
  // Turn on tunneling for the rest of request.

  var self = this

  if (typeof self.proxy === &#039;string&#039;) {
    self.proxy = url.parse(self.proxy)
  }

  if (!self.proxy) {
    return false
  }

  if (!self.tunnel &amp;&amp; self.uri.protocol !== &#039;https:&#039;) {
    return false
  }

  // Always include `defaultProxyHeaderExclusiveList`

  if (!self.proxyHeaderExclusiveList) {
    self.proxyHeaderExclusiveList = []
  }

  var proxyHeaderExclusiveList = self.proxyHeaderExclusiveList.concat(defaultProxyHeaderExclusiveList)

  // Treat `proxyHeaderExclusiveList` as part of `proxyHeaderWhiteList`

  if (!self.proxyHeaderWhiteList) {
    self.proxyHeaderWhiteList = defaultProxyHeaderWhiteList
  }

  var proxyHeaderWhiteList = self.proxyHeaderWhiteList.concat(proxyHeaderExclusiveList)

  var proxyHost = constructProxyHost(self.uri)
  self.proxyHeaders = constructProxyHeaderWhiteList(self.headers, proxyHeaderWhiteList)
  self.proxyHeaders.host = proxyHost

  proxyHeaderExclusiveList.forEach(self.removeHeader, self)

  var tunnelFn = getTunnelFn(self)
  var tunnelOptions = construcTunnelOptions(self)

  self.agent = tunnelFn(tunnelOptions)
  self.tunnel = true
  return true
}

Request.prototype.init = function (options) {
  // init() contains all the code to setup the request object.
  // the actual outgoing request is not started until start() is called
  // this function is called from both the constructor and on redirect.
  var self = this
  if (!options) {
    options = {}
  }
  self.headers = self.headers ? copy(self.headers) : {}

  caseless.httpify(self, self.headers)

  if (!self.method) {
    self.method = options.method || &#039;GET&#039;
  }
  self.localAddress = options.localAddress

  if (!self.qsLib) {
    self.qsLib = (options.useQuerystring ? querystring : qs)
  }

  debug(options)
  if (!self.pool &amp;&amp; self.pool !== false) {
    self.pool = globalPool
  }
  self.dests = self.dests || []
  self.__isRequestRequest = true

  // Protect against double callback
  if (!self._callback &amp;&amp; self.callback) {
    self._callback = self.callback
    self.callback = function () {
      if (self._callbackCalled) {
        return // Print a warning maybe?
      }
      self._callbackCalled = true
      self._callback.apply(self, arguments)
    }
    self.on(&#039;error&#039;, self.callback.bind())
    self.on(&#039;complete&#039;, self.callback.bind(self, null))
  }

  // People use this property instead all the time, so support it
  if (!self.uri &amp;&amp; self.url) {
    self.uri = self.url
    delete self.url
  }

  // A URI is needed by this point, throw if we haven&#039;t been able to get one
  if (!self.uri) {
    return self.emit(&#039;error&#039;, new Error(&#039;options.uri is a required argument&#039;))
  }

  // If a string URI/URL was given, parse it into a URL object
  if(typeof self.uri === &#039;string&#039;) {
    self.uri = url.parse(self.uri)
  }

  // DEPRECATED: Warning for users of the old Unix Sockets URL Scheme
  if (self.uri.protocol === &#039;unix:&#039;) {
    return self.emit(&#039;error&#039;, new Error(&#039;`unix://` URL scheme is no longer supported. Please use the format `http://unix:SOCKET:PATH`&#039;))
  }

  // Support Unix Sockets
  if(self.uri.host === &#039;unix&#039;) {
    // Get the socket &amp; request paths from the URL
    var unixParts = self.uri.path.split(&#039;:&#039;)
      , host = unixParts[0]
      , path = unixParts[1]
    // Apply unix properties to request
    self.socketPath = host
    self.uri.pathname = path
    self.uri.path = path
    self.uri.host = host
    self.uri.hostname = host
    self.uri.isUnix = true
  }

  if (self.strictSSL === false) {
    self.rejectUnauthorized = false
  }

  if(!self.hasOwnProperty(&#039;proxy&#039;)) {
    self.proxy = getProxyFromURI(self.uri)
  }

  // Pass in `tunnel:true` to *always* tunnel through proxies
  self.tunnel = !!options.tunnel
  if (self.proxy) {
    self.setupTunnel()
  }

  if (!self.uri.pathname) {self.uri.pathname = &#039;/&#039;}

  if (!(self.uri.host || (self.uri.hostname &amp;&amp; self.uri.port)) &amp;&amp; !self.uri.isUnix) {
    // Invalid URI: it may generate lot of bad errors, like &#039;TypeError: Cannot call method `indexOf` of undefined&#039; in CookieJar
    // Detect and reject it as soon as possible
    var faultyUri = url.format(self.uri)
    var message = &#039;Invalid URI &quot;&#039; + faultyUri + &#039;&quot;&#039;
    if (Object.keys(options).length === 0) {
      // No option ? This can be the sign of a redirect
      // As this is a case where the user cannot do anything (they didn&#039;t call request directly with this URL)
      // they should be warned that it can be caused by a redirection (can save some hair)
      message += &#039;. This can be caused by a crappy redirection.&#039;
    }
    // This error was fatal
    return self.emit(&#039;error&#039;, new Error(message))
  }

  self._redirectsFollowed = self._redirectsFollowed || 0
  self.maxRedirects = (self.maxRedirects !== undefined) ? self.maxRedirects : 10
  self.allowRedirect = (typeof self.followRedirect === &#039;function&#039;) ? self.followRedirect : function(response) {
    return true
  }
  self.followRedirects = (self.followRedirect !== undefined) ? !!self.followRedirect : true
  self.followAllRedirects = (self.followAllRedirects !== undefined) ? self.followAllRedirects : false
  if (self.followRedirects || self.followAllRedirects) {
    self.redirects = self.redirects || []
  }

  self.setHost = false
  if (!self.hasHeader(&#039;host&#039;)) {
    var hostHeaderName = self.originalHostHeaderName || &#039;host&#039;
    self.setHeader(hostHeaderName, self.uri.hostname)
    if (self.uri.port) {
      if ( !(self.uri.port === 80 &amp;&amp; self.uri.protocol === &#039;http:&#039;) &amp;&amp;
           !(self.uri.port === 443 &amp;&amp; self.uri.protocol === &#039;https:&#039;) ) {
        self.setHeader(hostHeaderName, self.getHeader(&#039;host&#039;) + (&#039;:&#039; + self.uri.port) )
      }
    }
    self.setHost = true
  }

  self.jar(self._jar || options.jar)

  if (!self.uri.port) {
    if (self.uri.protocol === &#039;http:&#039;) {self.uri.port = 80}
    else if (self.uri.protocol === &#039;https:&#039;) {self.uri.port = 443}
  }

  if (self.proxy &amp;&amp; !self.tunnel) {
    self.port = self.proxy.port
    self.host = self.proxy.hostname
  } else {
    self.port = self.uri.port
    self.host = self.uri.hostname
  }

  if (options.form) {
    self.form(options.form)
  }

  if (options.formData) {
    var formData = options.formData
    var requestForm = self.form()
    var appendFormValue = function (key, value) {
      if (value.hasOwnProperty(&#039;value&#039;) &amp;&amp; value.hasOwnProperty(&#039;options&#039;)) {
        requestForm.append(key, value.value, value.options)
      } else {
        requestForm.append(key, value)
      }
    }
    for (var formKey in formData) {
      if (formData.hasOwnProperty(formKey)) {
        var formValue = formData[formKey]
        if (formValue instanceof Array) {
          for (var j = 0; j &lt; formValue.length; j++) {
            appendFormValue(formKey, formValue[j])
          }
        } else {
          appendFormValue(formKey, formValue)
        }
      }
    }
  }

  if (options.qs) {
    self.qs(options.qs)
  }

  if (self.uri.path) {
    self.path = self.uri.path
  } else {
    self.path = self.uri.pathname + (self.uri.search || &#039;&#039;)
  }

  if (self.path.length === 0) {
    self.path = &#039;/&#039;
  }

  // Auth must happen last in case signing is dependent on other headers
  if (options.oauth) {
    self.oauth(options.oauth)
  }

  if (options.aws) {
    self.aws(options.aws)
  }

  if (options.hawk) {
    self.hawk(options.hawk)
  }

  if (options.httpSignature) {
    self.httpSignature(options.httpSignature)
  }

  if (options.auth) {
    if (Object.prototype.hasOwnProperty.call(options.auth, &#039;username&#039;)) {
      options.auth.user = options.auth.username
    }
    if (Object.prototype.hasOwnProperty.call(options.auth, &#039;password&#039;)) {
      options.auth.pass = options.auth.password
    }

    self.auth(
      options.auth.user,
      options.auth.pass,
      options.auth.sendImmediately,
      options.auth.bearer
    )
  }

  if (self.gzip &amp;&amp; !self.hasHeader(&#039;accept-encoding&#039;)) {
    self.setHeader(&#039;accept-encoding&#039;, &#039;gzip&#039;)
  }

  if (self.uri.auth &amp;&amp; !self.hasHeader(&#039;authorization&#039;)) {
    var uriAuthPieces = self.uri.auth.split(&#039;:&#039;).map(function(item){ return querystring.unescape(item) })
    self.auth(uriAuthPieces[0], uriAuthPieces.slice(1).join(&#039;:&#039;), true)
  }

  if (!self.tunnel &amp;&amp; self.proxy &amp;&amp; self.proxy.auth &amp;&amp; !self.hasHeader(&#039;proxy-authorization&#039;)) {
    var proxyAuthPieces = self.proxy.auth.split(&#039;:&#039;).map(function(item){
      return querystring.unescape(item)
    })
    var authHeader = &#039;Basic &#039; + toBase64(proxyAuthPieces.join(&#039;:&#039;))
    self.setHeader(&#039;proxy-authorization&#039;, authHeader)
  }

  if (self.proxy &amp;&amp; !self.tunnel) {
    self.path = (self.uri.protocol + &#039;//&#039; + self.uri.host + self.path)
  }

  if (options.json) {
    self.json(options.json)
  }
  if (options.multipart) {
    self.boundary = uuid()
    self.multipart(options.multipart)
  }

  if (self.body) {
    var length = 0
    if (!Buffer.isBuffer(self.body)) {
      if (Array.isArray(self.body)) {
        for (var i = 0; i &lt; self.body.length; i++) {
          length += self.body[i].length
        }
      } else {
        self.body = new Buffer(self.body)
        length = self.body.length
      }
    } else {
      length = self.body.length
    }
    if (length) {
      if (!self.hasHeader(&#039;content-length&#039;)) {
        self.setHeader(&#039;content-length&#039;, length)
      }
    } else {
      throw new Error(&#039;Argument error, options.body.&#039;)
    }
  }

  var protocol = self.proxy &amp;&amp; !self.tunnel ? self.proxy.protocol : self.uri.protocol
    , defaultModules = {&#039;http:&#039;:http, &#039;https:&#039;:https}
    , httpModules = self.httpModules || {}

  self.httpModule = httpModules[protocol] || defaultModules[protocol]

  if (!self.httpModule) {
    return self.emit(&#039;error&#039;, new Error(&#039;Invalid protocol: &#039; + protocol))
  }

  if (options.ca) {
    self.ca = options.ca
  }

  if (!self.agent) {
    if (options.agentOptions) {
      self.agentOptions = options.agentOptions
    }

    if (options.agentClass) {
      self.agentClass = options.agentClass
    } else if (options.forever) {
      self.agentClass = protocol === &#039;http:&#039; ? ForeverAgent : ForeverAgent.SSL
    } else {
      self.agentClass = self.httpModule.Agent
    }
  }

  if (self.pool === false) {
    self.agent = false
  } else {
    self.agent = self.agent || self.getNewAgent()
  }

  self.on(&#039;pipe&#039;, function (src) {
    if (self.ntick &amp;&amp; self._started) {
      throw new Error(&#039;You cannot pipe to this stream after the outbound request has started.&#039;)
    }
    self.src = src
    if (isReadStream(src)) {
      if (!self.hasHeader(&#039;content-type&#039;)) {
        self.setHeader(&#039;content-type&#039;, mime.lookup(src.path))
      }
    } else {
      if (src.headers) {
        for (var i in src.headers) {
          if (!self.hasHeader(i)) {
            self.setHeader(i, src.headers[i])
          }
        }
      }
      if (self._json &amp;&amp; !self.hasHeader(&#039;content-type&#039;)) {
        self.setHeader(&#039;content-type&#039;, &#039;application/json&#039;)
      }
      if (src.method &amp;&amp; !self.explicitMethod) {
        self.method = src.method
      }
    }

    // self.on(&#039;pipe&#039;, function () {
    //   console.error(&#039;You have already piped to this stream. Pipeing twice is likely to break the request.&#039;)
    // })
  })

  defer(function () {
    if (self._aborted) {
      return
    }

    var end = function () {
      if (self._form) {
        self._form.pipe(self)
      }
      if (self._multipart) {
        self._multipart.pipe(self)
      }
      if (self.body) {
        if (Array.isArray(self.body)) {
          self.body.forEach(function (part) {
            self.write(part)
          })
        } else {
          self.write(self.body)
        }
        self.end()
      } else if (self.requestBodyStream) {
        console.warn(&#039;options.requestBodyStream is deprecated, please pass the request object to stream.pipe.&#039;)
        self.requestBodyStream.pipe(self)
      } else if (!self.src) {
        if (self.method !== &#039;GET&#039; &amp;&amp; typeof self.method !== &#039;undefined&#039;) {
          self.setHeader(&#039;content-length&#039;, 0)
        }
        self.end()
      }
    }

    if (self._form &amp;&amp; !self.hasHeader(&#039;content-length&#039;)) {
      // Before ending the request, we had to compute the length of the whole form, asyncly
      self.setHeader(self._form.getHeaders())
      self._form.getLength(function (err, length) {
        if (!err) {
          self.setHeader(&#039;content-length&#039;, length)
        }
        end()
      })
    } else {
      end()
    }

    self.ntick = true
  })

}

// Must call this when following a redirect from https to http or vice versa
// Attempts to keep everything as identical as possible, but update the
// httpModule, Tunneling agent, and/or Forever Agent in use.
Request.prototype._updateProtocol = function () {
  var self = this
  var protocol = self.uri.protocol

  if (protocol === &#039;https:&#039; || self.tunnel) {
    // previously was doing http, now doing https
    // if it&#039;s https, then we might need to tunnel now.
    if (self.proxy) {
      if (self.setupTunnel()) {
        return
      }
    }

    self.httpModule = https
    switch (self.agentClass) {
      case ForeverAgent:
        self.agentClass = ForeverAgent.SSL
        break
      case http.Agent:
        self.agentClass = https.Agent
        break
      default:
        // nothing we can do.  Just hope for the best.
        return
    }

    // if there&#039;s an agent, we need to get a new one.
    if (self.agent) {
      self.agent = self.getNewAgent()
    }

  } else {
    // previously was doing https, now doing http
    self.httpModule = http
    switch (self.agentClass) {
      case ForeverAgent.SSL:
        self.agentClass = ForeverAgent
        break
      case https.Agent:
        self.agentClass = http.Agent
        break
      default:
        // nothing we can do.  just hope for the best
        return
    }

    // if there&#039;s an agent, then get a new one.
    if (self.agent) {
      self.agent = null
      self.agent = self.getNewAgent()
    }
  }
}

Request.prototype.getNewAgent = function () {
  var self = this
  var Agent = self.agentClass
  var options = {}
  if (self.agentOptions) {
    for (var i in self.agentOptions) {
      options[i] = self.agentOptions[i]
    }
  }
  if (self.ca) {
    options.ca = self.ca
  }
  if (self.ciphers) {
    options.ciphers = self.ciphers
  }
  if (self.secureProtocol) {
    options.secureProtocol = self.secureProtocol
  }
  if (self.secureOptions) {
    options.secureOptions = self.secureOptions
  }
  if (typeof self.rejectUnauthorized !== &#039;undefined&#039;) {
    options.rejectUnauthorized = self.rejectUnauthorized
  }

  if (self.cert &amp;&amp; self.key) {
    options.key = self.key
    options.cert = self.cert
  }

  var poolKey = &#039;&#039;

  // different types of agents are in different pools
  if (Agent !== self.httpModule.Agent) {
    poolKey += Agent.name
  }

  // ca option is only relevant if proxy or destination are https
  var proxy = self.proxy
  if (typeof proxy === &#039;string&#039;) {
    proxy = url.parse(proxy)
  }
  var isHttps = (proxy &amp;&amp; proxy.protocol === &#039;https:&#039;) || this.uri.protocol === &#039;https:&#039;

  if (isHttps) {
    if (options.ca) {
      if (poolKey) {
        poolKey += &#039;:&#039;
      }
      poolKey += options.ca
    }

    if (typeof options.rejectUnauthorized !== &#039;undefined&#039;) {
      if (poolKey) {
        poolKey += &#039;:&#039;
      }
      poolKey += options.rejectUnauthorized
    }

    if (options.cert) {
      poolKey += options.cert.toString(&#039;ascii&#039;) + options.key.toString(&#039;ascii&#039;)
    }

    if (options.ciphers) {
      if (poolKey) {
        poolKey += &#039;:&#039;
      }
      poolKey += options.ciphers
    }

    if (options.secureProtocol) {
      if (poolKey) {
        poolKey += &#039;:&#039;
      }
      poolKey += options.secureProtocol
    }

    if (options.secureOptions) {
      if (poolKey) {
        poolKey += &#039;:&#039;
      }
      poolKey += options.secureOptions
    }
  }

  if (self.pool === globalPool &amp;&amp; !poolKey &amp;&amp; Object.keys(options).length === 0 &amp;&amp; self.httpModule.globalAgent) {
    // not doing anything special.  Use the globalAgent
    return self.httpModule.globalAgent
  }

  // we&#039;re using a stored agent.  Make sure it&#039;s protocol-specific
  poolKey = self.uri.protocol + poolKey

  // generate a new agent for this setting if none yet exists
  if (!self.pool[poolKey]) {
    self.pool[poolKey] = new Agent(options)
    // properly set maxSockets on new agents
    if (self.pool.maxSockets) {
      self.pool[poolKey].maxSockets = self.pool.maxSockets
    }
  }

  return self.pool[poolKey]
}

Request.prototype.start = function () {
  // start() is called once we are ready to send the outgoing HTTP request.
  // this is usually called on the first write(), end() or on nextTick()
  var self = this

  if (self._aborted) {
    return
  }

  self._started = true
  self.method = self.method || &#039;GET&#039;
  self.href = self.uri.href

  if (self.src &amp;&amp; self.src.stat &amp;&amp; self.src.stat.size &amp;&amp; !self.hasHeader(&#039;content-length&#039;)) {
    self.setHeader(&#039;content-length&#039;, self.src.stat.size)
  }
  if (self._aws) {
    self.aws(self._aws, true)
  }

  // We have a method named auth, which is completely different from the http.request
  // auth option.  If we don&#039;t remove it, we&#039;re gonna have a bad time.
  var reqOptions = copy(self)
  delete reqOptions.auth

  debug(&#039;make request&#039;, self.uri.href)
  self.req = self.httpModule.request(reqOptions)

  if (self.timeout &amp;&amp; !self.timeoutTimer) {
    self.timeoutTimer = setTimeout(function () {
      self.abort()
      var e = new Error(&#039;ETIMEDOUT&#039;)
      e.code = &#039;ETIMEDOUT&#039;
      self.emit(&#039;error&#039;, e)
    }, self.timeout)

    // Set additional timeout on socket - in case if remote
    // server freeze after sending headers
    if (self.req.setTimeout) { // only works on node 0.6+
      self.req.setTimeout(self.timeout, function () {
        if (self.req) {
          self.req.abort()
          var e = new Error(&#039;ESOCKETTIMEDOUT&#039;)
          e.code = &#039;ESOCKETTIMEDOUT&#039;
          self.emit(&#039;error&#039;, e)
        }
      })
    }
  }

  self.req.on(&#039;response&#039;, self.onRequestResponse.bind(self))
  self.req.on(&#039;error&#039;, self.onRequestError.bind(self))
  self.req.on(&#039;drain&#039;, function() {
    self.emit(&#039;drain&#039;)
  })
  self.req.on(&#039;socket&#039;, function(socket) {
    self.emit(&#039;socket&#039;, socket)
  })

  self.on(&#039;end&#039;, function() {
    if ( self.req.connection ) {
      self.req.connection.removeListener(&#039;error&#039;, connectionErrorHandler)
    }
  })
  self.emit(&#039;request&#039;, self.req)
}

Request.prototype.onRequestError = function (error) {
  var self = this
  if (self._aborted) {
    return
  }
  if (self.req &amp;&amp; self.req._reusedSocket &amp;&amp; error.code === &#039;ECONNRESET&#039;
      &amp;&amp; self.agent.addRequestNoreuse) {
    self.agent = { addRequest: self.agent.addRequestNoreuse.bind(self.agent) }
    self.start()
    self.req.end()
    return
  }
  if (self.timeout &amp;&amp; self.timeoutTimer) {
    clearTimeout(self.timeoutTimer)
    self.timeoutTimer = null
  }
  self.emit(&#039;error&#039;, error)
}

Request.prototype.onRequestResponse = function (response) {
  var self = this
  debug(&#039;onRequestResponse&#039;, self.uri.href, response.statusCode, response.headers)
  response.on(&#039;end&#039;, function() {
    debug(&#039;response end&#039;, self.uri.href, response.statusCode, response.headers)
  })

  // The check on response.connection is a workaround for browserify.
  if (response.connection &amp;&amp; response.connection.listeners(&#039;error&#039;).indexOf(connectionErrorHandler) === -1) {
    response.connection.setMaxListeners(0)
    response.connection.once(&#039;error&#039;, connectionErrorHandler)
  }
  if (self._aborted) {
    debug(&#039;aborted&#039;, self.uri.href)
    response.resume()
    return
  }
  if (self._paused) {
    response.pause()
  } else if (response.resume) {
    // response.resume should be defined, but check anyway before calling. Workaround for browserify.
    response.resume()
  }

  self.response = response
  response.request = self
  response.toJSON = responseToJSON

  // XXX This is different on 0.10, because SSL is strict by default
  if (self.httpModule === https &amp;&amp;
      self.strictSSL &amp;&amp; (!response.hasOwnProperty(&#039;client&#039;) ||
      !response.client.authorized)) {
    debug(&#039;strict ssl error&#039;, self.uri.href)
    var sslErr = response.hasOwnProperty(&#039;client&#039;) ? response.client.authorizationError : self.uri.href + &#039; does not support SSL&#039;
    self.emit(&#039;error&#039;, new Error(&#039;SSL Error: &#039; + sslErr))
    return
  }

  // Save the original host before any redirect (if it changes, we need to
  // remove any authorization headers).  Also remember the case of the header
  // name because lots of broken servers expect Host instead of host and we
  // want the caller to be able to specify this.
  self.originalHost = self.getHeader(&#039;host&#039;)
  if (!self.originalHostHeaderName) {
    self.originalHostHeaderName = self.hasHeader(&#039;host&#039;)
  }
  if (self.setHost) {
    self.removeHeader(&#039;host&#039;)
  }
  if (self.timeout &amp;&amp; self.timeoutTimer) {
    clearTimeout(self.timeoutTimer)
    self.timeoutTimer = null
  }

  var targetCookieJar = (self._jar &amp;&amp; self._jar.setCookie) ? self._jar : globalCookieJar
  var addCookie = function (cookie) {
    //set the cookie if it&#039;s domain in the href&#039;s domain.
    try {
      targetCookieJar.setCookie(cookie, self.uri.href, {ignoreError: true})
    } catch (e) {
      self.emit(&#039;error&#039;, e)
    }
  }

  response.caseless = caseless(response.headers)

  if (response.caseless.has(&#039;set-cookie&#039;) &amp;&amp; (!self._disableCookies)) {
    var headerName = response.caseless.has(&#039;set-cookie&#039;)
    if (Array.isArray(response.headers[headerName])) {
      response.headers[headerName].forEach(addCookie)
    } else {
      addCookie(response.headers[headerName])
    }
  }

  var redirectTo = null
  if (response.statusCode &gt;= 300 &amp;&amp; response.statusCode &lt; 400 &amp;&amp; response.caseless.has(&#039;location&#039;)) {
    var location = response.caseless.get(&#039;location&#039;)
    debug(&#039;redirect&#039;, location)

    if (self.followAllRedirects) {
      redirectTo = location
    } else if (self.followRedirects) {
      switch (self.method) {
        case &#039;PATCH&#039;:
        case &#039;PUT&#039;:
        case &#039;POST&#039;:
        case &#039;DELETE&#039;:
          // Do not follow redirects
          break
        default:
          redirectTo = location
          break
      }
    }
  } else if (response.statusCode === 401 &amp;&amp; self._hasAuth &amp;&amp; !self._sentAuth) {
    var authHeader = response.caseless.get(&#039;www-authenticate&#039;)
    var authVerb = authHeader &amp;&amp; authHeader.split(&#039; &#039;)[0].toLowerCase()
    debug(&#039;reauth&#039;, authVerb)

    switch (authVerb) {
      case &#039;basic&#039;:
        self.auth(self._user, self._pass, true)
        redirectTo = self.uri
        break

      case &#039;bearer&#039;:
        self.auth(null, null, true, self._bearer)
        redirectTo = self.uri
        break

      case &#039;digest&#039;:
        // TODO: More complete implementation of RFC 2617.
        //   - check challenge.algorithm
        //   - support algorithm=&quot;MD5-sess&quot;
        //   - handle challenge.domain
        //   - support qop=&quot;auth-int&quot; only
        //   - handle Authentication-Info (not necessarily?)
        //   - check challenge.stale (not necessarily?)
        //   - increase nc (not necessarily?)
        // For reference:
        // http://tools.ietf.org/html/rfc2617#section-3
        // https://github.com/bagder/curl/blob/master/lib/http_digest.c

        var challenge = {}
        var re = /([a-z0-9_-]+)=(?:&quot;([^&quot;]+)&quot;|([a-z0-9_-]+))/gi
        for (;;) {
          var match = re.exec(authHeader)
          if (!match) {
            break
          }
          challenge[match[1]] = match[2] || match[3]
        }

        var ha1 = md5(self._user + &#039;:&#039; + challenge.realm + &#039;:&#039; + self._pass)
        var ha2 = md5(self.method + &#039;:&#039; + self.uri.path)
        var qop = /(^|,)\s*auth\s*($|,)/.test(challenge.qop) &amp;&amp; &#039;auth&#039;
        var nc = qop &amp;&amp; &#039;00000001&#039;
        var cnonce = qop &amp;&amp; uuid().replace(/-/g, &#039;&#039;)
        var digestResponse = qop ? md5(ha1 + &#039;:&#039; + challenge.nonce + &#039;:&#039; + nc + &#039;:&#039; + cnonce + &#039;:&#039; + qop + &#039;:&#039; + ha2) : md5(ha1 + &#039;:&#039; + challenge.nonce + &#039;:&#039; + ha2)
        var authValues = {
          username: self._user,
          realm: challenge.realm,
          nonce: challenge.nonce,
          uri: self.uri.path,
          qop: qop,
          response: digestResponse,
          nc: nc,
          cnonce: cnonce,
          algorithm: challenge.algorithm,
          opaque: challenge.opaque
        }

        authHeader = []
        for (var k in authValues) {
          if (authValues[k]) {
            if (k === &#039;qop&#039; || k === &#039;nc&#039; || k === &#039;algorithm&#039;) {
              authHeader.push(k + &#039;=&#039; + authValues[k])
            } else {
              authHeader.push(k + &#039;=&quot;&#039; + authValues[k] + &#039;&quot;&#039;)
            }
          }
        }
        authHeader = &#039;Digest &#039; + authHeader.join(&#039;, &#039;)
        self.setHeader(&#039;authorization&#039;, authHeader)
        self._sentAuth = true

        redirectTo = self.uri
        break
    }
  }

  if (redirectTo &amp;&amp; self.allowRedirect.call(self, response)) {
    debug(&#039;redirect to&#039;, redirectTo)

    // ignore any potential response body.  it cannot possibly be useful
    // to us at this point.
    if (self._paused) {
      response.resume()
    }

    if (self._redirectsFollowed &gt;= self.maxRedirects) {
      self.emit(&#039;error&#039;, new Error(&#039;Exceeded maxRedirects. Probably stuck in a redirect loop &#039; + self.uri.href))
      return
    }
    self._redirectsFollowed += 1

    if (!isUrl.test(redirectTo)) {
      redirectTo = url.resolve(self.uri.href, redirectTo)
    }

    var uriPrev = self.uri
    self.uri = url.parse(redirectTo)

    // handle the case where we change protocol from https to http or vice versa
    if (self.uri.protocol !== uriPrev.protocol) {
      self._updateProtocol()
    }

    self.redirects.push(
      { statusCode : response.statusCode
      , redirectUri: redirectTo
      }
    )
    if (self.followAllRedirects &amp;&amp; response.statusCode !== 401 &amp;&amp; response.statusCode !== 307) {
      self.method = &#039;GET&#039;
    }
    // self.method = &#039;GET&#039; // Force all redirects to use GET || commented out fixes #215
    delete self.src
    delete self.req
    delete self.agent
    delete self._started
    if (response.statusCode !== 401 &amp;&amp; response.statusCode !== 307) {
      // Remove parameters from the previous response, unless this is the second request
      // for a server that requires digest authentication.
      delete self.body
      delete self._form
      if (self.headers) {
        self.removeHeader(&#039;host&#039;)
        self.removeHeader(&#039;content-type&#039;)
        self.removeHeader(&#039;content-length&#039;)
        if (self.uri.hostname !== self.originalHost.split(&#039;:&#039;)[0]) {
          // Remove authorization if changing hostnames (but not if just
          // changing ports or protocols).  This matches the behavior of curl:
          // https://github.com/bagder/curl/blob/6beb0eee/lib/http.c#L710
          self.removeHeader(&#039;authorization&#039;)
        }
      }
    }

    self.emit(&#039;redirect&#039;)

    self.init()
    return // Ignore the rest of the response
  } else {
    self._redirectsFollowed = self._redirectsFollowed || 0
    // Be a good stream and emit end when the response is finished.
    // Hack to emit end on close because of a core bug that never fires end
    response.on(&#039;close&#039;, function () {
      if (!self._ended) {
        self.response.emit(&#039;end&#039;)
      }
    })

    response.on(&#039;end&#039;, function () {
      self._ended = true
    })

    var dataStream
    if (self.gzip) {
      var contentEncoding = response.headers[&#039;content-encoding&#039;] || &#039;identity&#039;
      contentEncoding = contentEncoding.trim().toLowerCase()

      if (contentEncoding === &#039;gzip&#039;) {
        dataStream = zlib.createGunzip()
        response.pipe(dataStream)
      } else {
        // Since previous versions didn&#039;t check for Content-Encoding header,
        // ignore any invalid values to preserve backwards-compatibility
        if (contentEncoding !== &#039;identity&#039;) {
          debug(&#039;ignoring unrecognized Content-Encoding &#039; + contentEncoding)
        }
        dataStream = response
      }
    } else {
      dataStream = response
    }

    if (self.encoding) {
      if (self.dests.length !== 0) {
        console.error(&#039;Ignoring encoding parameter as this stream is being piped to another stream which makes the encoding option invalid.&#039;)
      } else if (dataStream.setEncoding) {
        dataStream.setEncoding(self.encoding)
      } else {
        // Should only occur on node pre-v0.9.4 (joyent/node@9b5abe5) with
        // zlib streams.
        // If/When support for 0.9.4 is dropped, this should be unnecessary.
        dataStream = dataStream.pipe(stringstream(self.encoding))
      }
    }

    self.emit(&#039;response&#039;, response)

    self.dests.forEach(function (dest) {
      self.pipeDest(dest)
    })

    dataStream.on(&#039;data&#039;, function (chunk) {
      self._destdata = true
      self.emit(&#039;data&#039;, chunk)
    })
    dataStream.on(&#039;end&#039;, function (chunk) {
      self.emit(&#039;end&#039;, chunk)
    })
    dataStream.on(&#039;error&#039;, function (error) {
      self.emit(&#039;error&#039;, error)
    })
    dataStream.on(&#039;close&#039;, function () {self.emit(&#039;close&#039;)})

    if (self.callback) {
      var buffer = bl()
        , strings = []

      self.on(&#039;data&#039;, function (chunk) {
        if (Buffer.isBuffer(chunk)) {
          buffer.append(chunk)
        } else {
          strings.push(chunk)
        }
      })
      self.on(&#039;end&#039;, function () {
        debug(&#039;end event&#039;, self.uri.href)
        if (self._aborted) {
          debug(&#039;aborted&#039;, self.uri.href)
          return
        }

        if (buffer.length) {
          debug(&#039;has body&#039;, self.uri.href, buffer.length)
          if (self.encoding === null) {
            // response.body = buffer
            // can&#039;t move to this until https://github.com/rvagg/bl/issues/13
            response.body = buffer.slice()
          } else {
            response.body = buffer.toString(self.encoding)
          }
        } else if (strings.length) {
          // The UTF8 BOM [0xEF,0xBB,0xBF] is converted to [0xFE,0xFF] in the JS UTC16/UCS2 representation.
          // Strip this value out when the encoding is set to &#039;utf8&#039;, as upstream consumers won&#039;t expect it and it breaks JSON.parse().
          if (self.encoding === &#039;utf8&#039; &amp;&amp; strings[0].length &gt; 0 &amp;&amp; strings[0][0] === &#039;\uFEFF&#039;) {
            strings[0] = strings[0].substring(1)
          }
          response.body = strings.join(&#039;&#039;)
        }

        if (self._json) {
          try {
            response.body = JSON.parse(response.body)
          } catch (e) {}
        }
        debug(&#039;emitting complete&#039;, self.uri.href)
        if(typeof response.body === &#039;undefined&#039; &amp;&amp; !self._json) {
          response.body = &#039;&#039;
        }
        self.emit(&#039;complete&#039;, response, response.body)
      })
    }
    //if no callback
    else{
      self.on(&#039;end&#039;, function () {
        if (self._aborted) {
          debug(&#039;aborted&#039;, self.uri.href)
          return
        }
        self.emit(&#039;complete&#039;, response)
      })
    }
  }
  debug(&#039;finish init function&#039;, self.uri.href)
}

Request.prototype.abort = function () {
  var self = this
  self._aborted = true

  if (self.req) {
    self.req.abort()
  }
  else if (self.response) {
    self.response.abort()
  }

  self.emit(&#039;abort&#039;)
}

Request.prototype.pipeDest = function (dest) {
  var self = this
  var response = self.response
  // Called after the response is received
  if (dest.headers &amp;&amp; !dest.headersSent) {
    if (response.caseless.has(&#039;content-type&#039;)) {
      var ctname = response.caseless.has(&#039;content-type&#039;)
      if (dest.setHeader) {
        dest.setHeader(ctname, response.headers[ctname])
      }
      else {
        dest.headers[ctname] = response.headers[ctname]
      }
    }

    if (response.caseless.has(&#039;content-length&#039;)) {
      var clname = response.caseless.has(&#039;content-length&#039;)
      if (dest.setHeader) {
        dest.setHeader(clname, response.headers[clname])
      } else {
        dest.headers[clname] = response.headers[clname]
      }
    }
  }
  if (dest.setHeader &amp;&amp; !dest.headersSent) {
    for (var i in response.headers) {
      // If the response content is being decoded, the Content-Encoding header
      // of the response doesn&#039;t represent the piped content, so don&#039;t pass it.
      if (!self.gzip || i !== &#039;content-encoding&#039;) {
        dest.setHeader(i, response.headers[i])
      }
    }
    dest.statusCode = response.statusCode
  }
  if (self.pipefilter) {
    self.pipefilter(response, dest)
  }
}

Request.prototype.qs = function (q, clobber) {
  var self = this
  var base
  if (!clobber &amp;&amp; self.uri.query) {
    base = self.qsLib.parse(self.uri.query)
  } else {
    base = {}
  }

  for (var i in q) {
    base[i] = q[i]
  }

  if (self.qsLib.stringify(base) === &#039;&#039;){
    return self
  }

  self.uri = url.parse(self.uri.href.split(&#039;?&#039;)[0] + &#039;?&#039; + self.qsLib.stringify(base))
  self.url = self.uri
  self.path = self.uri.path

  return self
}
Request.prototype.form = function (form) {
  var self = this
  if (form) {
    self.setHeader(&#039;content-type&#039;, &#039;application/x-www-form-urlencoded&#039;)
    self.body = (typeof form === &#039;string&#039;) ? form.toString(&#039;utf8&#039;) : self.qsLib.stringify(form).toString(&#039;utf8&#039;)
    return self
  }
  // create form-data object
  self._form = new FormData()
  return self._form
}
Request.prototype.multipart = function (multipart) {
  var self = this

  var chunked = (multipart instanceof Array) || (multipart.chunked === undefined) || multipart.chunked
  multipart = multipart.data || multipart

  var items = chunked ? new CombinedStream() : []
  function add (part) {
    return chunked ? items.append(part) : items.push(new Buffer(part))
  }

  if (chunked) {
    self.setHeader(&#039;transfer-encoding&#039;, &#039;chunked&#039;)
  }

  var headerName = self.hasHeader(&#039;content-type&#039;)
  if (!headerName || self.headers[headerName].indexOf(&#039;multipart&#039;) === -1) {
    self.setHeader(&#039;content-type&#039;, &#039;multipart/related; boundary=&#039; + self.boundary)
  } else {
    self.setHeader(headerName, self.headers[headerName].split(&#039;;&#039;)[0] + &#039;; boundary=&#039; + self.boundary)
  }

  if (!multipart.forEach) {
    throw new Error(&#039;Argument error, options.multipart.&#039;)
  }

  if (self.preambleCRLF) {
    add(&#039;\r\n&#039;)
  }

  multipart.forEach(function (part) {
    var body = part.body
    if(typeof body === &#039;undefined&#039;) {
      throw new Error(&#039;Body attribute missing in multipart.&#039;)
    }
    var preamble = &#039;--&#039; + self.boundary + &#039;\r\n&#039;
    Object.keys(part).forEach(function (key) {
      if (key === &#039;body&#039;) { return }
      preamble += key + &#039;: &#039; + part[key] + &#039;\r\n&#039;
    })
    preamble += &#039;\r\n&#039;
    add(preamble)
    add(body)
    add(&#039;\r\n&#039;)
  })
  add(&#039;--&#039; + self.boundary + &#039;--&#039;)

  if (self.postambleCRLF) {
    add(&#039;\r\n&#039;)
  }

  self[chunked ? &#039;_multipart&#039; : &#039;body&#039;] = items
  return self
}
Request.prototype.json = function (val) {
  var self = this

  if (!self.hasHeader(&#039;accept&#039;)) {
    self.setHeader(&#039;accept&#039;, &#039;application/json&#039;)
  }

  self._json = true
  if (typeof val === &#039;boolean&#039;) {
    if (typeof self.body === &#039;object&#039;) {
      self.body = safeStringify(self.body)
      if (!self.hasHeader(&#039;content-type&#039;)) {
        self.setHeader(&#039;content-type&#039;, &#039;application/json&#039;)
      }
    }
  } else {
    self.body = safeStringify(val)
    if (!self.hasHeader(&#039;content-type&#039;)) {
      self.setHeader(&#039;content-type&#039;, &#039;application/json&#039;)
    }
  }

  return self
}
Request.prototype.getHeader = function (name, headers) {
  var self = this
  var result, re, match
  if (!headers) {
    headers = self.headers
  }
  Object.keys(headers).forEach(function (key) {
    if (key.length !== name.length) {
      return
    }
    re = new RegExp(name, &#039;i&#039;)
    match = key.match(re)
    if (match) {
      result = headers[key]
    }
  })
  return result
}
var getHeader = Request.prototype.getHeader

Request.prototype.auth = function (user, pass, sendImmediately, bearer) {
  var self = this
  if (bearer !== undefined) {
    self._bearer = bearer
    self._hasAuth = true
    if (sendImmediately || typeof sendImmediately === &#039;undefined&#039;) {
      if (typeof bearer === &#039;function&#039;) {
        bearer = bearer()
      }
      self.setHeader(&#039;authorization&#039;, &#039;Bearer &#039; + bearer)
      self._sentAuth = true
    }
    return self
  }
  if (typeof user !== &#039;string&#039; || (pass !== undefined &amp;&amp; typeof pass !== &#039;string&#039;)) {
    throw new Error(&#039;auth() received invalid user or password&#039;)
  }
  self._user = user
  self._pass = pass
  self._hasAuth = true
  var header = typeof pass !== &#039;undefined&#039; ? user + &#039;:&#039; + pass : user
  if (sendImmediately || typeof sendImmediately === &#039;undefined&#039;) {
    self.setHeader(&#039;authorization&#039;, &#039;Basic &#039; + toBase64(header))
    self._sentAuth = true
  }
  return self
}

Request.prototype.aws = function (opts, now) {
  var self = this

  if (!now) {
    self._aws = opts
    return self
  }
  var date = new Date()
  self.setHeader(&#039;date&#039;, date.toUTCString())
  var auth =
    { key: opts.key
    , secret: opts.secret
    , verb: self.method.toUpperCase()
    , date: date
    , contentType: self.getHeader(&#039;content-type&#039;) || &#039;&#039;
    , md5: self.getHeader(&#039;content-md5&#039;) || &#039;&#039;
    , amazonHeaders: aws.canonicalizeHeaders(self.headers)
    }
  var path = self.uri.path
  if (opts.bucket &amp;&amp; path) {
    auth.resource = &#039;/&#039; + opts.bucket + path
  } else if (opts.bucket &amp;&amp; !path) {
    auth.resource = &#039;/&#039; + opts.bucket
  } else if (!opts.bucket &amp;&amp; path) {
    auth.resource = path
  } else if (!opts.bucket &amp;&amp; !path) {
    auth.resource = &#039;/&#039;
  }
  auth.resource = aws.canonicalizeResource(auth.resource)
  self.setHeader(&#039;authorization&#039;, aws.authorization(auth))

  return self
}
Request.prototype.httpSignature = function (opts) {
  var self = this
  httpSignature.signRequest({
    getHeader: function(header) {
      return getHeader(header, self.headers)
    },
    setHeader: function(header, value) {
      self.setHeader(header, value)
    },
    method: self.method,
    path: self.path
  }, opts)
  debug(&#039;httpSignature authorization&#039;, self.getHeader(&#039;authorization&#039;))

  return self
}

Request.prototype.hawk = function (opts) {
  var self = this
  self.setHeader(&#039;Authorization&#039;, hawk.client.header(self.uri, self.method, opts).field)
}

Request.prototype.oauth = function (_oauth) {
  var self = this
  var form, query
  if (self.hasHeader(&#039;content-type&#039;) &amp;&amp;
      self.getHeader(&#039;content-type&#039;).slice(0, &#039;application/x-www-form-urlencoded&#039;.length) ===
        &#039;application/x-www-form-urlencoded&#039;
     ) {
    form = self.body
  }
  if (self.uri.query) {
    query = self.uri.query
  }

  var oa = {}
  for (var i in _oauth) {
    oa[&#039;oauth_&#039; + i] = _oauth[i]
  }
  if (&#039;oauth_realm&#039; in oa) {
    delete oa.oauth_realm
  }
  if (!oa.oauth_version) {
    oa.oauth_version = &#039;1.0&#039;
  }
  if (!oa.oauth_timestamp) {
    oa.oauth_timestamp = Math.floor( Date.now() / 1000 ).toString()
  }
  if (!oa.oauth_nonce) {
    oa.oauth_nonce = uuid().replace(/-/g, &#039;&#039;)
  }
  if (!oa.oauth_signature_method) {
    oa.oauth_signature_method = &#039;HMAC-SHA1&#039;
  }

  var consumer_secret_or_private_key = oa.oauth_consumer_secret || oa.oauth_private_key
  delete oa.oauth_consumer_secret
  delete oa.oauth_private_key
  var token_secret = oa.oauth_token_secret
  delete oa.oauth_token_secret

  var baseurl = self.uri.protocol + &#039;//&#039; + self.uri.host + self.uri.pathname
  var params = self.qsLib.parse([].concat(query, form, self.qsLib.stringify(oa)).join(&#039;&amp;&#039;))

  var signature = oauth.sign(
    oa.oauth_signature_method,
    self.method,
    baseurl,
    params,
    consumer_secret_or_private_key,
    token_secret)

  var realm = _oauth.realm ? &#039;realm=&quot;&#039; + _oauth.realm + &#039;&quot;,&#039; : &#039;&#039;
  var authHeader = &#039;OAuth &#039; + realm +
    Object.keys(oa).sort().map(function (i) {return i + &#039;=&quot;&#039; + oauth.rfc3986(oa[i]) + &#039;&quot;&#039;}).join(&#039;,&#039;)
  authHeader += &#039;,oauth_signature=&quot;&#039; + oauth.rfc3986(signature) + &#039;&quot;&#039;
  self.setHeader(&#039;Authorization&#039;, authHeader)
  return self
}
Request.prototype.jar = function (jar) {
  var self = this
  var cookies

  if (self._redirectsFollowed === 0) {
    self.originalCookieHeader = self.getHeader(&#039;cookie&#039;)
  }

  if (!jar) {
    // disable cookies
    cookies = false
    self._disableCookies = true
  } else {
    var targetCookieJar = (jar &amp;&amp; jar.getCookieString) ? jar : globalCookieJar
    var urihref = self.uri.href
    //fetch cookie in the Specified host
    if (targetCookieJar) {
      cookies = targetCookieJar.getCookieString(urihref)
    }
  }

  //if need cookie and cookie is not empty
  if (cookies &amp;&amp; cookies.length) {
    if (self.originalCookieHeader) {
      // Don&#039;t overwrite existing Cookie header
      self.setHeader(&#039;cookie&#039;, self.originalCookieHeader + &#039;; &#039; + cookies)
    } else {
      self.setHeader(&#039;cookie&#039;, cookies)
    }
  }
  self._jar = jar
  return self
}


// Stream API
Request.prototype.pipe = function (dest, opts) {
  var self = this

  if (self.response) {
    if (self._destdata) {
      throw new Error(&#039;You cannot pipe after data has been emitted from the response.&#039;)
    } else if (self._ended) {
      throw new Error(&#039;You cannot pipe after the response has been ended.&#039;)
    } else {
      stream.Stream.prototype.pipe.call(self, dest, opts)
      self.pipeDest(dest)
      return dest
    }
  } else {
    self.dests.push(dest)
    stream.Stream.prototype.pipe.call(self, dest, opts)
    return dest
  }
}
Request.prototype.write = function () {
  var self = this
  if (!self._started) {
    self.start()
  }
  return self.req.write.apply(self.req, arguments)
}
Request.prototype.end = function (chunk) {
  var self = this
  if (chunk) {
    self.write(chunk)
  }
  if (!self._started) {
    self.start()
  }
  self.req.end()
}
Request.prototype.pause = function () {
  var self = this
  if (!self.response) {
    self._paused = true
  } else {
    self.response.pause.apply(self.response, arguments)
  }
}
Request.prototype.resume = function () {
  var self = this
  if (!self.response) {
    self._paused = false
  } else {
    self.response.resume.apply(self.response, arguments)
  }
}
Request.prototype.destroy = function () {
  var self = this
  if (!self._ended) {
    self.end()
  } else if (self.response) {
    self.response.destroy()
  }
}

Request.defaultProxyHeaderWhiteList =
  defaultProxyHeaderWhiteList.slice()

Request.defaultProxyHeaderExclusiveList =
  defaultProxyHeaderExclusiveList.slice()

// Exports

Request.prototype.toJSON = requestToJSON
module.exports = Request</textarea>
  </div>
</div>

<footer class="footer">
  <div class="container">
    <p>.</p>
  </div>
</footer>

<script type="text/html" id="complexity-popover-template">
  <div class="complexity-notice">
    Complexity : {{ complexity.cyclomatic }} <br>
    Length : {{ complexity.halstead.length }} <br>
    Difficulty : {{ complexity.halstead.difficulty.toFixed(2) }} <br>
    Est # bugs : {{ complexity.halstead.bugs.toFixed(2) }}<br>
  </div>
</script>

<script type="text/javascript" src="../../assets/scripts/bundles/core-bundle.js"></script>
<script type="text/javascript" src="../../assets/scripts/bundles/codemirror.js"></script>
<script type="text/javascript" src="../../assets/scripts/codemirror.markpopovertext.js"></script>
<script type="text/javascript" src="report.js"></script>
<script type="text/javascript" src="report.history.js"></script>
<script type="text/javascript" src="../../assets/scripts/plato-file.js"></script>
</body>
</html>
