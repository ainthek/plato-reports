<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Plato - dojo/tests/unit/on.js</title>

  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="">
  <meta name="author" content="">

  <!--[if lt IE 9]>
  <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->

  <link href="../../assets/css/vendor/morris.css" rel="stylesheet">
  <link href="../../assets/css/vendor/bootstrap.css" rel="stylesheet">
  <link href="../../assets/css/vendor/font-awesome.css" rel="stylesheet">
  <link href="../../assets/css/vendor/codemirror.css" rel="stylesheet">
  <link href="../../assets/css/plato.css" rel="stylesheet">
  <link href="../../assets/css/plato-file.css" rel="stylesheet">

</head>

<body>

<div class="navbar navbar-fixed-top">
  <div class="container">
    <a class="navbar-brand" href="http://github.com/es-analysis/plato">Plato on Github</a>
    <ul class="nav navbar-nav">
      <li>
        <a href="../../index.html">Report Home</a>
      </li>
    </ul>
  </div>
</div>

<div class="jumbotron">
  <div class="container">
    <h1>dojo/tests/unit/on.js</h1>
  </div>
</div>

<div class="container aggregate-stats">
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Maintainability <a href="http://blogs.msdn.com/b/codeanalysis/archive/2007/11/20/maintainability-index-range-and-meaning.aspx"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="A value between 0 and 100 that represents the relative ease of maintaining the code. A high value means better maintainability." data-original-title="Maintainability Index"  data-container="body"></i></a></h2>
      <p class="stat">72.90</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Lines of code <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h2>
      <p class="stat">557</p>
    </div>
  </div>
  <div class="row historical">
    <div class="col-md-6">
      <p id="chart_historical_maint" class="chart"></p>
    </div>
    <div class="col-md-6">
      <p id="chart_historical_sloc" class="chart"></p>
    </div>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Difficulty  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="The difficulty measure is related to the difficulty of the program to write or understand." data-original-title="Difficulty" data-container="body"></i></a></h2>
      <p class="stat">74.75</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Estimated Errors  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Halstead's delivered bugs is an estimate for the number of errors in the implementation." data-original-title="Delivered Bugs" data-container="body"></i></a></h2>
      <p class="stat">5.31</p>
    </div>
  </div>
</div>

<div class="container charts">
  <div class="row">
    <h2 class="header">Function weight</h2>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h3 class="chart-header">By Complexity <a href="http://en.wikipedia.org/wiki/Cyclomatic_complexity"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="This metric counts the number of distinct paths through a block of code. Lower values are better." data-original-title="Cyclomatic Complexity" data-container="body"></i></a></h3>
      <div id="fn-by-complexity" class="stat"></div>
    </div>
    <div class="col-md-6">
      <h3 class="chart-header">By SLOC  <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h3>
      <div id="fn-by-sloc" class="stat"></div>
    </div>
  </div>
</div>

<div class="container">
  <div class="row">
    <textarea id="file-source" class="col-md-12">define([
	&#039;intern!object&#039;,
	&#039;intern/chai!assert&#039;,
	&#039;../../on&#039;,
	&#039;../../Evented&#039;,
	&#039;dojo/_base/lang&#039;,
	&#039;dojo/_base/array&#039;,
	&#039;dojo/has&#039;,
	&#039;dojo/has!host-browser?dojo/dom-construct&#039;,

	// Included to test on.selector
	&#039;dojo/has!host-browser?../../query&#039;,
	&#039;dojo/has!host-browser?dojo/domReady!&#039;
], function (registerSuite, assert, on, Evented, lang, arrayUtil, has, domConstruct) {

	var handles = [];

	var originalOn = on;
	on = function () {
		var handle = originalOn.apply(null, arguments);
		handles.push(handle);
		return handle;
	};
	for (var key in originalOn) {
		on[key] = originalOn[key];
	}

	function cleanUpListeners() {
		while (handles.length &gt; 0) {
			handles.pop().remove();
		}
	}

	function createCommonTests(args) {
		var target,
			testEventName = args.eventName;
		return {
			beforeEach: function () {
				target = args.createTarget();
			},
			afterEach: function () {
				// This would ideally be specified in a suite-wide afterEach,
				// but Safari throws exceptions if listener clean-up occurs after DOM nodes are destroyed
				cleanUpListeners();

				args.destroyTarget &amp;&amp; args.destroyTarget(target);
			},

			&#039;on and on.emit&#039;: function () {
				var listenerCallCount = 0,
					emittedEvent;

				on(target, testEventName, function (actualEvent) {
					listenerCallCount++;
					assert.strictEqual(actualEvent.value, emittedEvent.value);
				});

				emittedEvent = { value: &#039;foo&#039; };
				on.emit(target, testEventName, emittedEvent);
				assert.strictEqual(listenerCallCount, 1);

				emittedEvent = { value: &#039;bar&#039; };
				on.emit(target, testEventName, emittedEvent);
				assert.strictEqual(listenerCallCount, 2);
			},

			&#039;.emit return value&#039;: function () {
				var returnValue = on.emit(target, testEventName, { cancelable: false });
				assert.ok(returnValue);
				assert.propertyVal(returnValue, &#039;cancelable&#039;, false);

				returnValue = on.emit(target, testEventName, { cancelable: true });
				assert.ok(returnValue);
				assert.propertyVal(returnValue, &#039;cancelable&#039;, true);

				on(target, testEventName, function (event) {
					if (&#039;preventDefault&#039; in event) {
						event.preventDefault();
					}
					else {
						event.cancelable = false;
					}
				});
				assert.isFalse(on.emit(target, testEventName, { cancelable: true }));
			},

			&#039;on - multiple event names&#039;: function () {
				var listenerCallCount = 0,
					emittedEventType,
					emittedEvent;

				on(target, &#039;test1, test2&#039;, function (actualEvent) {
					listenerCallCount++;
					if (emittedEventType in actualEvent) {
						assert.strictEqual(actualEvent.type, emittedEventType);
					}
					assert.strictEqual(actualEvent.value, emittedEvent.value);
				});

				emittedEventType = &#039;test1&#039;;
				emittedEvent = { value: &#039;foo&#039; };
				on.emit(target, emittedEventType, emittedEvent);
				assert.strictEqual(listenerCallCount, 1);

				emittedEventType = &#039;test2&#039;;
				emittedEvent = { value: &#039;bar&#039; };
				on.emit(target, emittedEventType, emittedEvent);
				assert.strictEqual(listenerCallCount, 2);
			},

			&#039;on - multiple handlers&#039;: function () {
				var order = [];
				var customEvent = function (target, listener) {
					return on(target, &#039;custom&#039;, listener);
				};
				on(target, &#039;a, b&#039;, function (event) {
					order.push(1 + event.type);
				});
				on(target, [ &#039;a&#039;, customEvent ], function (event) {
					order.push(2 + event.type);
				});
				on.emit(target, &#039;a&#039;, { type: &#039;a&#039; });
				on.emit(target, &#039;b&#039;, { type: &#039;b&#039; });
				on.emit(target, &#039;custom&#039;, { type: &#039;custom&#039; });
				assert.deepEqual(order, [ &#039;1a&#039;, &#039;2a&#039;, &#039;1b&#039;, &#039;2custom&#039; ]);
			},

			&#039;on - extension events&#039;: function () {
				var listenerCallCount = 0,
					emittedEvent,
					extensionEvent = function (target, listener) {
						return on(target, testEventName, listener);
					};

				on(target, extensionEvent, function (actualEvent) {
					listenerCallCount++;
					assert.strictEqual(actualEvent.value, emittedEvent.value);
				});

				emittedEvent = { value: &#039;foo&#039; };
				on.emit(target, testEventName, emittedEvent);
				assert.strictEqual(listenerCallCount, 1);

				emittedEvent = { value: &#039;bar&#039; };
				on.emit(target, testEventName, emittedEvent);
				assert.strictEqual(listenerCallCount, 2);
			},

			&#039;.pausable&#039;: function () {
				var listenerCallCount = 0,
					handle = on.pausable(target, testEventName, function () {
						listenerCallCount++;
					});

				on.emit(target, testEventName, {});
				assert.strictEqual(listenerCallCount, 1);

				handle.pause();
				on.emit(target, testEventName, {});
				assert.strictEqual(listenerCallCount, 1);

				handle.resume();
				on.emit(target, testEventName, {});
				assert.strictEqual(listenerCallCount, 2);
			},

			&#039;.once&#039;: function () {
				var listenerCallCount = 0;

				on.once(target, testEventName, function () {
					++listenerCallCount;
				});

				assert.strictEqual(listenerCallCount, 0);
				on.emit(target, testEventName, {});
				assert.strictEqual(listenerCallCount, 1);
				on.emit(target, testEventName, {});
				assert.strictEqual(listenerCallCount, 1);
			},

			&#039;listener call order&#039;: function () {
				var order = [],
					onMethodName = &#039;on&#039; + testEventName;

				target[onMethodName] = function (event) {
					order.push(event.a);
				};
				var signal = on.pausable(target, testEventName, function () {
					order.push(1);
				});
				var signal2 = on(target, testEventName + &#039;, foo&#039;, function (event) {
					order.push(event.a);
				});
				on.emit(target, testEventName, {
					a: 3
				});
				signal.pause();
				var signal3 = on(target, testEventName, function () {
					order.push(3);
				}, true);
				on.emit(target, testEventName, {
					a: 3
				});
				signal2.remove();
				signal.resume();
				on.emit(target, testEventName, {
					a: 6
				});
				signal3.remove();
				on(target, &#039;foo, &#039; + testEventName, function () {
					order.push(4);
				}, true);
				signal.remove();
				on.emit(target, testEventName, {
					a: 7
				});
				assert.deepEqual(order,  [ 3, 1, 3, 3, 3, 3, 6, 1, 3, 7, 4 ]);
			}
		};
	}

	var suite = {
		name: &#039;dojo/on&#039;,

		common: {
			&#039;object events&#039;: createCommonTests({
				eventName: &#039;test&#039;,
				createTarget: function () {
					return new Evented();
				}
			})
		},

		&#039;cannot target non-emitter&#039;: function () {
			var threwError = false;
			try {
				var nonEmitter = {};
				on(nonEmitter, &#039;test&#039;, function () {});
			}
			catch (err) {
				threwError = true;
			}
			assert.isTrue(threwError);
		}
	};

	if (has(&#039;host-browser&#039;)) {
		suite.common[&#039;DOM events&#039;] = createCommonTests({
			eventName: &#039;click&#039;,
			createTarget: function () {
				return domConstruct.create(&#039;div&#039;, null, document.body);
			},
			destroyTarget: function (target) {
				domConstruct.destroy(target);
			}
		});

		// TODO: Add test to cover syntheticStopPropagation
		// TODO: Add tests to cover functionality of _fixEvent
		var containerDiv,
			childSpan;
		suite[&#039;DOM-specific&#039;] = {

			&#039;beforeEach&#039;: function () {
				containerDiv = domConstruct.create(&#039;div&#039;, null, document.body);
				childSpan = domConstruct.create(&#039;span&#039;, null, containerDiv);
			},
			&#039;afterEach&#039;: function () {
				cleanUpListeners();

				domConstruct.destroy(containerDiv);
				containerDiv = childSpan = null;
			},

			&#039;event.preventDefault&#039;: {
				&#039;native event&#039;: function () {
					var defaultPrevented = false;

					on(childSpan, &#039;click&#039;, function (event) {
						event.preventDefault();
						defaultPrevented = event.defaultPrevented;
					});

					childSpan.click();
					assert.isTrue(defaultPrevented);
				},
				&#039;synthetic event&#039;: function () {
					var secondListenerCalled = false,
						defaultPrevented = false;
					on(childSpan, &#039;click&#039;, function (event) {
						event.preventDefault();
					});
					on(containerDiv, &#039;click&#039;, function (event) {
						secondListenerCalled = true;
						defaultPrevented = event.defaultPrevented;
					});
					on.emit(childSpan, &#039;click&#039;, {bubbles: true, cancelable: true});
					assert.isTrue(secondListenerCalled, &#039;bubbled synthetic event on div&#039;);
					assert.isTrue(defaultPrevented, &#039;defaultPrevented set for synthetic event on div&#039;);
				}
			},

			&#039;event bubbling&#039;: function () {
				var eventBubbled = false;

				on(containerDiv, &#039;click&#039;, function () {
					eventBubbled = true;
				});

				childSpan.click();
				assert.isTrue(eventBubbled, &#039;expected event to bubble&#039;);
			},

			&#039;event.stopPropagation&#039;: function () {
				var eventBubbled;

				on(containerDiv, &#039;click&#039;, function () {
					eventBubbled = true;
				});
				on(childSpan, &#039;click&#039;, function (event) {
					event.stopPropagation();
				});

				// Testing with both Element#click and on.emit because they exercise different
				// code paths, most notably with the browsers that require synthetic dispatch and stopPropagation
				eventBubbled = false;
				childSpan.click();
				assert.isFalse(eventBubbled);

				eventBubbled = false;
				on.emit(childSpan, &#039;click&#039;, {});
				assert.isFalse(eventBubbled);
			},


			&#039;event.stopImmediatePropagation&#039;: function () {
				on(childSpan, &#039;click&#039;, function (event) {
					event.stopImmediatePropagation();
				});

				var afterStop = false;
				on(childSpan, &#039;click&#039;, function () {
					afterStop = true;
				});

				childSpan.click();
				assert.isFalse(afterStop, &#039;expected no other listener to be called&#039;);
			},

			&#039;emitting events from document and window&#039;: function () {
				// make sure &#039;document&#039; and &#039;window&#039; can also emit events
				var eventEmitted;
				var iframe = domConstruct.place(&#039;&lt;iframe&gt;&lt;/iframe&gt;&#039;, containerDiv);
				var globalObjects = [
					document, window, iframe.contentWindow, iframe.contentDocument || iframe.contentWindow.document
				];
				for (var i = 0, len = globalObjects.length; i &lt; len; i++) {
					eventEmitted = false;
					on(globalObjects[i], &#039;custom-test-event&#039;, function () {
						eventEmitted = true;
					});
					on.emit(globalObjects[i], &#039;custom-test-event&#039;, {});
					assert.isTrue(eventEmitted);
				}
			},

			&#039;event delegation&#039;: {
				&#039;CSS selector&#039;: function () {
					var button = domConstruct.create(&#039;button&#039;, null, childSpan);

					var listenerCalled = false;
					on(containerDiv, &#039;button:click&#039;, function () {
						listenerCalled = true;
					});
					button.click();
					assert.isTrue(listenerCalled);
				},

				&#039;listening on document&#039;: function () {
					var button = domConstruct.create(&#039;button&#039;, null, childSpan);

					var listenerCalled = false;
					on(document, &#039;button:click&#039;, function () {
						listenerCalled = true;
					});
					button.click();
					assert.isTrue(listenerCalled);
				},

				&#039;CSS selector and text node target&#039;: function () {
					childSpan.className = &#039;textnode-parent&#039;;
					childSpan.innerHTML = &#039;text&#039;;

					var listenerCalled;
					on(containerDiv, &#039;.textnode-parent:click&#039;, function () {
						listenerCalled = true;
					});

					on.emit(childSpan.firstChild, &#039;click&#039;, { bubbles: true, cancelable: true });
					assert.isTrue(listenerCalled);
				},

				&#039;custom selector&#039;: function () {
					var button = domConstruct.create(&#039;button&#039;, null, childSpan);

					var listenerCalled = false;
					on(containerDiv, on.selector(function (node) {
						return node.tagName === &#039;BUTTON&#039;;
					}, &#039;click&#039;), function () {
						listenerCalled = true;
					});

					button.click();
					assert.isTrue(listenerCalled);
				},

				&#039;on.selector and extension events&#039;: {
					&#039;basic extension events&#039;: function () {
						childSpan.setAttribute(&#039;foo&#039;, 2);
						var order = [];
						var customEvent = function (node, listener) {
							return on(node, &#039;custom&#039;, listener);
						};
						on(containerDiv, customEvent, function (event) {
							order.push(event.a);
						});
						on(containerDiv, on.selector(&#039;span&#039;, customEvent), function () {
							order.push(+this.getAttribute(&#039;foo&#039;));
						});
						on.emit(containerDiv, &#039;custom&#039;, {
							a: 0
						});
						// should trigger selector
						on.emit(childSpan, &#039;custom&#039;, {
							a: 1,
							bubbles: true,
							cancelable: true
						});
						// shouldn&#039;t trigger selector
						on.emit(containerDiv, &#039;custom&#039;, {
							a: 3,
							bubbles: true,
							cancelable: true
						});
						assert.deepEqual(order, [0, 1, 2, 3]);
					},

					&#039;extension events with bubbling forms&#039;: function () {
						var listenerCalled = false,
							bubbleListenerCalled = false;

						var customEvent = function (node, listener) {
							return on(node, &#039;custom&#039;, listener);
						};
						// simply test that an extension event&#039;s bubble method is applied if it exists
						customEvent.bubble = function (select) {
							return function (node, listener) {
								return customEvent(node, function (event) {
									bubbleListenerCalled = true;

									if (select(event.target)) {
										listener(event);
									}
								});
							};
						};

						on(containerDiv, on.selector(&#039;span&#039;, customEvent), function () {
							listenerCalled = true;
						});
						on.emit(childSpan, &#039;custom&#039;, { bubbles: true });
						assert.isTrue(listenerCalled);
						assert.isTrue(bubbleListenerCalled);
					}
				},

				&#039;only call listener when matching&#039;: function () {
					containerDiv.innerHTML = &#039;&lt;input type=&quot;checkbox&quot;&gt;&#039;;
					on(containerDiv, &#039;.matchesNothing:click&#039;, function (event) {
						event.preventDefault();
					});
					containerDiv.firstChild.click();
					assert.isTrue(containerDiv.firstChild.checked);
				}
			},

			&#039;event augmentation&#039;: function () {
				var button = domConstruct.create(&#039;button&#039;, null, containerDiv);
				on(button, &#039;click&#039;, function (event) {
					event.modified = true;
					event.test = 3;
				});
				var testValue;
				on(containerDiv, &#039;click&#039;, function (event) {
					testValue = event.test;
				});
				button.click();
				assert.strictEqual(testValue, 3);
			}
		};

		suite[&#039;.matches&#039;] = (function () {
			var containerDiv2;

			return {
				beforeEach: function () {
					containerDiv = domConstruct.create(&#039;div&#039;, null, document.body);
					containerDiv2 = domConstruct.create(&#039;div&#039;, null, containerDiv);
					childSpan = domConstruct.create(&#039;span&#039;, null, containerDiv2);
				},

				afterEach: function () {
					cleanUpListeners();

					domConstruct.destroy(containerDiv);
					containerDiv = containerDiv2 = childSpan = null;
				},

				&#039;inner-most child click&#039;: function () {
					on(containerDiv, &#039;click&#039;, function (event) {
						assert.ok(on.matches(event.target, &#039;span:click&#039;, this));
						assert.ok(on.matches(event.target, &#039;div:click&#039;, this));
						assert.ok(!on.matches(event.target, &#039;div:click&#039;, this, false));
						assert.ok(!on.matches(event.target, &#039;body:click&#039;, this));
					});
					childSpan.click();
				},

				&#039;inner-most container click&#039;: function () {
					on(containerDiv, &#039;click&#039;, function (event) {
						assert.ok(!on.matches(event.target, &#039;span:click&#039;, this));
						assert.ok(on.matches(event.target, &#039;div:click&#039;, this));
					});
					containerDiv2.click();
				}
			};
		})();

		// TODO: Add tests to improve touch-related code coverage
		has(&#039;touch&#039;) &amp;&amp; (suite[&#039;DOM-specific&#039;][&#039;touch event normalization&#039;] = function () {
			var div = document.body.appendChild(document.createElement(&#039;div&#039;));

			var lastEvent;
			on(div, &#039;touchstart&#039;, function (event) {
				// Copying event properties to an object because certain versions of Firefox
				// threw insecure operation errors when saving an event to a closure-bound variable.
				lastEvent = lang.mixin({}, event);
			});
			on.emit(div, &#039;touchstart&#039;, { changedTouches: [{ pageX: 100 }] });

			assert.property(lastEvent, &#039;rotation&#039;);
			assert.property(lastEvent, &#039;pageX&#039;);
		});
	}

	registerSuite(suite);
});</textarea>
  </div>
</div>

<footer class="footer">
  <div class="container">
    <p>.</p>
  </div>
</footer>

<script type="text/html" id="complexity-popover-template">
  <div class="complexity-notice">
    Complexity : {{ complexity.cyclomatic }} <br>
    Length : {{ complexity.halstead.length }} <br>
    Difficulty : {{ complexity.halstead.difficulty.toFixed(2) }} <br>
    Est # bugs : {{ complexity.halstead.bugs.toFixed(2) }}<br>
  </div>
</script>

<script type="text/javascript" src="../../assets/scripts/bundles/core-bundle.js"></script>
<script type="text/javascript" src="../../assets/scripts/bundles/codemirror.js"></script>
<script type="text/javascript" src="../../assets/scripts/codemirror.markpopovertext.js"></script>
<script type="text/javascript" src="report.js"></script>
<script type="text/javascript" src="report.history.js"></script>
<script type="text/javascript" src="../../assets/scripts/plato-file.js"></script>
</body>
</html>
