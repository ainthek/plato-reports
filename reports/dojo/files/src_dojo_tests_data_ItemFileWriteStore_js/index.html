<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Plato - src/dojo/tests/data/ItemFileWriteStore.js</title>

  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="">
  <meta name="author" content="">

  <!--[if lt IE 9]>
  <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->

  <link href="../../assets/css/vendor/morris.css" rel="stylesheet">
  <link href="../../assets/css/vendor/bootstrap.css" rel="stylesheet">
  <link href="../../assets/css/vendor/font-awesome.css" rel="stylesheet">
  <link href="../../assets/css/vendor/codemirror.css" rel="stylesheet">
  <link href="../../assets/css/plato.css" rel="stylesheet">
  <link href="../../assets/css/plato-file.css" rel="stylesheet">

</head>

<body>

<div class="navbar navbar-fixed-top">
  <div class="container">
    <a class="navbar-brand" href="http://github.com/es-analysis/plato">Plato on Github</a>
    <ul class="nav navbar-nav">
      <li>
        <a href="../../index.html">Report Home</a>
      </li>
    </ul>
  </div>
</div>

<div class="jumbotron">
  <div class="container">
    <h1>src/dojo/tests/data/ItemFileWriteStore.js</h1>
  </div>
</div>

<div class="container aggregate-stats">
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Maintainability <a href="http://blogs.msdn.com/b/codeanalysis/archive/2007/11/20/maintainability-index-range-and-meaning.aspx"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="A value between 0 and 100 that represents the relative ease of maintaining the code. A high value means better maintainability." data-original-title="Maintainability Index"  data-container="body"></i></a></h2>
      <p class="stat">64.81</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Lines of code <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h2>
      <p class="stat">1590</p>
    </div>
  </div>
  <div class="row historical">
    <div class="col-md-6">
      <p id="chart_historical_maint" class="chart"></p>
    </div>
    <div class="col-md-6">
      <p id="chart_historical_sloc" class="chart"></p>
    </div>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Difficulty  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="The difficulty measure is related to the difficulty of the program to write or understand." data-original-title="Difficulty" data-container="body"></i></a></h2>
      <p class="stat">150.31</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Estimated Errors  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Halstead's delivered bugs is an estimate for the number of errors in the implementation." data-original-title="Delivered Bugs" data-container="body"></i></a></h2>
      <p class="stat">20.92</p>
    </div>
  </div>
</div>

<div class="container charts">
  <div class="row">
    <h2 class="header">Function weight</h2>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h3 class="chart-header">By Complexity <a href="http://en.wikipedia.org/wiki/Cyclomatic_complexity"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="This metric counts the number of distinct paths through a block of code. Lower values are better." data-original-title="Cyclomatic Complexity" data-container="body"></i></a></h3>
      <div id="fn-by-complexity" class="stat"></div>
    </div>
    <div class="col-md-6">
      <h3 class="chart-header">By SLOC  <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h3>
      <div id="fn-by-sloc" class="stat"></div>
    </div>
  </div>
</div>

<div class="container">
  <div class="row">
    <textarea id="file-source" class="col-md-12">// FIXME: this test assumes the existence of the global object &quot;tests&quot;
define([
  &quot;dojo/main&quot;,
  &quot;doh/main&quot;,
  &quot;require&quot;,
  &quot;./readOnlyItemFileTestTemplates&quot;,
  &quot;dojo/data/ItemFileWriteStore&quot;,
  &quot;dojo/data/api/Read&quot;,
  &quot;dojo/data/api/Identity&quot;,
  &quot;dojo/data/api/Write&quot;,
  &quot;dojo/data/api/Notification&quot;], function(dojo, doh, require){

dojo.getObject(&quot;data.ItemFileWriteStore&quot;, true, tests);

// First, make sure ItemFileWriteStore can still pass all the same unit tests
// that we use for its superclass, ItemFileReadStore:
tests.data.readOnlyItemFileTestTemplates.registerTestsForDatastore(&quot;dojo.data.ItemFileWriteStore&quot;);

tests.data.ItemFileWriteStore.getTestData = function(name){
	var data = {};
	if(name === &quot;reference_integrity&quot;){
		if(dojo.isBrowser){
			data = {url: require.toUrl(&quot;./reference_integrity.json&quot;)};
		}else{
			data =
				{ data: {
					&quot;identifier&quot;: &quot;id&quot;,
					&quot;label&quot;: &quot;name&quot;,
					&quot;items&quot;: [
						{&quot;id&quot;: 1, &quot;name&quot;: &quot;Item 1&quot;},
						{&quot;id&quot;: 2, &quot;name&quot;: &quot;Item 2&quot;},
						{&quot;id&quot;: 3, &quot;name&quot;: &quot;Item 3&quot;},
						{&quot;id&quot;: 4, &quot;name&quot;: &quot;Item 4&quot;},
						{&quot;id&quot;: 5, &quot;name&quot;: &quot;Item 5&quot;},
						{&quot;id&quot;: 6, &quot;name&quot;: &quot;Item 6&quot;},
						{&quot;id&quot;: 7, &quot;name&quot;: &quot;Item 7&quot;},
						{&quot;id&quot;: 8, &quot;name&quot;: &quot;Item 8&quot;},
						{&quot;id&quot;: 9, &quot;name&quot;: &quot;Item 9&quot;},
						{&quot;id&quot;: 10, &quot;name&quot;: &quot;Item 10&quot;, &quot;friends&quot;: [{&quot;_reference&quot;: 1},{&quot;_reference&quot;: 3},{&quot;_reference&quot;: 5}]},
						{&quot;id&quot;: 11, &quot;name&quot;: &quot;Item 11&quot;, &quot;friends&quot;: [{&quot;_reference&quot;: 10}], &quot;siblings&quot;: [{&quot;_reference&quot;: 10}]},
						{&quot;id&quot;: 12, &quot;name&quot;: &quot;Item 12&quot;, &quot;friends&quot;: [{&quot;_reference&quot;: 3},{&quot;_reference&quot;: 7}], &quot;enemies&quot;: [{&quot;_reference&quot;: 10}]},
						{&quot;id&quot;: 13, &quot;name&quot;: &quot;Item 13&quot;, &quot;friends&quot;: [{&quot;_reference&quot;: 10}]},
						{&quot;id&quot;: 14, &quot;name&quot;: &quot;Item 14&quot;, &quot;friends&quot;: [{&quot;_reference&quot;: 11}]},
						{&quot;id&quot;: 15, &quot;name&quot;: &quot;item 15&quot;, &quot;friends&quot;: [{&quot;id&quot;: 16, &quot;name&quot;: &quot;Item 16&quot;}]}
					]
				}
			};
		}
	}
	return data;
};


// Now run some tests that are specific to the write-access features:
doh.register(&quot;tests.data.ItemFileWriteStore&quot;,
	[
		function test_getFeatures(){
			// summary:
			//		Simple test of the getFeatures function of the store
			// description:
			//		Simple test of the getFeatures function of the store
			var store = new dojo.data.ItemFileWriteStore(tests.data.readOnlyItemFileTestTemplates.getTestData(&quot;countries&quot;));

			var features = store.getFeatures();

			// make sure we have the expected features:
			doh.assertTrue(features[&quot;dojo.data.api.Read&quot;] !== null);
			doh.assertTrue(features[&quot;dojo.data.api.Identity&quot;] !== null);
			doh.assertTrue(features[&quot;dojo.data.api.Write&quot;] !== null);
			doh.assertTrue(features[&quot;dojo.data.api.Notification&quot;] !== null);
			doh.assertFalse(features[&quot;iggy&quot;]);

			// and only the expected features:
			var count = 0;
			for(var i in features){
				doh.assertTrue((i === &quot;dojo.data.api.Read&quot; ||
					i === &quot;dojo.data.api.Identity&quot; ||
					i === &quot;dojo.data.api.Write&quot; ||
					i === &quot;dojo.data.api.Notification&quot;));
				count++;
			}
			doh.assertEqual(count, 4);
		},
		function testWriteAPI_setValue(){
			// summary:
			//		Simple test of the setValue API
			// description:
			//		Simple test of the setValue API
			var store = new dojo.data.ItemFileWriteStore(tests.data.readOnlyItemFileTestTemplates.getTestData(&quot;countries&quot;));

			var deferred = new doh.Deferred();
			var onComplete = function(items, request){
				doh.assertEqual(1, items.length);
				var item = items[0];
				doh.assertTrue(store.containsValue(item, &quot;capital&quot;, &quot;Cairo&quot;));

				// FIXME:
				//	  Okay, so this seems very odd.  Maybe I&#039;m just being dense.
				//	  These tests works:
				doh.assertEqual(store.isDirty(item), false);
				doh.assertTrue(store.isDirty(item) === false);
				//	  But these seemingly equivalent tests will not work:
				// doh.assertFalse(store.isDirty(item));
				// doh.assertTrue(!(store.isDirty(item)));
				//
				//	  All of which seems especially weird, given that this *does* work:
				doh.assertFalse(store.isDirty());

				doh.assertTrue(store.isDirty(item) === false);
				doh.assertTrue(!store.isDirty());
				store.setValue(item, &quot;capital&quot;, &quot;New Cairo&quot;);
				doh.assertTrue(store.isDirty(item));
				doh.assertTrue(store.isDirty());
				doh.assertEqual(store.getValue(item, &quot;capital&quot;).toString(), &quot;New Cairo&quot;);
				deferred.callback(true);
			};
			var onError = function(error, request){
				deferred.errback(error);
			};
			store.fetch({query:{name:&quot;Egypt&quot;}, onComplete: onComplete, onError: onError});
			return deferred; //Object
		},
		function testWriteAPI_setValues(){
			// summary:
			//		Simple test of the setValues API
			// description:
			//		Simple test of the setValues API
			var store = new dojo.data.ItemFileWriteStore(tests.data.readOnlyItemFileTestTemplates.getTestData(&quot;countries&quot;));

			var deferred = new doh.Deferred();
			function onComplete(items, request){
				doh.assertEqual(1, items.length);
				var item = items[0];
				doh.assertTrue(store.containsValue(item, &quot;name&quot;, &quot;Egypt&quot;));
				doh.assertTrue(store.isDirty(item) === false);
				doh.assertTrue(!store.isDirty());
				store.setValues(item, &quot;name&quot;, [&quot;Egypt 1&quot;, &quot;Egypt 2&quot;]);
				doh.assertTrue(store.isDirty(item));
				doh.assertTrue(store.isDirty());
				var values = store.getValues(item, &quot;name&quot;);
				doh.assertTrue(values[0] == &quot;Egypt 1&quot;);
				doh.assertTrue(values[1] == &quot;Egypt 2&quot;);
				deferred.callback(true);
			}
			function onError(error, request){
				deferred.errback(error);
			}
			store.fetch({query:{name:&quot;Egypt&quot;}, onComplete: onComplete, onError: onError});
			return deferred; //Object
		},
		function testWriteAPI_unsetAttribute(){
			// summary:
			//		Simple test of the unsetAttribute API
			// description:
			//		Simple test of the unsetAttribute API
			var store = new dojo.data.ItemFileWriteStore(tests.data.readOnlyItemFileTestTemplates.getTestData(&quot;countries&quot;));

			var deferred = new doh.Deferred();
			function onComplete(items, request){
				doh.assertEqual(1, items.length);
				var item = items[0];
				doh.assertTrue(store.containsValue(item, &quot;name&quot;, &quot;Egypt&quot;));
				doh.assertTrue(store.isDirty(item) === false);
				doh.assertTrue(!store.isDirty());
				store.unsetAttribute(item, &quot;name&quot;);
				doh.assertTrue(store.isDirty(item));
				doh.assertTrue(store.isDirty());
				doh.assertTrue(!store.hasAttribute(item, &quot;name&quot;));
				deferred.callback(true);
			}
			function onError(error, request){
				deferred.errback(error);
			}
			store.fetch({query:{name:&quot;Egypt&quot;}, onComplete: onComplete, onError: onError});
			return deferred; //Object
		},
		function testWriteAPI_newItem(){
			// summary:
			//		Simple test of the newItem API
			// description:
			//		Simple test of the newItem API
			var store = new dojo.data.ItemFileWriteStore(tests.data.readOnlyItemFileTestTemplates.getTestData(&quot;countries&quot;));

			var deferred = new doh.Deferred();
			doh.assertTrue(!store.isDirty());

			var onNewInvoked = false;
			store.onNew = function(newItem, parentInfo){

				doh.assertTrue(newItem !== null);
				doh.assertTrue(parentInfo === null);
				doh.assertTrue(store.isItem(newItem));
				onNewInvoked = true;
			};
			var canada = store.newItem({name: &quot;Canada&quot;, abbr:&quot;ca&quot;, capital:&quot;Ottawa&quot;});
			doh.assertTrue(onNewInvoked);

			doh.assertTrue(store.isDirty(canada));
			doh.assertTrue(store.isDirty());
			doh.assertTrue(store.getValues(canada, &quot;name&quot;) == &quot;Canada&quot;);
			function onComplete(items, request){
				doh.assertEqual(1, items.length);
				var item = items[0];
				doh.assertTrue(store.containsValue(item, &quot;name&quot;, &quot;Canada&quot;));
				deferred.callback(true);
			}
			function onError(error, request){
				deferred.errback(error);
			}
			store.fetch({query:{name:&quot;Canada&quot;}, onComplete: onComplete, onError: onError});
			return deferred; //Object
		},
		function testWriteAPI_newItem_withParent(){
			// summary:
			//		Simple test of the newItem API with a parent assignment
			// description:
			//		Simple test of the newItem API with a parent assignment
			var store = new dojo.data.ItemFileWriteStore(tests.data.readOnlyItemFileTestTemplates.getTestData(&quot;countries&quot;));

			var deferred = new doh.Deferred();
			doh.assertTrue(!store.isDirty());

			var onError = function(error, request){
				deferred.errback(error);
			};

			var onComplete = function(items, request){
				doh.assertEqual(1, items.length);
				var item = items[0];
				doh.assertTrue(store.containsValue(item, &quot;name&quot;, &quot;Egypt&quot;));

				//Attach an onNew to validate we get expected values.
				var onNewInvoked = false;
				store.onNew = function(newItem, parentInfo){
					doh.assertEqual(item, parentInfo.item);
					doh.assertEqual(&quot;cities&quot;, parentInfo.attribute);
					doh.assertTrue(parentInfo.oldValue === undefined);
					doh.assertTrue(parentInfo.newValue === newItem);
					onNewInvoked = true;
				};

				//Attach an onSet and verify onSet is NOT called in this case.
				store.onSet = function(item, attribute, oldValue, newValue){
					doh.assertTrue(false);
				};



				//See if we can add in a new item representing the city of Cairo.
				//This should also call the onNew set above....
				var newItem = store.newItem({name: &quot;Cairo&quot;, abbr: &quot;Cairo&quot;}, {parent: item, attribute: &quot;cities&quot;});
				doh.assertTrue(onNewInvoked);

				function onCompleteNewItemShallow(items, request){
					doh.assertEqual(0, items.length);
					function onCompleteNewItemDeep(items, request){
						doh.assertEqual(1, items.length);
						var item = items[0];
						doh.assertEqual(&quot;Cairo&quot;, store.getValue(item, &quot;name&quot;));
						deferred.callback(true);
					}
					//Do a deep search now, should find the new item of the city with name attribute Cairo.
					store.fetch({query:{name:&quot;Cairo&quot;}, onComplete: onCompleteNewItemDeep, onError: onError, queryOptions: {deep:true}});
				}
				//Do a shallow search first, should find nothing.
				store.fetch({query:{name:&quot;Cairo&quot;}, onComplete: onCompleteNewItemShallow, onError: onError});
			};
			store.fetch({query:{name:&quot;Egypt&quot;}, onComplete: onComplete, onError: onError});
			return deferred; //Object
		},

		function testWriteAPI_newItem_multiple_withParent(){
			// summary:
			//		Simple test of the newItem API with a parent assignment multiple times.
			// description:
			//		Simple test of the newItem API with a parent assignment multiple times.
			var store = new dojo.data.ItemFileWriteStore(tests.data.readOnlyItemFileTestTemplates.getTestData(&quot;countries&quot;));

			var deferred = new doh.Deferred();

			doh.assertTrue(!store.isDirty());

			function onComplete(items, request){
				doh.assertEqual(1, items.length);
				var item = items[0];
				doh.assertTrue(store.containsValue(item, &quot;name&quot;, &quot;Egypt&quot;));

				//Attach an onNew to validate we get expected values.
				store.onNew = function(newItem, parentInfo){
					doh.assertEqual(item, parentInfo.item);
					doh.assertEqual(&quot;cities&quot;, parentInfo.attribute);

					doh.assertTrue(parentInfo.oldValue === undefined);

					doh.assertTrue(parentInfo.newValue === newItem);
				};

				//See if we can add in a new item representing the city of Cairo.
				//This should also call the onNew set above....
				var newItem1 = store.newItem({name: &quot;Cairo&quot;, abbr: &quot;Cairo&quot;}, {parent: item, attribute: &quot;cities&quot;});

				//Attach a new onNew to validate we get expected values.
				store.onNew = function(newItem, parentInfo){
					doh.assertEqual(item, parentInfo.item);
					doh.assertEqual(&quot;cities&quot;, parentInfo.attribute);

					console.log(parentInfo.oldValue);
					doh.assertTrue(parentInfo.oldValue == newItem1);

					doh.assertTrue(parentInfo.newValue[0] == newItem1);
					doh.assertTrue(parentInfo.newValue[1] == newItem);
				};
				var newItem2 = store.newItem({name: &quot;Banha&quot;, abbr: &quot;Banha&quot;}, {parent: item, attribute: &quot;cities&quot;});

				//Attach a new onNew to validate we get expected values.
				store.onNew = function(newItem, parentInfo){
					doh.assertEqual(item, parentInfo.item);
					doh.assertEqual(&quot;cities&quot;, parentInfo.attribute);

					doh.assertTrue(parentInfo.oldValue[0] == newItem1);
					doh.assertTrue(parentInfo.oldValue[1] == newItem2);

					doh.assertTrue(parentInfo.newValue[0] == newItem1);
					doh.assertTrue(parentInfo.newValue[1] == newItem2);
					doh.assertTrue(parentInfo.newValue[2] == newItem);
				};
				var newItem3 = store.newItem({name: &quot;Damanhur&quot;, abbr: &quot;Damanhur&quot;}, {parent: item, attribute: &quot;cities&quot;});
				deferred.callback(true);
			}
			function onError(error, request){
				deferred.errback(error);
			}
			store.fetch({query:{name:&quot;Egypt&quot;}, onComplete: onComplete, onError: onError});
			return deferred; //Object
		},

		function testWriteAPI_deleteItem(){
			// summary:
			//		Simple test of the deleteItem API
			// description:
			//		Simple test of the deleteItem API
			var store = new dojo.data.ItemFileWriteStore(tests.data.readOnlyItemFileTestTemplates.getTestData(&quot;countries&quot;));

			var deferred = new doh.Deferred();

			var onError = function(error, request){
				deferred.errback(error);
			};

			var onComplete = function(items, request){
				doh.assertEqual(1, items.length);
				var item = items[0];
				doh.assertTrue(store.containsValue(item, &quot;name&quot;, &quot;Egypt&quot;));
				doh.assertTrue(store.isDirty(item) === false);
				doh.assertTrue(!store.isDirty());
				store.deleteItem(item);
				doh.assertTrue(store.isDirty(item));
				doh.assertTrue(store.isDirty());
				var onCompleteToo = function(itemsToo, requestToo){
					doh.assertEqual(0, itemsToo.length);
					deferred.callback(true);
				};
				store.fetch({query:{name:&quot;Egypt&quot;}, onComplete: onCompleteToo, onError: onError});
			};
			store.fetch({query:{name:&quot;Egypt&quot;}, onComplete: onComplete, onError: onError});
			return deferred; //Object
		},
		function testWriteAPI_isDirty(){
			// summary:
			//		Simple test of the isDirty API
			// description:
			//		Simple test of the isDirty API
			var store = new dojo.data.ItemFileWriteStore(tests.data.readOnlyItemFileTestTemplates.getTestData(&quot;countries&quot;));

			var deferred = new doh.Deferred();
			function onComplete(items, request){
				doh.assertEqual(1, items.length);
				var item = items[0];
				doh.assertTrue(store.containsValue(item, &quot;name&quot;, &quot;Egypt&quot;));
				store.setValue(item, &quot;name&quot;, &quot;Egypt 2&quot;);
				doh.assertTrue(store.getValue(item, &quot;name&quot;) == &quot;Egypt 2&quot;);
				doh.assertTrue(store.isDirty(item));
				deferred.callback(true);
			}
			function onError(error, request){
				deferred.errback(error);
			}
			store.fetch({query:{name:&quot;Egypt&quot;}, onComplete: onComplete, onError: onError});
			return deferred; //Object
		},
		function testWriteAPI_revert(){
			// summary:
			//		Simple test of the revert API
			// description:
			//		Simple test of the revert API
			var store = new dojo.data.ItemFileWriteStore(tests.data.readOnlyItemFileTestTemplates.getTestData(&quot;countries&quot;));

			var deferred = new doh.Deferred();

			var onError = function(error, request){
				deferred.errback(error);
			};

			var onComplete = function(items, request){
				doh.assertEqual(1, items.length);
				var item = items[0];
				doh.assertTrue(store.containsValue(item, &quot;name&quot;, &quot;Egypt&quot;));
				doh.assertTrue(store.isDirty(item) === false);
				doh.assertTrue(!store.isDirty());
				store.setValue(item, &quot;name&quot;, &quot;Egypt 2&quot;);
				doh.assertTrue(store.getValue(item, &quot;name&quot;) == &quot;Egypt 2&quot;);
				doh.assertTrue(store.isDirty(item));
				doh.assertTrue(store.isDirty());
				store.revert();

				//Fetch again to see if it reset the state.
				var onCompleteToo = function(itemsToo, requestToo){
					doh.assertEqual(1, itemsToo.length);
					var itemToo = itemsToo[0];
					doh.assertTrue(store.containsValue(itemToo, &quot;name&quot;, &quot;Egypt&quot;));
					deferred.callback(true);
				};
				store.fetch({query:{name:&quot;Egypt&quot;}, onComplete: onCompleteToo, onError: onError});
			};
			store.fetch({query:{name:&quot;Egypt&quot;}, onComplete: onComplete, onError: onError});
			return deferred; //Object
		},
		function testWriteAPI_save(){
			// summary:
			//		Simple test of the save API
			// description:
			//		Simple test of the save API
			var store = new dojo.data.ItemFileWriteStore(tests.data.readOnlyItemFileTestTemplates.getTestData(&quot;countries&quot;));

			var deferred = new doh.Deferred();
			function onError(error){
				deferred.errback(error);
			}
			function onItem(item){
				store.setValue(item, &quot;capital&quot;, &quot;New Cairo&quot;);
				function onComplete(){
					deferred.callback(true);
				}
				store.save({onComplete:onComplete, onError:onError});
			}
			store.fetchItemByIdentity({identity:&quot;eg&quot;, onItem:onItem, onError:onError});
			return deferred; //Object
		},
		function testWriteAPI_saveVerifyState(){
			// summary:
			//		Simple test of the save API
			// description:
			//		Simple test of the save API
			var store = new dojo.data.ItemFileWriteStore(tests.data.readOnlyItemFileTestTemplates.getTestData(&quot;countries&quot;));

			var deferred = new doh.Deferred();
			function onError(error){
				deferred.errback(error);
			}
			function onItem(item){
				store.setValue(item, &quot;capital&quot;, &quot;New Cairo&quot;);
				function onComplete(){
					//Check internal state.  Note:  Users should NOT do this, this is a UT verification
					//of internals in this case.  Ref tracker: #4394
					doh.assertTrue(!store._saveInProgress);
					deferred.callback(true);
				}
				store.save({onComplete:onComplete, onError:onError});
			}
			store.fetchItemByIdentity({identity:&quot;eg&quot;, onItem:onItem, onError:onError});
			return deferred; //Object
		},
		function testWriteAPI_saveEverything(){
			// summary:
			//		Simple test of the save API
			// description:
			//		Simple test of the save API
			var store = new dojo.data.ItemFileWriteStore(tests.data.readOnlyItemFileTestTemplates.getTestData(&quot;countries&quot;));
			var egypt;

			var deferred = new doh.Deferred();
			var onError = function(error){
				deferred.errback(error);
			};

			store._saveEverything = function(saveCompleteCallback, saveFailedCallback, newFileContentString){
				var struct = dojo.fromJson(newFileContentString);
				doh.assertEqual(struct.identifier, store.getIdentityAttributes(egypt)[0]);
				doh.assertEqual(struct.label, store.getLabelAttributes(egypt)[0]);
				doh.assertEqual(struct.items.length, 7);

				var cloneStore = new dojo.data.ItemFileWriteStore({data:struct});
				var onItemClone = function(itemClone){
					var egyptClone = itemClone;
					doh.assertEqual(store.getIdentityAttributes(egypt)[0], cloneStore.getIdentityAttributes(egyptClone)[0]);
					doh.assertEqual(store.getLabelAttributes(egypt)[0], cloneStore.getLabelAttributes(egyptClone)[0]);
					doh.assertEqual(store.getValue(egypt, &quot;name&quot;), cloneStore.getValue(egyptClone, &quot;name&quot;));
				};
				cloneStore.fetchItemByIdentity({identity:&quot;eg&quot;, onItem:onItemClone, onError:onError});
				saveCompleteCallback();
			};
			var onItem = function(item){
				egypt = item;
				var onComplete = function(){
					deferred.callback(true);
				};
				store.setValue(egypt, &quot;capital&quot;, &quot;New Cairo&quot;);
				store.save({onComplete:onComplete, onError:onError});
			};
			store.fetchItemByIdentity({identity:&quot;eg&quot;, onItem:onItem, onError:onError});
			return deferred; //Object
		},
		function testWriteAPI_saveEverything_HierarchyOff(){
			// summary:
			//		Simple test of the save API
			// description:
			//		Simple test of the save API
			var store = new dojo.data.ItemFileWriteStore(tests.data.readOnlyItemFileTestTemplates.getTestData(&quot;geography_hierarchy_small&quot;));
			store.hierarchical = false;
			var africa;

			var deferred = new doh.Deferred();
			var onError = function(error){
				deferred.errback(error);
			};

			store._saveEverything = function(saveCompleteCallback, saveFailedCallback, newFileContentString){
				var struct = dojo.fromJson(newFileContentString);
				doh.assertEqual(struct.items.length, 3);
				var cloneStore = new dojo.data.ItemFileWriteStore({data:struct, hierarchical: false});
				var onItemClone = function(items, request){
					var africaClone = items[0];
					doh.assertEqual(store.getValue(africa, &quot;name&quot;), cloneStore.getValue(africaClone, &quot;name&quot;));
				};
				cloneStore.fetch({query: {name:&quot;Africa&quot;}, onComplete:onItemClone, onError:onError, queryOptions: {deep: true}});
				saveCompleteCallback();
			};
			var onComplete = function(items, request){
				africa = items[0];
				var onComplete = function(){
					deferred.callback(true);
				};
				store.setValue(africa, &quot;size&quot;, &quot;HUGE!&quot;);
				store.save({onComplete:onComplete, onError:onError});
			};
			store.fetch({query: {name:&quot;Africa&quot;}, onComplete:onComplete, onError:onError, queryOptions: {deep: true}});
			return deferred; //Object
		},
		function testWriteAPI_saveEverything_withDateType(){
			// summary:
			//		Simple test of the save API	with a non-atomic type (Date) that has a type mapping.
			// description:
			//		Simple test of the save API	with a non-atomic type (Date) that has a type mapping.
			var store = new dojo.data.ItemFileWriteStore(tests.data.readOnlyItemFileTestTemplates.getTestData(&quot;countries&quot;));

			var deferred = new doh.Deferred();
			store._saveEverything = function(saveCompleteCallback, saveFailedCallback, newFileContentString){

				//Now load the new data into a datastore and validate that it stored the date right.
				var dataset = dojo.fromJson(newFileContentString);
				var newStore = new dojo.data.ItemFileWriteStore({data: dataset});

				function gotItem(item){
					var independenceDate = newStore.getValue(item,&quot;independence&quot;);
					doh.assertTrue(independenceDate instanceof Date);
					doh.assertTrue(dojo.date.compare(new Date(1993,4,24), independenceDate, &quot;date&quot;) === 0);
					saveCompleteCallback();
				}
				function failed(error, request){
					deferred.errback(error);
					saveFailedCallback();
				}
				newStore.fetchItemByIdentity({identity:&quot;eg&quot;, onItem:gotItem, onError:failed});
			};

			var onError = function(error){
				deferred.errback(error);
			};
			var onItem = function(item){
				var onComplete = function(){
					deferred.callback(true);
				};
				store.setValue(item, &quot;independence&quot;, new Date(1993,4,24));
				store.save({onComplete:onComplete, onError:onError});
			};
			store.fetchItemByIdentity({identity:&quot;eg&quot;, onItem:onItem, onError:onError});
			return deferred; //Object
		},
		function testWriteAPI_saveEverything_withCustomColorTypeSimple(){
			// summary:
			//		Simple test of the save API	with a non-atomic type (dojo.Color) that has a type mapping.
			// description:
			//		Simple test of the save API	with a non-atomic type (dojo.Color) that has a type mapping.

			//Set up the store basics:  What data it has, and what to do when save is called for saveEverything
			//And how to map the &#039;Color&#039; type in and out of the format.
			//(Test of saving all to a some location...)
			var dataset = {
				identifier:&#039;name&#039;,
				items: [
					{ name:&#039;Kermit&#039;, species:&#039;frog&#039;, color:{_type:&#039;Color&#039;, _value:&#039;green&#039;} },
					{ name:&#039;Beaker&#039;, hairColor:{_type:&#039;Color&#039;, _value:&#039;red&#039;} }
				]
			};

			var customTypeMap = {&#039;Color&#039;: dojo.Color };

			var store = new dojo.data.ItemFileWriteStore({
					data:dataset,
					typeMap: customTypeMap
			});

			var deferred = new doh.Deferred();
			store._saveEverything = function(saveCompleteCallback, saveFailedCallback, newFileContentString){
				//Now load the new data into a datastore and validate that it stored the Color right.
				var dataset = dojo.fromJson(newFileContentString);
				var newStore = new dojo.data.ItemFileWriteStore({data: dataset, typeMap: customTypeMap});

				var deferred = new doh.Deferred();
				function gotItem(item){
					var hairColor = newStore.getValue(item,&quot;hairColor&quot;);
					doh.assertTrue(hairColor instanceof dojo.Color);
					doh.assertEqual(&quot;rgba(255, 255, 0, 1)&quot;, hairColor.toString());
					saveCompleteCallback();
				}
				function failed(error, request){
					deferred.errback(error);
					saveFailedCallback();
				}
				newStore.fetchItemByIdentity({identity:&quot;Animal&quot;, onItem:gotItem, onError:failed});
			};

			//Add a new item with a color type, then save it.
            var onError = function(error){
				deferred.errback(error);
			};
			var onComplete = function(){
				deferred.callback(true);
			};

			var animal = store.newItem({name: &quot;Animal&quot;, hairColor: new dojo.Color(&quot;yellow&quot;)});
			store.save({onComplete:onComplete, onError:onError});
			return deferred; //Object
		},
		function testWriteAPI_saveEverything_withCustomColorTypeGeneral(){
			// summary:
			//		Simple test of the save API	with a non-atomic type (dojo.Color) that has a type mapping.
			// description:
			//		Simple test of the save API	with a non-atomic type (dojo.Color) that has a type mapping.

			//Set up the store basics:  What data it has, and what to do when save is called for saveEverything
			//And how to map the &#039;Color&#039; type in and out of the format.
			//(Test of saving all to a some location...)
			var dataset = {
				identifier:&#039;name&#039;,
				items: [
					{ name:&#039;Kermit&#039;, species:&#039;frog&#039;, color:{_type:&#039;Color&#039;, _value:&#039;green&#039;} },
					{ name:&#039;Beaker&#039;, hairColor:{_type:&#039;Color&#039;, _value:&#039;red&#039;} }
				]
			};

			var customTypeMap = {&#039;Color&#039;: 	{
												type: dojo.Color,
												deserialize: function(value){
													return new dojo.Color(value);
												},
												serialize: function(obj){
													return obj.toString();
												}
											}
								};
			var store = new dojo.data.ItemFileWriteStore({
					data:dataset,
					typeMap: customTypeMap
			});

			var deferred = new doh.Deferred();
			store._saveEverything = function(saveCompleteCallback, saveFailedCallback, newFileContentString){
				//Now load the new data into a datastore and validate that it stored the Color right.
				var dataset = dojo.fromJson(newFileContentString);
				var newStore = new dojo.data.ItemFileWriteStore({data: dataset, typeMap: customTypeMap});

				var gotItem = function(item){
					var hairColor = newStore.getValue(item,&quot;hairColor&quot;);
					doh.assertTrue(hairColor instanceof dojo.Color);
					doh.assertEqual(&quot;rgba(255, 255, 0, 1)&quot;, hairColor.toString());
					saveCompleteCallback();
				};
				var failed = function(error, request){
					deferred.errback(error);
					saveFailedCallback();
				};
				newStore.fetchItemByIdentity({identity:&quot;Animal&quot;, onItem:gotItem, onError:failed});
			};

			//Add a new item with a color type, then save it.
            var onError = function(error){
				deferred.errback(error);
			};
			var onComplete = function(){
				deferred.callback(true);
			};

			var animal = store.newItem({name: &quot;Animal&quot;, hairColor: new dojo.Color(&quot;yellow&quot;)});
			store.save({onComplete:onComplete, onError:onError});
			return deferred; //Object
		},
		function testWriteAPI_newItem_revert(){
			// summary:
			//		Test for bug #5357.  Ensure that the revert properly nulls the identity position
			//		for a new item after revert.
			var args = {data: {
				label:&quot;name&quot;,
				items:[
					{name:&#039;Ecuador&#039;, capital:&#039;Quito&#039;},
					{name:&#039;Egypt&#039;, capital:&#039;Cairo&#039;},
					{name:&#039;El Salvador&#039;, capital:&#039;San Salvador&#039;},
					{name:&#039;Equatorial Guinea&#039;, capital:&#039;Malabo&#039;},
					{name:&#039;Eritrea&#039;, capital:&#039;Asmara&#039;},
					{name:&#039;Estonia&#039;, capital:&#039;Tallinn&#039;},
					{name:&#039;Ethiopia&#039;, capital:&#039;Addis Ababa&#039;}
				]
			} };
			var store = new dojo.data.ItemFileWriteStore(args);

			var newCountry = store.newItem({name: &quot;Utopia&quot;, capitol: &quot;Perfect&quot;});

			//DO NOT ACCESS THIS WAY.  THESE ARE INTERNAL VARIABLES.  DOING THIS FOR TEST PURPOSES.
			var itemEntryNum = newCountry[store._itemNumPropName];
			doh.assertTrue(store._arrayOfAllItems[itemEntryNum] === newCountry);
			store.revert();
			doh.assertTrue(store._arrayOfAllItems[itemEntryNum] === null);
		},
		function testWriteAPI_new_modify_revert(){
			// summary:
			//		Test of a new item, modify it, then revert, to ensure the state remains consistent.  Added due to #9022.
			// description:
			//		Test of a new item, modify it, then revert, to ensure the state remains consistent.  Added due to #9022.
			var store = new dojo.data.ItemFileWriteStore(tests.data.readOnlyItemFileTestTemplates.getTestData(&quot;countries&quot;));

			var deferred = new doh.Deferred();
			doh.assertTrue(!store.isDirty());

			var onError = function(error, request){
				deferred.errback(error);
			};

			var initialFetch = function(items, request){
				var initialCount = items.length;
				var canada = store.newItem({name: &quot;Canada&quot;, abbr:&quot;ca&quot;, capital:&quot;Ottawa&quot;});
				store.setValue(canada, &quot;someattribute&quot;, &quot;modified a new item!&quot;);
				var afterNewFetch = function(items, request){
					var afterNewCount = items.length;
					doh.assertEqual(afterNewCount, (initialCount + 1));
					store.revert();
					var afterRevertFetch = function(items, request){
						var afterRevertCount = items.length;
						doh.assertEqual(afterRevertCount, initialCount);
						deferred.callback(true);
					};
					store.fetch({onComplete: afterRevertFetch, onError: onError});
				};
				store.fetch({onComplete: afterNewFetch, onError: onError});
			};
			store.fetch({onComplete: initialFetch, onError: onError});
			return deferred; //Object
		},
		function testWriteAPI_new_modify_delete_revert(){
			// summary:
			//		Test of a new item, modify it, delete it, then revert, to ensure the state remains consistent.  Added due to #9022.
			// description:
			//		Test of a new item, modify it, delete it, then revert, to ensure the state remains consistent.  Added due to #9022.
			var store = new dojo.data.ItemFileWriteStore(tests.data.readOnlyItemFileTestTemplates.getTestData(&quot;countries&quot;));
			var i;
			var found = false;

			var deferred = new doh.Deferred();
			doh.assertTrue(!store.isDirty());

			var onError = function(error, request){
				deferred.errback(error);
			};

			var initialFetch = function(items, request){
				var initialCount = items.length;
				var canada = store.newItem({name: &quot;Canada&quot;, abbr:&quot;ca&quot;, capital:&quot;Ottawa&quot;});
				store.setValue(canada, &quot;someattribute&quot;, &quot;modified a new item!&quot;);

				// check that after new and modify, the total items count goes up by one.
				var afterNewFetch = function(items, request){
					var afterNewCount = items.length;
					doh.assertEqual(afterNewCount, (initialCount + 1));
					store.deleteItem(canada);

					//Check that after delete, the total items count goes back to initial count.
					//Also verify the item with abbr of ca is gone.
					var afterDeleteFetch = function(items, request){
						var afterDeleteCount = items.length;
						doh.assertEqual(initialCount, afterDeleteCount);

						for(i=0; i &lt; items.length; i++){
							found = (store.getIdentity(items[i]) === &quot;ca&quot;);
							if(found){
								break;
							}
						}
						if(found){
							deferred.errback(new Error(&quot;Error: Found the supposedly deleted item!&quot;));
						}else{
							store.revert();
							//Check that after revert, we still have the same item count as the
							//original fetch.  Also verify the item with abbr of ca is gone.
							var afterRevertFetch = function(items, request){
								var afterRevertCount = items.length;
								doh.assertEqual(afterRevertCount, initialCount);
								for(i=0; i &lt; items.length; i++){
									found = (store.getIdentity(items[i]) === &quot;ca&quot;);
									if(found){
										break;
									}
								}
								if(found){
									deferred.errback(new Error(&quot;Error: Found the &#039;new&#039; item after revert!&quot;));
								}else{
									deferred.callback(true);
								}
							};
							store.fetch({onComplete: afterRevertFetch, onError: onError});
						}
					};
					store.fetch({onComplete: afterDeleteFetch, onError: onError});
				};
				store.fetch({onComplete: afterNewFetch, onError: onError});
			};
			store.fetch({onComplete: initialFetch, onError: onError});
			return deferred; //Object
		},
		function testNotificationAPI_onSet(){
			// summary:
			//		Simple test of the onSet API
			// description:
			//		Simple test of the onSet API
			var store = new dojo.data.ItemFileWriteStore(tests.data.readOnlyItemFileTestTemplates.getTestData(&quot;countries&quot;));

			var deferred = new doh.Deferred();
			function onError(error){
				deferred.errback(error);
			}
			function onItem(fetchedItem){
				var egypt = fetchedItem;
				var connectHandle = null;
				function setValueHandler(item, attribute, oldValue, newValue){
					doh.assertTrue(store.isItem(item));
					doh.assertTrue(item == egypt);
					doh.assertTrue(attribute == &quot;capital&quot;);
					doh.assertTrue(oldValue == &quot;Cairo&quot;);
					doh.assertTrue(newValue == &quot;New Cairo&quot;);
					deferred.callback(true);
					dojo.disconnect(connectHandle);
				}
				connectHandle = dojo.connect(store, &quot;onSet&quot;, setValueHandler);
				store.setValue(egypt, &quot;capital&quot;, &quot;New Cairo&quot;);
			}
			store.fetchItemByIdentity({identity:&quot;eg&quot;, onItem:onItem, onError:onError});
		},
		function testNotificationAPI_onNew(){
			// summary:
			//		Simple test of the onNew API
			// description:
			//		Simple test of the onNew API
			var store = new dojo.data.ItemFileWriteStore(tests.data.readOnlyItemFileTestTemplates.getTestData(&quot;countries&quot;));

			var deferred = new doh.Deferred();
			var connectHandle = null;
			function newItemHandler(item){
				doh.assertTrue(store.isItem(item));
				doh.assertTrue(store.getValue(item, &quot;name&quot;) == &quot;Canada&quot;);
				deferred.callback(true);
				dojo.disconnect(connectHandle);
			}
			connectHandle = dojo.connect(store, &quot;onNew&quot;, newItemHandler);
			var canada = store.newItem({name:&quot;Canada&quot;, abbr:&quot;ca&quot;, capital:&quot;Ottawa&quot;});
		},
		function testNotificationAPI_onDelete(){
			// summary:
			//		Simple test of the onDelete API
			// description:
			//		Simple test of the onDelete API
			var store = new dojo.data.ItemFileWriteStore(tests.data.readOnlyItemFileTestTemplates.getTestData(&quot;countries&quot;));

			var deferred = new doh.Deferred();
			function onError(error){
				deferred.errback(error);
			}
			function onItem(fetchedItem){
				var egypt = fetchedItem;
				var connectHandle = null;
				function deleteItemHandler(item){
					doh.assertTrue(store.isItem(item) === false);
					doh.assertTrue(item == egypt);
					deferred.callback(true);
					dojo.disconnect(connectHandle);
				}
				connectHandle = dojo.connect(store, &quot;onDelete&quot;, deleteItemHandler);
				store.deleteItem(egypt);
			}
			store.fetchItemByIdentity({identity:&quot;eg&quot;, onItem:onItem, onError:onError});
		},
		function testReadAPI_functionConformanceToo(){
			// summary:
			//		Simple test read API conformance.  Checks to see all declared functions are actual functions on the instances.
			// description:
			//		Simple test read API conformance.  Checks to see all declared functions are actual functions on the instances.
			var testStore = new dojo.data.ItemFileWriteStore(tests.data.readOnlyItemFileTestTemplates.getTestData(&quot;countries&quot;));
			var readApi = new dojo.data.api.Read();
			var passed = true;

			for(var functionName in readApi){
				var member = readApi[functionName];
				//Check that all the &#039;Read&#039; defined functions exist on the test store.
				if(typeof member === &quot;function&quot;){
					var testStoreMember = testStore[functionName];
					if(!(typeof testStoreMember === &quot;function&quot;)){
						passed = false;
						break;
					}
				}
			}
			doh.assertTrue(passed);
		},
		function testWriteAPI_functionConformance(){
			// summary:
			//		Simple test write API conformance.  Checks to see all declared functions are actual functions on the instances.
			// description:
			//		Simple test write API conformance.  Checks to see all declared functions are actual functions on the instances.
			var testStore = new dojo.data.ItemFileWriteStore(tests.data.readOnlyItemFileTestTemplates.getTestData(&quot;countries&quot;));
			var writeApi = new dojo.data.api.Write();
			var passed = true;

			for(var functionName in writeApi){
				var member = writeApi[functionName];
				//Check that all the &#039;Write&#039; defined functions exist on the test store.
				if(typeof member === &quot;function&quot;){
					var testStoreMember = testStore[functionName];
					if(!(typeof testStoreMember === &quot;function&quot;)){
						passed = false;
						break;
					}
				}
			}
			doh.assertTrue(passed);
		},
		function testNotificationAPI_functionConformance(){
			// summary:
			//		Simple test Notification API conformance.  Checks to see all declared functions are actual functions on the instances.
			// description:
			//		Simple test Notification API conformance.  Checks to see all declared functions are actual functions on the instances.
			var testStore = new dojo.data.ItemFileWriteStore(tests.data.readOnlyItemFileTestTemplates.getTestData(&quot;countries&quot;));
			var api = new dojo.data.api.Notification();
			var passed = true;

			for(var functionName in api){
				var member = api[functionName];
				//Check that all the &#039;Write&#039; defined functions exist on the test store.
				if(typeof member === &quot;function&quot;){
					var testStoreMember = testStore[functionName];
					if(!(typeof testStoreMember === &quot;function&quot;)){
						passed = false;
						break;
					}
				}
			}
			doh.assertTrue(passed);
		},
		function testIdentityAPI_noIdentifierSpecified(){
			// summary:
			//		Test for bug #3873. Given a datafile that does not specify an
			//		identifier, make sure ItemFileWriteStore auto-creates identities
			//		that are unique even after calls to deleteItem() and newItem()
			var args = {data: {
				label:&quot;name&quot;,
				items:[
					{name:&#039;Ecuador&#039;, capital:&#039;Quito&#039;},
					{name:&#039;Egypt&#039;, capital:&#039;Cairo&#039;},
					{name:&#039;El Salvador&#039;, capital:&#039;San Salvador&#039;},
					{name:&#039;Equatorial Guinea&#039;, capital:&#039;Malabo&#039;},
					{name:&#039;Eritrea&#039;, capital:&#039;Asmara&#039;},
					{name:&#039;Estonia&#039;, capital:&#039;Tallinn&#039;},
					{name:&#039;Ethiopia&#039;, capital:&#039;Addis Ababa&#039;}
				]
			} };
			var store = new dojo.data.ItemFileWriteStore(args);
			var deferred = new doh.Deferred();

			var onError = function(error, request){
				deferred.errback(error);
			};
			var onComplete = function(items, request){
				doh.assertEqual(7, items.length);

				var lastItem = items[(items.length - 1)];
				var idOfLastItem = store.getIdentity(lastItem);
				store.deleteItem(lastItem);
				store.newItem({name:&#039;Canada&#039;, capital:&#039;Ottawa&#039;});

				var onCompleteAgain = function(itemsAgain, requestAgain){
					doh.assertEqual(7, itemsAgain.length);
					var identitiesInUse = {};
					for(var i = 0; i &lt; itemsAgain.length; ++i){
						var item = itemsAgain[i];
						var id = store.getIdentity(item);
						if(identitiesInUse.hasOwnProperty(id)){
							// there should not already be an entry for this id
							doh.assertTrue(false);
						}else{
							// we want to add the entry now
							identitiesInUse[id] = item;
						}
					}
					deferred.callback(true);
				};
				store.fetch({onComplete:onCompleteAgain, onError:onError});
			};

			store.fetch({onComplete:onComplete, onError:onError});
			return deferred;
		},
		function testIdentityAPI_noIdentifierSpecified_revert(){
			// summary:
			//		Test for bug #4691  Given a datafile that does not specify an
			//		identifier, make sure ItemFileWriteStore auto-creates identities
			//		that are unique even after calls to deleteItem() and newItem()
			var args = {data: {
				label:&quot;name&quot;,
				items:[
					{name:&#039;Ecuador&#039;, capital:&#039;Quito&#039;},
					{name:&#039;Egypt&#039;, capital:&#039;Cairo&#039;},
					{name:&#039;El Salvador&#039;, capital:&#039;San Salvador&#039;},
					{name:&#039;Equatorial Guinea&#039;, capital:&#039;Malabo&#039;},
					{name:&#039;Eritrea&#039;, capital:&#039;Asmara&#039;},
					{name:&#039;Estonia&#039;, capital:&#039;Tallinn&#039;},
					{name:&#039;Ethiopia&#039;, capital:&#039;Addis Ababa&#039;}
				]
			} };
			var store = new dojo.data.ItemFileWriteStore(args);
			var deferred = new doh.Deferred();

			var onError = function(error, request){
				deferred.errback(error);
			};
			var onComplete = function(items, request){
				doh.assertEqual(7, items.length);

				var lastItem = items[(items.length - 1)];
				var idOfLastItem = store.getIdentity(lastItem);
				store.deleteItem(lastItem);
				store.newItem({name:&#039;Canada&#039;, capital:&#039;Ottawa&#039;});

				var onCompleteAgain = function(itemsAgain, requestAgain){
					doh.assertEqual(7, itemsAgain.length);
					var identitiesInUse = {};
					for(var i = 0; i &lt; itemsAgain.length; ++i){
						var item = itemsAgain[i];
						var id = store.getIdentity(item);
						if(identitiesInUse.hasOwnProperty(id)){
							// there should not already be an entry for this id
							doh.assertTrue(false);
						}else{
							// we want to add the entry now
							identitiesInUse[id] = item;
						}
					}
					//Last test, revert everything and check item sizes.
					store.revert();

					//Now call fetch again and verify store state.
					var revertComplete = function(itemsReverted, request){
						doh.assertEqual(7, itemsReverted.length);
						deferred.callback(true);
					};
					store.fetch({onComplete:revertComplete, onError:onError});
				};
				store.fetch({onComplete:onCompleteAgain, onError:onError});
			};
			store.fetch({onComplete:onComplete, onError:onError});
			return deferred;
		},
		function testReferenceIntegrity_checkReferences(){
			// summary:
			//		Simple test to verify the references were properly resolved.
			// description:
			//		Simple test to verify the references were properly resolved.

			var store = new dojo.data.ItemFileWriteStore(tests.data.ItemFileWriteStore.getTestData(&quot;reference_integrity&quot;));

			var deferred = new doh.Deferred();
			var onError = function(error, request){
				deferred.errback(error);
			};
			var onComplete = function(items, request){

				var item10 = null;
				var item1  = null;
				var item3  = null;
				var item5  = null;

				var i;
				for (i = 0; i &lt; items.length; i++){
					var ident = store.getIdentity(items[i]);
					if (ident === 10){
						item10 = items[i];
					}else if (ident === 1){
						item1 = items[i];
					}else if (ident === 3){
						item3 = items[i];
					}else if (ident === 5){
						item5 = items[i];
					}
				}
				var friends = store.getValues(item10, &quot;friends&quot;);
				doh.assertTrue(friends !== null);
				doh.assertTrue(friends !== undefined);

				doh.assertTrue(store.isItem(item10));
				doh.assertTrue(store.isItem(item1));
				doh.assertTrue(store.isItem(item3));
				doh.assertTrue(store.isItem(item5));
				var found = 0;
				try{
					for (i = 0; i &lt; friends.length; i++){
						if (i === 0){
							doh.assertTrue(store.isItem(friends[i]));
							doh.assertEqual(friends[i], item1);
							doh.assertEqual(store.getIdentity(friends[i]), 1);
							found++;
						}else if (i === 1){
							doh.assertTrue(store.isItem(friends[i]));
							doh.assertEqual(friends[i], item3);
							doh.assertEqual(store.getIdentity(friends[i]), 3);
							found++;
						}else if (i === 2){
							doh.assertTrue(store.isItem(friends[i]));
							doh.assertEqual(friends[i], item5);
							doh.assertEqual(store.getIdentity(friends[i]), 5);
							found++;
						}
					}
				}catch(e){
					doh.errback(e);
				}
				doh.assertEqual(3, found);
				deferred.callback(true);
			};
			store.fetch({onError: onError, onComplete: onComplete});
			return deferred;
		},
		function testReferenceIntegrity_deleteReferencedItem(){
			// summary:
			//		Simple test to verify the references were properly deleted.
			// description:
			//		Simple test to verify the references were properly deleted.

			var store = new dojo.data.ItemFileWriteStore(tests.data.ItemFileWriteStore.getTestData(&quot;reference_integrity&quot;));

			var deferred = new doh.Deferred();
			var passed = true;
			function onError(error, request){
				deferred.errback(error);
			}
			function onItem(item, request){
				try{
					console.log(&quot;Before delete map state is: &quot; + dojo.toJson(item[store._reverseRefMap]));
					store.deleteItem(item);
					console.log(&quot;After delete map state is: &quot; + dojo.toJson(item[store._reverseRefMap]));
					function verifyRefDelete(items, request){
						var passed = true;
						for(var i = 0; i &lt; items.length; i++){
							var curItem = items[i];
							var attributes = store.getAttributes(curItem);
							for(var j = 0; j &lt; attributes.length; j++){
								var values = store.getValues(curItem, attributes[j]);
								var badRef = false;
								for(var k = 0; k &lt; values.length; k++){
									var value = values[k];
									try{
										var id = store.getIdentity(value);
										if(id == 10){
											badRef = true;
											break;
										}
									}catch(e){/*Not an item, even a dead one, just eat it.*/}
								}
								if(badRef){
									deferred.errback(new Error(&quot;Found a reference remaining to a deleted item.  Failure.&quot;));
									passed = false;
									break;
								}
							}
						}
						if(passed){
							deferred.callback(true);
						}
					}
					store.fetch({onComplete: verifyRefDelete, onError: onError});
				}catch(error){
					deferred.errback(error);
				}
			}
			store.fetchItemByIdentity({identity: 10, onError: onError, onItem: onItem});
			return deferred;
		},
		function testReferenceIntegrity_deleteReferencedItemThenRevert(){
			// summary:
			//		Simple test to verify the references were properly deleted.
			// description:
			//		Simple test to verify the references were properly deleted.

			var store = new dojo.data.ItemFileWriteStore(tests.data.ItemFileWriteStore.getTestData(&quot;reference_integrity&quot;));

			var deferred = new doh.Deferred();
			var passed = true;
			function onError(error, request){
				deferred.errback(error);
			}
			function onItem(item, request){
				try{
					//DO NOT EVER ACCESS THESE VARIABLES LIKE THIS!
					//THIS IS FOR TESTING INTERNAL STATE!
					console.log(&quot;Map before delete:&quot;);
					store._dumpReferenceMap();
					var beforeDelete = dojo.toJson(item[store._reverseRefMap]);
					store.deleteItem(item);
					console.log(&quot;Map after delete:&quot;);
					store._dumpReferenceMap();
					var afterDelete = dojo.toJson(item[store._reverseRefMap]);
					store.revert();
					console.log(&quot;Map after revert:&quot;);
					store._dumpReferenceMap();
					var afterRevert = dojo.toJson(item[store._reverseRefMap]);
					doh.assertTrue(afterRevert === beforeDelete);
				}catch(e){
					deferred.errback(e);
					passed = false;
				}
				if(passed){
					deferred.callback(true);
				}
			}
			store.fetchItemByIdentity({identity: 10, onError: onError, onItem: onItem});
			return deferred;
		},
		function testReferenceIntegrity_deleteMultipleItemsWithReferencesAndRevert(){
			// summary:
			//		Simple test to verify that a flow of deleting items with references and reverting does not damage the internal structure.
			//		Created for tracker bug: #5743
			// description:
			//		Simple test to verify that a flow of deleting items with references and reverting does not damage the internal structure.
			//		Created for tracker bug: #5743

			var store = new dojo.data.ItemFileWriteStore(tests.data.readOnlyItemFileTestTemplates.getTestData(&quot;countries_references&quot;));

			var deferred = new doh.Deferred();
			var passed = true;
			function onError(error, request){
				deferred.errback(error);
				doh.assertTrue(false);
			}
			function onItem(item, request){
				//Save off the located item, then locate another one (peer to Egypt)
				doh.assertTrue(store.isItem(item));
				var egypt = item;

				function onItem2(item, request){
					doh.assertTrue(store.isItem(item));
					var nairobi = item;

					//Delete them
					store.deleteItem(egypt);
					store.deleteItem(nairobi);
					try{
						//Revert, then do a fetch.  If the internals have been damaged, this will generally
						//cause onError to fire instead of onComplete.
						store.revert();
						function onComplete(items, request){
							deferred.callback(true);
						}
						store.fetch({query: {name: &quot;*&quot;}, start: 0, count: 20, onComplete: onComplete, onError: onError});
					}catch(e){
						deferred.errback(e);
					}
				}
				store.fetchItemByIdentity({identity: &quot;Nairobi&quot;, onError: onError, onItem: onItem2});
			}
			store.fetchItemByIdentity({identity: &quot;Egypt&quot;, onError: onError, onItem: onItem});
			return deferred;
		},
		function testReferenceIntegrity_removeReferenceFromAttribute(){
			// summary:
			//		Simple test to verify the reference removal updates the internal map.
			// description:
			//		Simple test to verify the reference removal updates the internal map.

			var store = new dojo.data.ItemFileWriteStore(tests.data.ItemFileWriteStore.getTestData(&quot;reference_integrity&quot;));

			var deferred = new doh.Deferred();
			var passed = true;
			function onError(error, request){
				deferred.errback(error);
				doh.assertTrue(false);
			}
			function onItem(item, request){
				try{
					store.setValues(item, &quot;friends&quot;, [null]);

					function onItem2(item10, request){
						//DO NOT EVER ACCESS THESE VARIABLES LIKE THIS!
						//THIS IS FOR TESTING INTERNAL STATE!
						var refMap = item10[store._reverseRefMap];
						store._dumpReferenceMap();

						console.log(&quot;MAP for Item 10 is: &quot; + dojo.toJson(refMap));

						//Assert there is no reference to item 10 in item 11&#039;s attribute &#039;friends&#039;.
						doh.assertTrue(!refMap[&quot;11&quot;][&quot;friends&quot;]);
						store.setValues(item, &quot;siblings&quot;, [0, 1, 2]);
						//Assert there are no more references to 10 in 11.  Ergo, &quot;11&quot;  should be a &#039;undefined&#039; attribute for the map of items referencing &#039;10&#039;..
						doh.assertTrue(!refMap[&quot;11&quot;]);
						deferred.callback(true);
					}
					store.fetchItemByIdentity({identity: 10, onError: onError, onItem: onItem2});

				}catch(e){
					console.debug(e);
					deferred.errback(e);
					doh.assertTrue(false);
				}
			}
			store.fetchItemByIdentity({identity: 11, onError: onError, onItem: onItem});
			return deferred;
		},
		function testReferenceIntegrity_deleteReferencedItemNonParent(){
			// summary:
			//		Simple test to verify the references to a non-parent item was properly deleted.
			// description:
			//		Simple test to verify the references to a non-parent item was properly deleted.

			var store = new dojo.data.ItemFileWriteStore(tests.data.ItemFileWriteStore.getTestData(&quot;reference_integrity&quot;));

			var deferred = new doh.Deferred();
			var passed = true;
			function onError(error, request){
				deferred.errback(error);
			}
			function onItem(item, request){
				try{
					console.log(&quot;Reference state for item 16 is: &quot; + dojo.toJson(item[store._reverseRefMap]));
					store.deleteItem(item);
					function verifyRefDelete(items, request){
						var passed = true;
						for(var i = 0; i &lt; items.length; i++){
							var curItem = items[i];
							var attributes = store.getAttributes(curItem);
							for(var j = 0; j &lt; attributes.length; j++){
								var values = store.getValues(curItem, attributes[j]);
								var badRef = false;
								for(var k = 0; k &lt; values.length; k++){
									var value = values[k];
									try{
										var id = store.getIdentity(value);
										if(id == 16){
											badRef = true;
											break;
										}
									}catch(e){/*Not an item, even a dead one, just eat it.*/}
								}
								if(badRef){
									deferred.errback(new Error(&quot;Found a reference remaining to a deleted item.  Failure.&quot;));
									passed = false;
									break;
								}
							}
						}
						if(passed){
							deferred.callback(true);
						}
					}
					store.fetch({onComplete: verifyRefDelete, onError: onError});
				}catch(error){
					deferred.errback(error);
				}
			}
			store.fetchItemByIdentity({identity: 16, onError: onError, onItem: onItem});
			return deferred;
		},
		function testReferenceIntegrity_addReferenceToAttribute(){
			// summary:
			//		Simple test to verify the reference additions can happen.
			// description:
			//		Simple test to verify the reference additions can happen.

			var store = new dojo.data.ItemFileWriteStore(tests.data.ItemFileWriteStore.getTestData(&quot;reference_integrity&quot;));

			var deferred = new doh.Deferred();
			var passed = true;
			function onError(error, request){
				deferred.errback(error);
				doh.assertTrue(false);
			}
			function onComplete(items, request){

				doh.assertTrue(items.length &gt; 2);

				var item1 = items[0];
				var item2 = items[1];

				//DO NOT EVER ACCESS THESE VARIABLES LIKE THIS!
				//THIS IS FOR TESTING INTERNAL STATE!
				console.log(&quot;Map state for Item 1 is: &quot; + dojo.toJson(item1[store._reverseRefMap]));
				console.log(&quot;Map state for Item 2 is: &quot; + dojo.toJson(item2[store._reverseRefMap]));

				store.setValue(item1, &quot;siblings&quot;, item2);

				//Emit the current map state for inspection.
				console.log(&quot;Map state for Item 1 is: &quot; + dojo.toJson(item1[store._reverseRefMap]));
				console.log(&quot;Map state for Item 2 is: &quot; + dojo.toJson(item2[store._reverseRefMap]));

				doh.assertTrue(item2[store._reverseRefMap] !== null);

				//Assert there is a recorded reference to item 2 in item 1&#039;s attribute &#039;sibling&#039;.
				doh.assertTrue(item2[store._reverseRefMap][store.getIdentity(item1)][&quot;siblings&quot;]);

				deferred.callback(true);
			}
			store.fetch({onError: onError, onComplete: onComplete});
			return deferred;
		},
		function testReferenceIntegrity_newItemWithParentReference(){
			// summary:
			//		Simple test to verify that newItems with a parent properly record the parent&#039;s reference in the map.
			// description:
			//		Simple test to verify that newItems with a parent properly record the parent&#039;s reference in the map.

			var store = new dojo.data.ItemFileWriteStore(tests.data.ItemFileWriteStore.getTestData(&quot;reference_integrity&quot;));

			var deferred = new doh.Deferred();
			var passed = true;
			function onError(error, request){
				deferred.errback(error);
				doh.assertTrue(false);
			}
			function onItem(item, request){
				try{
					//Create a new item and set its parent to item 10&#039;s uncle attribute.
					var newItem = store.newItem({id: 17, name: &quot;Item 17&quot;}, {parent: item, attribute: &quot;uncles&quot;});

					//DO NOT EVER ACCESS THESE VARIABLES LIKE THIS!
					//THIS IS FOR TESTING INTERNAL STATE!
					//Look up the references to 17, as item 10 has one now on attribute &#039;uncles&#039;
					var refs = newItem[store._reverseRefMap];

					//Assert there is a reference from 10 to item 17, on attribute uncle
					doh.assertTrue(refs[&quot;10&quot;][&quot;uncles&quot;]);

					console.log(&quot;State of map of item 17 after newItem: &quot; + dojo.toJson(refs));
				}catch(e){
					console.debug(e);
					deferred.errback(e);
					doh.assertTrue(false);
					passed = false;
				}
				if(passed){
					deferred.callback(true);
				}
			}
			store.fetchItemByIdentity({identity: 10, onError: onError, onItem: onItem});
			return deferred;
		},
		function testReferenceIntegrity_newItemWithReferenceToExistingItem(){
			// summary:
			//		Simple test to verify that a new item with references to existing items properly record the references in the map.
			// description:
			//		Simple test to verify that a new item with references to existing items properly record the references in the map.

			var store = new dojo.data.ItemFileWriteStore(tests.data.ItemFileWriteStore.getTestData(&quot;reference_integrity&quot;));

			var deferred = new doh.Deferred();
			var passed = true;
			function onError(error, request){
				deferred.errback(error);
				doh.assertTrue(false);
			}
			function onItem(item, request){
				try{
					//DO NOT EVER ACCESS THESE VARIABLES LIKE THIS!
					//THIS IS FOR TESTING INTERNAL STATE!
					console.log(&quot;State of reference map to item 10 before newItem: &quot; + dojo.toJson(item[store._reverseRefMap]));

					//Create a new item and set its parent to item 10&#039;s uncle attribute.
					var newItem = store.newItem({id: 17, name: &quot;Item 17&quot;, friends: [item]});

					//DO NOT EVER ACCESS THESE VARIABLES LIKE THIS!
					//THIS IS FOR TESTING INTERNAL STATE!
					//Look up the references to 10, as item 17 has one on friends now.
					var refs = item[store._reverseRefMap];

					//Assert there is a reference from 15 to item 10, on attribute friends
					doh.assertTrue(refs[&quot;17&quot;][&quot;friends&quot;]);

					console.log(&quot;State of reference map to item 10 after newItem: &quot; + dojo.toJson(refs));
				}catch(e){
					console.debug(e);
					deferred.errback(e);
					doh.assertTrue(false);
					passed = false;
				}
				if(passed){
					deferred.callback(true);
				}
			}
			store.fetchItemByIdentity({identity: 10, onError: onError, onItem: onItem});
			return deferred;
		},
		function testReferenceIntegrity_disableReferenceIntegrity(){
			// summary:
			//		Simple test to verify reference integrity can be disabled.
			// description:
			//		Simple test to verify reference integrity can be disabled.

			var params = tests.data.ItemFileWriteStore.getTestData(&quot;reference_integrity&quot;);
			params.referenceIntegrity = false;
			var store = new dojo.data.ItemFileWriteStore(params);

			var deferred = new doh.Deferred();
			function onError(error, request){
				deferred.errback(error);
				doh.assertTrue(false);
			}
			function onItem(item, request){
				//DO NOT EVER ACCESS THESE VARIABLES LIKE THIS!
				//THIS IS FOR TESTING INTERNAL STATE!
				if(item[store._reverseRefMap] === undefined){
					deferred.callback(true);
				}else{
					deferred.errback(new Error(&quot;Disabling of reference integrity failed.&quot;));
				}
			}
			store.fetchItemByIdentity({identity: 10, onError: onError, onItem: onItem});
			return deferred;
		},
		function testReadAPI_close_dirty_failure(){
			// summary:
			//		Function to test the close api properly clears the store for reload when clearOnClose is set.
			if (dojo.isBrowser){
				var params = tests.data.readOnlyItemFileTestTemplates.getTestData(&quot;countries&quot;);
				params.clearOnClose = true;
				params.urlPreventCache = true;
				var store = new dojo.data.ItemFileWriteStore(params);

				var d = new doh.Deferred();
				var onItem = function(item){
					var error = null;
					try {
						doh.assertTrue(item !== null);
						var ec = item;
						var val = store.getValue(ec, &quot;name&quot;);
						doh.assertEqual(&quot;Ecuador&quot;, val);
						var newItem = store.newItem({abbr: &quot;foo&quot;, name: &quot;bar&quot;});

						//Should throw an error...
						store.close();
					}catch (e){
						error = e;
					}
					if (error === null){
						d.errback(new Error(&quot;Store was dirty, should have thrown an error on close!&quot;));
					}else{
						d.callback(true);
					}
				};
				var onError = function(errData){
					d.errback(errData);
				};
				store.fetchItemByIdentity({identity:&quot;ec&quot;, onItem:onItem, onError:onError});
				return d; // Deferred
			}
		}
	]
);


});</textarea>
  </div>
</div>

<footer class="footer">
  <div class="container">
    <p>.</p>
  </div>
</footer>

<script type="text/html" id="complexity-popover-template">
  <div class="complexity-notice">
    Complexity : {{ complexity.cyclomatic }} <br>
    Length : {{ complexity.halstead.length }} <br>
    Difficulty : {{ complexity.halstead.difficulty.toFixed(2) }} <br>
    Est # bugs : {{ complexity.halstead.bugs.toFixed(2) }}<br>
  </div>
</script>

<script type="text/javascript" src="../../assets/scripts/bundles/core-bundle.js"></script>
<script type="text/javascript" src="../../assets/scripts/bundles/codemirror.js"></script>
<script type="text/javascript" src="../../assets/scripts/codemirror.markpopovertext.js"></script>
<script type="text/javascript" src="report.js"></script>
<script type="text/javascript" src="report.history.js"></script>
<script type="text/javascript" src="../../assets/scripts/plato-file.js"></script>
</body>
</html>
