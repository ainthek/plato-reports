<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Plato - dojo/parser.js</title>

  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="">
  <meta name="author" content="">

  <!--[if lt IE 9]>
  <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->

  <link href="../../assets/css/vendor/morris.css" rel="stylesheet">
  <link href="../../assets/css/vendor/bootstrap.css" rel="stylesheet">
  <link href="../../assets/css/vendor/font-awesome.css" rel="stylesheet">
  <link href="../../assets/css/vendor/codemirror.css" rel="stylesheet">
  <link href="../../assets/css/plato.css" rel="stylesheet">
  <link href="../../assets/css/plato-file.css" rel="stylesheet">

</head>

<body>

<div class="navbar navbar-fixed-top">
  <div class="container">
    <a class="navbar-brand" href="http://github.com/es-analysis/plato">Plato on Github</a>
    <ul class="nav navbar-nav">
      <li>
        <a href="../../index.html">Report Home</a>
      </li>
    </ul>
  </div>
</div>

<div class="jumbotron">
  <div class="container">
    <h1>dojo/parser.js</h1>
  </div>
</div>

<div class="container aggregate-stats">
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Maintainability <a href="http://blogs.msdn.com/b/codeanalysis/archive/2007/11/20/maintainability-index-range-and-meaning.aspx"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="A value between 0 and 100 that represents the relative ease of maintaining the code. A high value means better maintainability." data-original-title="Maintainability Index"  data-container="body"></i></a></h2>
      <p class="stat">56.80</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Lines of code <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h2>
      <p class="stat">926</p>
    </div>
  </div>
  <div class="row historical">
    <div class="col-md-6">
      <p id="chart_historical_maint" class="chart"></p>
    </div>
    <div class="col-md-6">
      <p id="chart_historical_sloc" class="chart"></p>
    </div>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Difficulty  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="The difficulty measure is related to the difficulty of the program to write or understand." data-original-title="Difficulty" data-container="body"></i></a></h2>
      <p class="stat">89.29</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Estimated Errors  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Halstead's delivered bugs is an estimate for the number of errors in the implementation." data-original-title="Delivered Bugs" data-container="body"></i></a></h2>
      <p class="stat">7.22</p>
    </div>
  </div>
</div>

<div class="container charts">
  <div class="row">
    <h2 class="header">Function weight</h2>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h3 class="chart-header">By Complexity <a href="http://en.wikipedia.org/wiki/Cyclomatic_complexity"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="This metric counts the number of distinct paths through a block of code. Lower values are better." data-original-title="Cyclomatic Complexity" data-container="body"></i></a></h3>
      <div id="fn-by-complexity" class="stat"></div>
    </div>
    <div class="col-md-6">
      <h3 class="chart-header">By SLOC  <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h3>
      <div id="fn-by-sloc" class="stat"></div>
    </div>
  </div>
</div>

<div class="container">
  <div class="row">
    <textarea id="file-source" class="col-md-12">define([
	&quot;require&quot;, &quot;./_base/kernel&quot;, &quot;./_base/lang&quot;, &quot;./_base/array&quot;, &quot;./_base/config&quot;, &quot;./dom&quot;, &quot;./_base/window&quot;,
		&quot;./_base/url&quot;, &quot;./aspect&quot;, &quot;./promise/all&quot;, &quot;./date/stamp&quot;, &quot;./Deferred&quot;, &quot;./has&quot;, &quot;./query&quot;, &quot;./on&quot;, &quot;./ready&quot;
], function(require, dojo, dlang, darray, config, dom, dwindow, _Url, aspect, all, dates, Deferred, has, query, don, ready){

	// module:
	//		dojo/parser

	new Date(&quot;X&quot;); // workaround for #11279, new Date(&quot;&quot;) == NaN

	// data-dojo-props etc. is not restricted to JSON, it can be any javascript
	function myEval(text){
		return eval(&quot;(&quot; + text + &quot;)&quot;);
	}

	// Widgets like BorderContainer add properties to _Widget via dojo.extend().
	// If BorderContainer is loaded after _Widget&#039;s parameter list has been cached,
	// we need to refresh that parameter list (for _Widget and all widgets that extend _Widget).
	var extendCnt = 0;
	aspect.after(dlang, &quot;extend&quot;, function(){
		extendCnt++;
	}, true);

	function getNameMap(ctor){
		// summary:
		//		Returns map from lowercase name to attribute name in class, ex: {onclick: &quot;onClick&quot;}
		var map = ctor._nameCaseMap, proto = ctor.prototype;

		// Create the map if it&#039;s undefined.
		// Refresh the map if a superclass was possibly extended with new methods since the map was created.
		if(!map || map._extendCnt &lt; extendCnt){
			map = ctor._nameCaseMap = {};
			for(var name in proto){
				if(name.charAt(0) === &quot;_&quot;){
					continue;
				}	// skip internal properties
				map[name.toLowerCase()] = name;
			}
			map._extendCnt = extendCnt;
		}
		return map;
	}

	function getCtor(/*String[]*/ types, /*Function?*/ contextRequire){
		// summary:
		//		Retrieves a constructor.  If the types array contains more than one class/MID then the
		//		subsequent classes will be mixed into the first class and a unique constructor will be
		//		returned for that array.

		if(!contextRequire){
			contextRequire = require;
		}

		// Map from widget name or list of widget names(ex: &quot;dijit/form/Button,acme/MyMixin&quot;) to a constructor.
		// Keep separate map for each requireContext to avoid false matches (ex: &quot;./Foo&quot; can mean different things
		// depending on context.)
		var ctorMap = contextRequire._dojoParserCtorMap || (contextRequire._dojoParserCtorMap = {});

		var ts = types.join();
		if(!ctorMap[ts]){
			var mixins = [];
			for(var i = 0, l = types.length; i &lt; l; i++){
				var t = types[i];
				// TODO: Consider swapping getObject and require in the future
				mixins[mixins.length] = (ctorMap[t] = ctorMap[t] || (dlang.getObject(t) || (~t.indexOf(&#039;/&#039;) &amp;&amp;
					contextRequire(t))));
			}
			var ctor = mixins.shift();
			ctorMap[ts] = mixins.length ? (ctor.createSubclass ? ctor.createSubclass(mixins) : ctor.extend.apply(ctor, mixins)) : ctor;
		}

		return ctorMap[ts];
	}

	var parser = {
		// summary:
		//		The Dom/Widget parsing package

		_clearCache: function(){
			// summary:
			//		Clear cached data.   Used mainly for benchmarking.
			extendCnt++;
			_ctorMap = {};
		},

		_functionFromScript: function(script, attrData){
			// summary:
			//		Convert a `&lt;script type=&quot;dojo/method&quot; args=&quot;a, b, c&quot;&gt; ... &lt;/script&gt;`
			//		into a function
			// script: DOMNode
			//		The `&lt;script&gt;` DOMNode
			// attrData: String
			//		For HTML5 compliance, searches for attrData + &quot;args&quot; (typically
			//		&quot;data-dojo-args&quot;) instead of &quot;args&quot;
			var preamble = &quot;&quot;,
				suffix = &quot;&quot;,
				argsStr = (script.getAttribute(attrData + &quot;args&quot;) || script.getAttribute(&quot;args&quot;)),
				withStr = script.getAttribute(&quot;with&quot;);

			// Convert any arguments supplied in script tag into an array to be passed to the
			var fnArgs = (argsStr || &quot;&quot;).split(/\s*,\s*/);

			if(withStr &amp;&amp; withStr.length){
				darray.forEach(withStr.split(/\s*,\s*/), function(part){
					preamble += &quot;with(&quot; + part + &quot;){&quot;;
					suffix += &quot;}&quot;;
				});
			}

			return new Function(fnArgs, preamble + script.innerHTML + suffix);
		},

		instantiate: function(nodes, mixin, options){
			// summary:
			//		Takes array of nodes, and turns them into class instances and
			//		potentially calls a startup method to allow them to connect with
			//		any children.
			// nodes: Array
			//		Array of DOM nodes
			// mixin: Object?
			//		An object that will be mixed in with each node in the array.
			//		Values in the mixin will override values in the node, if they
			//		exist.
			// options: Object?
			//		An object used to hold kwArgs for instantiation.
			//		See parse.options argument for details.
			// returns:
			//		Array of instances.

			mixin = mixin || {};
			options = options || {};

			var dojoType = (options.scope || dojo._scopeName) + &quot;Type&quot;, // typically &quot;dojoType&quot;
				attrData = &quot;data-&quot; + (options.scope || dojo._scopeName) + &quot;-&quot;, // typically &quot;data-dojo-&quot;
				dataDojoType = attrData + &quot;type&quot;, // typically &quot;data-dojo-type&quot;
				dataDojoMixins = attrData + &quot;mixins&quot;;					// typically &quot;data-dojo-mixins&quot;

			var list = [];
			darray.forEach(nodes, function(node){
				var type = dojoType in mixin ? mixin[dojoType] : node.getAttribute(dataDojoType) || node.getAttribute(dojoType);
				if(type){
					var mixinsValue = node.getAttribute(dataDojoMixins),
						types = mixinsValue ? [type].concat(mixinsValue.split(/\s*,\s*/)) : [type];

					list.push({
						node: node,
						types: types
					});
				}
			});

			// Instantiate the nodes and return the list of instances.
			return this._instantiate(list, mixin, options);
		},

		_instantiate: function(nodes, mixin, options, returnPromise){
			// summary:
			//		Takes array of objects representing nodes, and turns them into class instances and
			//		potentially calls a startup method to allow them to connect with
			//		any children.
			// nodes: Array
			//		Array of objects like
			//	|		{
			//	|			ctor: Function (may be null)
			//	|			types: [&quot;dijit/form/Button&quot;, &quot;acme/MyMixin&quot;] (used if ctor not specified)
			//	|			node: DOMNode,
			//	|			scripts: [ ... ],	// array of &lt;script type=&quot;dojo/...&quot;&gt; children of node
			//	|			inherited: { ... }	// settings inherited from ancestors like dir, theme, etc.
			//	|		}
			// mixin: Object
			//		An object that will be mixed in with each node in the array.
			//		Values in the mixin will override values in the node, if they
			//		exist.
			// options: Object
			//		An options object used to hold kwArgs for instantiation.
			//		See parse.options argument for details.
			// returnPromise: Boolean
			//		Return a Promise rather than the instance; supports asynchronous widget creation.
			// returns:
			//		Array of instances, or if returnPromise is true, a promise for array of instances
			//		that resolves when instances have finished initializing.

			// Call widget constructors.   Some may be asynchronous and return promises.
			var thelist = darray.map(nodes, function(obj){
				var ctor = obj.ctor || getCtor(obj.types, options.contextRequire);
				// If we still haven&#039;t resolved a ctor, it is fatal now
				if(!ctor){
					throw new Error(&quot;Unable to resolve constructor for: &#039;&quot; + obj.types.join() + &quot;&#039;&quot;);
				}
				return this.construct(ctor, obj.node, mixin, options, obj.scripts, obj.inherited);
			}, this);

			// After all widget construction finishes, call startup on each top level instance if it makes sense (as for
			// widgets).  Parent widgets will recursively call startup on their (non-top level) children
			function onConstruct(thelist){
				if(!mixin._started &amp;&amp; !options.noStart){
					darray.forEach(thelist, function(instance){
						if(typeof instance.startup === &quot;function&quot; &amp;&amp; !instance._started){
							instance.startup();
						}
					});
				}

				return thelist;
			}

			if(returnPromise){
				return all(thelist).then(onConstruct);
			}else{
				// Back-compat path, remove for 2.0
				return onConstruct(thelist);
			}
		},

		construct: function(ctor, node, mixin, options, scripts, inherited){
			// summary:
			//		Calls new ctor(params, node), where params is the hash of parameters specified on the node,
			//		excluding data-dojo-type and data-dojo-mixins.   Does not call startup().
			// ctor: Function
			//		Widget constructor.
			// node: DOMNode
			//		This node will be replaced/attached to by the widget.  It also specifies the arguments to pass to ctor.
			// mixin: Object?
			//		Attributes in this object will be passed as parameters to ctor,
			//		overriding attributes specified on the node.
			// options: Object?
			//		An options object used to hold kwArgs for instantiation.   See parse.options argument for details.
			// scripts: DomNode[]?
			//		Array of `&lt;script type=&quot;dojo/*&quot;&gt;` DOMNodes.  If not specified, will search for `&lt;script&gt;` tags inside node.
			// inherited: Object?
			//		Settings from dir=rtl or lang=... on a node above this node.   Overrides options.inherited.
			// returns:
			//		Instance or Promise for the instance, if markupFactory() itself returned a promise

			var proto = ctor &amp;&amp; ctor.prototype;
			options = options || {};

			// Setup hash to hold parameter settings for this widget.	Start with the parameter
			// settings inherited from ancestors (&quot;dir&quot; and &quot;lang&quot;).
			// Inherited setting may later be overridden by explicit settings on node itself.
			var params = {};

			if(options.defaults){
				// settings for the document itself (or whatever subtree is being parsed)
				dlang.mixin(params, options.defaults);
			}
			if(inherited){
				// settings from dir=rtl or lang=... on a node above this node
				dlang.mixin(params, inherited);
			}

			// Get list of attributes explicitly listed in the markup
			var attributes;
			if(has(&quot;dom-attributes-explicit&quot;)){
				// Standard path to get list of user specified attributes
				attributes = node.attributes;
			}else if(has(&quot;dom-attributes-specified-flag&quot;)){
				// Special processing needed for IE8, to skip a few faux values in attributes[]
				attributes = darray.filter(node.attributes, function(a){
					return a.specified;
				});
			}else{
				// Special path for IE6-7, avoid (sometimes &gt;100) bogus entries in node.attributes
				var clone = /^input$|^img$/i.test(node.nodeName) ? node : node.cloneNode(false),
					attrs = clone.outerHTML.replace(/=[^\s&quot;&#039;]+|=&quot;[^&quot;]*&quot;|=&#039;[^&#039;]*&#039;/g, &quot;&quot;).replace(/^\s*&lt;[a-zA-Z0-9]*\s*/, &quot;&quot;).replace(/\s*&gt;.*$/, &quot;&quot;);

				attributes = darray.map(attrs.split(/\s+/), function(name){
					var lcName = name.toLowerCase();
					return {
						name: name,
						// getAttribute() doesn&#039;t work for button.value, returns innerHTML of button.
						// but getAttributeNode().value doesn&#039;t work for the form.encType or li.value
						value: (node.nodeName == &quot;LI&quot; &amp;&amp; name == &quot;value&quot;) || lcName == &quot;enctype&quot; ?
							node.getAttribute(lcName) : node.getAttributeNode(lcName).value
					};
				});
			}

			// Hash to convert scoped attribute name (ex: data-dojo17-params) to something friendly (ex: data-dojo-params)
			// TODO: remove scope for 2.0
			var scope = options.scope || dojo._scopeName,
				attrData = &quot;data-&quot; + scope + &quot;-&quot;, // typically &quot;data-dojo-&quot;
				hash = {};
			if(scope !== &quot;dojo&quot;){
				hash[attrData + &quot;props&quot;] = &quot;data-dojo-props&quot;;
				hash[attrData + &quot;type&quot;] = &quot;data-dojo-type&quot;;
				hash[attrData + &quot;mixins&quot;] = &quot;data-dojo-mixins&quot;;
				hash[scope + &quot;type&quot;] = &quot;dojotype&quot;;
				hash[attrData + &quot;id&quot;] = &quot;data-dojo-id&quot;;
			}

			// Read in attributes and process them, including data-dojo-props, data-dojo-type,
			// dojoAttachPoint, etc., as well as normal foo=bar attributes.
			var i = 0, item, funcAttrs = [], jsname, extra;
			while(item = attributes[i++]){
				var name = item.name,
					lcName = name.toLowerCase(),
					value = item.value;

				switch(hash[lcName] || lcName){
				// Already processed, just ignore
				case &quot;data-dojo-type&quot;:
				case &quot;dojotype&quot;:
				case &quot;data-dojo-mixins&quot;:
					break;

				// Data-dojo-props.   Save for later to make sure it overrides direct foo=bar settings
				case &quot;data-dojo-props&quot;:
					extra = value;
					break;

				// data-dojo-id or jsId. TODO: drop jsId in 2.0
				case &quot;data-dojo-id&quot;:
				case &quot;jsid&quot;:
					jsname = value;
					break;

				// For the benefit of _Templated
				case &quot;data-dojo-attach-point&quot;:
				case &quot;dojoattachpoint&quot;:
					params.dojoAttachPoint = value;
					break;
				case &quot;data-dojo-attach-event&quot;:
				case &quot;dojoattachevent&quot;:
					params.dojoAttachEvent = value;
					break;

				// Special parameter handling needed for IE
				case &quot;class&quot;:
					params[&quot;class&quot;] = node.className;
					break;
				case &quot;style&quot;:
					params[&quot;style&quot;] = node.style &amp;&amp; node.style.cssText;
					break;
				default:
					// Normal attribute, ex: value=&quot;123&quot;

					// Find attribute in widget corresponding to specified name.
					// May involve case conversion, ex: onclick --&gt; onClick
					if(!(name in proto)){
						var map = getNameMap(ctor);
						name = map[lcName] || name;
					}

					// Set params[name] to value, doing type conversion
					if(name in proto){
						switch(typeof proto[name]){
						case &quot;string&quot;:
							params[name] = value;
							break;
						case &quot;number&quot;:
							params[name] = value.length ? Number(value) : NaN;
							break;
						case &quot;boolean&quot;:
							// for checked/disabled value might be &quot;&quot; or &quot;checked&quot;.	 interpret as true.
							params[name] = value.toLowerCase() != &quot;false&quot;;
							break;
						case &quot;function&quot;:
							if(value === &quot;&quot; || value.search(/[^\w\.]+/i) != -1){
								// The user has specified some text for a function like &quot;return x+5&quot;
								params[name] = new Function(value);
							}else{
								// The user has specified the name of a global function like &quot;myOnClick&quot;
								// or a single word function &quot;return&quot;
								params[name] = dlang.getObject(value, false) || new Function(value);
							}
							funcAttrs.push(name);	// prevent &quot;double connect&quot;, see #15026
							break;
						default:
							var pVal = proto[name];
							params[name] =
								(pVal &amp;&amp; &quot;length&quot; in pVal) ? (value ? value.split(/\s*,\s*/) : []) :	// array
									(pVal instanceof Date) ?
										(value == &quot;&quot; ? new Date(&quot;&quot;) :	// the NaN of dates
										value == &quot;now&quot; ? new Date() :	// current date
										dates.fromISOString(value)) :
								(pVal instanceof _Url) ? (dojo.baseUrl + value) :
								myEval(value);
						}
					}else{
						params[name] = value;
					}
				}
			}

			// Remove function attributes from DOMNode to prevent &quot;double connect&quot; problem, see #15026.
			// Do this as a separate loop since attributes[] is often a live collection (depends on the browser though).
			for(var j = 0; j &lt; funcAttrs.length; j++){
				var lcfname = funcAttrs[j].toLowerCase();
				node.removeAttribute(lcfname);
				node[lcfname] = null;
			}

			// Mix things found in data-dojo-props into the params, overriding any direct settings
			if(extra){
				try{
					extra = myEval.call(options.propsThis, &quot;{&quot; + extra + &quot;}&quot;);
					dlang.mixin(params, extra);
				}catch(e){
					// give the user a pointer to their invalid parameters. FIXME: can we kill this in production?
					throw new Error(e.toString() + &quot; in data-dojo-props=&#039;&quot; + extra + &quot;&#039;&quot;);
				}
			}

			// Any parameters specified in &quot;mixin&quot; override everything else.
			dlang.mixin(params, mixin);

			// Get &lt;script&gt; nodes associated with this widget, if they weren&#039;t specified explicitly
			if(!scripts){
				scripts = (ctor &amp;&amp; (ctor._noScript || proto._noScript) ? [] : query(&quot;&gt; script[type^=&#039;dojo/&#039;]&quot;, node));
			}

			// Process &lt;script type=&quot;dojo/*&quot;&gt; script tags
			// &lt;script type=&quot;dojo/method&quot; data-dojo-event=&quot;foo&quot;&gt; tags are added to params, and passed to
			// the widget on instantiation.
			// &lt;script type=&quot;dojo/method&quot;&gt; tags (with no event) are executed after instantiation
			// &lt;script type=&quot;dojo/connect&quot; data-dojo-event=&quot;foo&quot;&gt; tags are dojo.connected after instantiation,
			// and likewise with &lt;script type=&quot;dojo/aspect&quot; data-dojo-method=&quot;foo&quot;&gt;
			// &lt;script type=&quot;dojo/watch&quot; data-dojo-prop=&quot;foo&quot;&gt; tags are dojo.watch after instantiation
			// &lt;script type=&quot;dojo/on&quot; data-dojo-event=&quot;foo&quot;&gt; tags are dojo.on after instantiation
			// note: dojo/* script tags cannot exist in self closing widgets, like &lt;input /&gt;
			var aspects = [],	// aspects to connect after instantiation
				calls = [],		// functions to call after instantiation
				watches = [],  // functions to watch after instantiation
				ons = []; // functions to on after instantiation

			if(scripts){
				for(i = 0; i &lt; scripts.length; i++){
					var script = scripts[i];
					node.removeChild(script);
					// FIXME: drop event=&quot;&quot; support in 2.0. use data-dojo-event=&quot;&quot; instead
					var event = (script.getAttribute(attrData + &quot;event&quot;) || script.getAttribute(&quot;event&quot;)),
						prop = script.getAttribute(attrData + &quot;prop&quot;),
						method = script.getAttribute(attrData + &quot;method&quot;),
						advice = script.getAttribute(attrData + &quot;advice&quot;),
						scriptType = script.getAttribute(&quot;type&quot;),
						nf = this._functionFromScript(script, attrData);
					if(event){
						if(scriptType == &quot;dojo/connect&quot;){
							aspects.push({ method: event, func: nf });
						}else if(scriptType == &quot;dojo/on&quot;){
							ons.push({ event: event, func: nf });
						}else{
							// &lt;script type=&quot;dojo/method&quot; data-dojo-event=&quot;foo&quot;&gt;
							// TODO for 2.0: use data-dojo-method=&quot;foo&quot; instead (also affects dijit/Declaration)
							params[event] = nf;
						}
					}else if(scriptType == &quot;dojo/aspect&quot;){
						aspects.push({ method: method, advice: advice, func: nf });
					}else if(scriptType == &quot;dojo/watch&quot;){
						watches.push({ prop: prop, func: nf });
					}else{
						calls.push(nf);
					}
				}
			}

			// create the instance
			var markupFactory = ctor.markupFactory || proto.markupFactory;
			var instance = markupFactory ? markupFactory(params, node, ctor) : new ctor(params, node);

			function onInstantiate(instance){
				// map it to the JS namespace if that makes sense
				if(jsname){
					dlang.setObject(jsname, instance);
				}

				// process connections and startup functions
				for(i = 0; i &lt; aspects.length; i++){
					aspect[aspects[i].advice || &quot;after&quot;](instance, aspects[i].method, dlang.hitch(instance, aspects[i].func), true);
				}
				for(i = 0; i &lt; calls.length; i++){
					calls[i].call(instance);
				}
				for(i = 0; i &lt; watches.length; i++){
					instance.watch(watches[i].prop, watches[i].func);
				}
				for(i = 0; i &lt; ons.length; i++){
					don(instance, ons[i].event, ons[i].func);
				}

				return instance;
			}

			if(instance.then){
				return instance.then(onInstantiate);
			}else{
				return onInstantiate(instance);
			}
		},

		scan: function(root, options){
			// summary:
			//		Scan a DOM tree and return an array of objects representing the DOMNodes
			//		that need to be turned into widgets.
			// description:
			//		Search specified node (or document root node) recursively for class instances
			//		and return an array of objects that represent potential widgets to be
			//		instantiated. Searches for either data-dojo-type=&quot;MID&quot; or dojoType=&quot;MID&quot; where
			//		&quot;MID&quot; is a module ID like &quot;dijit/form/Button&quot; or a fully qualified Class name
			//		like &quot;dijit/form/Button&quot;.  If the MID is not currently available, scan will
			//		attempt to require() in the module.
			//
			//		See parser.parse() for details of markup.
			// root: DomNode?
			//		A default starting root node from which to start the parsing. Can be
			//		omitted, defaulting to the entire document. If omitted, the `options`
			//		object can be passed in this place. If the `options` object has a
			//		`rootNode` member, that is used.
			// options: Object
			//		a kwArgs options object, see parse() for details
			//
			// returns: Promise
			//		A promise that is resolved with the nodes that have been parsed.

			var list = [], // Output List
				mids = [], // An array of modules that are not yet loaded
				midsHash = {}; // Used to keep the mids array unique

			var dojoType = (options.scope || dojo._scopeName) + &quot;Type&quot;, // typically &quot;dojoType&quot;
				attrData = &quot;data-&quot; + (options.scope || dojo._scopeName) + &quot;-&quot;, // typically &quot;data-dojo-&quot;
				dataDojoType = attrData + &quot;type&quot;, // typically &quot;data-dojo-type&quot;
				dataDojoTextDir = attrData + &quot;textdir&quot;, // typically &quot;data-dojo-textdir&quot;
				dataDojoMixins = attrData + &quot;mixins&quot;;					// typically &quot;data-dojo-mixins&quot;

			// Info on DOMNode currently being processed
			var node = root.firstChild;

			// Info on parent of DOMNode currently being processed
			//	- inherited: dir, lang, and textDir setting of parent, or inherited by parent
			//	- parent: pointer to identical structure for my parent (or null if no parent)
			//	- scripts: if specified, collects &lt;script type=&quot;dojo/...&quot;&gt; type nodes from children
			var inherited = options.inherited;
			if(!inherited){
				function findAncestorAttr(node, attr){
					return (node.getAttribute &amp;&amp; node.getAttribute(attr)) ||
						(node.parentNode &amp;&amp; findAncestorAttr(node.parentNode, attr));
				}

				inherited = {
					dir: findAncestorAttr(root, &quot;dir&quot;),
					lang: findAncestorAttr(root, &quot;lang&quot;),
					textDir: findAncestorAttr(root, dataDojoTextDir)
				};
				for(var key in inherited){
					if(!inherited[key]){
						delete inherited[key];
					}
				}
			}

			// Metadata about parent node
			var parent = {
				inherited: inherited
			};

			// For collecting &lt;script type=&quot;dojo/...&quot;&gt; type nodes (when null, we don&#039;t need to collect)
			var scripts;

			// when true, only look for &lt;script type=&quot;dojo/...&quot;&gt; tags, and don&#039;t recurse to children
			var scriptsOnly;

			function getEffective(parent){
				// summary:
				//		Get effective dir, lang, textDir settings for specified obj
				//		(matching &quot;parent&quot; object structure above), and do caching.
				//		Take care not to return null entries.
				if(!parent.inherited){
					parent.inherited = {};
					var node = parent.node,
						grandparent = getEffective(parent.parent);
					var inherited = {
						dir: node.getAttribute(&quot;dir&quot;) || grandparent.dir,
						lang: node.getAttribute(&quot;lang&quot;) || grandparent.lang,
						textDir: node.getAttribute(dataDojoTextDir) || grandparent.textDir
					};
					for(var key in inherited){
						if(inherited[key]){
							parent.inherited[key] = inherited[key];
						}
					}
				}
				return parent.inherited;
			}

			// DFS on DOM tree, collecting nodes with data-dojo-type specified.
			while(true){
				if(!node){
					// Finished this level, continue to parent&#039;s next sibling
					if(!parent || !parent.node){
						break;
					}
					node = parent.node.nextSibling;
					scriptsOnly = false;
					parent = parent.parent;
					scripts = parent.scripts;
					continue;
				}

				if(node.nodeType != 1){
					// Text or comment node, skip to next sibling
					node = node.nextSibling;
					continue;
				}

				if(scripts &amp;&amp; node.nodeName.toLowerCase() == &quot;script&quot;){
					// Save &lt;script type=&quot;dojo/...&quot;&gt; for parent, then continue to next sibling
					type = node.getAttribute(&quot;type&quot;);
					if(type &amp;&amp; /^dojo\/\w/i.test(type)){
						scripts.push(node);
					}
					node = node.nextSibling;
					continue;
				}
				if(scriptsOnly){
					// scriptsOnly flag is set, we have already collected scripts if the parent wants them, so now we shouldn&#039;t
					// continue further analysis of the node and will continue to the next sibling
					node = node.nextSibling;
					continue;
				}

				// Check for data-dojo-type attribute, fallback to backward compatible dojoType
				// TODO: Remove dojoType in 2.0
				var type = node.getAttribute(dataDojoType) || node.getAttribute(dojoType);

				// Short circuit for leaf nodes containing nothing [but text]
				var firstChild = node.firstChild;
				if(!type &amp;&amp; (!firstChild || (firstChild.nodeType == 3 &amp;&amp; !firstChild.nextSibling))){
					node = node.nextSibling;
					continue;
				}

				// Meta data about current node
				var current;

				var ctor = null;
				if(type){
					// If dojoType/data-dojo-type specified, add to output array of nodes to instantiate.
					var mixinsValue = node.getAttribute(dataDojoMixins),
						types = mixinsValue ? [type].concat(mixinsValue.split(/\s*,\s*/)) : [type];

					// Note: won&#039;t find classes declared via dojo/Declaration or any modules that haven&#039;t been
					// loaded yet so use try/catch to avoid throw from require()
					try{
						ctor = getCtor(types, options.contextRequire);
					}catch(e){}

					// If the constructor was not found, check to see if it has modules that can be loaded
					if(!ctor){
						darray.forEach(types, function(t){
							if(~t.indexOf(&#039;/&#039;) &amp;&amp; !midsHash[t]){
								// If the type looks like a MID and it currently isn&#039;t in the array of MIDs to load, add it.
								midsHash[t] = true;
								mids[mids.length] = t;
							}
						});
					}

					var childScripts = ctor &amp;&amp; !ctor.prototype._noScript ? [] : null; // &lt;script&gt; nodes that are parent&#039;s children

					// Setup meta data about this widget node, and save it to list of nodes to instantiate
					current = {
						types: types,
						ctor: ctor,
						parent: parent,
						node: node,
						scripts: childScripts
					};
					current.inherited = getEffective(current); // dir &amp; lang settings for current node, explicit or inherited
					list.push(current);
				}else{
					// Meta data about this non-widget node
					current = {
						node: node,
						scripts: scripts,
						parent: parent
					};
				}

				// Recurse, collecting &lt;script type=&quot;dojo/...&quot;&gt; children, and also looking for
				// descendant nodes with dojoType specified (unless the widget has the stopParser flag).
				// When finished with children, go to my next sibling.
				scripts = childScripts;
				scriptsOnly = node.stopParser || (ctor &amp;&amp; ctor.prototype.stopParser &amp;&amp; !(options.template));
				parent = current;
				node = firstChild;
			}

			var d = new Deferred();

			// If there are modules to load then require them in
			if(mids.length){
				// Warn that there are modules being auto-required
				if(has(&quot;dojo-debug-messages&quot;)){
					console.warn(&quot;WARNING: Modules being Auto-Required: &quot; + mids.join(&quot;, &quot;));
				}
				var r = options.contextRequire || require;
				r(mids, function(){
					// Go through list of widget nodes, filling in missing constructors, and filtering out nodes that shouldn&#039;t
					// be instantiated due to a stopParser flag on an ancestor that we belatedly learned about due to
					// auto-require of a module like ContentPane.   Assumes list is in DFS order.
					d.resolve(darray.filter(list, function(widget){
						if(!widget.ctor){
							// Attempt to find the constructor again.   Still won&#039;t find classes defined via
							// dijit/Declaration so need to try/catch.
							try{
								widget.ctor = getCtor(widget.types, options.contextRequire);
							}catch(e){}
						}

						// Get the parent widget
						var parent = widget.parent;
						while(parent &amp;&amp; !parent.types){
							parent = parent.parent;
						}

						// Return false if this node should be skipped due to stopParser on an ancestor.
						// Since list[] is in DFS order, this loop will always set parent.instantiateChildren before
						// trying to compute widget.instantiate.
						var proto = widget.ctor &amp;&amp; widget.ctor.prototype;
						widget.instantiateChildren = !(proto &amp;&amp; proto.stopParser &amp;&amp; !(options.template));
						widget.instantiate = !parent || (parent.instantiate &amp;&amp; parent.instantiateChildren);
						return widget.instantiate;
					}));
				});
			}else{
				// There were no modules to load, so just resolve with the parsed nodes.   This separate code path is for
				// efficiency, to avoid running the require() and the callback code above.
				d.resolve(list);
			}

			// Return the promise
			return d.promise;
		},

		_require: function(/*DOMNode*/ script, /*Object?*/ options){
			// summary:
			//		Helper for _scanAMD().  Takes a `&lt;script type=dojo/require&gt;bar: &quot;acme/bar&quot;, ...&lt;/script&gt;` node,
			//		calls require() to load the specified modules and (asynchronously) assign them to the specified global
			//		variables, and returns a Promise for when that operation completes.
			//
			//		In the example above, it is effectively doing a require([&quot;acme/bar&quot;, ...], function(a){ bar = a; }).

			var hash = myEval(&quot;{&quot; + script.innerHTML + &quot;}&quot;), // can&#039;t use dojo/json::parse() because maybe no quotes
				vars = [],
				mids = [],
				d = new Deferred();

			var contextRequire = (options &amp;&amp; options.contextRequire) || require;

			for(var name in hash){
				vars.push(name);
				mids.push(hash[name]);
			}

			contextRequire(mids, function(){
				for(var i = 0; i &lt; vars.length; i++){
					dlang.setObject(vars[i], arguments[i]);
				}
				d.resolve(arguments);
			});

			return d.promise;
		},

		_scanAmd: function(root, options){
			// summary:
			//		Scans the DOM for any declarative requires and returns their values.
			// description:
			//		Looks for `&lt;script type=dojo/require&gt;bar: &quot;acme/bar&quot;, ...&lt;/script&gt;` node, calls require() to load the
			//		specified modules and (asynchronously) assign them to the specified global variables,
			//		and returns a Promise for when those operations complete.
			// root: DomNode
			//		The node to base the scan from.
			// options: Object?
			//		a kwArgs options object, see parse() for details

			// Promise that resolves when all the &lt;script type=dojo/require&gt; nodes have finished loading.
			var deferred = new Deferred(),
				promise = deferred.promise;
			deferred.resolve(true);

			var self = this;
			query(&quot;script[type=&#039;dojo/require&#039;]&quot;, root).forEach(function(node){
				// Fire off require() call for specified modules.  Chain this require to fire after
				// any previous requires complete, so that layers can be loaded before individual module require()&#039;s fire.
				promise = promise.then(function(){
					return self._require(node, options);
				});

				// Remove from DOM so it isn&#039;t seen again
				node.parentNode.removeChild(node);
			});

			return promise;
		},

		parse: function(rootNode, options){
			// summary:
			//		Scan the DOM for class instances, and instantiate them.
			// description:
			//		Search specified node (or root node) recursively for class instances,
			//		and instantiate them. Searches for either data-dojo-type=&quot;Class&quot; or
			//		dojoType=&quot;Class&quot; where &quot;Class&quot; is a a fully qualified class name,
			//		like `dijit/form/Button`
			//
			//		Using `data-dojo-type`:
			//		Attributes using can be mixed into the parameters used to instantiate the
			//		Class by using a `data-dojo-props` attribute on the node being converted.
			//		`data-dojo-props` should be a string attribute to be converted from JSON.
			//
			//		Using `dojoType`:
			//		Attributes are read from the original domNode and converted to appropriate
			//		types by looking up the Class prototype values. This is the default behavior
			//		from Dojo 1.0 to Dojo 1.5. `dojoType` support is deprecated, and will
			//		go away in Dojo 2.0.
			// rootNode: DomNode?
			//		A default starting root node from which to start the parsing. Can be
			//		omitted, defaulting to the entire document. If omitted, the `options`
			//		object can be passed in this place. If the `options` object has a
			//		`rootNode` member, that is used.
			// options: Object?
			//		A hash of options.
			//
			//		- noStart: Boolean?:
			//			when set will prevent the parser from calling .startup()
			//			when locating the nodes.
			//		- rootNode: DomNode?:
			//			identical to the function&#039;s `rootNode` argument, though
			//			allowed to be passed in via this `options object.
			//		- template: Boolean:
			//			If true, ignores ContentPane&#039;s stopParser flag and parses contents inside of
			//			a ContentPane inside of a template.   This allows dojoAttachPoint on widgets/nodes
			//			nested inside the ContentPane to work.
			//		- inherited: Object:
			//			Hash possibly containing dir and lang settings to be applied to
			//			parsed widgets, unless there&#039;s another setting on a sub-node that overrides
			//		- scope: String:
			//			Root for attribute names to search for.   If scopeName is dojo,
			//			will search for data-dojo-type (or dojoType).   For backwards compatibility
			//			reasons defaults to dojo._scopeName (which is &quot;dojo&quot; except when
			//			multi-version support is used, when it will be something like dojo16, dojo20, etc.)
			//		- propsThis: Object:
			//			If specified, &quot;this&quot; referenced from data-dojo-props will refer to propsThis.
			//			Intended for use from the widgets-in-template feature of `dijit._WidgetsInTemplateMixin`
			//		- contextRequire: Function:
			//			If specified, this require is utilised for looking resolving modules instead of the
			//			`dojo/parser` context `require()`.  Intended for use from the widgets-in-template feature of
			//			`dijit._WidgetsInTemplateMixin`.
			// returns: Mixed
			//		Returns a blended object that is an array of the instantiated objects, but also can include
			//		a promise that is resolved with the instantiated objects.  This is done for backwards
			//		compatibility.  If the parser auto-requires modules, it will always behave in a promise
			//		fashion and `parser.parse().then(function(instances){...})` should be used.
			// example:
			//		Parse all widgets on a page:
			//	|		parser.parse();
			// example:
			//		Parse all classes within the node with id=&quot;foo&quot;
			//	|		parser.parse(dojo.byId(&#039;foo&#039;));
			// example:
			//		Parse all classes in a page, but do not call .startup() on any
			//		child
			//	|		parser.parse({ noStart: true })
			// example:
			//		Parse all classes in a node, but do not call .startup()
			//	|		parser.parse(someNode, { noStart:true });
			//	|		// or
			//	|		parser.parse({ noStart:true, rootNode: someNode });

			// determine the root node and options based on the passed arguments.
			var root;
			if(!options &amp;&amp; rootNode &amp;&amp; rootNode.rootNode){
				options = rootNode;
				root = options.rootNode;
			}else if(rootNode &amp;&amp; dlang.isObject(rootNode) &amp;&amp; !(&quot;nodeType&quot; in rootNode)){
				options = rootNode;
			}else{
				root = rootNode;
			}
			root = root ? dom.byId(root) : dwindow.body();

			options = options || {};

			var mixin = options.template ? { template: true } : {},
				instances = [],
				self = this;

			// First scan for any &lt;script type=dojo/require&gt; nodes, and execute.
			// Then scan for all nodes with data-dojo-type, and load any unloaded modules.
			// Then build the object instances.  Add instances to already existing (but empty) instances[] array,
			// which may already have been returned to caller.  Also, use otherwise to collect and throw any errors
			// that occur during the parse().
			var p =
				this._scanAmd(root, options).then(function(){
					return self.scan(root, options);
				}).then(function(parsedNodes){
					return self._instantiate(parsedNodes, mixin, options, true);
				}).then(function(_instances){
					// Copy the instances into the instances[] array we declared above, and are accessing as
					// our return value.
					return instances = instances.concat(_instances);
				}).otherwise(function(e){
					// TODO Modify to follow better pattern for promise error management when available
					console.error(&quot;dojo/parser::parse() error&quot;, e);
					throw e;
				});

			// Blend the array with the promise
			dlang.mixin(instances, p);
			return instances;
		}
	};

	if(has(&quot;extend-dojo&quot;)){
		dojo.parser = parser;
	}

	// Register the parser callback. It should be the first callback
	// after the a11y test.
	if(config.parseOnLoad){
		ready(100, parser, &quot;parse&quot;);
	}

	return parser;
});</textarea>
  </div>
</div>

<footer class="footer">
  <div class="container">
    <p>.</p>
  </div>
</footer>

<script type="text/html" id="complexity-popover-template">
  <div class="complexity-notice">
    Complexity : {{ complexity.cyclomatic }} <br>
    Length : {{ complexity.halstead.length }} <br>
    Difficulty : {{ complexity.halstead.difficulty.toFixed(2) }} <br>
    Est # bugs : {{ complexity.halstead.bugs.toFixed(2) }}<br>
  </div>
</script>

<script type="text/javascript" src="../../assets/scripts/bundles/core-bundle.js"></script>
<script type="text/javascript" src="../../assets/scripts/bundles/codemirror.js"></script>
<script type="text/javascript" src="../../assets/scripts/codemirror.markpopovertext.js"></script>
<script type="text/javascript" src="report.js"></script>
<script type="text/javascript" src="report.history.js"></script>
<script type="text/javascript" src="../../assets/scripts/plato-file.js"></script>
</body>
</html>
