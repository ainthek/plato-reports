<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Plato - src/dojo/dojo.js</title>

  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="">
  <meta name="author" content="">

  <!--[if lt IE 9]>
  <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->

  <link href="../../assets/css/vendor/morris.css" rel="stylesheet">
  <link href="../../assets/css/vendor/bootstrap.css" rel="stylesheet">
  <link href="../../assets/css/vendor/font-awesome.css" rel="stylesheet">
  <link href="../../assets/css/vendor/codemirror.css" rel="stylesheet">
  <link href="../../assets/css/plato.css" rel="stylesheet">
  <link href="../../assets/css/plato-file.css" rel="stylesheet">

</head>

<body>

<div class="navbar navbar-fixed-top">
  <div class="container">
    <a class="navbar-brand" href="http://github.com/es-analysis/plato">Plato on Github</a>
    <ul class="nav navbar-nav">
      <li>
        <a href="../../index.html">Report Home</a>
      </li>
    </ul>
  </div>
</div>

<div class="jumbotron">
  <div class="container">
    <h1>src/dojo/dojo.js</h1>
  </div>
</div>

<div class="container aggregate-stats">
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Maintainability <a href="http://blogs.msdn.com/b/codeanalysis/archive/2007/11/20/maintainability-index-range-and-meaning.aspx"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="A value between 0 and 100 that represents the relative ease of maintaining the code. A high value means better maintainability." data-original-title="Maintainability Index"  data-container="body"></i></a></h2>
      <p class="stat">59.49</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Lines of code <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h2>
      <p class="stat">2025</p>
    </div>
  </div>
  <div class="row historical">
    <div class="col-md-6">
      <p id="chart_historical_maint" class="chart"></p>
    </div>
    <div class="col-md-6">
      <p id="chart_historical_sloc" class="chart"></p>
    </div>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Difficulty  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="The difficulty measure is related to the difficulty of the program to write or understand." data-original-title="Difficulty" data-container="body"></i></a></h2>
      <p class="stat">127.55</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Estimated Errors  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Halstead's delivered bugs is an estimate for the number of errors in the implementation." data-original-title="Delivered Bugs" data-container="body"></i></a></h2>
      <p class="stat">19.56</p>
    </div>
  </div>
</div>

<div class="container charts">
  <div class="row">
    <h2 class="header">Function weight</h2>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h3 class="chart-header">By Complexity <a href="http://en.wikipedia.org/wiki/Cyclomatic_complexity"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="This metric counts the number of distinct paths through a block of code. Lower values are better." data-original-title="Cyclomatic Complexity" data-container="body"></i></a></h3>
      <div id="fn-by-complexity" class="stat"></div>
    </div>
    <div class="col-md-6">
      <h3 class="chart-header">By SLOC  <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h3>
      <div id="fn-by-sloc" class="stat"></div>
    </div>
  </div>
</div>

<div class="container">
  <div class="row">
    <textarea id="file-source" class="col-md-12">(function(
	userConfig,
	defaultConfig
){
	// summary:
	//		This is the &quot;source loader&quot; and is the entry point for Dojo during development. You may also load Dojo with
	//		any AMD-compliant loader via the package main module dojo/main.
	// description:
	//		This is the &quot;source loader&quot; for Dojo. It provides an AMD-compliant loader that can be configured
	//		to operate in either synchronous or asynchronous modes. After the loader is defined, dojo is loaded
	//		IAW the package main module dojo/main. In the event you wish to use a foreign loader, you may load dojo as a package
	//		via the package main module dojo/main and this loader is not required; see dojo/package.json for details.
	//
	//		In order to keep compatibility with the v1.x line, this loader includes additional machinery that enables
	//		the dojo.provide, dojo.require et al API. This machinery is loaded by default, but may be dynamically removed
	//		via the has.js API and statically removed via the build system.
	//
	//		This loader includes sniffing machinery to determine the environment; the following environments are supported:
	//
	//		- browser
	//		- node.js
	//		- rhino
	//
	//		This is the so-called &quot;source loader&quot;. As such, it includes many optional features that may be discarded by
	//		building a customized version with the build system.

	// Design and Implementation Notes
	//
	// This is a dojo-specific adaption of bdLoad, donated to the dojo foundation by Altoviso LLC.
	//
	// This function defines an AMD-compliant (http://wiki.commonjs.org/wiki/Modules/AsynchronousDefinition)
	// loader that can be configured to operate in either synchronous or asynchronous modes.
	//
	// Since this machinery implements a loader, it does not have the luxury of using a load system and/or
	// leveraging a utility library. This results in an unpleasantly long file; here is a road map of the contents:
	//
	//	 1. Small library for use implementing the loader.
	//	 2. Define the has.js API; this is used throughout the loader to bracket features.
	//	 3. Define the node.js and rhino sniffs and sniff.
	//	 4. Define the loader&#039;s data.
	//	 5. Define the configuration machinery.
	//	 6. Define the script element sniffing machinery and sniff for configuration data.
	//	 7. Configure the loader IAW the provided user, default, and sniffing data.
	//	 8. Define the global require function.
	//	 9. Define the module resolution machinery.
	//	10. Define the module and plugin module definition machinery
	//	11. Define the script injection machinery.
	//	12. Define the window load detection.
	//	13. Define the logging API.
	//	14. Define the tracing API.
	//	16. Define the AMD define function.
	//	17. Define the dojo v1.x provide/require machinery--so called &quot;legacy&quot; modes.
	//	18. Publish global variables.
	//
	// Language and Acronyms and Idioms
	//
	// moduleId: a CJS module identifier, (used for public APIs)
	// mid: moduleId (used internally)
	// packageId: a package identifier (used for public APIs)
	// pid: packageId (used internally); the implied system or default package has pid===&quot;&quot;
	// pack: package is used internally to reference a package object (since javascript has reserved words including &quot;package&quot;)
	// prid: plugin resource identifier
	// The integer constant 1 is used in place of true and 0 in place of false.

	// define a minimal library to help build the loader
	var	noop = function(){
		},

		isEmpty = function(it){
			for(var p in it){
				return 0;
			}
			return 1;
		},

		toString = {}.toString,

		isFunction = function(it){
			return toString.call(it) == &quot;[object Function]&quot;;
		},

		isString = function(it){
			return toString.call(it) == &quot;[object String]&quot;;
		},

		isArray = function(it){
			return toString.call(it) == &quot;[object Array]&quot;;
		},

		forEach = function(vector, callback){
			if(vector){
				for(var i = 0; i &lt; vector.length;){
					callback(vector[i++]);
				}
			}
		},

		mix = function(dest, src){
			for(var p in src){
				dest[p] = src[p];
			}
			return dest;
		},

		makeError = function(error, info){
			return mix(new Error(error), {src:&quot;dojoLoader&quot;, info:info});
		},

		uidSeed = 1,

		uid = function(){
			// Returns a unique identifier (within the lifetime of the document) of the form /_d+/.
			return &quot;_&quot; + uidSeed++;
		},

		// FIXME: how to doc window.require() api

		// this will be the global require function; define it immediately so we can start hanging things off of it
		req = function(
			config,		  //(object, optional) hash of configuration properties
			dependencies, //(array of commonjs.moduleId, optional) list of modules to be loaded before applying callback
			callback	  //(function, optional) lambda expression to apply to module values implied by dependencies
		){
			return contextRequire(config, dependencies, callback, 0, req);
		},

		// the loader uses the has.js API to control feature inclusion/exclusion; define then use throughout
		global = this,

		doc = global.document,

		element = doc &amp;&amp; doc.createElement(&quot;DiV&quot;),

		has = req.has = function(name){
			return isFunction(hasCache[name]) ? (hasCache[name] = hasCache[name](global, doc, element)) : hasCache[name];
		},

		hasCache = has.cache = defaultConfig.hasCache;

	has.add = function(name, test, now, force){
		(hasCache[name]===undefined || force) &amp;&amp; (hasCache[name] = test);
		return now &amp;&amp; has(name);
	};

	has.add(&quot;host-node&quot;, userConfig.has &amp;&amp; &quot;host-node&quot; in userConfig.has ?
		userConfig.has[&quot;host-node&quot;] :
		(typeof process == &quot;object&quot; &amp;&amp; process.versions &amp;&amp; process.versions.node &amp;&amp; process.versions.v8));
	if(has(&quot;host-node&quot;)){
		// fixup the default config for node.js environment
		require(&quot;./_base/configNode.js&quot;).config(defaultConfig);
		// remember node&#039;s require (with respect to baseUrl==dojo&#039;s root)
		defaultConfig.loaderPatch.nodeRequire = require;
	}

	has.add(&quot;host-rhino&quot;, userConfig.has &amp;&amp; &quot;host-rhino&quot; in userConfig.has ?
		userConfig.has[&quot;host-rhino&quot;] :
		(typeof load == &quot;function&quot; &amp;&amp; (typeof Packages == &quot;function&quot; || typeof Packages == &quot;object&quot;)));
	if(has(&quot;host-rhino&quot;)){
		// owing to rhino&#039;s lame feature that hides the source of the script, give the user a way to specify the baseUrl...
		for(var baseUrl = userConfig.baseUrl || &quot;.&quot;, arg, rhinoArgs = this.arguments, i = 0; i &lt; rhinoArgs.length;){
			arg = (rhinoArgs[i++] + &quot;&quot;).split(&quot;=&quot;);
			if(arg[0] == &quot;baseUrl&quot;){
				baseUrl = arg[1];
				break;
			}
		}
		load(baseUrl + &quot;/_base/configRhino.js&quot;);
		rhinoDojoConfig(defaultConfig, baseUrl, rhinoArgs);
	}

	has.add(&quot;host-webworker&quot;, ((typeof WorkerGlobalScope !== &#039;undefined&#039;) &amp;&amp; (self instanceof WorkerGlobalScope)));
	if(has(&quot;host-webworker&quot;)){
		mix(defaultConfig.hasCache, {
			&quot;host-browser&quot;: 0,
			&quot;dom&quot;: 0,
			&quot;dojo-dom-ready-api&quot;: 0,
			&quot;dojo-sniff&quot;: 0,
			&quot;dojo-inject-api&quot;: 1,
			&quot;host-webworker&quot;: 1
		});

		defaultConfig.loaderPatch = {
			injectUrl: function(url, callback){
				// TODO:
				//		This is not async, nor can it be in Webworkers.  It could be made better by passing
				//		the entire require array into importScripts at.  This way the scripts are loaded in
				//		async mode; even if the callbacks are ran in sync.  It is not a major issue as webworkers
				//		tend to be long running where initial startup is not a major factor.

				try{
					importScripts(url);
					callback();
				}catch(e){
					console.info(&quot;failed to load resource (&quot; + url + &quot;)&quot;);
					console.error(e);
				}
			}
		};
	}

	// userConfig has tests override defaultConfig has tests; do this after the environment detection because
	// the environment detection usually sets some has feature values in the hasCache.
	for(var p in userConfig.has){
		has.add(p, userConfig.has[p], 0, 1);
	}

	//
	// define the loader data
	//

	// the loader will use these like symbols if the loader has the traceApi; otherwise
	// define magic numbers so that modules can be provided as part of defaultConfig
	var	requested = 1,
		arrived = 2,
		nonmodule = 3,
		executing = 4,
		executed = 5;

	if(has(&quot;dojo-trace-api&quot;)){
		// these make debugging nice; but using strings for symbols is a gross rookie error; don&#039;t do it for production code
		requested = &quot;requested&quot;;
		arrived = &quot;arrived&quot;;
		nonmodule = &quot;not-a-module&quot;;
		executing = &quot;executing&quot;;
		executed = &quot;executed&quot;;
	}

	var legacyMode = 0,
		sync = &quot;sync&quot;,
		xd = &quot;xd&quot;,
		syncExecStack = [],
		dojoRequirePlugin = 0,
		checkDojoRequirePlugin = noop,
		transformToAmd = noop,
		getXhr;
	if(has(&quot;dojo-sync-loader&quot;)){
		req.isXdUrl = noop;

		req.initSyncLoader = function(dojoRequirePlugin_, checkDojoRequirePlugin_, transformToAmd_){
			// the first dojo/_base/loader loaded gets to define these variables; they are designed to work
			// in the presence of zero to many mapped dojo/_base/loaders
			if(!dojoRequirePlugin){
				dojoRequirePlugin = dojoRequirePlugin_;
				checkDojoRequirePlugin = checkDojoRequirePlugin_;
				transformToAmd = transformToAmd_;
			}

			return {
				sync:sync,
				requested:requested,
				arrived:arrived,
				nonmodule:nonmodule,
				executing:executing,
				executed:executed,
				syncExecStack:syncExecStack,
				modules:modules,
				execQ:execQ,
				getModule:getModule,
				injectModule:injectModule,
				setArrived:setArrived,
				signal:signal,
				finishExec:finishExec,
				execModule:execModule,
				dojoRequirePlugin:dojoRequirePlugin,
				getLegacyMode:function(){return legacyMode;},
				guardCheckComplete:guardCheckComplete
			};
		};

		if(has(&quot;dom&quot;) || has(&quot;host-webworker&quot;)){
			// in legacy sync mode, the loader needs a minimal XHR library

			var locationProtocol = location.protocol,
				locationHost = location.host;
			req.isXdUrl = function(url){
				if(/^\./.test(url)){
					// begins with a dot is always relative to page URL; therefore not xdomain
					return false;
				}
				if(/^\/\//.test(url)){
					// for v1.6- backcompat, url starting with // indicates xdomain
					return true;
				}
				// get protocol and host
				// \/+ takes care of the typical file protocol that looks like file:///drive/path/to/file
				// locationHost is falsy if file protocol =&gt; if locationProtocol matches and is &quot;file:&quot;, || will return false
				var match = url.match(/^([^\/\:]+\:)\/+([^\/]+)/);
				return match &amp;&amp; (match[1] != locationProtocol || (locationHost &amp;&amp; match[2] != locationHost));
			};


			// note: to get the file:// protocol to work in FF, you must set security.fileuri.strict_origin_policy to false in about:config
			has.add(&quot;dojo-xhr-factory&quot;, 1);
			has.add(&quot;dojo-force-activex-xhr&quot;, has(&quot;host-browser&quot;) &amp;&amp; !doc.addEventListener &amp;&amp; window.location.protocol == &quot;file:&quot;);
			has.add(&quot;native-xhr&quot;, typeof XMLHttpRequest != &quot;undefined&quot;);
			if(has(&quot;native-xhr&quot;) &amp;&amp; !has(&quot;dojo-force-activex-xhr&quot;)){
				getXhr = function(){
					return new XMLHttpRequest();
				};
			}else{
				// if in the browser an old IE; find an xhr
				for(var XMLHTTP_PROGIDS = [&#039;Msxml2.XMLHTTP&#039;, &#039;Microsoft.XMLHTTP&#039;, &#039;Msxml2.XMLHTTP.4.0&#039;], progid, i = 0; i &lt; 3;){
					try{
						progid = XMLHTTP_PROGIDS[i++];
						if(new ActiveXObject(progid)){
							// this progid works; therefore, use it from now on
							break;
						}
					}catch(e){
						// squelch; we&#039;re just trying to find a good ActiveX progid
						// if they all fail, then progid ends up as the last attempt and that will signal the error
						// the first time the client actually tries to exec an xhr
					}
				}
				getXhr = function(){
					return new ActiveXObject(progid);
				};
			}
			req.getXhr = getXhr;

			has.add(&quot;dojo-gettext-api&quot;, 1);
			req.getText = function(url, async, onLoad){
				var xhr = getXhr();
				xhr.open(&#039;GET&#039;, fixupUrl(url), false);
				xhr.send(null);
				if(xhr.status == 200 || (!location.host &amp;&amp; !xhr.status)){
					if(onLoad){
						onLoad(xhr.responseText, async);
					}
				}else{
					throw makeError(&quot;xhrFailed&quot;, xhr.status);
				}
				return xhr.responseText;
			};
		}
	}else{
		req.async = 1;
	}

	//
	// loader eval
	//
	var eval_ =
		// use the function constructor so our eval is scoped close to (but not in) in the global space with minimal pollution
		new Function(&#039;return eval(arguments[0]);&#039;);

	req.eval =
		function(text, hint){
			return eval_(text + &quot;\r\n//# sourceURL=&quot; + hint);
		};

	//
	// loader micro events API
	//
	var listenerQueues = {},
		error = &quot;error&quot;,
		signal = req.signal = function(type, args){
			var queue = listenerQueues[type];
			// notice we run a copy of the queue; this allows listeners to add/remove
			// other listeners without affecting this particular signal
			forEach(queue &amp;&amp; queue.slice(0), function(listener){
				listener.apply(null, isArray(args) ? args : [args]);
			});
		},
		on = req.on = function(type, listener){
			// notice a queue is not created until a client actually connects
			var queue = listenerQueues[type] || (listenerQueues[type] = []);
			queue.push(listener);
			return {
				remove:function(){
					for(var i = 0; i&lt;queue.length; i++){
						if(queue[i]===listener){
							queue.splice(i, 1);
							return;
						}
					}
				}
			};
		};

	// configuration machinery; with an optimized/built defaultConfig, all configuration machinery can be discarded
	// lexical variables hold key loader data structures to help with minification; these may be completely,
	// one-time initialized by defaultConfig for optimized/built versions
	var
		aliases
			// a vector of pairs of [regexs or string, replacement] =&gt; (alias, actual)
			= [],

		paths
			// CommonJS paths
			= {},

		pathsMapProg
			// list of (from-path, to-path, regex, length) derived from paths;
			// a &quot;program&quot; to apply paths; see computeMapProg
			= [],

		packs
			// a map from packageId to package configuration object; see fixupPackageInfo
			= {},

		map = req.map
			// AMD map config variable; dojo/_base/kernel needs req.map to figure out the scope map
			= {},

		mapProgs
			// vector of quads as described by computeMapProg; map-key is AMD map key, map-value is AMD map value
			= [],

		modules
			// A hash:(mid) --&gt; (module-object) the module namespace
			//
			// pid: the package identifier to which the module belongs (e.g., &quot;dojo&quot;); &quot;&quot; indicates the system or default package
			// mid: the fully-resolved (i.e., mappings have been applied) module identifier without the package identifier (e.g., &quot;dojo/io/script&quot;)
			// url: the URL from which the module was retrieved
			// pack: the package object of the package to which the module belongs
			// executed: 0 =&gt; not executed; executing =&gt; in the process of traversing deps and running factory; executed =&gt; factory has been executed
			// deps: the dependency vector for this module (vector of modules objects)
			// def: the factory for this module
			// result: the result of the running the factory for this module
			// injected: (0 | requested | arrived) the status of the module; nonmodule means the resource did not call define
			// load: plugin load function; applicable only for plugins
			//
			// Modules go through several phases in creation:
			//
			// 1. Requested: some other module&#039;s definition or a require application contained the requested module in
			//	  its dependency vector or executing code explicitly demands a module via req.require.
			//
			// 2. Injected: a script element has been appended to the insert-point element demanding the resource implied by the URL
			//
			// 3. Loaded: the resource injected in [2] has been evaluated.
			//
			// 4. Defined: the resource contained a define statement that advised the loader about the module. Notice that some
			//	  resources may just contain a bundle of code and never formally define a module via define
			//
			// 5. Evaluated: the module was defined via define and the loader has evaluated the factory and computed a result.
			= {},

		cacheBust
			// query string to append to module URLs to bust browser cache
			= &quot;&quot;,

		cache
			// hash:(mid | url)--&gt;(function | string)
			//
			// A cache of resources. The resources arrive via a config.cache object, which is a hash from either mid --&gt; function or
			// url --&gt; string. The url key is distinguished from the mid key by always containing the prefix &quot;url:&quot;. url keys as provided
			// by config.cache always have a string value that represents the contents of the resource at the given url. mid keys as provided
			// by configl.cache always have a function value that causes the same code to execute as if the module was script injected.
			//
			// Both kinds of key-value pairs are entered into cache via the function consumePendingCache, which may relocate keys as given
			// by any mappings *iff* the config.cache was received as part of a module resource request.
			//
			// Further, for mid keys, the implied url is computed and the value is entered into that key as well. This allows mapped modules
			// to retrieve cached items that may have arrived consequent to another namespace.
			//
			 = {},

		urlKeyPrefix
			// the prefix to prepend to a URL key in the cache.
			= &quot;url:&quot;,

		pendingCacheInsert
			// hash:(mid)--&gt;(function)
			//
			// Gives a set of cache modules pending entry into cache. When cached modules are published to the loader, they are
			// entered into pendingCacheInsert; modules are then pressed into cache upon (1) AMD define or (2) upon receiving another
			// independent set of cached modules. (1) is the usual case, and this case allows normalizing mids given in the pending
			// cache for the local configuration, possibly relocating modules.
			 = {},

		dojoSniffConfig
			// map of configuration variables
			// give the data-dojo-config as sniffed from the document (if any)
			= {},

		insertPointSibling
			// the nodes used to locate where scripts are injected into the document
			= 0;

	if(has(&quot;dojo-config-api&quot;)){
		var consumePendingCacheInsert = function(referenceModule){
				var p, item, match, now, m;
				for(p in pendingCacheInsert){
					item = pendingCacheInsert[p];
					match = p.match(/^url\:(.+)/);
					if(match){
						cache[urlKeyPrefix + toUrl(match[1], referenceModule)] =  item;
					}else if(p==&quot;*now&quot;){
						now = item;
					}else if(p!=&quot;*noref&quot;){
						m = getModuleInfo(p, referenceModule, true);
						cache[m.mid] = cache[urlKeyPrefix + m.url] = item;
					}
				}
				if(now){
					now(createRequire(referenceModule));
				}
				pendingCacheInsert = {};
			},

			escapeString = function(s){
				return s.replace(/([\.$?*|{}\(\)\[\]\\\/\+^])/g, function(c){ return &quot;\\&quot; + c; });
			},

			computeMapProg = function(map, dest){
				// This routine takes a map as represented by a JavaScript object and initializes dest, a vector of
				// quads of (map-key, map-value, refex-for-map-key, length-of-map-key), sorted decreasing by length-
				// of-map-key. The regex looks for the map-key followed by either &quot;/&quot; or end-of-string at the beginning
				// of a the search source. Notice the map-value is irrelevant to the algorithm
				dest.splice(0, dest.length);
				for(var p in map){
					dest.push([
						p,
						map[p],
						new RegExp(&quot;^&quot; + escapeString(p) + &quot;(\/|$)&quot;),
						p.length]);
				}
				dest.sort(function(lhs, rhs){ return rhs[3] - lhs[3]; });
				return dest;
			},

			computeAliases = function(config, dest){
				forEach(config, function(pair){
					// take a fixed-up copy...
					dest.push([isString(pair[0]) ? new RegExp(&quot;^&quot; + escapeString(pair[0]) + &quot;$&quot;) : pair[0], pair[1]]);
				});
			},


			fixupPackageInfo = function(packageInfo){
				// calculate the precise (name, location, main, mappings) for a package
				var name = packageInfo.name;
				if(!name){
					// packageInfo must be a string that gives the name
					name = packageInfo;
					packageInfo = {name:name};
				}
				packageInfo = mix({main:&quot;main&quot;}, packageInfo);
				packageInfo.location = packageInfo.location ? packageInfo.location : name;

				// packageMap is deprecated in favor of AMD map
				if(packageInfo.packageMap){
					map[name] = packageInfo.packageMap;
				}

				if(!packageInfo.main.indexOf(&quot;./&quot;)){
					packageInfo.main = packageInfo.main.substring(2);
				}

				// now that we&#039;ve got a fully-resolved package object, push it into the configuration
				packs[name] = packageInfo;
			},

			delayedModuleConfig
				// module config cannot be consumed until the loader is completely initialized; therefore, all
				// module config detected during booting is memorized and applied at the end of loader initialization
				// TODO: this is a bit of a kludge; all config should be moved to end of loader initialization, but
				// we&#039;ll delay this chore and do it with a final loader 1.x cleanup after the 2.x loader prototyping is complete
				= [],


			config = function(config, booting, referenceModule){
				for(var p in config){
					if(p==&quot;waitSeconds&quot;){
						req.waitms = (config[p] || 0) * 1000;
					}
					if(p==&quot;cacheBust&quot;){
						cacheBust = config[p] ? (isString(config[p]) ? config[p] : (new Date()).getTime() + &quot;&quot;) : &quot;&quot;;
					}
					if(p==&quot;baseUrl&quot; || p==&quot;combo&quot;){
						req[p] = config[p];
					}
					if(has(&quot;dojo-sync-loader&quot;) &amp;&amp; p==&quot;async&quot;){
						// falsy or &quot;sync&quot; =&gt; legacy sync loader
						// &quot;xd&quot; =&gt; sync but loading xdomain tree and therefore loading asynchronously (not configurable, set automatically by the loader)
						// &quot;legacyAsync&quot; =&gt; permanently in &quot;xd&quot; by choice
						// &quot;debugAtAllCosts&quot; =&gt; trying to load everything via script injection (not implemented)
						// otherwise, must be truthy =&gt; AMD
						// legacyMode: sync | legacyAsync | xd | false
						var mode = config[p];
						req.legacyMode = legacyMode = (isString(mode) &amp;&amp; /sync|legacyAsync/.test(mode) ? mode : (!mode ? sync : false));
						req.async = !legacyMode;
					}
					if(config[p]!==hasCache){
						// accumulate raw config info for client apps which can use this to pass their own config
						req.rawConfig[p] = config[p];
						p!=&quot;has&quot; &amp;&amp; has.add(&quot;config-&quot;+p, config[p], 0, booting);
					}
				}

				// make sure baseUrl exists
				if(!req.baseUrl){
					req.baseUrl = &quot;./&quot;;
				}
				// make sure baseUrl ends with a slash
				if(!/\/$/.test(req.baseUrl)){
					req.baseUrl += &quot;/&quot;;
				}

				// now do the special work for has, packages, packagePaths, paths, aliases, and cache

				for(p in config.has){
					has.add(p, config.has[p], 0, booting);
				}

				// for each package found in any packages config item, augment the packs map owned by the loader
				forEach(config.packages, fixupPackageInfo);

				// for each packagePath found in any packagePaths config item, augment the packageConfig
				// packagePaths is deprecated; remove in 2.0
				for(var baseUrl in config.packagePaths){
					forEach(config.packagePaths[baseUrl], function(packageInfo){
						var location = baseUrl + &quot;/&quot; + packageInfo;
						if(isString(packageInfo)){
							packageInfo = {name:packageInfo};
						}
						packageInfo.location = location;
						fixupPackageInfo(packageInfo);
					});
				}

				// notice that computeMapProg treats the dest as a reference; therefore, if/when that variable
				// is published (see dojo-publish-privates), the published variable will always hold a valid value.

				// this must come after all package processing since package processing may mutate map
				computeMapProg(mix(map, config.map), mapProgs);
				forEach(mapProgs, function(item){
					item[1] = computeMapProg(item[1], []);
					if(item[0]==&quot;*&quot;){
						mapProgs.star = item;
					}
				});

				// push in any paths and recompute the internal pathmap
				computeMapProg(mix(paths, config.paths), pathsMapProg);

				// aliases
				computeAliases(config.aliases, aliases);

				if(booting){
					delayedModuleConfig.push({config:config.config});
				}else{
					for(p in config.config){
						var module = getModule(p, referenceModule);
						module.config = mix(module.config || {}, config.config[p]);
					}
				}

				// push in any new cache values
				if(config.cache){
					consumePendingCacheInsert();
					pendingCacheInsert = config.cache;
					if(config.cache[&quot;*noref&quot;]){
						consumePendingCacheInsert();
					}
				}

				signal(&quot;config&quot;, [config, req.rawConfig]);
			};

		//
		// execute the various sniffs; userConfig can override and value
		//

		if(has(&quot;dojo-cdn&quot;) || has(&quot;dojo-sniff&quot;)){
			// the sniff regex looks for a src attribute ending in dojo.js, optionally preceded with a path.
			// match[3] returns the path to dojo.js (if any) without the trailing slash. This is used for the
			// dojo location on CDN deployments and baseUrl when either/both of these are not provided
			// explicitly in the config data; this is the 1.6- behavior.

			var scripts = doc.getElementsByTagName(&quot;script&quot;),
				i = 0,
				script, dojoDir, src, match;
			while(i &lt; scripts.length){
				script = scripts[i++];
				if((src = script.getAttribute(&quot;src&quot;)) &amp;&amp; (match = src.match(/(((.*)\/)|^)dojo\.js(\W|$)/i))){
					// sniff dojoDir and baseUrl
					dojoDir = match[3] || &quot;&quot;;
					defaultConfig.baseUrl = defaultConfig.baseUrl || dojoDir;

					// remember an insertPointSibling
					insertPointSibling = script;
				}

				// sniff configuration on attribute in script element
				if((src = (script.getAttribute(&quot;data-dojo-config&quot;) || script.getAttribute(&quot;djConfig&quot;)))){
					dojoSniffConfig = req.eval(&quot;({ &quot; + src + &quot; })&quot;, &quot;data-dojo-config&quot;);

					// remember an insertPointSibling
					insertPointSibling = script;
				}

				// sniff requirejs attribute
				if(has(&quot;dojo-requirejs-api&quot;)){
					if((src = script.getAttribute(&quot;data-main&quot;))){
						dojoSniffConfig.deps = dojoSniffConfig.deps || [src];
					}
				}
			}
		}

		if(has(&quot;dojo-test-sniff&quot;)){
			// pass down doh.testConfig from parent as if it were a data-dojo-config
			try{
				if(window.parent != window &amp;&amp; window.parent.require){
					var doh = window.parent.require(&quot;doh&quot;);
					doh &amp;&amp; mix(dojoSniffConfig, doh.testConfig);
				}
			}catch(e){}
		}

		// configure the loader; let the user override defaults
		req.rawConfig = {};
		config(defaultConfig, 1);

		// do this before setting userConfig/sniffConfig to allow userConfig/sniff overrides
		if(has(&quot;dojo-cdn&quot;)){
			packs.dojo.location = dojoDir;
			if(dojoDir){
				dojoDir += &quot;/&quot;;
			}
			packs.dijit.location = dojoDir + &quot;../dijit/&quot;;
			packs.dojox.location = dojoDir + &quot;../dojox/&quot;;
		}

		config(userConfig, 1);
		config(dojoSniffConfig, 1);

	}else{
		// no config API, assume defaultConfig has everything the loader needs...for the entire lifetime of the application
		paths = defaultConfig.paths;
		pathsMapProg = defaultConfig.pathsMapProg;
		packs = defaultConfig.packs;
		aliases = defaultConfig.aliases;
		mapProgs = defaultConfig.mapProgs;
		modules = defaultConfig.modules;
		cache = defaultConfig.cache;
		cacheBust = defaultConfig.cacheBust;

		// remember the default config for other processes (e.g., dojo/config)
		req.rawConfig = defaultConfig;
	}


	if(has(&quot;dojo-combo-api&quot;)){
		req.combo = req.combo || {add:noop};
		var	comboPending = 0,
			combosPending = [],
			comboPendingTimer = null;
	}


	// build the loader machinery iaw configuration, including has feature tests
	var	injectDependencies = function(module){
			// checkComplete!=0 holds the idle signal; we&#039;re not idle if we&#039;re injecting dependencies
			guardCheckComplete(function(){
				forEach(module.deps, injectModule);
				if(has(&quot;dojo-combo-api&quot;) &amp;&amp; comboPending &amp;&amp; !comboPendingTimer){
					comboPendingTimer = setTimeout(function() {
						comboPending = 0;
						comboPendingTimer = null;
						req.combo.done(function(mids, url) {
							var onLoadCallback= function(){
								// defQ is a vector of module definitions 1-to-1, onto mids
								runDefQ(0, mids);
								checkComplete();
							};
							combosPending.push(mids);
							injectingModule = mids;
							req.injectUrl(url, onLoadCallback, mids);
							injectingModule = 0;
						}, req);
					}, 0);
				}
			});
		},

		contextRequire = function(a1, a2, a3, referenceModule, contextRequire){
			var module, syntheticMid;
			if(isString(a1)){
				// signature is (moduleId)
				module = getModule(a1, referenceModule, true);
				if(module &amp;&amp; module.executed){
					return module.result;
				}
				throw makeError(&quot;undefinedModule&quot;, a1);
			}
			if(!isArray(a1)){
				// a1 is a configuration
				config(a1, 0, referenceModule);

				// juggle args; (a2, a3) may be (dependencies, callback)
				a1 = a2;
				a2 = a3;
			}
			if(isArray(a1)){
				// signature is (requestList [,callback])
				if(!a1.length){
					a2 &amp;&amp; a2();
				}else{
					syntheticMid = &quot;require*&quot; + uid();

					// resolve the request list with respect to the reference module
					for(var mid, deps = [], i = 0; i &lt; a1.length;){
						mid = a1[i++];
						deps.push(getModule(mid, referenceModule));
					}

					// construct a synthetic module to control execution of the requestList, and, optionally, callback
					module = mix(makeModuleInfo(&quot;&quot;, syntheticMid, 0, &quot;&quot;), {
						injected: arrived,
						deps: deps,
						def: a2 || noop,
						require: referenceModule ? referenceModule.require : req,
						gc: 1 //garbage collect
					});
					modules[module.mid] = module;

					// checkComplete!=0 holds the idle signal; we&#039;re not idle if we&#039;re injecting dependencies
					injectDependencies(module);

					// try to immediately execute
					// if already traversing a factory tree, then strict causes circular dependency to abort the execution; maybe
					// it&#039;s possible to execute this require later after the current traversal completes and avoid the circular dependency.
					// ...but *always* insist on immediate in synch mode
					var strict = checkCompleteGuard &amp;&amp; legacyMode!=sync;
					guardCheckComplete(function(){
						execModule(module, strict);
					});
					if(!module.executed){
						// some deps weren&#039;t on board or circular dependency detected and strict; therefore, push into the execQ
						execQ.push(module);
					}
					checkComplete();
				}
			}
			return contextRequire;
		},

		createRequire = function(module){
			if(!module){
				return req;
			}
			var result = module.require;
			if(!result){
				result = function(a1, a2, a3){
					return contextRequire(a1, a2, a3, module, result);
				};
				module.require = mix(result, req);
				result.module = module;
				result.toUrl = function(name){
					return toUrl(name, module);
				};
				result.toAbsMid = function(mid){
					return toAbsMid(mid, module);
				};
				if(has(&quot;dojo-undef-api&quot;)){
					result.undef = function(mid){
						req.undef(mid, module);
					};
				}
				if(has(&quot;dojo-sync-loader&quot;)){
					result.syncLoadNls = function(mid){
						var nlsModuleInfo = getModuleInfo(mid, module),
							nlsModule = modules[nlsModuleInfo.mid];
						if(!nlsModule || !nlsModule.executed){
							cached = cache[nlsModuleInfo.mid] || cache[urlKeyPrefix + nlsModuleInfo.url];
							if(cached){
								evalModuleText(cached);
								nlsModule = modules[nlsModuleInfo.mid];
							}
						}
						return nlsModule &amp;&amp; nlsModule.executed &amp;&amp; nlsModule.result;
					};
				}

			}
			return result;
		},

		execQ =
			// The list of modules that need to be evaluated.
			[],

		defQ =
			// The queue of define arguments sent to loader.
			[],

		waiting =
			// The set of modules upon which the loader is waiting for definition to arrive
			{},

		setRequested = function(module){
			module.injected = requested;
			waiting[module.mid] = 1;
			if(module.url){
				waiting[module.url] = module.pack || 1;
			}
			startTimer();
		},

		setArrived = function(module){
			module.injected = arrived;
			delete waiting[module.mid];
			if(module.url){
				delete waiting[module.url];
			}
			if(isEmpty(waiting)){
				clearTimer();
				has(&quot;dojo-sync-loader&quot;) &amp;&amp; legacyMode==xd &amp;&amp; (legacyMode = sync);
			}
		},

		execComplete = req.idle =
			// says the loader has completed (or not) its work
			function(){
				return !defQ.length &amp;&amp; isEmpty(waiting) &amp;&amp; !execQ.length &amp;&amp; !checkCompleteGuard;
			},

		runMapProg = function(targetMid, map){
			// search for targetMid in map; return the map item if found; falsy otherwise
			if(map){
			for(var i = 0; i &lt; map.length; i++){
				if(map[i][2].test(targetMid)){
					return map[i];
				}
			}
			}
			return 0;
		},

		compactPath = function(path){
			var result = [],
				segment, lastSegment;
			path = path.replace(/\\/g, &#039;/&#039;).split(&#039;/&#039;);
			while(path.length){
				segment = path.shift();
				if(segment==&quot;..&quot; &amp;&amp; result.length &amp;&amp; lastSegment!=&quot;..&quot;){
					result.pop();
					lastSegment = result[result.length - 1];
				}else if(segment!=&quot;.&quot;){
					result.push(lastSegment= segment);
				} // else ignore &quot;.&quot;
			}
			return result.join(&quot;/&quot;);
		},

		makeModuleInfo = function(pid, mid, pack, url){
			if(has(&quot;dojo-sync-loader&quot;)){
				var xd= req.isXdUrl(url);
				return {pid:pid, mid:mid, pack:pack, url:url, executed:0, def:0, isXd:xd, isAmd:!!(xd || (packs[pid] &amp;&amp; packs[pid].isAmd))};
			}else{
				return {pid:pid, mid:mid, pack:pack, url:url, executed:0, def:0};
			}
		},

		getModuleInfo_ = function(mid, referenceModule, packs, modules, baseUrl, mapProgs, pathsMapProg, aliases, alwaysCreate){
			// arguments are passed instead of using lexical variables so that this function my be used independent of the loader (e.g., the builder)
			// alwaysCreate is useful in this case so that getModuleInfo never returns references to real modules owned by the loader
			var pid, pack, midInPackage, mapItem, url, result, isRelative, requestedMid;
			requestedMid = mid;
			isRelative = /^\./.test(mid);
			if(/(^\/)|(\:)|(\.js$)/.test(mid) || (isRelative &amp;&amp; !referenceModule)){
				// absolute path or protocol of .js filetype, or relative path but no reference module and therefore relative to page
				// whatever it is, it&#039;s not a module but just a URL of some sort
				// note: pid===0 indicates the routine is returning an unmodified mid

				return makeModuleInfo(0, mid, 0, mid);
			}else{
				// relative module ids are relative to the referenceModule; get rid of any dots
				mid = compactPath(isRelative ? (referenceModule.mid + &quot;/../&quot; + mid) : mid);
				if(/^\./.test(mid)){
					throw makeError(&quot;irrationalPath&quot;, mid);
				}
				// at this point, mid is an absolute mid

				// map the mid
				if(referenceModule){
					mapItem = runMapProg(referenceModule.mid, mapProgs);
				}
				mapItem = mapItem || mapProgs.star;
				mapItem = mapItem &amp;&amp; runMapProg(mid, mapItem[1]);

				if(mapItem){
					mid = mapItem[1] + mid.substring(mapItem[3]);
					}

				match = mid.match(/^([^\/]+)(\/(.+))?$/);
				pid = match ? match[1] : &quot;&quot;;
				if((pack = packs[pid])){
					mid = pid + &quot;/&quot; + (midInPackage = (match[3] || pack.main));
				}else{
					pid = &quot;&quot;;
				}

				// search aliases
				var candidateLength = 0,
					candidate = 0;
				forEach(aliases, function(pair){
					var match = mid.match(pair[0]);
					if(match &amp;&amp; match.length&gt;candidateLength){
						candidate = isFunction(pair[1]) ? mid.replace(pair[0], pair[1]) : pair[1];
					}
				});
				if(candidate){
					return getModuleInfo_(candidate, 0, packs, modules, baseUrl, mapProgs, pathsMapProg, aliases, alwaysCreate);
				}

				result = modules[mid];
				if(result){
					return alwaysCreate ? makeModuleInfo(result.pid, result.mid, result.pack, result.url) : modules[mid];
				}
			}
			// get here iff the sought-after module does not yet exist; therefore, we need to compute the URL given the
			// fully resolved (i.e., all relative indicators and package mapping resolved) module id

			// note: pid!==0 indicates the routine is returning a url that has .js appended unmodified mid
			mapItem = runMapProg(mid, pathsMapProg);
			if(mapItem){
				url = mapItem[1] + mid.substring(mapItem[3]);
			}else if(pid){
				url = pack.location + &quot;/&quot; + midInPackage;
			}else if(has(&quot;config-tlmSiblingOfDojo&quot;)){
				url = &quot;../&quot; + mid;
			}else{
				url = mid;
			}
			// if result is not absolute, add baseUrl
			if(!(/(^\/)|(\:)/.test(url))){
				url = baseUrl + url;
			}
			url += &quot;.js&quot;;
			return makeModuleInfo(pid, mid, pack, compactPath(url));
		},

		getModuleInfo = function(mid, referenceModule, fromPendingCache){
			return getModuleInfo_(mid, referenceModule, packs, modules, req.baseUrl, fromPendingCache ? [] : mapProgs, fromPendingCache ? [] : pathsMapProg, fromPendingCache ? [] : aliases);
		},

		resolvePluginResourceId = function(plugin, prid, referenceModule){
			return plugin.normalize ? plugin.normalize(prid, function(mid){return toAbsMid(mid, referenceModule);}) : toAbsMid(prid, referenceModule);
		},

		dynamicPluginUidGenerator = 0,

		getModule = function(mid, referenceModule, immediate){
			// compute and optionally construct (if necessary) the module implied by the mid with respect to referenceModule
			var match, plugin, prid, result;
			match = mid.match(/^(.+?)\!(.*)$/);
			if(match){
				// name was &lt;plugin-module&gt;!&lt;plugin-resource-id&gt;
				plugin = getModule(match[1], referenceModule, immediate);

				if(has(&quot;dojo-sync-loader&quot;) &amp;&amp; legacyMode == sync &amp;&amp; !plugin.executed){
					injectModule(plugin);
					if(plugin.injected===arrived &amp;&amp; !plugin.executed){
						guardCheckComplete(function(){
							execModule(plugin);
						});
					}
					if(plugin.executed){
						promoteModuleToPlugin(plugin);
					}else{
						// we are in xdomain mode for some reason
						execQ.unshift(plugin);
					}
				}



				if(plugin.executed === executed &amp;&amp; !plugin.load){
					// executed the module not knowing it was a plugin
					promoteModuleToPlugin(plugin);
				}

				// if the plugin has not been loaded, then can&#039;t resolve the prid and  must assume this plugin is dynamic until we find out otherwise
				if(plugin.load){
					prid = resolvePluginResourceId(plugin, match[2], referenceModule);
					mid = (plugin.mid + &quot;!&quot; + (plugin.dynamic ? ++dynamicPluginUidGenerator + &quot;!&quot; : &quot;&quot;) + prid);
				}else{
					prid = match[2];
					mid = plugin.mid + &quot;!&quot; + (++dynamicPluginUidGenerator) + &quot;!waitingForPlugin&quot;;
				}
				result = {plugin:plugin, mid:mid, req:createRequire(referenceModule), prid:prid};
			}else{
				result = getModuleInfo(mid, referenceModule);
			}
			return modules[result.mid] || (!immediate &amp;&amp; (modules[result.mid] = result));
		},

		toAbsMid = req.toAbsMid = function(mid, referenceModule){
			return getModuleInfo(mid, referenceModule).mid;
		},

		toUrl = req.toUrl = function(name, referenceModule){
			var moduleInfo = getModuleInfo(name+&quot;/x&quot;, referenceModule),
				url= moduleInfo.url;
			return fixupUrl(moduleInfo.pid===0 ?
				// if pid===0, then name had a protocol or absolute path; either way, toUrl is the identify function in such cases
				name :
				// &quot;/x.js&quot; since getModuleInfo automatically appends &quot;.js&quot; and we appended &quot;/x&quot; to make name look like a module id
				url.substring(0, url.length-5)
			);
		},

		nonModuleProps = {
			injected: arrived,
			executed: executed,
			def: nonmodule,
			result: nonmodule
		},

		makeCjs = function(mid){
			return modules[mid] = mix({mid:mid}, nonModuleProps);
		},

		cjsRequireModule = makeCjs(&quot;require&quot;),
		cjsExportsModule = makeCjs(&quot;exports&quot;),
		cjsModuleModule = makeCjs(&quot;module&quot;),

		runFactory = function(module, args){
			req.trace(&quot;loader-run-factory&quot;, [module.mid]);
			var factory = module.def,
				result;
			has(&quot;dojo-sync-loader&quot;) &amp;&amp; syncExecStack.unshift(module);
			if(has(&quot;config-dojo-loader-catches&quot;)){
				try{
					result= isFunction(factory) ? factory.apply(null, args) : factory;
				}catch(e){
					signal(error, module.result = makeError(&quot;factoryThrew&quot;, [module, e]));
				}
			}else{
				result= isFunction(factory) ? factory.apply(null, args) : factory;
			}
			module.result = result===undefined &amp;&amp; module.cjs ? module.cjs.exports : result;
			has(&quot;dojo-sync-loader&quot;) &amp;&amp; syncExecStack.shift(module);
		},

		abortExec = {},

		defOrder = 0,

		promoteModuleToPlugin = function(pluginModule){
			var plugin = pluginModule.result;
			pluginModule.dynamic = plugin.dynamic;
			pluginModule.normalize = plugin.normalize;
			pluginModule.load = plugin.load;
			return pluginModule;
		},

		resolvePluginLoadQ = function(plugin){
			// plugins is a newly executed module that has a loadQ waiting to run

			// step 1: traverse the loadQ and fixup the mid and prid; remember the map from original mid to new mid
			// recall the original mid was created before the plugin was on board and therefore it was impossible to
			// compute the final mid; accordingly, prid may or may not change, but the mid will definitely change
			var map = {};
			forEach(plugin.loadQ, function(pseudoPluginResource){
				// manufacture and insert the real module in modules
				var prid = resolvePluginResourceId(plugin, pseudoPluginResource.prid, pseudoPluginResource.req.module),
					mid = plugin.dynamic ? pseudoPluginResource.mid.replace(/waitingForPlugin$/, prid) : (plugin.mid + &quot;!&quot; + prid),
					pluginResource = mix(mix({}, pseudoPluginResource), {mid:mid, prid:prid, injected:0});
				if(!modules[mid]){
					// create a new (the real) plugin resource and inject it normally now that the plugin is on board
					injectPlugin(modules[mid] = pluginResource);
				} // else this was a duplicate request for the same (plugin, rid) for a nondynamic plugin

				// pluginResource is really just a placeholder with the wrong mid (because we couldn&#039;t calculate it until the plugin was on board)
				// mark is as arrived and delete it from modules; the real module was requested above
				map[pseudoPluginResource.mid] = modules[mid];
				setArrived(pseudoPluginResource);
				delete modules[pseudoPluginResource.mid];
			});
			plugin.loadQ = 0;

			// step2: replace all references to any placeholder modules with real modules
			var substituteModules = function(module){
				for(var replacement, deps = module.deps || [], i = 0; i&lt;deps.length; i++){
					replacement = map[deps[i].mid];
					if(replacement){
						deps[i] = replacement;
					}
				}
			};
			for(var p in modules){
				substituteModules(modules[p]);
			}
			forEach(execQ, substituteModules);
		},

		finishExec = function(module){
			req.trace(&quot;loader-finish-exec&quot;, [module.mid]);
			module.executed = executed;
			module.defOrder = defOrder++;
			has(&quot;dojo-sync-loader&quot;) &amp;&amp; forEach(module.provides, function(cb){ cb(); });
			if(module.loadQ){
				// the module was a plugin
				promoteModuleToPlugin(module);
				resolvePluginLoadQ(module);
			}
			// remove all occurrences of this module from the execQ
			for(i = 0; i &lt; execQ.length;){
				if(execQ[i] === module){
					execQ.splice(i, 1);
				}else{
					i++;
				}
			}
			// delete references to synthetic modules
			if (/^require\*/.test(module.mid)) {
				delete modules[module.mid];
			}
		},

		circleTrace = [],

		execModule = function(module, strict){
			// run the dependency vector, then run the factory for module
			if(module.executed === executing){
				req.trace(&quot;loader-circular-dependency&quot;, [circleTrace.concat(module.mid).join(&quot;-&gt;&quot;)]);
				return (!module.def || strict) ? abortExec :  (module.cjs &amp;&amp; module.cjs.exports);
			}
			// at this point the module is either not executed or fully executed


			if(!module.executed){
				if(!module.def){
					return abortExec;
				}
				var mid = module.mid,
					deps = module.deps || [],
					arg, argResult,
					args = [],
					i = 0;

				if(has(&quot;dojo-trace-api&quot;)){
					circleTrace.push(mid);
					req.trace(&quot;loader-exec-module&quot;, [&quot;exec&quot;, circleTrace.length, mid]);
				}

				// for circular dependencies, assume the first module encountered was executed OK
				// modules that circularly depend on a module that has not run its factory will get
				// the pre-made cjs.exports===module.result. They can take a reference to this object and/or
				// add properties to it. When the module finally runs its factory, the factory can
				// read/write/replace this object. Notice that so long as the object isn&#039;t replaced, any
				// reference taken earlier while walking the deps list is still valid.
				module.executed = executing;
				while((arg = deps[i++])){
					argResult = ((arg === cjsRequireModule) ? createRequire(module) :
									((arg === cjsExportsModule) ? module.cjs.exports :
										((arg === cjsModuleModule) ? module.cjs :
											execModule(arg, strict))));
					if(argResult === abortExec){
						module.executed = 0;
						req.trace(&quot;loader-exec-module&quot;, [&quot;abort&quot;, mid]);
						has(&quot;dojo-trace-api&quot;) &amp;&amp; circleTrace.pop();
						return abortExec;
					}
					args.push(argResult);
				}
				runFactory(module, args);
				finishExec(module);
				has(&quot;dojo-trace-api&quot;) &amp;&amp; circleTrace.pop();
			}
			// at this point the module is guaranteed fully executed

			return module.result;
		},


		checkCompleteGuard = 0,

		guardCheckComplete = function(proc){
			try{
				checkCompleteGuard++;
				proc();
			}finally{
				checkCompleteGuard--;
			}
			if(execComplete()){
				signal(&quot;idle&quot;, []);
			}
		},

		checkComplete = function(){
			// keep going through the execQ as long as at least one factory is executed
			// plugins, recursion, cached modules all make for many execution path possibilities
			if(checkCompleteGuard){
				return;
			}
			guardCheckComplete(function(){
				checkDojoRequirePlugin();
				for(var currentDefOrder, module, i = 0; i &lt; execQ.length;){
					currentDefOrder = defOrder;
					module = execQ[i];
					execModule(module);
					if(currentDefOrder!=defOrder){
						// defOrder was bumped one or more times indicating something was executed (note, this indicates
						// the execQ was modified, maybe a lot (for example a later module causes an earlier module to execute)
						checkDojoRequirePlugin();
						i = 0;
					}else{
						// nothing happened; check the next module in the exec queue
						i++;
					}
				}
			});
		};


	if(has(&quot;dojo-undef-api&quot;)){
		req.undef = function(moduleId, referenceModule){
			// In order to reload a module, it must be undefined (this routine) and then re-requested.
			// This is useful for testing frameworks (at least).
			var module = getModule(moduleId, referenceModule);
			setArrived(module);
			mix(module, {def:0, executed:0, injected:0, node:0});
		};
	}

	if(has(&quot;dojo-inject-api&quot;)){
		if(has(&quot;dojo-loader-eval-hint-url&quot;)===undefined){
			has.add(&quot;dojo-loader-eval-hint-url&quot;, 1);
		}

		var fixupUrl= typeof userConfig.fixupUrl == &quot;function&quot; ? userConfig.fixupUrl : function(url){
				url += &quot;&quot;; // make sure url is a Javascript string (some paths may be a Java string)
				return url + (cacheBust ? ((/\?/.test(url) ? &quot;&amp;&quot; : &quot;?&quot;) + cacheBust) : &quot;&quot;);
			},

			injectPlugin = function(
				module
			){
				// injects the plugin module given by module; may have to inject the plugin itself
				var plugin = module.plugin;

				if(plugin.executed === executed &amp;&amp; !plugin.load){
					// executed the module not knowing it was a plugin
					promoteModuleToPlugin(plugin);
				}

				var onLoad = function(def){
						module.result = def;
						setArrived(module);
						finishExec(module);
						checkComplete();
					};

				if(plugin.load){
					plugin.load(module.prid, module.req, onLoad);
				}else if(plugin.loadQ){
					plugin.loadQ.push(module);
				}else{
					// the unshift instead of push is important: we don&#039;t want plugins to execute as
					// dependencies of some other module because this may cause circles when the plugin
					// loadQ is run; also, generally, we want plugins to run early since they may load
					// several other modules and therefore can potentially unblock many modules
					plugin.loadQ = [module];
					execQ.unshift(plugin);
					injectModule(plugin);
				}
			},

			// for IE, injecting a module may result in a recursive execution if the module is in the cache

			cached = 0,

			injectingModule = 0,

			injectingCachedModule = 0,

			evalModuleText = function(text, module){
				// see def() for the injectingCachedModule bracket; it simply causes a short, safe circuit
				if(has(&quot;config-stripStrict&quot;)){
					text = text.replace(/&quot;use strict&quot;/g, &#039;&#039;);
				}
				injectingCachedModule = 1;
				if(has(&quot;config-dojo-loader-catches&quot;)){
					try{
						if(text===cached){
							cached.call(null);
						}else{
							req.eval(text, has(&quot;dojo-loader-eval-hint-url&quot;) ? module.url : module.mid);
						}
					}catch(e){
						signal(error, makeError(&quot;evalModuleThrew&quot;, module));
					}
				}else{
					if(text===cached){
						cached.call(null);
					}else{
						req.eval(text, has(&quot;dojo-loader-eval-hint-url&quot;) ? module.url : module.mid);
					}
				}
				injectingCachedModule = 0;
			},

			injectModule = function(module){
				// Inject the module. In the browser environment, this means appending a script element into
				// the document; in other environments, it means loading a file.
				//
				// If in synchronous mode, then get the module synchronously if it&#039;s not xdomainLoading.

				var mid = module.mid,
					url = module.url;
				if(module.executed || module.injected || waiting[mid] || (module.url &amp;&amp; ((module.pack &amp;&amp; waiting[module.url]===module.pack) || waiting[module.url]==1))){
					return;
				}
				setRequested(module);

				if(has(&quot;dojo-combo-api&quot;)){
					var viaCombo = 0;
					if(module.plugin &amp;&amp; module.plugin.isCombo){
						// a combo plugin; therefore, must be handled by combo service
						// the prid should have already been converted to a URL (if required by the plugin) during
						// the normalize process; in any event, there is no way for the loader to know how to
						// to the conversion; therefore the third argument is zero
						req.combo.add(module.plugin.mid, module.prid, 0, req);
						viaCombo = 1;
					}else if(!module.plugin){
						viaCombo = req.combo.add(0, module.mid, module.url, req);
					}
					if(viaCombo){
						comboPending= 1;
						return;
					}
				}

				if(module.plugin){
					injectPlugin(module);
					return;
				} // else a normal module (not a plugin)


				var onLoadCallback = function(){
					runDefQ(module);
					if(module.injected !== arrived){
						// the script that contained the module arrived and has been executed yet
						// nothing was added to the defQ (so it wasn&#039;t an AMD module) and the module
						// wasn&#039;t marked as arrived by dojo.provide (so it wasn&#039;t a v1.6- module);
						// therefore, it must not have been a module; adjust state accordingly
						if(has(&quot;dojo-enforceDefine&quot;)){
							signal(error, makeError(&quot;noDefine&quot;, module));
							return;
						}
						setArrived(module);
						mix(module, nonModuleProps);
						req.trace(&quot;loader-define-nonmodule&quot;, [module.url]);
					}

					if(has(&quot;dojo-sync-loader&quot;) &amp;&amp; legacyMode){
						// must call checkComplete even in for sync loader because we may be in xdomainLoading mode;
						// but, if xd loading, then don&#039;t call checkComplete until out of the current sync traversal
						// in order to preserve order of execution of the dojo.required modules
						!syncExecStack.length &amp;&amp; checkComplete();
					}else{
						checkComplete();
					}
				};
				cached = cache[mid] || cache[urlKeyPrefix + module.url];
				if(cached){
					req.trace(&quot;loader-inject&quot;, [&quot;cache&quot;, module.mid, url]);
					evalModuleText(cached, module);
					onLoadCallback();
					return;
				}
				if(has(&quot;dojo-sync-loader&quot;) &amp;&amp; legacyMode){
					if(module.isXd){
						// switch to async mode temporarily; if current legacyMode!=sync, then is must be one of {legacyAsync, xd, false}
						legacyMode==sync &amp;&amp; (legacyMode = xd);
						// fall through and load via script injection
					}else if(module.isAmd &amp;&amp; legacyMode!=sync){
						// fall through and load via script injection
					}else{
						// mode may be sync, xd/legacyAsync, or async; module may be AMD or legacy; but module is always located on the same domain
						var xhrCallback = function(text){
							if(legacyMode==sync){
								// the top of syncExecStack gives the current synchronously executing module; the loader needs
								// to know this if it has to switch to async loading in the middle of evaluating a legacy module
								// this happens when a modules dojo.require&#039;s a module that must be loaded async because it&#039;s xdomain
								// (using unshift/shift because there is no back() methods for Javascript arrays)
								syncExecStack.unshift(module);
								evalModuleText(text, module);
								syncExecStack.shift();

								// maybe the module was an AMD module
								runDefQ(module);

								// legacy modules never get to defineModule() =&gt; cjs and injected never set; also evaluation implies executing
								if(!module.cjs){
									setArrived(module);
									finishExec(module);
								}

								if(module.finish){
									// while synchronously evaluating this module, dojo.require was applied referencing a module
									// that had to be loaded async; therefore, the loader stopped answering all dojo.require
									// requests so they could be answered completely in the correct sequence; module.finish gives
									// the list of dojo.requires that must be re-applied once all target modules are available;
									// make a synthetic module to execute the dojo.require&#039;s in the correct order

									// compute a guaranteed-unique mid for the synthetic finish module; remember the finish vector; remove it from the reference module
									// TODO: can we just leave the module.finish...what&#039;s it hurting?
									var finishMid = mid + &quot;*finish&quot;,
										finish = module.finish;
									delete module.finish;

									def(finishMid, [&quot;dojo&quot;, (&quot;dojo/require!&quot; + finish.join(&quot;,&quot;)).replace(/\./g, &quot;/&quot;)], function(dojo){
										forEach(finish, function(mid){ dojo.require(mid); });
									});
									// unshift, not push, which causes the current traversal to be reattempted from the top
									execQ.unshift(getModule(finishMid));
								}
								onLoadCallback();
							}else{
								text = transformToAmd(module, text);
								if(text){
									evalModuleText(text, module);
									onLoadCallback();
								}else{
									// if transformToAmd returned falsy, then the module was already AMD and it can be script-injected
									// do so to improve debugability(even though it means another download...which probably won&#039;t happen with a good browser cache)
									injectingModule = module;
									req.injectUrl(fixupUrl(url), onLoadCallback, module);
									injectingModule = 0;
								}
							}
						};

						req.trace(&quot;loader-inject&quot;, [&quot;xhr&quot;, module.mid, url, legacyMode!=sync]);
						if(has(&quot;config-dojo-loader-catches&quot;)){
							try{
								req.getText(url, legacyMode!=sync, xhrCallback);
							}catch(e){
								signal(error, makeError(&quot;xhrInjectFailed&quot;, [module, e]));
							}
						}else{
							req.getText(url, legacyMode!=sync, xhrCallback);
						}
						return;
					}
				} // else async mode or fell through in xdomain loading mode; either way, load by script injection
				req.trace(&quot;loader-inject&quot;, [&quot;script&quot;, module.mid, url]);
				injectingModule = module;
				req.injectUrl(fixupUrl(url), onLoadCallback, module);
				injectingModule = 0;
			},

			defineModule = function(module, deps, def){
				req.trace(&quot;loader-define-module&quot;, [module.mid, deps]);

				if(has(&quot;dojo-combo-api&quot;) &amp;&amp; module.plugin &amp;&amp; module.plugin.isCombo){
					// the module is a plugin resource loaded by the combo service
					// note: check for module.plugin should be enough since normal plugin resources should
					// not follow this path; module.plugin.isCombo is future-proofing belt and suspenders
					module.result = isFunction(def) ? def() : def;
					setArrived(module);
					finishExec(module);
					return module;
				}

				var mid = module.mid;
				if(module.injected === arrived){
					signal(error, makeError(&quot;multipleDefine&quot;, module));
					return module;
				}
				mix(module, {
					deps: deps,
					def: def,
					cjs: {
						id: module.mid,
						uri: module.url,
						exports: (module.result = {}),
						setExports: function(exports){
							module.cjs.exports = exports;
						},
						config:function(){
							return module.config;
						}
					}
				});

				// resolve deps with respect to this module
				for(var i = 0; deps[i]; i++){
					deps[i] = getModule(deps[i], module);
				}

				if(has(&quot;dojo-sync-loader&quot;) &amp;&amp; legacyMode &amp;&amp; !waiting[mid]){
					// the module showed up without being asked for; it was probably in a &lt;script&gt; element
					injectDependencies(module);
					execQ.push(module);
					checkComplete();
				}
				setArrived(module);

				if(!isFunction(def) &amp;&amp; !deps.length){
					module.result = def;
					finishExec(module);
				}

				return module;
			},

			runDefQ = function(referenceModule, mids){
				// defQ is an array of [id, dependencies, factory]
				// mids (if any) is a vector of mids given by a combo service
				var definedModules = [],
					module, args;
				while(defQ.length){
					args = defQ.shift();
					mids &amp;&amp; (args[0]= mids.shift());
					// explicit define indicates possible multiple modules in a single file; delay injecting dependencies until defQ fully
					// processed since modules earlier in the queue depend on already-arrived modules that are later in the queue
					// TODO: what if no args[0] and no referenceModule
					module = (args[0] &amp;&amp; getModule(args[0])) || referenceModule;
					definedModules.push([module, args[1], args[2]]);
				}
				consumePendingCacheInsert(referenceModule);
				forEach(definedModules, function(args){
					injectDependencies(defineModule.apply(null, args));
				});
			};
	}

	var timerId = 0,
		clearTimer = noop,
		startTimer = noop;
	if(has(&quot;dojo-timeout-api&quot;)){
		// Timer machinery that monitors how long the loader is waiting and signals an error when the timer runs out.
		clearTimer = function(){
			timerId &amp;&amp; clearTimeout(timerId);
			timerId = 0;
		};

		startTimer = function(){
			clearTimer();
			if(req.waitms){
				timerId = global.setTimeout(function(){
					clearTimer();
					signal(error, makeError(&quot;timeout&quot;, waiting));
				}, req.waitms);
			}
		};
	}

	if (has(&quot;dom&quot;)) {
		// Test for IE&#039;s different way of signaling when scripts finish loading.  Note that according to
		// http://bugs.dojotoolkit.org/ticket/15096#comment:14, IE9 also needs to follow the
		// IE specific code path even though it has an addEventListener() method.
		// Unknown if special path needed on IE10+, which also has a document.attachEvent() method.
		// Should evaluate to false for Opera and Windows 8 apps, even though they document.attachEvent()
		//  is defined in both those environments.
		has.add(&quot;ie-event-behavior&quot;, doc.attachEvent &amp;&amp; typeof Windows === &quot;undefined&quot; &amp;&amp;
			(typeof opera === &quot;undefined&quot; || opera.toString() != &quot;[object Opera]&quot;));
	}

	if(has(&quot;dom&quot;) &amp;&amp; (has(&quot;dojo-inject-api&quot;) || has(&quot;dojo-dom-ready-api&quot;))){
		var domOn = function(node, eventName, ieEventName, handler){
				// Add an event listener to a DOM node using the API appropriate for the current browser;
				// return a function that will disconnect the listener.
				if(!has(&quot;ie-event-behavior&quot;)){
					node.addEventListener(eventName, handler, false);
					return function(){
						node.removeEventListener(eventName, handler, false);
					};
				}else{
					node.attachEvent(ieEventName, handler);
					return function(){
						node.detachEvent(ieEventName, handler);
					};
				}
			},
			windowOnLoadListener = domOn(window, &quot;load&quot;, &quot;onload&quot;, function(){
				req.pageLoaded = 1;
				doc.readyState!=&quot;complete&quot; &amp;&amp; (doc.readyState = &quot;complete&quot;);
				windowOnLoadListener();
			});

		if(has(&quot;dojo-inject-api&quot;)){
			// if the loader is on the page, there must be at least one script element
			// getting its parent and then doing insertBefore solves the &quot;Operation Aborted&quot;
			// error in IE from appending to a node that isn&#039;t properly closed; see
			// dojo/tests/_base/loader/requirejs/simple-badbase.html for an example
			// don&#039;t use scripts with type dojo/... since these may be removed; see #15809
			// prefer to use the insertPoint computed during the config sniff in case a script is removed; see #16958
			var scripts = doc.getElementsByTagName(&quot;script&quot;),
				i = 0,
				script;
			while(!insertPointSibling){
				if(!/^dojo/.test((script = scripts[i++]) &amp;&amp; script.type)){
					insertPointSibling= script;
				}
			}

			req.injectUrl = function(url, callback, owner){
				// insert a script element to the insert-point element with src=url;
				// apply callback upon detecting the script has loaded.

				var node = owner.node = doc.createElement(&quot;script&quot;),
					onLoad = function(e){
						e = e || window.event;
						var node = e.target || e.srcElement;
						if(e.type === &quot;load&quot; || /complete|loaded/.test(node.readyState)){
							loadDisconnector();
							errorDisconnector();
							callback &amp;&amp; callback();
						}
					},
					loadDisconnector = domOn(node, &quot;load&quot;, &quot;onreadystatechange&quot;, onLoad),
					errorDisconnector = domOn(node, &quot;error&quot;, &quot;onerror&quot;, function(e){
						loadDisconnector();
						errorDisconnector();
						signal(error, makeError(&quot;scriptError&quot;, [url, e]));
					});

				node.type = &quot;text/javascript&quot;;
				node.charset = &quot;utf-8&quot;;
				node.src = url;
				insertPointSibling.parentNode.insertBefore(node, insertPointSibling);
				return node;
			};
		}
	}

	if(has(&quot;dojo-log-api&quot;)){
		req.log = function(){
			try{
				for(var i = 0; i &lt; arguments.length; i++){
					console.log(arguments[i]);
				}
			}catch(e){}
		};
	}else{
		req.log = noop;
	}

	if(has(&quot;dojo-trace-api&quot;)){
		var trace = req.trace = function(
			group,	// the trace group to which this application belongs
			args	// the contents of the trace
		){
			///
			// Tracing interface by group.
			//
			// Sends the contents of args to the console iff (req.trace.on &amp;&amp; req.trace[group])

			if(trace.on &amp;&amp; trace.group[group]){
				signal(&quot;trace&quot;, [group, args]);
				for(var arg, dump = [], text= &quot;trace:&quot; + group + (args.length ? (&quot;:&quot; + args[0]) : &quot;&quot;), i= 1; i&lt;args.length;){
					arg = args[i++];
					if(isString(arg)){
						text += &quot;, &quot; + arg;
					}else{
						dump.push(arg);
					}
				}
				req.log(text);
				dump.length &amp;&amp; dump.push(&quot;.&quot;);
				req.log.apply(req, dump);
			}
		};
		mix(trace, {
			on:1,
			group:{},
			set:function(group, value){
				if(isString(group)){
					trace.group[group]= value;
				}else{
					mix(trace.group, group);
				}
			}
		});
		trace.set(mix(mix(mix({}, defaultConfig.trace), userConfig.trace), dojoSniffConfig.trace));
		on(&quot;config&quot;, function(config){
			config.trace &amp;&amp; trace.set(config.trace);
		});
	}else{
		req.trace = noop;
	}

	var def = function(
		mid,		  //(commonjs.moduleId, optional)
		dependencies, //(array of commonjs.moduleId, optional) list of modules to be loaded before running factory
		factory		  //(any)
	){
		///
		// Advises the loader of a module factory. //Implements http://wiki.commonjs.org/wiki/Modules/AsynchronousDefinition.
		///
		//note
		// CommonJS factory scan courtesy of http://requirejs.org

		var arity = arguments.length,
			defaultDeps = [&quot;require&quot;, &quot;exports&quot;, &quot;module&quot;],
			// the predominate signature...
			args = [0, mid, dependencies];
		if(arity==1){
			args = [0, (isFunction(mid) ? defaultDeps : []), mid];
		}else if(arity==2 &amp;&amp; isString(mid)){
			args = [mid, (isFunction(dependencies) ? defaultDeps : []), dependencies];
		}else if(arity==3){
			args = [mid, dependencies, factory];
		}

		if(has(&quot;dojo-amd-factory-scan&quot;) &amp;&amp; args[1]===defaultDeps){
			args[2].toString()
				.replace(/(\/\*([\s\S]*?)\*\/|\/\/(.*)$)/mg, &quot;&quot;)
				.replace(/require\([&quot;&#039;]([\w\!\-_\.\/]+)[&quot;&#039;]\)/g, function(match, dep){
				args[1].push(dep);
			});
		}

		req.trace(&quot;loader-define&quot;, args.slice(0, 2));
		var targetModule = args[0] &amp;&amp; getModule(args[0]),
			module;
		if(targetModule &amp;&amp; !waiting[targetModule.mid]){
			// given a mid that hasn&#039;t been requested; therefore, defined through means other than injecting
			// consequent to a require() or define() application; examples include defining modules on-the-fly
			// due to some code path or including a module in a script element. In any case,
			// there is no callback waiting to finish processing and nothing to trigger the defQ and the
			// dependencies are never requested; therefore, do it here.
			injectDependencies(defineModule(targetModule, args[1], args[2]));
		}else if(!has(&quot;ie-event-behavior&quot;) || !has(&quot;host-browser&quot;) || injectingCachedModule){
			// not IE path: anonymous module and therefore must have been injected; therefore, onLoad will fire immediately
			// after script finishes being evaluated and the defQ can be run from that callback to detect the module id
			defQ.push(args);
		}else{
			// IE path: possibly anonymous module and therefore injected; therefore, cannot depend on 1-to-1,
			// in-order exec of onLoad with script eval (since it&#039;s IE) and must manually detect here
			targetModule = targetModule || injectingModule;
			if(!targetModule){
				for(mid in waiting){
					module = modules[mid];
					if(module &amp;&amp; module.node &amp;&amp; module.node.readyState === &#039;interactive&#039;){
						targetModule = module;
						break;
					}
				}
				if(has(&quot;dojo-combo-api&quot;) &amp;&amp; !targetModule){
					for(var i = 0; i&lt;combosPending.length; i++){
						targetModule = combosPending[i];
						if(targetModule.node &amp;&amp; targetModule.node.readyState === &#039;interactive&#039;){
							break;
						}
						targetModule= 0;
					}
				}
			}
			if(has(&quot;dojo-combo-api&quot;) &amp;&amp; isArray(targetModule)){
				injectDependencies(defineModule(getModule(targetModule.shift()), args[1], args[2]));
				if(!targetModule.length){
					combosPending.splice(i, 1);
				}
			}else if(targetModule){
				consumePendingCacheInsert(targetModule);
				injectDependencies(defineModule(targetModule, args[1], args[2]));
			}else{
				signal(error, makeError(&quot;ieDefineFailed&quot;, args[0]));
			}
			checkComplete();
		}
	};
	def.amd = {
		vendor:&quot;dojotoolkit.org&quot;
	};

	if(has(&quot;dojo-requirejs-api&quot;)){
		req.def = def;
	}

	// allow config to override default implementation of named functions; this is useful for
	// non-browser environments, e.g., overriding injectUrl, getText, log, etc. in node.js, Rhino, etc.
	// also useful for testing and monkey patching loader
	mix(mix(req, defaultConfig.loaderPatch), userConfig.loaderPatch);

	// now that req is fully initialized and won&#039;t change, we can hook it up to the error signal
	on(error, function(arg){
		try{
			console.error(arg);
			if(arg instanceof Error){
				for(var p in arg){
					console.log(p + &quot;:&quot;, arg[p]);
				}
				console.log(&quot;.&quot;);
			}
		}catch(e){}
	});

	// always publish these
	mix(req, {
		uid:uid,
		cache:cache,
		packs:packs
	});


	if(has(&quot;dojo-publish-privates&quot;)){
		mix(req, {
			// these may be interesting to look at when debugging
			paths:paths,
			aliases:aliases,
			modules:modules,
			legacyMode:legacyMode,
			execQ:execQ,
			defQ:defQ,
			waiting:waiting,

			// these are used for testing
			// TODO: move testing infrastructure to a different has feature
			packs:packs,
			mapProgs:mapProgs,
			pathsMapProg:pathsMapProg,
			listenerQueues:listenerQueues,

			// these are used by the builder (at least)
			computeMapProg:computeMapProg,
			computeAliases:computeAliases,
			runMapProg:runMapProg,
			compactPath:compactPath,
			getModuleInfo:getModuleInfo_
		});
	}

	// the loader can be defined exactly once; look for global define which is the symbol AMD loaders are
	// *required* to define (as opposed to require, which is optional)
	if(global.define){
		if(has(&quot;dojo-log-api&quot;)){
			signal(error, makeError(&quot;defineAlreadyDefined&quot;, 0));
		}
		return;
	}else{
		global.define = def;
		global.require = req;
		if(has(&quot;host-node&quot;)){
			require = req;
		}
	}

	if(has(&quot;dojo-combo-api&quot;) &amp;&amp; req.combo &amp;&amp; req.combo.plugins){
		var plugins = req.combo.plugins,
			pluginName;
		for(pluginName in plugins){
			mix(mix(getModule(pluginName), plugins[pluginName]), {isCombo:1, executed:&quot;executed&quot;, load:1});
		}
	}

	if(has(&quot;dojo-config-api&quot;)){
		forEach(delayedModuleConfig, function(c){ config(c); });
		var bootDeps = dojoSniffConfig.deps ||	userConfig.deps || defaultConfig.deps,
			bootCallback = dojoSniffConfig.callback || userConfig.callback || defaultConfig.callback;
		req.boot = (bootDeps || bootCallback) ? [bootDeps || [], bootCallback] : 0;
	}
	if(!has(&quot;dojo-built&quot;)){
		!req.async &amp;&amp; req([&quot;dojo&quot;]);
		req.boot &amp;&amp; req.apply(null, req.boot);
	}
})
//&gt;&gt;excludeStart(&quot;replaceLoaderConfig&quot;, kwArgs.replaceLoaderConfig);
(
	// userConfig
	(function(){
		// make sure we&#039;re looking at global dojoConfig etc.
		return this.dojoConfig || this.djConfig || this.require || {};
	})(),

	// defaultConfig
	{
		// the default configuration for a browser; this will be modified by other environments
		hasCache:{
			&quot;host-browser&quot;:1,
			&quot;dom&quot;:1,
			&quot;dojo-amd-factory-scan&quot;:1,
			&quot;dojo-loader&quot;:1,
			&quot;dojo-has-api&quot;:1,
			&quot;dojo-inject-api&quot;:1,
			&quot;dojo-timeout-api&quot;:1,
			&quot;dojo-trace-api&quot;:1,
			&quot;dojo-log-api&quot;:1,
			&quot;dojo-dom-ready-api&quot;:1,
			&quot;dojo-publish-privates&quot;:1,
			&quot;dojo-config-api&quot;:1,
			&quot;dojo-sniff&quot;:1,
			&quot;dojo-sync-loader&quot;:1,
			&quot;dojo-test-sniff&quot;:1,
			&quot;config-deferredInstrumentation&quot;:1,
			&quot;config-tlmSiblingOfDojo&quot;:1
		},
		packages:[{
			// note: like v1.6-, this bootstrap computes baseUrl to be the dojo directory
			name:&#039;dojo&#039;,
			location:&#039;.&#039;
		},{
			name:&#039;tests&#039;,
			location:&#039;./tests&#039;
		},{
			name:&#039;dijit&#039;,
			location:&#039;../dijit&#039;
		},{
			name:&#039;build&#039;,
			location:&#039;../util/build&#039;
		},{
			name:&#039;doh&#039;,
			location:&#039;../util/doh&#039;
		},{
			name:&#039;dojox&#039;,
			location:&#039;../dojox&#039;
		},{
			name:&#039;demos&#039;,
			location:&#039;../demos&#039;
		}],
		trace:{
			// these are listed so it&#039;s simple to turn them on/off while debugging loading
			&quot;loader-inject&quot;:0,
			&quot;loader-define&quot;:0,
			&quot;loader-exec-module&quot;:0,
			&quot;loader-run-factory&quot;:0,
			&quot;loader-finish-exec&quot;:0,
			&quot;loader-define-module&quot;:0,
			&quot;loader-circular-dependency&quot;:0,
			&quot;loader-define-nonmodule&quot;:0
		},
		async:0,
		waitSeconds:15
	}
);
//&gt;&gt;excludeEnd(&quot;replaceLoaderConfig&quot;)</textarea>
  </div>
</div>

<footer class="footer">
  <div class="container">
    <p>.</p>
  </div>
</footer>

<script type="text/html" id="complexity-popover-template">
  <div class="complexity-notice">
    Complexity : {{ complexity.cyclomatic }} <br>
    Length : {{ complexity.halstead.length }} <br>
    Difficulty : {{ complexity.halstead.difficulty.toFixed(2) }} <br>
    Est # bugs : {{ complexity.halstead.bugs.toFixed(2) }}<br>
  </div>
</script>

<script type="text/javascript" src="../../assets/scripts/bundles/core-bundle.js"></script>
<script type="text/javascript" src="../../assets/scripts/bundles/codemirror.js"></script>
<script type="text/javascript" src="../../assets/scripts/codemirror.markpopovertext.js"></script>
<script type="text/javascript" src="report.js"></script>
<script type="text/javascript" src="report.history.js"></script>
<script type="text/javascript" src="../../assets/scripts/plato-file.js"></script>
</body>
</html>
