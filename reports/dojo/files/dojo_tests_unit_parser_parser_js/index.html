<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Plato - dojo/tests/unit/parser/parser.js</title>

  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="">
  <meta name="author" content="">

  <!--[if lt IE 9]>
  <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->

  <link href="../../assets/css/vendor/morris.css" rel="stylesheet">
  <link href="../../assets/css/vendor/bootstrap.css" rel="stylesheet">
  <link href="../../assets/css/vendor/font-awesome.css" rel="stylesheet">
  <link href="../../assets/css/vendor/codemirror.css" rel="stylesheet">
  <link href="../../assets/css/plato.css" rel="stylesheet">
  <link href="../../assets/css/plato-file.css" rel="stylesheet">

</head>

<body>

<div class="navbar navbar-fixed-top">
  <div class="container">
    <a class="navbar-brand" href="http://github.com/es-analysis/plato">Plato on Github</a>
    <ul class="nav navbar-nav">
      <li>
        <a href="../../index.html">Report Home</a>
      </li>
    </ul>
  </div>
</div>

<div class="jumbotron">
  <div class="container">
    <h1>dojo/tests/unit/parser/parser.js</h1>
  </div>
</div>

<div class="container aggregate-stats">
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Maintainability <a href="http://blogs.msdn.com/b/codeanalysis/archive/2007/11/20/maintainability-index-range-and-meaning.aspx"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="A value between 0 and 100 that represents the relative ease of maintaining the code. A high value means better maintainability." data-original-title="Maintainability Index"  data-container="body"></i></a></h2>
      <p class="stat">70.09</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Lines of code <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h2>
      <p class="stat">959</p>
    </div>
  </div>
  <div class="row historical">
    <div class="col-md-6">
      <p id="chart_historical_maint" class="chart"></p>
    </div>
    <div class="col-md-6">
      <p id="chart_historical_sloc" class="chart"></p>
    </div>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Difficulty  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="The difficulty measure is related to the difficulty of the program to write or understand." data-original-title="Difficulty" data-container="body"></i></a></h2>
      <p class="stat">41.85</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Estimated Errors  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Halstead's delivered bugs is an estimate for the number of errors in the implementation." data-original-title="Delivered Bugs" data-container="body"></i></a></h2>
      <p class="stat">10.78</p>
    </div>
  </div>
</div>

<div class="container charts">
  <div class="row">
    <h2 class="header">Function weight</h2>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h3 class="chart-header">By Complexity <a href="http://en.wikipedia.org/wiki/Cyclomatic_complexity"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="This metric counts the number of distinct paths through a block of code. Lower values are better." data-original-title="Cyclomatic Complexity" data-container="body"></i></a></h3>
      <div id="fn-by-complexity" class="stat"></div>
    </div>
    <div class="col-md-6">
      <h3 class="chart-header">By SLOC  <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h3>
      <div id="fn-by-sloc" class="stat"></div>
    </div>
  </div>
</div>

<div class="container">
  <div class="row">
    <textarea id="file-source" class="col-md-12">define([
	&#039;intern!object&#039;,
	&#039;intern/chai!assert&#039;,
	&#039;../../../parser&#039;,
	&#039;dojo/dom-construct&#039;,
	&#039;dojo/_base/array&#039;,
	&#039;dojo/aspect&#039;,
	&#039;dojo/_base/declare&#039;,
	&#039;dojo/dom&#039;,
	&#039;dojo/dom-attr&#039;,
	&#039;dojo/_base/lang&#039;,
	&#039;dojo/on&#039;,
	&#039;dojo/_base/window&#039;,
	&#039;dojo/date/stamp&#039;,
	&#039;dojo/Stateful&#039;,
	&#039;dojo/Evented&#039;,
	&#039;dojo/text!./parser.html&#039;,
	&#039;./support/util&#039;
], function (
	registerSuite,
	assert,
	parser,
	domConstruct,
	array,
	aspect,
	declare,
	dom,
	domAttr,
	lang,
	on,
	win,
	dstamp,
	Stateful,
	Evented,
	template,
	util
) {
	var container;

	/* global tests */
	function setup(id, shouldReturn) {
		return function () {
			var MyNonDojoClass = window.MyNonDojoClass = function () {};
			MyNonDojoClass.extend = function () {
				var args = arguments;
				return function () {
					this.expectedClass = true;
					this.params = args;
				};
			};

			declare(&#039;tests.parser.Widget&#039;, null, {
				constructor: function (args) {
					this.params = args;
				}
			});

			declare(&#039;tests.parser.Class1&#039;, null, {
				constructor: function (args) {
					this.params = args;
					lang.mixin(this, args);
				},
				preambleTestProp: 1,
				preamble: function () {
					this.preambleTestProp++;
				},
				intProp: 1,
				callCount: 0, // for connect testing
				callInc: function () { this.callCount++; },
				callCount2: 0, // for assignment testing
				strProp1: &#039;original1&#039;,
				strProp2: &#039;original2&#039;,
				arrProp: [],
				arrProp2: [&#039;foo&#039;],
				boolProp1: false,
				boolProp2: true,
				boolProp3: false,
				boolProp4: true,
				dateProp1: dstamp.fromISOString(&#039;2007-01-01&#039;),
				dateProp2: dstamp.fromISOString(&#039;2007-01-01&#039;),
				dateProp3: dstamp.fromISOString(&#039;2007-01-01&#039;),
				funcProp: function () {},
				funcProp2: function () {},
				funcProp3: function () {},
				onclick: function () { this.prototypeOnclick = true; }
				// FIXME: have to test dates!!
				// FIXME: need to test the args property!!
			});

			declare(&#039;tests.parser.Class2&#039;, null, {
				constructor: function () {
					this.fromMarkup = false;
				},
				fromMarkup: false,
				markupFactory: function () {
					var i = new tests.parser.Class2();
					i.fromMarkup = true;
					return i;
				}
			});

			declare(&#039;tests.parser.Class3&#039;, tests.parser.Class2, {
				fromMarkup: false,
				markupFactory: function (args, node, ClassCtor) {
					var i = new ClassCtor();
					i.classCtor = ClassCtor;
					i.params = args;
					return i;
				}
			});

			declare(&#039;tests.parser.InputClass&#039;, null, {
				constructor: function (args) {
					this.params = args;
					lang.mixin(this, args);
				},

				// these attributes are special in HTML, they don&#039;t have a value specified
				disabled: false,
				readonly: false,
				checked: false,

				// other attributes native to HTML
				value: &#039;default value&#039;,
				title: &#039;default title&#039;,
				tabIndex: &#039;0&#039;,		// special because mixed case

				// custom widget attributes that don&#039;t match a native HTML attributes
				custom1: 123,
				custom2: 456
			});

			// Test that dir, lang, etc. attributes can be inherited from ancestor node
			declare(&#039;tests.parser.BidiClass&#039;, tests.parser.Widget, {
				constructor: function (args) { lang.mixin(this, args); },
				dir: &#039;&#039;,
				lang: &#039;&#039;,
				textdir: &#039;&#039;,
				name: &#039;&#039;
			});

			// For testing that parser recurses correctly, except when the prototype has a
			// stopParser flag
			declare(&#039;tests.parser.NormalContainer&#039;, null, {
				constructor: function (args) { lang.mixin(this, args); }
			});
			declare(&#039;tests.parser.ShieldedContainer&#039;, null, {
				constructor: function (args) { lang.mixin(this, args); },

				// flag to tell parser not to instantiate nodes inside of me
				stopParser: true
			});

			declare(&#039;tests.parser.HTML5Props&#039;, null, {
				constructor: function (args) { lang.mixin(this, args); },
				simple: false,
				a: 2,
				b: null,
				c: null,
				d: null,
				e: null,
				f: null,
				afn: function () {
					return this.a * 2;
				}
			});

			// not on .prototype:
			tests.parser.HTML5Props._aDefaultObj = {
				a: 1,
				b: 2,
				simple: true
			};

			declare(&#039;tests.parser.HTML5withMethod&#039;, null, {
				constructor: function (args) { lang.mixin(this, args); },
				baseValue: 10,
				someMethod: function () {
					return this.baseValue;
				},
				diffMethod: function () {
					this._ran = true;
				}
			});

			declare(&#039;tests.parser.StatefulClass&#039;, [Evented, Stateful], {
				strProp1: &#039;&#039;,
				objProp1: {},
				boolProp1: false,
				prototypeOnclick: false,
				onclick: function () { this.prototypeOnclick = true; }
			});

			declare(&#039;tests.parser.MethodClass&#039;, null, {
				method1ran: false,
				method1after: false,
				method2ran: false,
				method2before: false,
				method2after: false,
				method3result: &#039;&#039;,
				method4ran: false,
				method4after: false,
				method1: function () { this.method1ran = true; },
				method2: function () { this.method2ran = true; },
				method3: function (result) { this.method3result = result; },
				method4: function () { this.method4ran = true; }
			});

			declare(&#039;tests.parser.ClassForMixins&#039;, null, {
				classDone: true
			});

			declare(&#039;tests.parser.Mixin1&#039;, null, {
				mixin1Done: true
			});

			declare(&#039;tests.parser.Mixin2&#039;, null, {
				mixin2Done: true
			});

			declare(&#039;tests.resources.AMDWidget&#039;, null, {
				constructor: function (args) {
					this.params = args;
				}
			});

			declare(&#039;tests.resources.AMDWidget2&#039;, null, {
				constructor: function (args) {
					this.params = args;
				},

				method1: function (value) {
					value++;
					return value;
				}
			});

			declare(&#039;tests.resources.AMDWidget3&#039;, null, {
				constructor: function (args) {
					this.params = args;
				}
			});

			window.deepTestProp = {
				blah: {
					thinger: 1
				}
			};

			tests.parser.FormClass = declare(tests.parser.Widget, {
				encType: &#039;&#039;
			});

			window.foo = function () {
				this.fooCalled = true;
			};

			container = domConstruct.place(util.fixScope(template), document.body);
			var el = id ? dom.byId(id) : null,
				ret = parser.parse(el);

			return shouldReturn &amp;&amp; ret;
		};
	}

	function teardown() {
		domConstruct.destroy(container);
		container = null;
		window.foo = undefined;
	}

	registerSuite({
		name: &#039;dojo/parser basic tests&#039;,
		setup: setup(&#039;main&#039;, true),

		teardown: teardown,

		/* global obj */
		&#039;data-dojo-id&#039;: function () {
			assert.isObject(obj);
		},

		/* global obj3 */
		&#039;JsId&#039;: function () {
			assert.isObject(obj3);
		},

		&#039;string property&#039;: function () {
			assert.isString(obj.strProp1);
			assert.equal(obj.strProp1, &#039;text&#039;);
		},

		&#039;int property&#039;: function () {
			assert.isNumber(obj.intProp);
			assert.equal(obj.intProp, 5);
		},

		&#039;array property&#039;: function () {
			assert.lengthOf(obj.arrProp, 3);
			assert.lengthOf(obj.arrProp[1], 3);
			assert.equal(obj.arrProp[1], &#039;bar&#039;);
		},

		&#039;boolean property&#039;: function () {
			// boolProp1
			assert.isBoolean(obj.boolProp1);
			assert.isTrue(obj.boolProp1);

			// boolProp2
			assert.isBoolean(obj.boolProp2);
			assert.isFalse(obj.boolProp2);

			// boolProp3 not specified (prototype says false)
			assert.isBoolean(obj.boolProp3);
			// assert.isFalse(obj.boolprop3);

			// boolProp4 not specified (prototype says true)
			// assert.isBoolean(obj.boolProp4);
			// assert.isTrue(obj.boolProp4);
		},

		&#039;date property&#039;: function () {
			assert.equal(dstamp.toISOString(obj.dateProp1, { selector: &#039;date&#039; }), &#039;2006-01-01&#039;);
			// dateProp2=&#039;&#039;, should map to NaN (a blank value on DateTextBox)
			assert.ok(isNaN(obj.dateProp2));

			// dateProp3=&#039;now&#039;, should map to current date
			assert.equal(dstamp.toISOString(obj.dateProp3, { selector: &#039;date&#039; }),
				dstamp.toISOString(new Date(), { selector: &#039;date&#039; }));
		},

		&#039;unwanted params&#039;: function () {
			// Make sure that parser doesn&#039;t pass any unwanted parameters to
			// widget constructor, especially &#039;toString&#039; or &#039;constructor&#039;.
			// Make exception for dir/lang which parser gleans from document itself.
			for (var param in obj.params) {
				assert.ok(array.indexOf(
					[
						&#039;strProp1&#039;, &#039;strProp2&#039;,
						&#039;intProp&#039;,
						&#039;arrProp&#039;, &#039;arrProp2&#039;,
						&#039;boolProp1&#039;, &#039;boolProp2&#039;,
						&#039;dateProp1&#039;, &#039;dateProp2&#039;, &#039;dateProp3&#039;,
						&#039;funcProp2&#039;, &#039;funcProp3&#039;,
						&#039;preamble&#039;,
						&#039;callInc1&#039;, &#039;callInc2&#039;, &#039;dir&#039;, &#039;lang&#039;, &#039;textDir&#039;
					],
				param) &gt;= 0, param + &#039; should not be in the parameters passed to the widget constructor&#039;);
			}
		},

		&#039;disabled flag&#039;: function () {
			/* global disabledObj */
			assert.isBoolean(disabledObj.disabled);
			assert.isTrue(disabledObj.disabled);
			assert.isFalse(disabledObj.checked);
		},

		&#039;checked flag&#039;: function () {
			/* global checkedObj */
			assert.isBoolean(checkedObj.checked);
			assert.isFalse(checkedObj.disabled);
			assert.isTrue(checkedObj.checked);
		},

		&#039;function property&#039;: function () {
			// make sure that unspecified functions (even with common names)
			// don&#039;t get overridden (bug #3074)
			obj.onclick();
			assert.isTrue(obj.prototypeOnclick, &#039;prototypeOnClick&#039;);

			// funcProp2=&#039;foo&#039;
			obj.funcProp2();
			assert.isTrue(obj.fooCalled, &#039;fooCalled&#039;);

			// funcProp3=&#039;this.func3Called=true;&#039;
			obj.funcProp3();
			assert.isTrue(obj.func3Called, &#039;func3Called&#039;);
		},

		&#039;connect&#039;: function () {
			obj.callInc();
			assert.equal(obj.callCount, 2);
		},

		&#039;function assignment&#039;: function () {
			obj.callInc2();
			assert.equal(obj.callCount2, 1);
		},

		&#039;subnode parse&#039;: function () {
			assert.isFalse(lang.exists(&#039;obj2&#039;), &#039;exists before parse&#039;);
			var toParse = dom.byId(&#039;toParse&#039;);
			parser.parse(toParse.parentNode);
			assert.isTrue(lang.exists(&#039;obj2&#039;), &#039;exists after parse&#039;);
			assert.equal(obj.declaredClass, &#039;tests.parser.Class1&#039;);
		},

		&#039;markup factory&#039;: function () {
			assert.isTrue(lang.exists(&#039;obj3&#039;), &#039;obj3 exists&#039;);
			assert.isTrue(obj3.fromMarkup);
		},

		/* global obj4 */
		&#039;markup factory class&#039;: function () {
			assert.isTrue(lang.exists(&#039;obj4&#039;), &#039;obj4 exists&#039;);
			assert.equal(obj4.classCtor, tests.parser.Class3);
			assert.instanceOf(obj4, tests.parser.Class3);
			assert.instanceOf(obj4, tests.parser.Class2);
		},

		&#039;no start&#039;: function () {
			var started = false;
			declare(&#039;SampleThinger&#039;, null, {
				startup: function () {
					started = true;
				}
			});

			domConstruct.create(&#039;div&#039;, {
				dojoType: &#039;SampleThinger&#039;
			}, &#039;parsertest&#039;);

			parser.parse(&#039;parsertest&#039;, { noStart: true });
			assert.isFalse(started, &#039;first started check&#039;);

			domConstruct.empty(&#039;parsertest&#039;);

			started = false;

			domConstruct.create(&#039;div&#039;, {
				dojoType: &#039;SampleThinger&#039;
			}, &#039;parsertest&#039;);

			parser.parse(&#039;parsertest&#039;, { noStart: true, rootNode: &#039;parserTest&#039; });
			assert.isFalse(started, &#039;second started check&#039;);
		},

		// test the varios iterations of parser test
		// TODO: the following test doesn&#039;t acutally test anything because
		// the parser is calling dojo/query&#039;s function instead of dojo.query
		// This also causes other tests to fail because the aspect call replaces
		// dojo.query which has functions on it (like dojo.query.matches)
		/*&#039;root test&#039;: function () {
			var tmp = aspect.after(dojo, &#039;query&#039;, function (sel, root) {
				assert.equal(root, &#039;parsertest2&#039;);
			});

			parser.parse(&#039;parsertest2&#039;);
			parser.parse({ rootNode: &#039;parsertest2&#039; });
			parser.parse(&#039;parsertest2&#039;, { noStart: true });
			tmp.remove();
		},*/

		// Test that when BorderContainer etc. extends _Widget,
		// parser is aware of the new parameters added (to _Widget
		// and all of it&#039;s subclasses)
		&#039;cache refresh&#039;: function () {
			// Add new node to be parsed, referencing a widget that the parser has already
			// dealt with (and thus cached)
			var wrapper = domConstruct.place(
				util.fixScope(&#039;&lt;div&gt;&lt;div ${dojo}Type=&quot;tests.parser.Class3&quot; newParam=12345&gt;hi&lt;/div&gt;&lt;/div&gt;&#039;),
				win.body(), &#039;last&#039;);

			try {
				// Modify Class3&#039;s superclass widget to have new parameter (thus Class3 inherits it)
				lang.extend(tests.parser.Class2, {
					newParam: 0
				});

				// Run the parser and see if it reads in newParam
				var widgets = parser.parse({ rootNode: wrapper });
				assert.lengthOf(widgets, 1);
				assert.equal(widgets[0].params.newparam || widgets[0].params.newParam, 12345);
			}
			finally {
				domConstruct.destroy(wrapper);
			}
		},

		// Test that parser recurses correctly, except when there&#039;s a stopParser flag not to
		/* global container1, contained1, container2, contained2 */
		&#039;recurse&#039;: function () {
			assert.isDefined(container1, &#039;normal container created&#039;);
			assert.isDefined(container1.incr, &#039;script tag works too&#039;);
			assert.isDefined(contained1, &#039;child widget also created&#039;);
			assert.isDefined(contained2, &#039;child widget 2 also created&#039;);

			assert.isDefined(container2, &#039;shielded container created&#039;);
			assert.isDefined(container2.incr, &#039;script tag works too&#039;);
			assert.isUndefined(window.contained3, &#039;child widget not created&#039;);
			assert.isUndefined(window.contained4, &#039;child widget 2 not created&#039;);
		},

		/* global html5simple, html5simple2 */
		&#039;simple HTML5&#039;: function () {
			assert.isObject(html5simple, &#039;data-dojo-id export&#039;);
			assert.isObject(html5simple2, &#039;data-dojo-id export&#039;);

			assert.isTrue(html5simple.simple, &#039;default respecified in props=&quot;&quot;&#039;);
			assert.isFalse(html5simple2.simple, &#039;default overridden by props=&quot;&quot;&#039;);

			// test data-dojo-props=&#039;simple:false, a:1, b:&#039;two&#039;, c:[1,2,3], d:function(){ return this; }, e:{ f:&#039;g&#039; }&#039;
			var it = html5simple2;
			assert.equal(it.a, 1, &#039;number in param&#039;);
			assert.equal(it.b, &#039;two&#039;, &#039;string in param&#039;);
			assert.isArray(it.c, &#039;array in param&#039;);
			assert.lengthOf(it.c, 3, &#039;array sanity&#039;);
			assert.equal(it.e.f, &#039;g&#039;, &#039;nested object with string&#039;);

			// test the function
			assert.equal(it.d(), it, &#039;simple \&#039;return this\&#039; function&#039;);
		},

		/* global html5simple3 */
		&#039;HTML5 inherited&#039;: function () {
			assert.isObject(html5simple3);
			var val = html5simple3.afn();
			assert.equal(val, html5simple3.a * 2, &#039;afn() overrides default but calls inherited&#039;);
		},

		/* global htmldojomethod */
		&#039;HTML5 with method&#039;: function () {
			// testing data-dojo-event and data-dojo-args support for dojo/method and dojo/connect
			assert.isObject(htmldojomethod);
			assert.isTrue(htmldojomethod._methodRan, &#039;plain dojo/method ran&#039;);

			var x = htmldojomethod.someMethod(2, 2);
			assert.equal(x, 14, &#039;overridden dojo/method&#039;);

			htmldojomethod.diffMethod(2);
			assert.isTrue(htmldojomethod._ran, &#039;ensures original was called first&#039;);
			assert.equal(htmldojomethod._fromvalue, 2, &#039;ensures connected was executed in scope&#039;);
		},

		/* global objOnWatch */
		&#039;test watch&#039;: function () {
			// testing script-type dojo/watch and dojo/on
			assert.isObject(objOnWatch);
			objOnWatch.set(&#039;strProp1&#039;, &#039;newValue1&#039;);
			assert.equal(objOnWatch.arrProp.newValue, &#039;newValue1&#039;, &#039;ensures watch executed&#039;);

			objOnWatch.onclick();
			assert.isTrue(objOnWatch.prototypeOnclick, &#039;ensures original was called&#039;);
			assert.isTrue(objOnWatch.boolProp1, &#039;ensure on executed in scope&#039;);
		},

		/* global on_form */
		&#039;on&#039;: function () {
			/*jshint camelcase:false*/
			// testing script-type dojo/on, when script comes after another element
			parser.parse(&#039;on&#039;);
			assert.property(window, &#039;on_form&#039;, &#039;widget created&#039;);
			on_form.emit(&#039;click&#039;);
			assert.isTrue(on_form.clicked, &#039;on callback fired&#039;);
		},


		/* global objAspect */
		&#039;aspect&#039;: function () {
			// testing script-type dojo/aspect
			assert.isObject(objAspect);
			assert.isFalse(objAspect.method1ran, &#039;ensures method unfired&#039;);
			assert.isFalse(objAspect.method2ran, &#039;ensures method unfired&#039;);
			assert.equal(objAspect.method3result, &#039;&#039;, &#039;ensures method unfired&#039;);
			assert.isFalse(objAspect.method4ran, &#039;ensures method unfired&#039;);

			objAspect.method1();
			objAspect.method2();
			objAspect.method3(&#039;something&#039;);
			objAspect.method4();

			assert.isTrue(objAspect.method1ran, &#039;method fired&#039;);
			assert.isTrue(objAspect.method1after, &#039;after advice fired&#039;);
			assert.isTrue(objAspect.method2ran, &#039;method fired&#039;);
			assert.isTrue(objAspect.method2before, &#039;around before advice fired&#039;);
			assert.isTrue(objAspect.method2after, &#039;around after advice fired&#039;);
			assert.equal(objAspect.method3result, &#039;before&#039;, &#039;before argument passed&#039;);
			assert.isTrue(objAspect.method4ran, &#039;method fired&#039;);
			assert.isTrue(objAspect.method4after, &#039;after advice fired&#039;);
		},

		/* global objAMDWidget */
		&#039;mid&#039;: function () {
			// testing specifying data-dojo-type as mid
			assert.isObject(objAMDWidget);
			assert.equal(objAMDWidget.params.value, &#039;Value1&#039;, &#039;ensure object was properly parsed using MID&#039;);
		}
	});

	registerSuite({
		name: &#039;bidi&#039;,

		setup: setup(&#039;main&#039;),

		teardown: teardown,

		// Test that dir=rtl or dir=ltr setting trickles down from root node
		/* global setRtl, inheritRtl, inheritRtl2, inheritLtr, setLtr */
		&#039;dir attribute&#039;: function () {
			parser.parse(&#039;dirSection1&#039;);
			parser.parse(&#039;dirSection2&#039;);
			assert.equal(setRtl.dir, &#039;rtl&#039;, &#039;direct setting of dir=rtl works&#039;);
			assert.equal(inheritRtl.dir, &#039;rtl&#039;, &#039;inherited rtl works&#039;);
			assert.equal(inheritLtr.dir, &#039;ltr&#039;, &#039;inherited ltr works (closest ancestor wins)&#039;);
			assert.equal(inheritRtl2.dir, &#039;rtl&#039;, &#039;inherited rtl works, from grandparent&#039;);
			assert.equal(setLtr.dir, &#039;ltr&#039;, &#039;direct setting of dir=ltr overrides inherited RTL&#039;);
		},

		/* global noLang, inheritedLang, specifiedLang */
		&#039;lang attribute&#039;: function () {
			parser.parse(&#039;langSection&#039;);
			assert.notProperty(noLang.params, &#039;lang&#039;, &#039;no lang&#039;);
			assert.equal(inheritedLang.lang, &#039;it_it&#039;, &#039;inherited lang works&#039;);
			assert.equal(specifiedLang.lang, &#039;en_us&#039;, &#039;direct setting of lang overrides inherited&#039;);
		},

		/* global noTextdir, inheritedTextdir, specifiedTextdir */
		&#039;textDir attribute&#039;: function () {
			parser.parse(&#039;textDirSection&#039;);
			assert.notProperty(noTextdir.params, &#039;textDir&#039;, &#039;no textdir&#039;);
			assert.equal(inheritedTextdir.textDir, &#039;rtl&#039;, &#039;inherited textdir works&#039;);
			assert.equal(specifiedTextdir.textDir, &#039;ltr&#039;, &#039;direct setting of textdir overrides inherited&#039;);
		},

		&#039;inheritance from HTML&#039;: function () {
			// Test that calling parser.parse(nodeX) will inherit dir/lang/etc. settings
			// even from &lt;html&gt;

			var textdirAttr = util.fixScope(&#039;data-${dojo}-textdir&#039;);
			var attrs = { dir: &#039;rtl&#039;, lang: &#039;ja-jp&#039; };
			attrs[textdirAttr] = &#039;auto&#039;;
			domAttr.set(win.doc.documentElement, attrs);
			parser.parse(&#039;bidiInheritanceFromHtml&#039;);

			/* global inheritedFromHtml */
			assert.equal(inheritedFromHtml.params.dir, &#039;rtl&#039;, &#039;dir&#039;);
			assert.equal(inheritedFromHtml.params.lang, &#039;ja-jp&#039;, &#039;lang&#039;);
			assert.equal(inheritedFromHtml.params.textDir, &#039;auto&#039;, &#039;textDir&#039;);

			// teardown
			array.forEach([&#039;dir&#039;, &#039;lang&#039;, textdirAttr], function (attr) {
				win.doc.documentElement.removeAttribute(attr);
			});
		}
	});

	registerSuite({
		name: &#039;IE Attribute Detection&#039;,

		setup: setup(&#039;main&#039;),

		teardown: teardown,

		&#039;input1&#039;: function () {
			var widgets = parser.instantiate([dom.byId(&#039;ieInput1&#039;)]);
			var params = widgets[0].params;

			assert.equal(params.type, &#039;checkbox&#039;, &#039;type&#039;);
			assert.isTrue(params.disabled, &#039;disabled&#039;);
			assert.isTrue(params.checked, &#039;checked&#039;);
			assert.isTrue(params.readonly, &#039;readonly&#039;);
			assert.equal(params.foo, &#039;bar&#039;, &#039;foo&#039;);
			assert.equal(params.bar, &#039;zaz&#039;, &#039;bar&#039;);
			assert.equal(params.bob, &#039;escaped\&quot;dq&#039;, &#039;bob&#039;);
			assert.equal(params.frank, &#039;escaped\&#039;sq&#039;, &#039;frank&#039;);
			//assert.isFalse(&#039;value&#039; in params, &#039;value not specified&#039;);	// fails in IE8, thinks value==&#039;on&#039;
		},

		&#039;input2&#039;: function () {
			var widgets = parser.instantiate([dom.byId(&#039;ieInput2&#039;)]);
			var params = widgets[0].params;

			assert.notProperty(params, &#039;type&#039;, &#039;type&#039;);
			assert.notProperty(params, &#039;name&#039;, &#039;name&#039;);
			assert.notProperty(params, &#039;value&#039;, &#039;value&#039;);
			assert.notProperty(params, &#039;data-dojo-type&#039;, &#039;data-dojo-type&#039;);
			assert.notProperty(params, &#039;data-dojo-props&#039;, &#039;data-dojo-props&#039;);
			assert.equal(params.foo, &#039;hi&#039;, &#039;foo&#039;);
			assert.notProperty(params, &#039;value&#039;, &#039;value not specified&#039;);
		},

		&#039;input3&#039;: function () {
			var widgets = parser.instantiate([dom.byId(&#039;ieInput3&#039;)]);
			var params = widgets[0].params;

			assert.equal(params.type, &#039;password&#039;, &#039;type&#039;);
			assert.equal(params.name, &#039;test&#039;, &#039;name&#039;);
			assert.equal(params.value, &#039;123&#039;, &#039;value&#039;);
			assert.equal(params[&#039;class&#039;], &#039;myClass&#039;, &#039;class&#039;);
			assert.equal(params.style.replace(/[ ;]/g, &#039;&#039;).toLowerCase(), &#039;display:block&#039;, &#039;style&#039;);
			assert.equal(params.tabIndex, &#039;3&#039;, &#039;tabIndex&#039;);
		},

		&#039;textarea&#039;: function () {
			var widgets = parser.instantiate([dom.byId(&#039;ieTextarea&#039;)]);
			var params = widgets[0].params;

			assert.equal(params.value, &#039;attrVal&#039;, &#039;value&#039;);
		},

		&#039;button1&#039;: function () {
			var widgets = parser.instantiate([dom.byId(&#039;ieButton1&#039;)]);
			var params = widgets[0].params;

			assert.isTrue(params.checked, &#039;checked&#039;);
			assert.equal(params.value, &#039;button1val&#039;, &#039;value&#039;);
		},

		&#039;button2&#039;: function () {
			var widgets = parser.instantiate([dom.byId(&#039;ieButton2&#039;)]);
			var params = widgets[0].params;
			assert.notProperty(params, &#039;checked&#039;, &#039;checked&#039;);
			assert.notProperty(params, &#039;value&#039;, &#039;value&#039;);
		},

		&#039;button3&#039;: function () {
			var widgets = parser.instantiate([dom.byId(&#039;ieButton3&#039;)]);
			var params = widgets[0].params;
			assert.isTrue(params.checked, &#039;checked&#039;);
		},

		&#039;button4&#039;: function () {
			var widgets = parser.instantiate([dom.byId(&#039;ieButton4&#039;)]);
			var params = widgets[0].params;
			assert.notProperty(params, &#039;checked&#039;);
		},

		&#039;form1&#039;: function () {
			var widgets = parser.instantiate([dom.byId(&#039;ieForm1&#039;)]);
			var params = widgets[0].params;

			assert.equal(params.encType, &#039;foo&#039;, &#039;encType is specified&#039;);
		},

		&#039;form2&#039;: function () {
			var widgets = parser.instantiate([dom.byId(&#039;ieForm2&#039;)]);
			var params = widgets[0].params;

			assert.notProperty(params, &#039;encType&#039;, &#039;encType not specified&#039;);
		},

		&#039;li&#039;: function () {
			var widgets = parser.instantiate([dom.byId(&#039;li&#039;)]);
			var params = widgets[0].params;
			assert.equal(params.value, &#039;home&#039;);
		}
	});

	registerSuite({
		name: &#039;mixed attribute specification&#039;,

		setup: setup(&#039;main&#039;),

		teardown: teardown,

		/* global mixedObj */
		&#039;mixed&#039;: function () {
			parser.parse(dom.byId(&#039;mixedContainer&#039;));
			assert.isObject(mixedObj, &#039;widget created&#039;);
			assert.equal(mixedObj.value, &#039;mixedValue&#039;, &#039;native attribute&#039;);
			assert.equal(mixedObj.custom1, 999, &#039;data-dojo-props attribute&#039;);
			assert.equal(mixedObj.title, &#039;custom title&#039;, &#039;data-dojo-props overrides native&#039;);
		}
	});

	registerSuite({
		name: &#039;functions&#039;,

		setup: setup(&#039;main&#039;),

		teardown: teardown,

		&#039;onclick&#039;: function () {
			declare(&#039;tests.parser.Button&#039;, null, {
				onClick: function () {
					console.log(&#039;prototype click&#039;);
				},
				constructor: function (args, node) {
					lang.mixin(this, args);
					this.domNode = node;
					aspect.after(this.domNode, &#039;onclick&#039;, lang.hitch(this, &#039;onClick&#039;));
				}
			});

			buttonClicked = function () {
				console.log(&#039;markup click&#039;);
			};	// markup says onClick=&#039;buttonClicked&#039;

			// Parse markup inside &#039;functions&#039; div
			parser.parse(&#039;functions&#039;);

			// Should have created an instance called &#039;button&#039; where button.onClick == buttonClicked
			/* global button, buttonClicked */
			assert.isObject(button, &#039;widget created&#039;);
			assert.isFunction(button.onClick, &#039;created as function&#039;);
			assert.isTrue(buttonClicked === button.onClick, &#039;points to specified function&#039;);
		}
	});

	registerSuite({
		name: &#039;parser.construct()&#039;,

		setup: setup(&#039;main&#039;),

		teardown: teardown,

		/* global objC1, objC2 */
		&#039;construct1&#039;: function () {
			// var nodes = [dom.byId(&#039;objC1&#039;), dom.byId(&#039;objC2&#039;)];

			parser.construct(tests.parser.Class1, dom.byId(&#039;objC1&#039;));
			assert.isObject(objC1, &#039;widget 1 created&#039;);
			assert.equal(objC1.intProp, 5, &#039;objC1.intProp&#039;);

			parser.construct(tests.parser.Class1, dom.byId(&#039;objC2&#039;));
			assert.isObject(objC2, &#039;widget 2 created&#039;);
			assert.equal(objC2.intProp, 5, &#039;objC2.intProp&#039;);
		}
	});

	registerSuite({
		name: &#039;data-dojo-mixins support&#039;,

		setup: setup(&#039;mixins&#039;, true),

		teardown: teardown,

		&#039;mixins&#039;: function () {
			/* global resultMixins1, resultMixins2 */
			assert.ok(resultMixins1, &#039;object using data-dojo-mixins created from an already parsed type&#039;);
			assert.isTrue(resultMixins1.mixin1Done, &#039;mixin1 correctly mixed in&#039;);
			assert.isTrue(resultMixins1.mixin2Done, &#039;mixin2 correctly mixed in&#039;);
			assert.isTrue(resultMixins1.amdMixinDone, &#039;amd mixin correctly mixed in&#039;);
			assert.ok(resultMixins2, &#039;object using data-dojo-mixins created from a non parsed type&#039;);
			assert.isTrue(resultMixins2.classDone, &#039;class correctly created&#039;);
			assert.isTrue(resultMixins2.mixin1Done, &#039;mixin1 correctly mixed in&#039;);
			assert.isTrue(resultMixins2.mixin2Done, &#039;mixin2 correctly mixed in&#039;);
			assert.isTrue(resultMixins2.amdMixinDone, &#039;amd mixin correctly mixed in&#039;);

			/* global resultNonDojoMixin */
			assert.isTrue(resultNonDojoMixin.expectedClass, &#039;correct class is returned for composeJS mixin&#039;);
			assert.equal(resultNonDojoMixin.params.length, 2, &#039;correct # of params were passed to compose JS&#039;);
			assert.equal(resultNonDojoMixin.params[0], tests.parser.Mixin1, &#039;correct param 1&#039;);
			assert.equal(resultNonDojoMixin.params[1], tests.parser.Mixin2, &#039;correct param 2&#039;);
		}
	});

	registerSuite({
		name: &#039;behavorial&#039;,

		setup: setup(&#039;main&#039;),

		teardown: teardown,

		&#039;doubleConnect&#039;: function () {
			// Class used in &#039;behavioral&#039; &lt;div&gt;
			/* global Behavioral1:true */
			Behavioral1 = declare(null, {
				constructor: function (params, node) {
					on(node, &#039;click&#039;, lang.hitch(this, &#039;onClick&#039;));
					if (typeof params.onClick !== &#039;function&#039;) {
						throw new Error(&#039;onClick not passed to constructor&#039;);
					}
					lang.mixin(this, params);
				},
				onClick: function () {
					console.log(&#039;original onnClick handler&#039;);
				},
				foo: &#039;&#039;
			});

			parser.parse(&#039;behavioral&#039;);

			// Setup global accessed by Behavioral1.onclick handler
			behavioralClickCounter = 0;

			// Trigger click event, and make sure that handler was only called once.
			on.emit(dom.byId(&#039;bh1&#039;), &#039;click&#039;, {bubbles: true, cancelable: true});

			/* global behavioralClickCounter */
			assert.equal(behavioralClickCounter, 1, &#039;one click event processed&#039;);

			assert.equal(dom.byId(&#039;bh1&#039;).getAttribute(&#039;foo&#039;), &#039;bar&#039;, &#039;foo attribute not removed from widget DOMNode&#039;);
		}
	});

	registerSuite({
		name: &#039;script type=dojo/require support&#039;,

		setup: setup(&#039;main&#039;),

		teardown: teardown,

		&#039;declarativeRequire&#039;: function () {
			var td = this.async();

			parser.parse(&#039;declarativeRequire&#039;).then(td.callback(function () {
				/* global dr1, dr2, dr3, dr4, dr5 */
				assert.isObject(dr1, &#039;object using MID mapped to return var&#039;);
				assert.equal(dr1.params.foo, &#039;bar&#039;, &#039;parameters set on instantiation&#039;);
				assert.isObject(dr2, &#039;object using MID mapped to return var&#039;);
				assert.equal(dr2.params.foo, &#039;bar&#039;, &#039;parameters set on instantiation&#039;);
				assert.isObject(dr3, &#039;object using fully required&#039;);
				assert.equal(dr3.params.foo, &#039;bar&#039;, &#039;parameters set on instantiation&#039;);
				assert.equal(dr4.params.foo, 2, &#039;module loaded and executed&#039;);
				assert.equal(dr5.method1(1), 3, &#039;declarative script has access to parser scope&#039;);
			}));
		},

		&#039;contextRequire&#039;: function () {
			var td = this.async();

			parser.parse(&#039;contextRequire&#039;, {
				contextRequire: require
			}).then(td.callback(function () {
				/* global cr1, cr2, cr3, cr4 */
				assert.isObject(cr1, &#039;object using relative MID mapped to return var&#039;);
				assert.equal(cr1.params.foo, &#039;bar&#039;, &#039;parameters set on instantiation&#039;);
				assert.isObject(cr2, &#039;object using relative MID mapped to return var&#039;);
				assert.equal(cr2.params.foo, &#039;bar&#039;, &#039;parameters set on instantiation&#039;);
				assert.isObject(cr3, &#039;object using relative MID mapped to return var&#039;);
				assert.equal(cr3.params.foo, &#039;bar&#039;, &#039;parameters set on instantiation&#039;);
				assert.isObject(cr4, &#039;object using relative MID mapped to return var&#039;);
				assert.equal(cr4.params.foo, &#039;bar&#039;, &#039;parameters set on instantiation&#039;);
			}));
		}
	});

	registerSuite({
		name: &#039;promise error handling support&#039;,

		setup: setup(&#039;main&#039;),

		teardown: teardown,

		&#039;asyncError&#039;: function () {
			var td = this.async();

			parser.parse(&#039;errorHandling&#039;).then(td.rejectOnError(function () {
				throw new Error(&#039;shouldn\&#039;t get here&#039;);
			}), td.callback(function (e) {
				assert.equal(typeof e, &#039;object&#039;, &#039;error object returned&#039;);
			}));
		},

		&#039;missingCtor&#039;: function () {
			var td = this.async();

			parser.parse(&#039;missingCtor&#039;).then(td.rejectOnError(function () {
				throw new Error(&#039;shouldn\&#039;t get here&#039;);
			}), td.callback(function (e) {
				assert.equal(typeof e, &#039;object&#039;, &#039;error object returned&#039;);
				assert.equal(e.toString(),
					&#039;Error: Unable to resolve constructor for: \&#039;some.type\&#039;&#039;, &#039;proper error value returned&#039;);
			}));
		}
	});
});</textarea>
  </div>
</div>

<footer class="footer">
  <div class="container">
    <p>.</p>
  </div>
</footer>

<script type="text/html" id="complexity-popover-template">
  <div class="complexity-notice">
    Complexity : {{ complexity.cyclomatic }} <br>
    Length : {{ complexity.halstead.length }} <br>
    Difficulty : {{ complexity.halstead.difficulty.toFixed(2) }} <br>
    Est # bugs : {{ complexity.halstead.bugs.toFixed(2) }}<br>
  </div>
</script>

<script type="text/javascript" src="../../assets/scripts/bundles/core-bundle.js"></script>
<script type="text/javascript" src="../../assets/scripts/bundles/codemirror.js"></script>
<script type="text/javascript" src="../../assets/scripts/codemirror.markpopovertext.js"></script>
<script type="text/javascript" src="report.js"></script>
<script type="text/javascript" src="report.history.js"></script>
<script type="text/javascript" src="../../assets/scripts/plato-file.js"></script>
</body>
</html>
