<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Plato - dojo/tests/unit/_base/declare.js</title>

  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="">
  <meta name="author" content="">

  <!--[if lt IE 9]>
  <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->

  <link href="../../assets/css/vendor/morris.css" rel="stylesheet">
  <link href="../../assets/css/vendor/bootstrap.css" rel="stylesheet">
  <link href="../../assets/css/vendor/font-awesome.css" rel="stylesheet">
  <link href="../../assets/css/vendor/codemirror.css" rel="stylesheet">
  <link href="../../assets/css/plato.css" rel="stylesheet">
  <link href="../../assets/css/plato-file.css" rel="stylesheet">

</head>

<body>

<div class="navbar navbar-fixed-top">
  <div class="container">
    <a class="navbar-brand" href="http://github.com/es-analysis/plato">Plato on Github</a>
    <ul class="nav navbar-nav">
      <li>
        <a href="../../index.html">Report Home</a>
      </li>
    </ul>
  </div>
</div>

<div class="jumbotron">
  <div class="container">
    <h1>dojo/tests/unit/_base/declare.js</h1>
  </div>
</div>

<div class="container aggregate-stats">
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Maintainability <a href="http://blogs.msdn.com/b/codeanalysis/archive/2007/11/20/maintainability-index-range-and-meaning.aspx"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="A value between 0 and 100 that represents the relative ease of maintaining the code. A high value means better maintainability." data-original-title="Maintainability Index"  data-container="body"></i></a></h2>
      <p class="stat">69.77</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Lines of code <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h2>
      <p class="stat">661</p>
    </div>
  </div>
  <div class="row historical">
    <div class="col-md-6">
      <p id="chart_historical_maint" class="chart"></p>
    </div>
    <div class="col-md-6">
      <p id="chart_historical_sloc" class="chart"></p>
    </div>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Difficulty  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="The difficulty measure is related to the difficulty of the program to write or understand." data-original-title="Difficulty" data-container="body"></i></a></h2>
      <p class="stat">56.55</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Estimated Errors  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Halstead's delivered bugs is an estimate for the number of errors in the implementation." data-original-title="Delivered Bugs" data-container="body"></i></a></h2>
      <p class="stat">6.15</p>
    </div>
  </div>
</div>

<div class="container charts">
  <div class="row">
    <h2 class="header">Function weight</h2>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h3 class="chart-header">By Complexity <a href="http://en.wikipedia.org/wiki/Cyclomatic_complexity"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="This metric counts the number of distinct paths through a block of code. Lower values are better." data-original-title="Cyclomatic Complexity" data-container="body"></i></a></h3>
      <div id="fn-by-complexity" class="stat"></div>
    </div>
    <div class="col-md-6">
      <h3 class="chart-header">By SLOC  <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h3>
      <div id="fn-by-sloc" class="stat"></div>
    </div>
  </div>
</div>

<div class="container">
  <div class="row">
    <textarea id="file-source" class="col-md-12">/* globals global */
(function (global) {
	define([
		&#039;intern!object&#039;,
		&#039;intern/chai!assert&#039;,
		&#039;dojo/aspect&#039;,
		&#039;dojo/_base/lang&#039;,
		&#039;dojo/_base/kernel&#039;,
		&#039;../../../_base/declare&#039;,
		&#039;sinon&#039;
	], function (
		registerSuite,
		assert,
		aspect,
		lang,
		kernel,
		declare,
		sinon
	) {
		registerSuite({
			name: &#039;dojo/_base/declare&#039;,

			// There is a bug in lang.setObject() which prevents declare from extending a
			// global which has been set to undefined. To work around this problem we
			// are setting global.tests to an empty object before each test and once all
			// the tests have completed we set it to undefined.
			beforeEach: function () {
				global.tests = {};
			},

			teardown: function () {
				global.tests = undefined;
			},

			afterEach: function () {
				global.testsFoo = undefined;
			},

			&#039;smoke test 1&#039;: function () {
				declare(&#039;tests._base.declare.tmp&#039;, null);
				declare(&#039;testsFoo&#039;, null);
				assert.isFunction(global.tests._base.declare.tmp);
				assert.isFunction(global.testsFoo);
			},

			&#039;smoke test 2&#039;: function () {
				var test;

				declare(&#039;tests._base.declare.foo&#039;, null, {
					foo: &#039;thonk&#039;
				});

				test = new global.tests._base.declare.foo();
				assert.equal(test.foo, &#039;thonk&#039;);

				declare(&#039;testsFoo&#039;, null, {
					foo: &#039;thonk&#039;
				});

				test = new global.testsFoo();
				assert.equal(test.foo, &#039;thonk&#039;);
			},

			&#039;smoke test with Ctor&#039;: function () {
				var test;

				declare(&#039;tests._base.declare.fooBar&#039;, null, {
					constructor: function () {
						this.foo = &#039;blah&#039;;
					},
					foo: &#039;thonk&#039;
				});

				test = new global.tests._base.declare.fooBar();
				assert.equal(test.foo, &#039;blah&#039;);
			},

			&#039;smoke test compact args&#039;: function () {
				var test;

				declare(&#039;tests._base.declare.fooBar2&#039;, null, {
					foo: &#039;thonk&#039;
				});

				test = new global.tests._base.declare.fooBar2();
				assert.equal(test.foo, &#039;thonk&#039;);
			},

			&#039;subclass&#039;: function () {
				var test;

				declare(&#039;tests._base.declare.tmp3&#039;, null, {
					foo: &#039;thonk&#039;
				});

				declare(&#039;tests._base.declare.tmp4&#039;, global.tests._base.declare.tmp3);

				test = new global.tests._base.declare.tmp4();
				assert.equal(test.foo, &#039;thonk&#039;);
			},

			&#039;subclass with Ctor&#039;: function () {
				var test;

				declare(&#039;tests._base.declare.tmp5&#039;, null, {
					constructor: function () {
						this.foo = &#039;blah&#039;;
					},
					foo: &#039;thonk&#039;
				});

				declare(&#039;tests._base.declare.tmp6&#039;, global.tests._base.declare.tmp5);

				test = new global.tests._base.declare.tmp6();
				assert.instanceOf(test, global.tests._base.declare.tmp5);
			},

			&#039;mixin subclass&#039;: function () {
				var test;

				declare(&#039;tests._base.declare.tmp7&#039;, null, {
					foo: &#039;thonk&#039;
				});

				declare(&#039;tests._base.declare.tmp8&#039;, null, {
					constructor: function () {
						this.foo = &#039;blah&#039;;
					}
				});

				test = new global.tests._base.declare.tmp8();
				assert.equal(test.foo, &#039;blah&#039;);

				declare(&#039;tests._base.declare.tmp9&#039;, [
					global.tests._base.declare.tmp7, // prototypal
					global.tests._base.declare.tmp8  // mixin
				]);

				test = new global.tests._base.declare.tmp9();
				assert.equal(test.foo, &#039;blah&#039;);
				assert.instanceOf(test, global.tests._base.declare.tmp7);
			},

			&#039;super class ref&#039;: function () {
				var test;

				declare(&#039;tests._base.declare.tmp10&#039;, null, {
					foo: &#039;thonk&#039;
				});

				declare(&#039;tests._base.declare.tmp11&#039;, global.tests._base.declare.tmp10, {
					constructor: function () {
						this.foo = &#039;blah&#039;;
					}
				});

				test = new global.tests._base.declare.tmp11();
				assert.equal(test.foo, &#039;blah&#039;);
				assert.equal(global.tests._base.declare.tmp11.superclass.foo, &#039;thonk&#039;);
			},

			&#039;inherited call&#039;: function () {
				var foo = &#039;xyzzy&#039;;
				var test;

				declare(&#039;tests._base.declare.tmp12&#039;, null, {
					foo: &#039;thonk&#039;,
					bar: function (arg1, arg2) {
						if (arg1) {
							this.foo = arg1;
						}
						if (arg2) {
							foo = arg2;
						}
					}
				});

				declare(&#039;tests._base.declare.tmp13&#039;, global.tests._base.declare.tmp12, {
					constructor: function () {
						this.foo = &#039;blah&#039;;
					}
				});

				test = new global.tests._base.declare.tmp13();
				assert.equal(test.foo, &#039;blah&#039;);
				assert.equal(foo, &#039;xyzzy&#039;);

				test.bar(&#039;zot&#039;);
				assert.equal(test.foo, &#039;zot&#039;);
				assert.equal(foo, &#039;xyzzy&#039;);

				test.bar(&#039;trousers&#039;, &#039;squiggle&#039;);
				assert.equal(test.foo, &#039;trousers&#039;);
				assert.equal(foo, &#039;squiggle&#039;);
			},

			&#039;inherited explicit call&#039;: function () {
				var foo = &#039;xyzzy&#039;;
				var test;

				declare(&#039;tests._base.declare.tmp14&#039;, null, {
					foo: &#039;thonk&#039;,
					bar: function (arg1, arg2) {
						if (arg1) {
							this.foo = arg1;
						}
						if (arg2) {
							foo = arg2;
						}
					}
				});

				declare(&#039;tests._base.declare.tmp15&#039;, global.tests._base.declare.tmp14, {
					constructor: function () {
						this.foo = &#039;blah&#039;;
					},
					bar: function (arg1, arg2) {
						this.inherited(&#039;bar&#039;, arguments, [arg2, arg1]);
					},
					baz: function () {
						global.tests._base.declare.tmp15.superclass.bar.apply(this, arguments);
					}
				});

				test = new global.tests._base.declare.tmp15();
				assert.equal(test.foo, &#039;blah&#039;);
				assert.equal(foo, &#039;xyzzy&#039;);

				test.baz(&#039;zot&#039;);
				assert.equal(test.foo, &#039;zot&#039;);
				assert.equal(foo, &#039;xyzzy&#039;);

				test.bar(&#039;trousers&#039;, &#039;squiggle&#039;);
				assert.equal(test.foo, &#039;squiggle&#039;);
				assert.equal(foo, &#039;trousers&#039;);
			},

			&#039;inherited with mixin calls&#039;: function () {
				var test;

				declare(&#039;tests._base.declare.tmp16&#039;, null, {
					foo: &#039;&#039;,
					bar: function () {
						this.foo += &#039;tmp16&#039;;
					}
				});

				declare(&#039;tests._base.declare.mixin16&#039;, null, {
					bar: function () {
						this.inherited(arguments);
						this.foo += &#039;.mixin16&#039;;
					}
				});

				declare(&#039;tests._base.declare.mixin17&#039;, global.tests._base.declare.mixin16, {
					bar: function () {
						this.inherited(arguments);
						this.foo += &#039;.mixin17&#039;;
					}
				});

				declare(&#039;tests._base.declare.tmp17&#039;, [
					global.tests._base.declare.tmp16,
					global.tests._base.declare.mixin17
				], {
					bar: function () {
						this.inherited(arguments);
						this.foo += &#039;.tmp17&#039;;
					}
				});

				test = new global.tests._base.declare.tmp17();
				test.bar();
				assert.equal(test.foo, &#039;tmp16.mixin16.mixin17.tmp17&#039;);
			},

			&#039;mixin preamble&#039;: function () {
				var passed = false;
				var test;
				declare(&#039;tests._base.declare.tmp16&#039;, null);
				test = new global.tests._base.declare.tmp16({
					preamble: function () {
						passed = true;
					}
				});
				assert.isTrue(passed);
			},

			&#039;basic mixin&#039;: function () {
				// testing if a plain Class-like object can be inherited
				// by declare
				var test;

				function Thing() { }

				Thing.prototype.method = sinon.spy();

				declare(&#039;tests.Thinger&#039;, Thing, {
					method: function () {
						this.inherited(arguments);
					}
				});

				test = new global.tests.Thinger();
				test.method();
				assert.isTrue(Thing.prototype.method.called, &#039;expected method to be called&#039;);
			},

			&#039;mutated methods&#039;: function () {
				// testing if methods can be mutated (within a reason)
				declare(&#039;tests._base.declare.tmp18&#039;, null, {
					constructor: function () { this.clear(); },
					clear: function () { this.flag = 0; },
					foo: function () { ++this.flag; },
					bar: function () { ++this.flag; },
					baz: function () { ++this.flag; }
				});

				declare(&#039;tests._base.declare.tmp19&#039;, global.tests._base.declare.tmp18, {
					foo: function () { ++this.flag; this.inherited(arguments); },
					bar: function () { ++this.flag; this.inherited(arguments); },
					baz: function () { ++this.flag; this.inherited(arguments); }
				});

				var x = new global.tests._base.declare.tmp19();
				// smoke tests
				assert.equal(x.flag, 0);

				x.foo();
				assert.equal(x.flag, 2);

				x.clear();
				assert.equal(x.flag, 0);

				var a = 0;

				// aspect.after() on a prototype method
				aspect.after(global.tests._base.declare.tmp19.prototype, &#039;foo&#039;, function () { a = 1; });
				x.foo();
				assert.equal(x.flag, 2);
				assert.equal(a, 1);
				x.clear();
				a = 0;

				// extra chaining
				var old = global.tests._base.declare.tmp19.prototype.bar;
				global.tests._base.declare.tmp19.prototype.bar = function () {
					a = 1;
					++this.flag;
					old.call(this);
				};

				x.bar();
				assert.equal(x.flag, 3);
				assert.equal(a, 1);
				x.clear();
				a = 0;

				// replacement
				global.tests._base.declare.tmp19.prototype.baz = function () {
					a = 1;
					++this.flag;
					this.inherited(&#039;baz&#039;, arguments);
				};

				x.baz();
				assert.equal(x.flag, 2);
				assert.equal(a, 1);
			},

			&#039;modified instance&#039;: function () {
				var stack;

				declare(&#039;tests._base.declare.tmp20&#039;, null, {
					foo: function () { stack.push(20); }
				});

				declare(&#039;tests._base.declare.tmp21&#039;, null, {
					foo: function () {
						this.inherited(arguments);
						stack.push(21);
					}
				});

				declare(&#039;tests._base.declare.tmp22&#039;, global.tests._base.declare.tmp20, {
					foo: function () {
						this.inherited(arguments);
						stack.push(22);
					}
				});

				declare(&#039;tests._base.declare.tmp23&#039;, [
					global.tests._base.declare.tmp20,
					global.tests._base.declare.tmp21
				], {
					foo: function () {
						this.inherited(arguments);
						stack.push(22);
					}
				});

				var a = new global.tests._base.declare.tmp22();
				var b = new global.tests._base.declare.tmp23();
				var c = {
					foo: function () {
						this.inherited(&#039;foo&#039;, arguments);
						stack.push(&#039;INSIDE C&#039;);
					}
				};

				stack = [];
				a.foo();
				assert.deepEqual(stack, [20, 22]);

				stack = [];
				b.foo();
				assert.deepEqual(stack, [20, 21, 22]);

				lang.mixin(a, c);
				lang.mixin(b, c);

				stack = [];
				a.foo();
				assert.deepEqual(stack, [20, 22, &#039;INSIDE C&#039;]);

				stack = [];
				b.foo();
				assert.deepEqual(stack, [20, 21, 22, &#039;INSIDE C&#039;]);
			},

			&#039;duplicated base&#039;: function () {
				var stack;
				var tmp;
				var A = declare(null, {
					constructor: function () {
						stack.push(1);
					}
				});
				var B = declare([A, A, A], {
					constructor: function () {
						stack.push(2);
					}
				});

				stack = [];
				tmp = new A();
				assert.deepEqual(stack, [1]);

				stack = [];
				tmp = new B();
				assert.deepEqual(stack, [1, 2]);
			},

			&#039;indirectly duplicated base&#039;: function () {
				var stack;
				var tmp;
				var A = declare(null, {
					constructor: function () {
						stack.push(1);
					}
				});
				var B = declare(A, {
					constructor: function () {
						stack.push(2);
					}
				});
				var C = declare([A, B], {
					constructor: function () {
						stack.push(3);
					}
				});
				var D = declare([B, A], {
					constructor: function () {
						stack.push(4);
					}
				});

				stack = [];
				tmp = new C();
				assert.deepEqual(stack, [1, 2, 3]);

				stack = [];
				tmp = new D();
				assert.deepEqual(stack, [1, 2, 4]);
			},

			&#039;wrong multiple inheritance&#039;: function () {
				var stack;
				var tmp;
				var A = declare([], {
					constructor: function () {
						stack.push(1);
					}
				});
				var B = declare([A], {
					constructor: function () {
						stack.push(2);
					}
				});

				stack = [];
				tmp = new A();
				assert.deepEqual(stack, [1]);

				stack = [];
				tmp = new B();
				assert.deepEqual(stack, [1, 2]);
			},

			&#039;impossible bases&#039;: function () {
				var A = declare(null);
				var B = declare(null);
				var C = declare([A, B]);
				var D = declare([B, A]);
				var E;

				var flag = false;
				try {
					E = declare([C, D]);
				} catch (e) {
					flag = true;
				}
				assert.isTrue(flag);
			},

			&#039;no new&#039;: function () {
				/*jshint camelcase: false */
				// all of the classes I create will use this as their
				// pseudo-constructor function
				function noNewConstructor() {
					this.noNew_Value = &#039;instance value&#039;;
				}

				var g = kernel.global;
				// this value will remain unchanged if the code for
				// calling a constructor without &#039;new&#039; works correctly.
				g.noNew_Value = &#039;global value&#039;;

				// perform the actual test
				function noNewTest(cls) {
					// call class function without new
					var obj = cls(&#039;instance value&#039;);
					assert.equal(obj.noNew_Value, &#039;instance value&#039;);
					assert.equal(g.noNew_Value, &#039;global value&#039;);
				}

				// There are three different functions that might be
				// created by declare(), so I need to test all
				// three.

				// 1. Class with manual-chained constructor
				noNewTest(
					declare(null, {
						constructor: noNewConstructor,
						&#039;-chains-&#039;: {constructor: &#039;manual&#039;}
					})
				);

				// 2. Class with no superclasses
				var A = declare(null, {
					constructor: noNewConstructor
				});
				noNewTest(A);

				// 3. Class with at least one superclass
				noNewTest(declare(A));

				// Make sure multiple inheritance call works
				var B = declare(A);
				var C = declare(null, { ctest: function () { return true; } });
				var D = declare([A, B, C], { dtest: function () { return true; } });
				noNewTest(D);
				// make sure I get the test functions from
				// all superclasses
				var d = D();
				assert.isTrue(d.ctest());
				assert.isTrue(d.dtest());

				// Make sure call through an object works
				var noNewClasses = {
					D: D,
					noNew_Value: &#039;unchanged&#039;
				};
				var obj = noNewClasses.D();
				assert.equal(obj.noNew_Value, &#039;instance value&#039;);
				assert.equal(noNewClasses.noNew_Value, &#039;unchanged&#039;);
			},

			&#039;create subclass&#039;: function () {
				var A = declare(null, {
					foo: &#039;thonk&#039;
				});
				var B = declare(null, {
				});
				var C = declare(null, {
					bar: &#039;thonk&#039;
				});

				// Both &#039;mixins&#039; and &#039;props&#039; parameters are provided
				var D1 = A.createSubclass([B, C], {
					constructor: function () {
						this.foo = &#039;blah&#039;;
					}
				});

				// Only &#039;mixins&#039; parameters is provided
				var D2 = A.createSubclass([B, C]);

				// The &#039;props&#039; parameter is provided as first instead of second parameter
				var D3 = A.createSubclass({
					constructor: function () {
						this.foo = &#039;blah&#039;;
					}
				});

				// No arguments at all provided
				var D4 = A.createSubclass();

				// Single Mixin
				var D5 = A.createSubclass(C);

				var d1 = new D1();
				var d2 = new D2();
				var d3 = new D3();
				var d4 = new D4();
				var d5 = new D5();

				assert.equal(d1.foo, &#039;blah&#039;);
				assert.equal(d2.foo, &#039;thonk&#039;);
				assert.equal(d1.bar, &#039;thonk&#039;);
				assert.equal(d2.bar, &#039;thonk&#039;);
				assert.equal(d3.foo, &#039;blah&#039;);
				assert.equal(d4.foo, &#039;thonk&#039;);
				assert.equal(d5.bar, &#039;thonk&#039;);
			},

			safeMixin: function () {
				var C = declare(null, {
					foo: sinon.spy()
				});
				var c = new C();
				// make sure we can mixin foo
				declare.safeMixin(c, {
					foo: function () {
						this.inherited(arguments);
					}
				});
				sinon.spy(c, &#039;foo&#039;);
				c.foo();

				assert.isTrue(C.prototype.foo.called);
				assert.isTrue(c.foo.called);
				assert.doesNotThrow(function () {
					declare.safeMixin(c);
				});
			}
			// TODO: there are still some permutations to test like:
			//	- ctor arguments
			//	- multi-level inheritance + L/R conflict checks
		});
	});
})(typeof global !== &#039;undefined&#039; ? global : this);</textarea>
  </div>
</div>

<footer class="footer">
  <div class="container">
    <p>.</p>
  </div>
</footer>

<script type="text/html" id="complexity-popover-template">
  <div class="complexity-notice">
    Complexity : {{ complexity.cyclomatic }} <br>
    Length : {{ complexity.halstead.length }} <br>
    Difficulty : {{ complexity.halstead.difficulty.toFixed(2) }} <br>
    Est # bugs : {{ complexity.halstead.bugs.toFixed(2) }}<br>
  </div>
</script>

<script type="text/javascript" src="../../assets/scripts/bundles/core-bundle.js"></script>
<script type="text/javascript" src="../../assets/scripts/bundles/codemirror.js"></script>
<script type="text/javascript" src="../../assets/scripts/codemirror.markpopovertext.js"></script>
<script type="text/javascript" src="report.js"></script>
<script type="text/javascript" src="report.history.js"></script>
<script type="text/javascript" src="../../assets/scripts/plato-file.js"></script>
</body>
</html>
