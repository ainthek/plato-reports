<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Plato - node_modules/cssstyle/lib/parsers.js</title>

  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="">
  <meta name="author" content="">

  <!--[if lt IE 9]>
  <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->

  <link href="../../assets/css/vendor/morris.css" rel="stylesheet">
  <link href="../../assets/css/vendor/bootstrap.css" rel="stylesheet">
  <link href="../../assets/css/vendor/font-awesome.css" rel="stylesheet">
  <link href="../../assets/css/vendor/codemirror.css" rel="stylesheet">
  <link href="../../assets/css/plato.css" rel="stylesheet">
  <link href="../../assets/css/plato-file.css" rel="stylesheet">

</head>

<body>

<div class="navbar navbar-fixed-top">
  <div class="container">
    <a class="navbar-brand" href="http://github.com/es-analysis/plato">Plato on Github</a>
    <ul class="nav navbar-nav">
      <li>
        <a href="../../index.html">Report Home</a>
      </li>
    </ul>
  </div>
</div>

<div class="jumbotron">
  <div class="container">
    <h1>node_modules/cssstyle/lib/parsers.js</h1>
  </div>
</div>

<div class="container aggregate-stats">
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Maintainability <a href="http://blogs.msdn.com/b/codeanalysis/archive/2007/11/20/maintainability-index-range-and-meaning.aspx"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="A value between 0 and 100 that represents the relative ease of maintaining the code. A high value means better maintainability." data-original-title="Maintainability Index"  data-container="body"></i></a></h2>
      <p class="stat">55.79</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Lines of code <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h2>
      <p class="stat">628</p>
    </div>
  </div>
  <div class="row historical">
    <div class="col-md-6">
      <p id="chart_historical_maint" class="chart"></p>
    </div>
    <div class="col-md-6">
      <p id="chart_historical_sloc" class="chart"></p>
    </div>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Difficulty  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="The difficulty measure is related to the difficulty of the program to write or understand." data-original-title="Difficulty" data-container="body"></i></a></h2>
      <p class="stat">110.07</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Estimated Errors  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Halstead's delivered bugs is an estimate for the number of errors in the implementation." data-original-title="Delivered Bugs" data-container="body"></i></a></h2>
      <p class="stat">7.26</p>
    </div>
  </div>
</div>

<div class="container charts">
  <div class="row">
    <h2 class="header">Function weight</h2>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h3 class="chart-header">By Complexity <a href="http://en.wikipedia.org/wiki/Cyclomatic_complexity"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="This metric counts the number of distinct paths through a block of code. Lower values are better." data-original-title="Cyclomatic Complexity" data-container="body"></i></a></h3>
      <div id="fn-by-complexity" class="stat"></div>
    </div>
    <div class="col-md-6">
      <h3 class="chart-header">By SLOC  <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h3>
      <div id="fn-by-sloc" class="stat"></div>
    </div>
  </div>
</div>

<div class="container">
  <div class="row">
    <textarea id="file-source" class="col-md-12">/*********************************************************************
 * These are commonly used parsers for CSS Values they take a string *
 * to parse and return a string after it&#039;s been converted, if needed *
 ********************************************************************/
&#039;use strict&#039;;

exports.TYPES = {
    INTEGER: 1,
    NUMBER: 2,
    LENGTH: 3,
    PERCENT: 4,
    URL: 5,
    COLOR: 6,
    STRING: 7,
    ANGLE: 8,
    KEYWORD: 9,
    NULL_OR_EMPTY_STR: 10
};

/*jslint regexp: true*/
// rough regular expressions
var integerRegEx = /^[\-+]?[0-9]+$/;
var numberRegEx = /^[\-+]?[0-9]*\.[0-9]+$/;
var lengthRegEx = /^(0|[\-+]?[0-9]?\.?[0-9]+(in|cm|em|mm|pt|pc|px))$/;
var percentRegEx = /^[\-+]?[0-9]?\.?[0-9]+%$/;
var urlRegEx = /^url\(\s*([^\)]*)\s*\)$/;
var stringRegEx = /^(&quot;[^&quot;]*&quot;|&#039;[^&#039;]*&#039;)$/;
var colorRegEx1 = /^#[0-9a-fA-F][0-9a-fA-F][0-9a-fA-F]([0-9a-fA-F][0-9a-fA-F][0-9a-fA-F])?$/;
var colorRegEx2 = /^rgb\(([^\)]*)\)$/;
var colorRegEx3 = /^rgba\(([^\)]*)\)$/;
var angleRegEx = /^([\-+]?[0-9]?\.?[0-9]+)(deg|grad|rad)$/;
/*jslint regexp: false*/

// This will return one of the above types based on the passed in string
exports.valueType = function valueType(val) {
    if (val === &#039;&#039; || val === null) {
        return exports.TYPES.NULL_OR_EMPTY_STR;
    }
    if (typeof val === &#039;number&#039;) {
        val = val.toString();
    }

    if (typeof val !== &#039;string&#039;) {
        return undefined;
    }

    if (integerRegEx.test(val)) {
        return exports.TYPES.INTEGER;
    }
    if (numberRegEx.test(val)) {
        return exports.TYPES.NUMBER;
    }
    if (lengthRegEx.test(val)) {
        return exports.TYPES.LENGTH;
    }
    if (percentRegEx.test(val)) {
        return exports.TYPES.PERCENT;
    }
    if (urlRegEx.test(val)) {
        return exports.TYPES.URL;
    }
    if (stringRegEx.test(val)) {
        return exports.TYPES.STRING;
    }
    if (angleRegEx.test(val)) {
        return exports.TYPES.ANGLE;
    }
    if (colorRegEx1.test(val)) {
        return exports.TYPES.COLOR;
    }
    var res = colorRegEx2.exec(val);
    var parts;
    if (res !== null) {
        parts = res[1].split(/\s*,\s*/);
        if (parts.length !== 3) {
            return undefined;
        }
        if (parts.every(percentRegEx.test.bind(percentRegEx)) || parts.every(integerRegEx.test.bind(integerRegEx))) {
            return exports.TYPES.COLOR;
        }
        return undefined;
    }
    res = colorRegEx3.exec(val);
    if (res !== null) {
        parts = res[1].split(/\s*,\s*/);
        if (parts.length !== 4) {
            return undefined;
        }
        if (parts.slice(0, 3).every(percentRegEx.test.bind(percentRegEx)) || parts.every(integerRegEx.test.bind(integerRegEx))) {
            if (numberRegEx.test(parts[3])) {
                return exports.TYPES.COLOR;
            }
        }
        return undefined;
    }

    // could still be a color, one of the standard keyword colors
    val = val.toLowerCase();
    switch (val) {
    case &#039;maroon&#039;:
    case &#039;red&#039;:
    case &#039;orange&#039;:
    case &#039;yellow&#039;:
    case &#039;olive&#039;:
    case &#039;purple&#039;:
    case &#039;fuchsia&#039;:
    case &#039;white&#039;:
    case &#039;lime&#039;:
    case &#039;green&#039;:
    case &#039;navy&#039;:
    case &#039;blue&#039;:
    case &#039;aqua&#039;:
    case &#039;teal&#039;:
    case &#039;black&#039;:
    case &#039;silver&#039;:
    case &#039;gray&#039;:
        // the following are deprecated in CSS3
    case &#039;activeborder&#039;:
    case &#039;activecaption&#039;:
    case &#039;appworkspace&#039;:
    case &#039;background&#039;:
    case &#039;buttonface&#039;:
    case &#039;buttonhighlight&#039;:
    case &#039;buttonshadow&#039;:
    case &#039;buttontext&#039;:
    case &#039;captiontext&#039;:
    case &#039;graytext&#039;:
    case &#039;highlight&#039;:
    case &#039;highlighttext&#039;:
    case &#039;inactiveborder&#039;:
    case &#039;inactivecaption&#039;:
    case &#039;inactivecaptiontext&#039;:
    case &#039;infobackground&#039;:
    case &#039;infotext&#039;:
    case &#039;menu&#039;:
    case &#039;menutext&#039;:
    case &#039;scrollbar&#039;:
    case &#039;threeddarkshadow&#039;:
    case &#039;threedface&#039;:
    case &#039;threedhighlight&#039;:
    case &#039;threedlightshadow&#039;:
    case &#039;threedshadow&#039;:
    case &#039;window&#039;:
    case &#039;windowframe&#039;:
    case &#039;windowtext&#039;:
        return exports.TYPES.COLOR;
    default:
        return exports.TYPES.KEYWORD;
    }
};

exports.parseInteger = function parseInteger(val) {
    var type = exports.valueType(val);
    if (type === exports.TYPES.NULL_OR_EMPTY_STR) {
        return val;
    }
    if (type !== exports.TYPES.INTEGER) {
        return undefined;
    }
    return String(parseInt(val, 10));
};

exports.parseNumber = function parseNumber(val) {
    var type = exports.valueType(val);
    if (type === exports.TYPES.NULL_OR_EMPTY_STR) {
        return val;
    }
    if (type !== exports.TYPES.NUMBER &amp;&amp; type !== exports.TYPES.INTEGER) {
        return undefined;
    }
    return String(parseFloat(val));
};

exports.parseLength = function parseLength(val) {
    if (val === 0 || val === &#039;0&#039;) {
        return &#039;0px&#039;;
    }
    var type = exports.valueType(val);
    if (type === exports.TYPES.NULL_OR_EMPTY_STR) {
        return val;
    }
    if (type !== exports.TYPES.LENGTH) {
        return undefined;
    }
    return val;
};

exports.parsePercent = function parsePercent(val) {
    if (val === 0 || val === &#039;0&#039;) {
        return &#039;0%&#039;;
    }
    var type = exports.valueType(val);
    if (type === exports.TYPES.NULL_OR_EMPTY_STR) {
        return val;
    }
    if (type !== exports.TYPES.PERCENT) {
        return undefined;
    }
    return val;
};

// either a length or a percent
exports.parseMeasurement = function parseMeasurement(val) {
    var length = exports.parseLength(val);
    if (length !== undefined) {
        return length;
    }
    return exports.parsePercent(val);
};

exports.parseUrl = function parseUrl(val) {
    var type = exports.valueType(val);
    if (type === exports.TYPES.NULL_OR_EMPTY_STR) {
        return val;
    }
    var res = urlRegEx.exec(val);
    // does it match the regex?
    if (!res) {
        return undefined;
    }
    var str = res[1];
    // if it starts with single or double quotes, does it end with the same?
    if ((str[1] === &#039;&quot;&#039; || str[1] === &quot;&#039;&quot;) &amp;&amp; str[1] !== str[str.length - 1]) {
        return undefined;
    }
    if (str[1] === &#039;&quot;&#039; || str[1] === &quot;&#039;&quot;) {
        str = str.substr(1, -1);
    }

    var i;
    for (i = 0; i &lt; str.length; i++) {
        switch (str[i]) {
        case &#039;(&#039;:
        case &#039;)&#039;:
        case &#039; &#039;:
        case &#039;\t&#039;:
        case &#039;\n&#039;:
        case &quot;&#039;&quot;:
        case &#039;&quot;&#039;:
            return undefined;
        case &#039;\\&#039;:
            i++;
            break;
        }
    }
    return &#039;url(&#039; + str + &#039;)&#039;;
};

exports.parseString = function parseString(val) {
    var type = exports.valueType(val);
    if (type === exports.TYPES.NULL_OR_EMPTY_STR) {
        return val;
    }
    if (type !== exports.TYPES.STRING) {
        return undefined;
    }
    var i;
    for (i = 1; i &lt; val.length - 1; i++) {
        switch (val[i]) {
        case val[0]:
            return undefined;
        case &#039;\\&#039;:
            i++;
            while (i &lt; val.length - 1 &amp;&amp; /[0-9A-Fa-f]/.test(val[i])) {
                i++;
            }
            break;
        }
    }
    if (i &gt;= val.length) {
        return undefined;
    }
    return val;
};

exports.parseColor = function parseColor(val) {
    var type = exports.valueType(val);
    if (type === exports.TYPES.NULL_OR_EMPTY_STR) {
        return val;
    }
    var red, green, blue, alpha = 1;
    var parts;
    var res = colorRegEx1.exec(val);
    // is it #aaa or #ababab
    if (res) {
        var hex = val.substr(1);
        if (hex.length === 3) {
            hex = hex[0] + hex[0] + hex[1] + hex[1] + hex[2] + hex[2];
        }
        red = parseInt(hex.substr(0, 2), 16);
        green = parseInt(hex.substr(2, 2), 16);
        blue = parseInt(hex.substr(4, 2), 16);
        return &#039;rgb(&#039; + red + &#039;, &#039; + green + &#039;, &#039; + blue + &#039;)&#039;;
    }

    res = colorRegEx2.exec(val);
    if (res) {
        parts = res[1].split(/\s*,\s*/);
        if (parts.length !== 3) {
            return undefined;
        }
        if (parts.every(percentRegEx.test.bind(percentRegEx))) {
            red = Math.floor(parseFloat(parts[0].slice(0, -1)) * 255 / 100);
            green = Math.floor(parseFloat(parts[1].slice(0, -1)) * 255 / 100);
            blue = Math.floor(parseFloat(parts[2].slice(0, -1)) * 255 / 100);
        } else if (parts.every(integerRegEx.test.bind(integerRegEx))) {
            red = parseInt(parts[0], 10);
            green = parseInt(parts[1], 10);
            blue = parseInt(parts[2], 10);
        } else {
            return undefined;
        }
        red = Math.min(255, Math.max(0, red));
        green = Math.min(255, Math.max(0, green));
        blue = Math.min(255, Math.max(0, blue));
        return &#039;rgb(&#039; + red + &#039;, &#039; + green + &#039;, &#039; + blue + &#039;)&#039;;
    }

    res = colorRegEx3.exec(val);
    if (res) {
        parts = res[1].split(/\s*,\s*/);
        if (parts.length !== 4) {
            return undefined;
        }
        if (parts.slice(0, 3).every(percentRegEx.test.bind(percentRegEx))) {
            red = Math.floor(parseFloat(parts[0].slice(0, -1)) * 255 / 100);
            green = Math.floor(parseFloat(parts[1].slice(0, -1)) * 255 / 100);
            blue = Math.floor(parseFloat(parts[2].slice(0, -1)) * 255 / 100);
            alpha = parseFloat(parts[3]);
        } else if (parts.slice(0, 3).every(integerRegEx.test.bind(integerRegEx))) {
            red = parseInt(parts[0], 10);
            green = parseInt(parts[1], 10);
            blue = parseInt(parts[2], 10);
            alpha = parseFloat(parts[3]);
        } else {
            return undefined;
        }
        if (isNaN(alpha)) {
            alpha = 1;
        }
        red = Math.min(255, Math.max(0, red));
        green = Math.min(255, Math.max(0, green));
        blue = Math.min(255, Math.max(0, blue));
        alpha = Math.min(1, Math.max(0, alpha));
        if (alpha === 1) {
            return &#039;rgb(&#039; + red + &#039;, &#039; + green + &#039;, &#039; + blue + &#039;)&#039;;
        }
        return &#039;rgba(&#039; + red + &#039;, &#039; + green + &#039;, &#039; + blue + &#039;, &#039; + alpha + &#039;)&#039;;
    }

    if (type === exports.TYPES.COLOR) {
        return val;
    }
    return undefined;
};

exports.parseAngle = function parseAngle(val) {
    var type = exports.valueType(val);
    if (type === exports.TYPES.NULL_OR_EMPTY_STR) {
        return val;
    }
    if (type !== exports.TYPES.ANGLE) {
        return undefined;
    }
    var res = angleRegEx.exec(val);
    var flt = parseFloat(res[1]);
    if (res[2] === &#039;rad&#039;) {
        flt *= 180 / Math.PI;
    } else if (res[2] === &#039;grad&#039;) {
        flt *= 360 / 400;
    }

    while (flt &lt; 0) {
        flt += 360;
    }
    while (flt &gt; 360) {
        flt -= 360;
    }
    return flt + &#039;deg&#039;;
};

exports.parseKeyword = function parseKeyword(val, valid_keywords) {
    var type = exports.valueType(val);
    if (type === exports.TYPES.NULL_OR_EMPTY_STR) {
        return val;
    }
    if (type !== exports.TYPES.KEYWORD) {
        return undefined;
    }
    val = val.toString().toLowerCase();
    var i;
    for (i = 0; i &lt; valid_keywords.length; i++) {
        if (valid_keywords[i].toLowerCase() === val) {
            return valid_keywords[i];
        }
    }
    return undefined;
};

// utility to translate from border-width to borderWidth
var dashedToCamelCase = function (dashed) {
    var i;
    var camel = &#039;&#039;;
    var nextCap = false;
    for (i = 0; i &lt; dashed.length; i++) {
        if (dashed[i] !== &#039;-&#039;) {
            camel += nextCap ? dashed[i].toUpperCase() : dashed[i];
            nextCap = false;
        } else {
            nextCap = true;
        }
    }
    return camel;
};
exports.dashedToCamelCase = dashedToCamelCase;

var is_space = /\s/;
var opening_deliminators = [&#039;&quot;&#039;, &#039;\&#039;&#039;, &#039;(&#039;];
var closing_deliminators = [&#039;&quot;&#039;, &#039;\&#039;&#039;, &#039;)&#039;];
// this splits on whitespace, but keeps quoted and parened parts together
var getParts = function (str) {
    var deliminator_stack = [];
    var length = str.length;
    var i;
    var parts = [];
    var current_part = &#039;&#039;;
    var opening_index;
    var closing_index;
    for (i = 0; i &lt; length; i++) {
        opening_index = opening_deliminators.indexOf(str[i]);
        closing_index = closing_deliminators.indexOf(str[i]);
        if (is_space.test(str[i])) {
            if (deliminator_stack.length === 0) {
                parts.push(current_part);
                current_part = &#039;&#039;;
            } else {
                current_part += str[i];
            }
        } else {
            if (str[i] === &#039;\\&#039;) {
                i++;
                current_part += str[i];
            } else {
                current_part += str[i];
                if (closing_index !== -1 &amp;&amp; closing_index === deliminator_stack[deliminator_stack.length - 1]) {
                    deliminator_stack.pop();
                } else if (opening_index !== -1) {
                    deliminator_stack.push(opening_index);
                }
            }
        }
    }
    if (current_part !== &#039;&#039;) {
        parts.push(current_part);
    }
    return parts;
};

/*
 * this either returns undefined meaning that it isn&#039;t valid
 * or returns an object where the keys are dashed short
 * hand properties and the values are the values to set
 * on them
 */
exports.shorthandParser = function parse(v, shorthand_for) {
    var obj = {};
    var type = exports.valueType(v);
    if (type === exports.TYPES.NULL_OR_EMPTY_STR) {
        Object.keys(shorthand_for).forEach(function (property) {
            obj[property] = v;
        });
        return obj;
    }

    if (typeof v === &#039;number&#039;) {
        v = v.toString();
    }

    if (typeof v !== &#039;string&#039;) {
        return undefined;
    }

    if (v.toLowerCase() === &#039;inherit&#039;) {
        return {};
    }
    var parts = getParts(v);
    var valid = true;
    parts.forEach(function (part) {
        var part_valid = false;
        Object.keys(shorthand_for).forEach(function (property) {
            if (shorthand_for[property].isValid(part)) {
                part_valid = true;
                obj[property] = part;
            }
        });
        valid = valid &amp;&amp; part_valid;
    });
    if (!valid) {
        return undefined;
    }
    return obj;
};

exports.shorthandSetter = function (property, shorthand_for) {
    return function (v) {
        var obj = exports.shorthandParser(v, shorthand_for);
        if (obj === undefined) {
            return;
        }
        //console.log(&#039;shorthandSetter for:&#039;, property, &#039;obj:&#039;, obj);
        Object.keys(obj).forEach(function (subprop) {
            // in case subprop is an implicit property, this will clear
            // *its* subpropertiesX
            var camel = dashedToCamelCase(subprop);
            this[camel] = obj[subprop];
            // in case it gets translated into something else (0 -&gt; 0px)
            obj[subprop] = this[camel];
            this.removeProperty(subprop);
            this._values[subprop] = obj[subprop];
        }, this);
        Object.keys(shorthand_for).forEach(function (subprop) {
            if (!obj.hasOwnProperty(subprop)) {
                this.removeProperty(subprop);
                delete this._values[subprop];
            }
        }, this);
        // in case the value is something like &#039;none&#039; that removes all values,
        // check that the generated one is not empty, first remove the property
        // if it already exists, then call the shorthandGetter, if it&#039;s an empty
        // string, don&#039;t set the property
        this.removeProperty(property);
        var calculated = exports.shorthandGetter(property, shorthand_for).call(this);
        if (calculated !== &#039;&#039;) {
            this._setProperty(property, calculated);
        }
    };
};

exports.shorthandGetter = function (property, shorthand_for) {
    return function () {
        if (this._values[property] !== undefined) {
            return this.getPropertyValue(property);
        }
        return Object.keys(shorthand_for).map(function (subprop) {
            return this.getPropertyValue(subprop);
        }, this).filter(function (value) {
            return value !== &#039;&#039;;
        }).join(&#039; &#039;);
    };
};

// isValid(){1,4} | inherit
// if one, it applies to all
// if two, the first applies to the top and bottom, and the second to left and right
// if three, the first applies to the top, the second to left and right, the third bottom
// if four, top, right, bottom, left
exports.implicitSetter = function (property_before, property_after, isValid, parser) {
    property_after = property_after || &#039;&#039;;
    if (property_after !== &#039;&#039;) {
        property_after = &#039;-&#039; + property_after;
    }

    return function (v) {
        if (typeof v === &#039;number&#039;) {
            v = v.toString();
        }
        if (typeof v !== &#039;string&#039;) {
            return undefined;
        }
        var parts;
        if (v.toLowerCase() === &#039;inherit&#039; || v === &#039;&#039;) {
            parts = [v];
        } else {
            parts = getParts(v);
        }
        if (parts.length &lt; 1 || parts.length &gt; 4) {
            return undefined;
        }

        if (!parts.every(isValid)) {
            return undefined;
        }

        this._setProperty(property_before + property_after, parts.map(function (part) { return parser(part); }).join(&#039; &#039;));

        this.removeProperty(property_before + &#039;-top&#039; + property_after);
        this.removeProperty(property_before + &#039;-right&#039; + property_after);
        this.removeProperty(property_before + &#039;-bottom&#039; + property_after);
        this.removeProperty(property_before + &#039;-left&#039; + property_after);
        switch (parts.length) {
        case 1:
            this._values[property_before + &#039;-top&#039; + property_after] = parser(parts[0]);
            this._values[property_before + &#039;-right&#039; + property_after] = parser(parts[0]);
            this._values[property_before + &#039;-bottom&#039; + property_after] = parser(parts[0]);
            this._values[property_before + &#039;-left&#039; + property_after] = parser(parts[0]);
            return v;
        case 2:
            this._values[property_before + &#039;-top&#039; + property_after] = parser(parts[0]);
            this._values[property_before + &#039;-right&#039; + property_after] = parser(parts[1]);
            this._values[property_before + &#039;-bottom&#039; + property_after] = parser(parts[0]);
            this._values[property_before + &#039;-left&#039; + property_after] = parser(parts[1]);
            return v;
        case 3:
            this._values[property_before + &#039;-top&#039; + property_after] = parser(parts[0]);
            this._values[property_before + &#039;-right&#039; + property_after] = parser(parts[1]);
            this._values[property_before + &#039;-bottom&#039; + property_after] = parser(parts[2]);
            this._values[property_before + &#039;-left&#039; + property_after] = parser(parts[1]);
            return v;
        case 4:
            this._values[property_before + &#039;-top&#039; + property_after] = parser(parts[0]);
            this._values[property_before + &#039;-right&#039; + property_after] = parser(parts[1]);
            this._values[property_before + &#039;-bottom&#039; + property_after] = parser(parts[2]);
            this._values[property_before + &#039;-left&#039; + property_after] = parser(parts[3]);
            return v;
        }
    };
};

var camel_to_dashed = /[A-Z]/g;
/*jslint regexp: true*/
var first_segment = /^\([^\-]\)-/;
/*jslint regexp: false*/
var vendor_prefixes = [&#039;o&#039;, &#039;moz&#039;, &#039;ms&#039;, &#039;webkit&#039;];
exports.camelToDashed = function (camel_case) {
    var match;
    var dashed = camel_case.replace(camel_to_dashed, &#039;-$&amp;&#039;).toLowerCase();
    match = dashed.match(first_segment);
    if (match &amp;&amp; vendor_prefixes.indexOf(match[1]) !== -1) {
        dashed = &#039;-&#039; + dashed;
    }
    return dashed;
};</textarea>
  </div>
</div>

<footer class="footer">
  <div class="container">
    <p>.</p>
  </div>
</footer>

<script type="text/html" id="complexity-popover-template">
  <div class="complexity-notice">
    Complexity : {{ complexity.cyclomatic }} <br>
    Length : {{ complexity.halstead.length }} <br>
    Difficulty : {{ complexity.halstead.difficulty.toFixed(2) }} <br>
    Est # bugs : {{ complexity.halstead.bugs.toFixed(2) }}<br>
  </div>
</script>

<script type="text/javascript" src="../../assets/scripts/bundles/core-bundle.js"></script>
<script type="text/javascript" src="../../assets/scripts/bundles/codemirror.js"></script>
<script type="text/javascript" src="../../assets/scripts/codemirror.markpopovertext.js"></script>
<script type="text/javascript" src="report.js"></script>
<script type="text/javascript" src="report.history.js"></script>
<script type="text/javascript" src="../../assets/scripts/plato-file.js"></script>
</body>
</html>
